'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link MetricUnit} that the service accepts. */
exports.KnownMetricUnit = void 0;
(function (KnownMetricUnit) {
    /** NotSpecified */
    KnownMetricUnit["NotSpecified"] = "NotSpecified";
    /** Percent */
    KnownMetricUnit["Percent"] = "Percent";
    /** Count */
    KnownMetricUnit["Count"] = "Count";
    /** Seconds */
    KnownMetricUnit["Seconds"] = "Seconds";
    /** Milliseconds */
    KnownMetricUnit["Milliseconds"] = "Milliseconds";
    /** Bytes */
    KnownMetricUnit["Bytes"] = "Bytes";
    /** BytesPerSecond */
    KnownMetricUnit["BytesPerSecond"] = "BytesPerSecond";
    /** CountPerSecond */
    KnownMetricUnit["CountPerSecond"] = "CountPerSecond";
})(exports.KnownMetricUnit || (exports.KnownMetricUnit = {}));
/** Known values of {@link MetricAggregationType} that the service accepts. */
exports.KnownMetricAggregationType = void 0;
(function (KnownMetricAggregationType) {
    /** NotSpecified */
    KnownMetricAggregationType["NotSpecified"] = "NotSpecified";
    /** None */
    KnownMetricAggregationType["None"] = "None";
    /** Average */
    KnownMetricAggregationType["Average"] = "Average";
    /** Minimum */
    KnownMetricAggregationType["Minimum"] = "Minimum";
    /** Maximum */
    KnownMetricAggregationType["Maximum"] = "Maximum";
    /** Total */
    KnownMetricAggregationType["Total"] = "Total";
    /** Count */
    KnownMetricAggregationType["Count"] = "Count";
})(exports.KnownMetricAggregationType || (exports.KnownMetricAggregationType = {}));
/** Known values of {@link MetricCategory} that the service accepts. */
exports.KnownMetricCategory = void 0;
(function (KnownMetricCategory) {
    /** Capacity */
    KnownMetricCategory["Capacity"] = "Capacity";
    /** Transaction */
    KnownMetricCategory["Transaction"] = "Transaction";
})(exports.KnownMetricCategory || (exports.KnownMetricCategory = {}));
/** Known values of {@link TimeGrain} that the service accepts. */
exports.KnownTimeGrain = void 0;
(function (KnownTimeGrain) {
    /** PT1M */
    KnownTimeGrain["PT1M"] = "PT1M";
    /** PT5M */
    KnownTimeGrain["PT5M"] = "PT5M";
    /** PT15M */
    KnownTimeGrain["PT15M"] = "PT15M";
    /** PT30M */
    KnownTimeGrain["PT30M"] = "PT30M";
    /** PT1H */
    KnownTimeGrain["PT1H"] = "PT1H";
    /** PT6H */
    KnownTimeGrain["PT6H"] = "PT6H";
    /** PT12H */
    KnownTimeGrain["PT12H"] = "PT12H";
    /** PT1D */
    KnownTimeGrain["PT1D"] = "PT1D";
})(exports.KnownTimeGrain || (exports.KnownTimeGrain = {}));
/** Known values of {@link SkuName} that the service accepts. */
exports.KnownSkuName = void 0;
(function (KnownSkuName) {
    /** Gateway */
    KnownSkuName["Gateway"] = "Gateway";
    /** Edge */
    KnownSkuName["Edge"] = "Edge";
    /** TEA1Node */
    KnownSkuName["TEA1Node"] = "TEA_1Node";
    /** TEA1NodeUPS */
    KnownSkuName["TEA1NodeUPS"] = "TEA_1Node_UPS";
    /** TEA1NodeHeater */
    KnownSkuName["TEA1NodeHeater"] = "TEA_1Node_Heater";
    /** TEA1NodeUPSHeater */
    KnownSkuName["TEA1NodeUPSHeater"] = "TEA_1Node_UPS_Heater";
    /** TEA4NodeHeater */
    KnownSkuName["TEA4NodeHeater"] = "TEA_4Node_Heater";
    /** TEA4NodeUPSHeater */
    KnownSkuName["TEA4NodeUPSHeater"] = "TEA_4Node_UPS_Heater";
    /** TMA */
    KnownSkuName["TMA"] = "TMA";
    /** TDC */
    KnownSkuName["TDC"] = "TDC";
    /** TCASmall */
    KnownSkuName["TCASmall"] = "TCA_Small";
    /** GPU */
    KnownSkuName["GPU"] = "GPU";
    /** TCALarge */
    KnownSkuName["TCALarge"] = "TCA_Large";
    /** EdgePBase */
    KnownSkuName["EdgePBase"] = "EdgeP_Base";
    /** EdgePHigh */
    KnownSkuName["EdgePHigh"] = "EdgeP_High";
    /** EdgePRBase */
    KnownSkuName["EdgePRBase"] = "EdgePR_Base";
    /** EdgePRBaseUPS */
    KnownSkuName["EdgePRBaseUPS"] = "EdgePR_Base_UPS";
    /** EP2641VPUW */
    KnownSkuName["EP2641VPUW"] = "EP2_64_1VPU_W";
    /** EP21281T4Mx1W */
    KnownSkuName["EP21281T4Mx1W"] = "EP2_128_1T4_Mx1_W";
    /** EP22562T4W */
    KnownSkuName["EP22562T4W"] = "EP2_256_2T4_W";
    /** EdgeMRMini */
    KnownSkuName["EdgeMRMini"] = "EdgeMR_Mini";
    /** RCASmall */
    KnownSkuName["RCASmall"] = "RCA_Small";
    /** RCALarge */
    KnownSkuName["RCALarge"] = "RCA_Large";
    /** RDC */
    KnownSkuName["RDC"] = "RDC";
    /** Management */
    KnownSkuName["Management"] = "Management";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
/** Known values of {@link SkuTier} that the service accepts. */
exports.KnownSkuTier = void 0;
(function (KnownSkuTier) {
    /** Standard */
    KnownSkuTier["Standard"] = "Standard";
})(exports.KnownSkuTier || (exports.KnownSkuTier = {}));
/** Known values of {@link SkuSignupOption} that the service accepts. */
exports.KnownSkuSignupOption = void 0;
(function (KnownSkuSignupOption) {
    /** None */
    KnownSkuSignupOption["None"] = "None";
    /** Available */
    KnownSkuSignupOption["Available"] = "Available";
})(exports.KnownSkuSignupOption || (exports.KnownSkuSignupOption = {}));
/** Known values of {@link SkuVersion} that the service accepts. */
exports.KnownSkuVersion = void 0;
(function (KnownSkuVersion) {
    /** Stable */
    KnownSkuVersion["Stable"] = "Stable";
    /** Preview */
    KnownSkuVersion["Preview"] = "Preview";
})(exports.KnownSkuVersion || (exports.KnownSkuVersion = {}));
/** Known values of {@link SkuAvailability} that the service accepts. */
exports.KnownSkuAvailability = void 0;
(function (KnownSkuAvailability) {
    /** Available */
    KnownSkuAvailability["Available"] = "Available";
    /** Unavailable */
    KnownSkuAvailability["Unavailable"] = "Unavailable";
})(exports.KnownSkuAvailability || (exports.KnownSkuAvailability = {}));
/** Known values of {@link ShipmentType} that the service accepts. */
exports.KnownShipmentType = void 0;
(function (KnownShipmentType) {
    /** NotApplicable */
    KnownShipmentType["NotApplicable"] = "NotApplicable";
    /** ShippedToCustomer */
    KnownShipmentType["ShippedToCustomer"] = "ShippedToCustomer";
    /** SelfPickup */
    KnownShipmentType["SelfPickup"] = "SelfPickup";
})(exports.KnownShipmentType || (exports.KnownShipmentType = {}));
/** Known values of {@link MsiIdentityType} that the service accepts. */
exports.KnownMsiIdentityType = void 0;
(function (KnownMsiIdentityType) {
    /** None */
    KnownMsiIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownMsiIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownMsiIdentityType["UserAssigned"] = "UserAssigned";
})(exports.KnownMsiIdentityType || (exports.KnownMsiIdentityType = {}));
/** Known values of {@link DataBoxEdgeDeviceKind} that the service accepts. */
exports.KnownDataBoxEdgeDeviceKind = void 0;
(function (KnownDataBoxEdgeDeviceKind) {
    /** AzureDataBoxGateway */
    KnownDataBoxEdgeDeviceKind["AzureDataBoxGateway"] = "AzureDataBoxGateway";
    /** AzureStackEdge */
    KnownDataBoxEdgeDeviceKind["AzureStackEdge"] = "AzureStackEdge";
    /** AzureStackHub */
    KnownDataBoxEdgeDeviceKind["AzureStackHub"] = "AzureStackHub";
    /** AzureModularDataCentre */
    KnownDataBoxEdgeDeviceKind["AzureModularDataCentre"] = "AzureModularDataCentre";
})(exports.KnownDataBoxEdgeDeviceKind || (exports.KnownDataBoxEdgeDeviceKind = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DataBoxEdgeDeviceStatus} that the service accepts. */
exports.KnownDataBoxEdgeDeviceStatus = void 0;
(function (KnownDataBoxEdgeDeviceStatus) {
    /** ReadyToSetup */
    KnownDataBoxEdgeDeviceStatus["ReadyToSetup"] = "ReadyToSetup";
    /** Online */
    KnownDataBoxEdgeDeviceStatus["Online"] = "Online";
    /** Offline */
    KnownDataBoxEdgeDeviceStatus["Offline"] = "Offline";
    /** NeedsAttention */
    KnownDataBoxEdgeDeviceStatus["NeedsAttention"] = "NeedsAttention";
    /** Disconnected */
    KnownDataBoxEdgeDeviceStatus["Disconnected"] = "Disconnected";
    /** PartiallyDisconnected */
    KnownDataBoxEdgeDeviceStatus["PartiallyDisconnected"] = "PartiallyDisconnected";
    /** Maintenance */
    KnownDataBoxEdgeDeviceStatus["Maintenance"] = "Maintenance";
})(exports.KnownDataBoxEdgeDeviceStatus || (exports.KnownDataBoxEdgeDeviceStatus = {}));
/** Known values of {@link DeviceType} that the service accepts. */
exports.KnownDeviceType = void 0;
(function (KnownDeviceType) {
    /** DataBoxEdgeDevice */
    KnownDeviceType["DataBoxEdgeDevice"] = "DataBoxEdgeDevice";
})(exports.KnownDeviceType || (exports.KnownDeviceType = {}));
/** Known values of {@link RoleTypes} that the service accepts. */
exports.KnownRoleTypes = void 0;
(function (KnownRoleTypes) {
    /** IOT */
    KnownRoleTypes["IOT"] = "IOT";
    /** ASA */
    KnownRoleTypes["ASA"] = "ASA";
    /** Functions */
    KnownRoleTypes["Functions"] = "Functions";
    /** Cognitive */
    KnownRoleTypes["Cognitive"] = "Cognitive";
    /** MEC */
    KnownRoleTypes["MEC"] = "MEC";
    /** CloudEdgeManagement */
    KnownRoleTypes["CloudEdgeManagement"] = "CloudEdgeManagement";
    /** Kubernetes */
    KnownRoleTypes["Kubernetes"] = "Kubernetes";
})(exports.KnownRoleTypes || (exports.KnownRoleTypes = {}));
/** Known values of {@link ResourceMoveStatus} that the service accepts. */
exports.KnownResourceMoveStatus = void 0;
(function (KnownResourceMoveStatus) {
    /** None */
    KnownResourceMoveStatus["None"] = "None";
    /** ResourceMoveInProgress */
    KnownResourceMoveStatus["ResourceMoveInProgress"] = "ResourceMoveInProgress";
    /** ResourceMoveFailed */
    KnownResourceMoveStatus["ResourceMoveFailed"] = "ResourceMoveFailed";
})(exports.KnownResourceMoveStatus || (exports.KnownResourceMoveStatus = {}));
/** Known values of {@link SubscriptionState} that the service accepts. */
exports.KnownSubscriptionState = void 0;
(function (KnownSubscriptionState) {
    /** Registered */
    KnownSubscriptionState["Registered"] = "Registered";
    /** Warned */
    KnownSubscriptionState["Warned"] = "Warned";
    /** Suspended */
    KnownSubscriptionState["Suspended"] = "Suspended";
    /** Deleted */
    KnownSubscriptionState["Deleted"] = "Deleted";
    /** Unregistered */
    KnownSubscriptionState["Unregistered"] = "Unregistered";
})(exports.KnownSubscriptionState || (exports.KnownSubscriptionState = {}));
/** Known values of {@link DataResidencyType} that the service accepts. */
exports.KnownDataResidencyType = void 0;
(function (KnownDataResidencyType) {
    /** GeoZoneReplication */
    KnownDataResidencyType["GeoZoneReplication"] = "GeoZoneReplication";
    /** ZoneReplication */
    KnownDataResidencyType["ZoneReplication"] = "ZoneReplication";
})(exports.KnownDataResidencyType || (exports.KnownDataResidencyType = {}));
/** Known values of {@link AlertSeverity} that the service accepts. */
exports.KnownAlertSeverity = void 0;
(function (KnownAlertSeverity) {
    /** Informational */
    KnownAlertSeverity["Informational"] = "Informational";
    /** Warning */
    KnownAlertSeverity["Warning"] = "Warning";
    /** Critical */
    KnownAlertSeverity["Critical"] = "Critical";
})(exports.KnownAlertSeverity || (exports.KnownAlertSeverity = {}));
/** Known values of {@link DayOfWeek} that the service accepts. */
exports.KnownDayOfWeek = void 0;
(function (KnownDayOfWeek) {
    /** Sunday */
    KnownDayOfWeek["Sunday"] = "Sunday";
    /** Monday */
    KnownDayOfWeek["Monday"] = "Monday";
    /** Tuesday */
    KnownDayOfWeek["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownDayOfWeek["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownDayOfWeek["Thursday"] = "Thursday";
    /** Friday */
    KnownDayOfWeek["Friday"] = "Friday";
    /** Saturday */
    KnownDayOfWeek["Saturday"] = "Saturday";
})(exports.KnownDayOfWeek || (exports.KnownDayOfWeek = {}));
/** Known values of {@link ProactiveDiagnosticsConsent} that the service accepts. */
exports.KnownProactiveDiagnosticsConsent = void 0;
(function (KnownProactiveDiagnosticsConsent) {
    /** Enabled */
    KnownProactiveDiagnosticsConsent["Enabled"] = "Enabled";
    /** Disabled */
    KnownProactiveDiagnosticsConsent["Disabled"] = "Disabled";
})(exports.KnownProactiveDiagnosticsConsent || (exports.KnownProactiveDiagnosticsConsent = {}));
/** Known values of {@link RemoteApplicationType} that the service accepts. */
exports.KnownRemoteApplicationType = void 0;
(function (KnownRemoteApplicationType) {
    /** Powershell */
    KnownRemoteApplicationType["Powershell"] = "Powershell";
    /** WAC */
    KnownRemoteApplicationType["WAC"] = "WAC";
    /** LocalUI */
    KnownRemoteApplicationType["LocalUI"] = "LocalUI";
    /** AllApplications */
    KnownRemoteApplicationType["AllApplications"] = "AllApplications";
})(exports.KnownRemoteApplicationType || (exports.KnownRemoteApplicationType = {}));
/** Known values of {@link AccessLevel} that the service accepts. */
exports.KnownAccessLevel = void 0;
(function (KnownAccessLevel) {
    /** None */
    KnownAccessLevel["None"] = "None";
    /** ReadOnly */
    KnownAccessLevel["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownAccessLevel["ReadWrite"] = "ReadWrite";
    /** FullAccess */
    KnownAccessLevel["FullAccess"] = "FullAccess";
})(exports.KnownAccessLevel || (exports.KnownAccessLevel = {}));
/** Known values of {@link KeyVaultSyncStatus} that the service accepts. */
exports.KnownKeyVaultSyncStatus = void 0;
(function (KnownKeyVaultSyncStatus) {
    /** KeyVaultSynced */
    KnownKeyVaultSyncStatus["KeyVaultSynced"] = "KeyVaultSynced";
    /** KeyVaultSyncFailed */
    KnownKeyVaultSyncStatus["KeyVaultSyncFailed"] = "KeyVaultSyncFailed";
    /** KeyVaultNotConfigured */
    KnownKeyVaultSyncStatus["KeyVaultNotConfigured"] = "KeyVaultNotConfigured";
    /** KeyVaultSyncPending */
    KnownKeyVaultSyncStatus["KeyVaultSyncPending"] = "KeyVaultSyncPending";
    /** KeyVaultSyncing */
    KnownKeyVaultSyncStatus["KeyVaultSyncing"] = "KeyVaultSyncing";
    /** KeyVaultNotSynced */
    KnownKeyVaultSyncStatus["KeyVaultNotSynced"] = "KeyVaultNotSynced";
})(exports.KnownKeyVaultSyncStatus || (exports.KnownKeyVaultSyncStatus = {}));
/** Known values of {@link EncryptionAlgorithm} that the service accepts. */
exports.KnownEncryptionAlgorithm = void 0;
(function (KnownEncryptionAlgorithm) {
    /** None */
    KnownEncryptionAlgorithm["None"] = "None";
    /** AES256 */
    KnownEncryptionAlgorithm["AES256"] = "AES256";
    /** RsaesPkcs1V15 */
    KnownEncryptionAlgorithm["RsaesPkcs1V15"] = "RSAES_PKCS1_v_1_5";
})(exports.KnownEncryptionAlgorithm || (exports.KnownEncryptionAlgorithm = {}));
/** Known values of {@link JobStatus} that the service accepts. */
exports.KnownJobStatus = void 0;
(function (KnownJobStatus) {
    /** Invalid */
    KnownJobStatus["Invalid"] = "Invalid";
    /** Running */
    KnownJobStatus["Running"] = "Running";
    /** Succeeded */
    KnownJobStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownJobStatus["Failed"] = "Failed";
    /** Canceled */
    KnownJobStatus["Canceled"] = "Canceled";
    /** Paused */
    KnownJobStatus["Paused"] = "Paused";
    /** Scheduled */
    KnownJobStatus["Scheduled"] = "Scheduled";
})(exports.KnownJobStatus || (exports.KnownJobStatus = {}));
/** Known values of {@link JobType} that the service accepts. */
exports.KnownJobType = void 0;
(function (KnownJobType) {
    /** Invalid */
    KnownJobType["Invalid"] = "Invalid";
    /** ScanForUpdates */
    KnownJobType["ScanForUpdates"] = "ScanForUpdates";
    /** DownloadUpdates */
    KnownJobType["DownloadUpdates"] = "DownloadUpdates";
    /** InstallUpdates */
    KnownJobType["InstallUpdates"] = "InstallUpdates";
    /** RefreshShare */
    KnownJobType["RefreshShare"] = "RefreshShare";
    /** RefreshContainer */
    KnownJobType["RefreshContainer"] = "RefreshContainer";
    /** Backup */
    KnownJobType["Backup"] = "Backup";
    /** Restore */
    KnownJobType["Restore"] = "Restore";
    /** TriggerSupportPackage */
    KnownJobType["TriggerSupportPackage"] = "TriggerSupportPackage";
})(exports.KnownJobType || (exports.KnownJobType = {}));
/** Known values of {@link UpdateOperationStage} that the service accepts. */
exports.KnownUpdateOperationStage = void 0;
(function (KnownUpdateOperationStage) {
    /** Unknown */
    KnownUpdateOperationStage["Unknown"] = "Unknown";
    /** Initial */
    KnownUpdateOperationStage["Initial"] = "Initial";
    /** ScanStarted */
    KnownUpdateOperationStage["ScanStarted"] = "ScanStarted";
    /** ScanComplete */
    KnownUpdateOperationStage["ScanComplete"] = "ScanComplete";
    /** ScanFailed */
    KnownUpdateOperationStage["ScanFailed"] = "ScanFailed";
    /** DownloadStarted */
    KnownUpdateOperationStage["DownloadStarted"] = "DownloadStarted";
    /** DownloadComplete */
    KnownUpdateOperationStage["DownloadComplete"] = "DownloadComplete";
    /** DownloadFailed */
    KnownUpdateOperationStage["DownloadFailed"] = "DownloadFailed";
    /** InstallStarted */
    KnownUpdateOperationStage["InstallStarted"] = "InstallStarted";
    /** InstallComplete */
    KnownUpdateOperationStage["InstallComplete"] = "InstallComplete";
    /** InstallFailed */
    KnownUpdateOperationStage["InstallFailed"] = "InstallFailed";
    /** RebootInitiated */
    KnownUpdateOperationStage["RebootInitiated"] = "RebootInitiated";
    /** Success */
    KnownUpdateOperationStage["Success"] = "Success";
    /** Failure */
    KnownUpdateOperationStage["Failure"] = "Failure";
    /** RescanStarted */
    KnownUpdateOperationStage["RescanStarted"] = "RescanStarted";
    /** RescanComplete */
    KnownUpdateOperationStage["RescanComplete"] = "RescanComplete";
    /** RescanFailed */
    KnownUpdateOperationStage["RescanFailed"] = "RescanFailed";
})(exports.KnownUpdateOperationStage || (exports.KnownUpdateOperationStage = {}));
/** Known values of {@link DownloadPhase} that the service accepts. */
exports.KnownDownloadPhase = void 0;
(function (KnownDownloadPhase) {
    /** Unknown */
    KnownDownloadPhase["Unknown"] = "Unknown";
    /** Initializing */
    KnownDownloadPhase["Initializing"] = "Initializing";
    /** Downloading */
    KnownDownloadPhase["Downloading"] = "Downloading";
    /** Verifying */
    KnownDownloadPhase["Verifying"] = "Verifying";
})(exports.KnownDownloadPhase || (exports.KnownDownloadPhase = {}));
/** Known values of {@link NetworkGroup} that the service accepts. */
exports.KnownNetworkGroup = void 0;
(function (KnownNetworkGroup) {
    /** None */
    KnownNetworkGroup["None"] = "None";
    /** NonRdma */
    KnownNetworkGroup["NonRdma"] = "NonRDMA";
    /** Rdma */
    KnownNetworkGroup["Rdma"] = "RDMA";
})(exports.KnownNetworkGroup || (exports.KnownNetworkGroup = {}));
/** Known values of {@link NetworkAdapterStatus} that the service accepts. */
exports.KnownNetworkAdapterStatus = void 0;
(function (KnownNetworkAdapterStatus) {
    /** Inactive */
    KnownNetworkAdapterStatus["Inactive"] = "Inactive";
    /** Active */
    KnownNetworkAdapterStatus["Active"] = "Active";
})(exports.KnownNetworkAdapterStatus || (exports.KnownNetworkAdapterStatus = {}));
/** Known values of {@link NetworkAdapterRdmaStatus} that the service accepts. */
exports.KnownNetworkAdapterRdmaStatus = void 0;
(function (KnownNetworkAdapterRdmaStatus) {
    /** Incapable */
    KnownNetworkAdapterRdmaStatus["Incapable"] = "Incapable";
    /** Capable */
    KnownNetworkAdapterRdmaStatus["Capable"] = "Capable";
})(exports.KnownNetworkAdapterRdmaStatus || (exports.KnownNetworkAdapterRdmaStatus = {}));
/** Known values of {@link NetworkAdapterDhcpStatus} that the service accepts. */
exports.KnownNetworkAdapterDhcpStatus = void 0;
(function (KnownNetworkAdapterDhcpStatus) {
    /** Disabled */
    KnownNetworkAdapterDhcpStatus["Disabled"] = "Disabled";
    /** Enabled */
    KnownNetworkAdapterDhcpStatus["Enabled"] = "Enabled";
})(exports.KnownNetworkAdapterDhcpStatus || (exports.KnownNetworkAdapterDhcpStatus = {}));
/** Known values of {@link NodeStatus} that the service accepts. */
exports.KnownNodeStatus = void 0;
(function (KnownNodeStatus) {
    /** Unknown */
    KnownNodeStatus["Unknown"] = "Unknown";
    /** Up */
    KnownNodeStatus["Up"] = "Up";
    /** Down */
    KnownNodeStatus["Down"] = "Down";
    /** Rebooting */
    KnownNodeStatus["Rebooting"] = "Rebooting";
    /** ShuttingDown */
    KnownNodeStatus["ShuttingDown"] = "ShuttingDown";
})(exports.KnownNodeStatus || (exports.KnownNodeStatus = {}));
/** Known values of {@link OrderState} that the service accepts. */
exports.KnownOrderState = void 0;
(function (KnownOrderState) {
    /** Untracked */
    KnownOrderState["Untracked"] = "Untracked";
    /** AwaitingFulfillment */
    KnownOrderState["AwaitingFulfillment"] = "AwaitingFulfillment";
    /** AwaitingPreparation */
    KnownOrderState["AwaitingPreparation"] = "AwaitingPreparation";
    /** AwaitingShipment */
    KnownOrderState["AwaitingShipment"] = "AwaitingShipment";
    /** Shipped */
    KnownOrderState["Shipped"] = "Shipped";
    /** Arriving */
    KnownOrderState["Arriving"] = "Arriving";
    /** Delivered */
    KnownOrderState["Delivered"] = "Delivered";
    /** ReplacementRequested */
    KnownOrderState["ReplacementRequested"] = "ReplacementRequested";
    /** LostDevice */
    KnownOrderState["LostDevice"] = "LostDevice";
    /** Declined */
    KnownOrderState["Declined"] = "Declined";
    /** ReturnInitiated */
    KnownOrderState["ReturnInitiated"] = "ReturnInitiated";
    /** AwaitingReturnShipment */
    KnownOrderState["AwaitingReturnShipment"] = "AwaitingReturnShipment";
    /** ShippedBack */
    KnownOrderState["ShippedBack"] = "ShippedBack";
    /** CollectedAtMicrosoft */
    KnownOrderState["CollectedAtMicrosoft"] = "CollectedAtMicrosoft";
    /** AwaitingPickup */
    KnownOrderState["AwaitingPickup"] = "AwaitingPickup";
    /** PickupCompleted */
    KnownOrderState["PickupCompleted"] = "PickupCompleted";
    /** AwaitingDrop */
    KnownOrderState["AwaitingDrop"] = "AwaitingDrop";
})(exports.KnownOrderState || (exports.KnownOrderState = {}));
/** Known values of {@link AddonType} that the service accepts. */
exports.KnownAddonType = void 0;
(function (KnownAddonType) {
    /** IotEdge */
    KnownAddonType["IotEdge"] = "IotEdge";
    /** ArcForKubernetes */
    KnownAddonType["ArcForKubernetes"] = "ArcForKubernetes";
})(exports.KnownAddonType || (exports.KnownAddonType = {}));
/** Known values of {@link ShareStatus} that the service accepts. */
exports.KnownShareStatus = void 0;
(function (KnownShareStatus) {
    /** Offline */
    KnownShareStatus["Offline"] = "Offline";
    /** Unknown */
    KnownShareStatus["Unknown"] = "Unknown";
    /** OK */
    KnownShareStatus["OK"] = "OK";
    /** Updating */
    KnownShareStatus["Updating"] = "Updating";
    /** NeedsAttention */
    KnownShareStatus["NeedsAttention"] = "NeedsAttention";
})(exports.KnownShareStatus || (exports.KnownShareStatus = {}));
/** Known values of {@link MonitoringStatus} that the service accepts. */
exports.KnownMonitoringStatus = void 0;
(function (KnownMonitoringStatus) {
    /** Enabled */
    KnownMonitoringStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownMonitoringStatus["Disabled"] = "Disabled";
})(exports.KnownMonitoringStatus || (exports.KnownMonitoringStatus = {}));
/** Known values of {@link AzureContainerDataFormat} that the service accepts. */
exports.KnownAzureContainerDataFormat = void 0;
(function (KnownAzureContainerDataFormat) {
    /** BlockBlob */
    KnownAzureContainerDataFormat["BlockBlob"] = "BlockBlob";
    /** PageBlob */
    KnownAzureContainerDataFormat["PageBlob"] = "PageBlob";
    /** AzureFile */
    KnownAzureContainerDataFormat["AzureFile"] = "AzureFile";
})(exports.KnownAzureContainerDataFormat || (exports.KnownAzureContainerDataFormat = {}));
/** Known values of {@link ShareAccessProtocol} that the service accepts. */
exports.KnownShareAccessProtocol = void 0;
(function (KnownShareAccessProtocol) {
    /** SMB */
    KnownShareAccessProtocol["SMB"] = "SMB";
    /** NFS */
    KnownShareAccessProtocol["NFS"] = "NFS";
})(exports.KnownShareAccessProtocol || (exports.KnownShareAccessProtocol = {}));
/** Known values of {@link ShareAccessType} that the service accepts. */
exports.KnownShareAccessType = void 0;
(function (KnownShareAccessType) {
    /** Change */
    KnownShareAccessType["Change"] = "Change";
    /** Read */
    KnownShareAccessType["Read"] = "Read";
    /** Custom */
    KnownShareAccessType["Custom"] = "Custom";
})(exports.KnownShareAccessType || (exports.KnownShareAccessType = {}));
/** Known values of {@link ClientPermissionType} that the service accepts. */
exports.KnownClientPermissionType = void 0;
(function (KnownClientPermissionType) {
    /** NoAccess */
    KnownClientPermissionType["NoAccess"] = "NoAccess";
    /** ReadOnly */
    KnownClientPermissionType["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownClientPermissionType["ReadWrite"] = "ReadWrite";
})(exports.KnownClientPermissionType || (exports.KnownClientPermissionType = {}));
/** Known values of {@link MountType} that the service accepts. */
exports.KnownMountType = void 0;
(function (KnownMountType) {
    /** Volume */
    KnownMountType["Volume"] = "Volume";
    /** HostPath */
    KnownMountType["HostPath"] = "HostPath";
})(exports.KnownMountType || (exports.KnownMountType = {}));
/** Known values of {@link DataPolicy} that the service accepts. */
exports.KnownDataPolicy = void 0;
(function (KnownDataPolicy) {
    /** Cloud */
    KnownDataPolicy["Cloud"] = "Cloud";
    /** Local */
    KnownDataPolicy["Local"] = "Local";
})(exports.KnownDataPolicy || (exports.KnownDataPolicy = {}));
/** Known values of {@link SSLStatus} that the service accepts. */
exports.KnownSSLStatus = void 0;
(function (KnownSSLStatus) {
    /** Enabled */
    KnownSSLStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownSSLStatus["Disabled"] = "Disabled";
})(exports.KnownSSLStatus || (exports.KnownSSLStatus = {}));
/** Known values of {@link AccountType} that the service accepts. */
exports.KnownAccountType = void 0;
(function (KnownAccountType) {
    /** GeneralPurposeStorage */
    KnownAccountType["GeneralPurposeStorage"] = "GeneralPurposeStorage";
    /** BlobStorage */
    KnownAccountType["BlobStorage"] = "BlobStorage";
})(exports.KnownAccountType || (exports.KnownAccountType = {}));
/** Known values of {@link StorageAccountStatus} that the service accepts. */
exports.KnownStorageAccountStatus = void 0;
(function (KnownStorageAccountStatus) {
    /** OK */
    KnownStorageAccountStatus["OK"] = "OK";
    /** Offline */
    KnownStorageAccountStatus["Offline"] = "Offline";
    /** Unknown */
    KnownStorageAccountStatus["Unknown"] = "Unknown";
    /** Updating */
    KnownStorageAccountStatus["Updating"] = "Updating";
    /** NeedsAttention */
    KnownStorageAccountStatus["NeedsAttention"] = "NeedsAttention";
})(exports.KnownStorageAccountStatus || (exports.KnownStorageAccountStatus = {}));
/** Known values of {@link ContainerStatus} that the service accepts. */
exports.KnownContainerStatus = void 0;
(function (KnownContainerStatus) {
    /** OK */
    KnownContainerStatus["OK"] = "OK";
    /** Offline */
    KnownContainerStatus["Offline"] = "Offline";
    /** Unknown */
    KnownContainerStatus["Unknown"] = "Unknown";
    /** Updating */
    KnownContainerStatus["Updating"] = "Updating";
    /** NeedsAttention */
    KnownContainerStatus["NeedsAttention"] = "NeedsAttention";
})(exports.KnownContainerStatus || (exports.KnownContainerStatus = {}));
/** Known values of {@link TriggerEventType} that the service accepts. */
exports.KnownTriggerEventType = void 0;
(function (KnownTriggerEventType) {
    /** FileEvent */
    KnownTriggerEventType["FileEvent"] = "FileEvent";
    /** PeriodicTimerEvent */
    KnownTriggerEventType["PeriodicTimerEvent"] = "PeriodicTimerEvent";
})(exports.KnownTriggerEventType || (exports.KnownTriggerEventType = {}));
/** Known values of {@link InstallRebootBehavior} that the service accepts. */
exports.KnownInstallRebootBehavior = void 0;
(function (KnownInstallRebootBehavior) {
    /** NeverReboots */
    KnownInstallRebootBehavior["NeverReboots"] = "NeverReboots";
    /** RequiresReboot */
    KnownInstallRebootBehavior["RequiresReboot"] = "RequiresReboot";
    /** RequestReboot */
    KnownInstallRebootBehavior["RequestReboot"] = "RequestReboot";
})(exports.KnownInstallRebootBehavior || (exports.KnownInstallRebootBehavior = {}));
/** Known values of {@link UpdateOperation} that the service accepts. */
exports.KnownUpdateOperation = void 0;
(function (KnownUpdateOperation) {
    /** None */
    KnownUpdateOperation["None"] = "None";
    /** Scan */
    KnownUpdateOperation["Scan"] = "Scan";
    /** Download */
    KnownUpdateOperation["Download"] = "Download";
    /** Install */
    KnownUpdateOperation["Install"] = "Install";
})(exports.KnownUpdateOperation || (exports.KnownUpdateOperation = {}));
/** Known values of {@link UpdateType} that the service accepts. */
exports.KnownUpdateType = void 0;
(function (KnownUpdateType) {
    /** Software */
    KnownUpdateType["Software"] = "Software";
    /** Kubernetes */
    KnownUpdateType["Kubernetes"] = "Kubernetes";
    /** Firmware */
    KnownUpdateType["Firmware"] = "Firmware";
})(exports.KnownUpdateType || (exports.KnownUpdateType = {}));
/** Known values of {@link InstallationImpact} that the service accepts. */
exports.KnownInstallationImpact = void 0;
(function (KnownInstallationImpact) {
    /** None */
    KnownInstallationImpact["None"] = "None";
    /** DeviceRebooted */
    KnownInstallationImpact["DeviceRebooted"] = "DeviceRebooted";
    /** KubernetesWorkloadsDown */
    KnownInstallationImpact["KubernetesWorkloadsDown"] = "KubernetesWorkloadsDown";
})(exports.KnownInstallationImpact || (exports.KnownInstallationImpact = {}));
/** Known values of {@link UpdateStatus} that the service accepts. */
exports.KnownUpdateStatus = void 0;
(function (KnownUpdateStatus) {
    /** DownloadPending */
    KnownUpdateStatus["DownloadPending"] = "DownloadPending";
    /** DownloadStarted */
    KnownUpdateStatus["DownloadStarted"] = "DownloadStarted";
    /** DownloadCompleted */
    KnownUpdateStatus["DownloadCompleted"] = "DownloadCompleted";
    /** InstallStarted */
    KnownUpdateStatus["InstallStarted"] = "InstallStarted";
    /** InstallCompleted */
    KnownUpdateStatus["InstallCompleted"] = "InstallCompleted";
})(exports.KnownUpdateStatus || (exports.KnownUpdateStatus = {}));
/** Known values of {@link AuthenticationType} that the service accepts. */
exports.KnownAuthenticationType = void 0;
(function (KnownAuthenticationType) {
    /** Invalid */
    KnownAuthenticationType["Invalid"] = "Invalid";
    /** AzureActiveDirectory */
    KnownAuthenticationType["AzureActiveDirectory"] = "AzureActiveDirectory";
})(exports.KnownAuthenticationType || (exports.KnownAuthenticationType = {}));
/** Known values of {@link UserType} that the service accepts. */
exports.KnownUserType = void 0;
(function (KnownUserType) {
    /** Share */
    KnownUserType["Share"] = "Share";
    /** LocalManagement */
    KnownUserType["LocalManagement"] = "LocalManagement";
    /** ARM */
    KnownUserType["ARM"] = "ARM";
})(exports.KnownUserType || (exports.KnownUserType = {}));
/** Known values of {@link PlatformType} that the service accepts. */
exports.KnownPlatformType = void 0;
(function (KnownPlatformType) {
    /** Windows */
    KnownPlatformType["Windows"] = "Windows";
    /** Linux */
    KnownPlatformType["Linux"] = "Linux";
})(exports.KnownPlatformType || (exports.KnownPlatformType = {}));
/** Known values of {@link HostPlatformType} that the service accepts. */
exports.KnownHostPlatformType = void 0;
(function (KnownHostPlatformType) {
    /** KubernetesCluster */
    KnownHostPlatformType["KubernetesCluster"] = "KubernetesCluster";
    /** LinuxVM */
    KnownHostPlatformType["LinuxVM"] = "LinuxVM";
})(exports.KnownHostPlatformType || (exports.KnownHostPlatformType = {}));
/** Known values of {@link AddonState} that the service accepts. */
exports.KnownAddonState = void 0;
(function (KnownAddonState) {
    /** Invalid */
    KnownAddonState["Invalid"] = "Invalid";
    /** Creating */
    KnownAddonState["Creating"] = "Creating";
    /** Created */
    KnownAddonState["Created"] = "Created";
    /** Updating */
    KnownAddonState["Updating"] = "Updating";
    /** Reconfiguring */
    KnownAddonState["Reconfiguring"] = "Reconfiguring";
    /** Failed */
    KnownAddonState["Failed"] = "Failed";
    /** Deleting */
    KnownAddonState["Deleting"] = "Deleting";
})(exports.KnownAddonState || (exports.KnownAddonState = {}));
/** Known values of {@link RoleStatus} that the service accepts. */
exports.KnownRoleStatus = void 0;
(function (KnownRoleStatus) {
    /** Enabled */
    KnownRoleStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownRoleStatus["Disabled"] = "Disabled";
})(exports.KnownRoleStatus || (exports.KnownRoleStatus = {}));
/** Known values of {@link KubernetesNodeType} that the service accepts. */
exports.KnownKubernetesNodeType = void 0;
(function (KnownKubernetesNodeType) {
    /** Invalid */
    KnownKubernetesNodeType["Invalid"] = "Invalid";
    /** Master */
    KnownKubernetesNodeType["Master"] = "Master";
    /** Worker */
    KnownKubernetesNodeType["Worker"] = "Worker";
})(exports.KnownKubernetesNodeType || (exports.KnownKubernetesNodeType = {}));
/** Known values of {@link KubernetesState} that the service accepts. */
exports.KnownKubernetesState = void 0;
(function (KnownKubernetesState) {
    /** Invalid */
    KnownKubernetesState["Invalid"] = "Invalid";
    /** Creating */
    KnownKubernetesState["Creating"] = "Creating";
    /** Created */
    KnownKubernetesState["Created"] = "Created";
    /** Updating */
    KnownKubernetesState["Updating"] = "Updating";
    /** Reconfiguring */
    KnownKubernetesState["Reconfiguring"] = "Reconfiguring";
    /** Failed */
    KnownKubernetesState["Failed"] = "Failed";
    /** Deleting */
    KnownKubernetesState["Deleting"] = "Deleting";
})(exports.KnownKubernetesState || (exports.KnownKubernetesState = {}));
/** Known values of {@link PosixComplianceStatus} that the service accepts. */
exports.KnownPosixComplianceStatus = void 0;
(function (KnownPosixComplianceStatus) {
    /** Invalid */
    KnownPosixComplianceStatus["Invalid"] = "Invalid";
    /** Enabled */
    KnownPosixComplianceStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownPosixComplianceStatus["Disabled"] = "Disabled";
})(exports.KnownPosixComplianceStatus || (exports.KnownPosixComplianceStatus = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationsList = {
    type: {
        name: "Composite",
        className: "OperationsList",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecificationV1"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecificationV1 = {
    type: {
        name: "Composite",
        className: "MetricSpecificationV1",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimensionV1"
                        }
                    }
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetricDimensionV1 = {
    type: {
        name: "Composite",
        className: "MetricDimensionV1",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const DataBoxEdgeSkuList = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeSkuList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataBoxEdgeSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataBoxEdgeSku = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            apiVersions: {
                serializedName: "apiVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuLocationInfo"
                        }
                    }
                }
            },
            costs: {
                serializedName: "costs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuCost"
                        }
                    }
                }
            },
            signupOption: {
                serializedName: "signupOption",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availability: {
                serializedName: "availability",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            shipmentTypes: {
                serializedName: "shipmentTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuCapability"
                        }
                    }
                }
            }
        }
    }
};
const SkuLocationInfo = {
    type: {
        name: "Composite",
        className: "SkuLocationInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sites: {
                serializedName: "sites",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SkuCost = {
    type: {
        name: "Composite",
        className: "SkuCost",
        modelProperties: {
            meterId: {
                serializedName: "meterId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            quantity: {
                serializedName: "quantity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            extendedUnit: {
                serializedName: "extendedUnit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuCapability = {
    type: {
        name: "Composite",
        className: "SkuCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataBoxEdgeDeviceList = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeDeviceList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataBoxEdgeDevice"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceIdentity = {
    type: {
        name: "Composite",
        className: "ResourceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ResourceMoveDetails = {
    type: {
        name: "Composite",
        className: "ResourceMoveDetails",
        modelProperties: {
            operationInProgress: {
                serializedName: "operationInProgress",
                type: {
                    name: "String"
                }
            },
            operationInProgressLockTimeoutInUTC: {
                serializedName: "operationInProgressLockTimeoutInUTC",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const EdgeProfile = {
    type: {
        name: "Composite",
        className: "EdgeProfile",
        modelProperties: {
            subscription: {
                serializedName: "subscription",
                type: {
                    name: "Composite",
                    className: "EdgeProfileSubscription"
                }
            }
        }
    }
};
const EdgeProfileSubscription = {
    type: {
        name: "Composite",
        className: "EdgeProfileSubscription",
        modelProperties: {
            registrationId: {
                serializedName: "registrationId",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            registrationDate: {
                serializedName: "registrationDate",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            },
            locationPlacementId: {
                serializedName: "properties.locationPlacementId",
                type: {
                    name: "String"
                }
            },
            quotaId: {
                serializedName: "properties.quotaId",
                type: {
                    name: "String"
                }
            },
            serializedDetails: {
                serializedName: "properties.serializedDetails",
                type: {
                    name: "String"
                }
            },
            registeredFeatures: {
                serializedName: "properties.registeredFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubscriptionRegisteredFeatures"
                        }
                    }
                }
            }
        }
    }
};
const SubscriptionRegisteredFeatures = {
    type: {
        name: "Composite",
        className: "SubscriptionRegisteredFeatures",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataResidency = {
    type: {
        name: "Composite",
        className: "DataResidency",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ARMBaseModel = {
    type: {
        name: "Composite",
        className: "ARMBaseModel",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataBoxEdgeDevicePatch = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeDevicePatch",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            edgeProfile: {
                serializedName: "properties.edgeProfile",
                type: {
                    name: "Composite",
                    className: "EdgeProfilePatch"
                }
            }
        }
    }
};
const EdgeProfilePatch = {
    type: {
        name: "Composite",
        className: "EdgeProfilePatch",
        modelProperties: {
            subscription: {
                serializedName: "subscription",
                type: {
                    name: "Composite",
                    className: "EdgeProfileSubscriptionPatch"
                }
            }
        }
    }
};
const EdgeProfileSubscriptionPatch = {
    type: {
        name: "Composite",
        className: "EdgeProfileSubscriptionPatch",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertList = {
    type: {
        name: "Composite",
        className: "AlertList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Alert"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AlertErrorDetails = {
    type: {
        name: "Composite",
        className: "AlertErrorDetails",
        modelProperties: {
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            occurrences: {
                serializedName: "occurrences",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BandwidthSchedulesList = {
    type: {
        name: "Composite",
        className: "BandwidthSchedulesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BandwidthSchedule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RemoteSupportSettings = {
    type: {
        name: "Composite",
        className: "RemoteSupportSettings",
        modelProperties: {
            remoteApplicationType: {
                serializedName: "remoteApplicationType",
                type: {
                    name: "String"
                }
            },
            accessLevel: {
                serializedName: "accessLevel",
                type: {
                    name: "String"
                }
            },
            expirationTimeStampInUTC: {
                serializedName: "expirationTimeStampInUTC",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GenerateCertResponse = {
    type: {
        name: "Composite",
        className: "GenerateCertResponse",
        modelProperties: {
            publicKey: {
                serializedName: "publicKey",
                type: {
                    name: "String"
                }
            },
            privateKey: {
                serializedName: "privateKey",
                type: {
                    name: "String"
                }
            },
            expiryTimeInUTC: {
                serializedName: "expiryTimeInUTC",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: {
            encryptedSecret: {
                serializedName: "encryptedSecret",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            },
            keyVaultId: {
                serializedName: "keyVaultId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AsymmetricEncryptedSecret = {
    type: {
        name: "Composite",
        className: "AsymmetricEncryptedSecret",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptionCertThumbprint: {
                serializedName: "encryptionCertThumbprint",
                type: {
                    name: "String"
                }
            },
            encryptionAlgorithm: {
                serializedName: "encryptionAlgorithm",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Job = {
    type: {
        name: "Composite",
        className: "Job",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            percentComplete: {
                serializedName: "percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "JobErrorDetails"
                }
            },
            jobType: {
                serializedName: "properties.jobType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentStage: {
                serializedName: "properties.currentStage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            downloadProgress: {
                serializedName: "properties.downloadProgress",
                type: {
                    name: "Composite",
                    className: "UpdateDownloadProgress"
                }
            },
            installProgress: {
                serializedName: "properties.installProgress",
                type: {
                    name: "Composite",
                    className: "UpdateInstallProgress"
                }
            },
            totalRefreshErrors: {
                serializedName: "properties.totalRefreshErrors",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            errorManifestFile: {
                serializedName: "properties.errorManifestFile",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            refreshedEntityId: {
                serializedName: "properties.refreshedEntityId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            folder: {
                serializedName: "properties.folder",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobErrorDetails = {
    type: {
        name: "Composite",
        className: "JobErrorDetails",
        modelProperties: {
            errorDetails: {
                serializedName: "errorDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobErrorItem"
                        }
                    }
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobErrorItem = {
    type: {
        name: "Composite",
        className: "JobErrorItem",
        modelProperties: {
            recommendations: {
                serializedName: "recommendations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateDownloadProgress = {
    type: {
        name: "Composite",
        className: "UpdateDownloadProgress",
        modelProperties: {
            downloadPhase: {
                serializedName: "downloadPhase",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            percentComplete: {
                serializedName: "percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            totalBytesToDownload: {
                serializedName: "totalBytesToDownload",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            totalBytesDownloaded: {
                serializedName: "totalBytesDownloaded",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            numberOfUpdatesToDownload: {
                serializedName: "numberOfUpdatesToDownload",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            numberOfUpdatesDownloaded: {
                serializedName: "numberOfUpdatesDownloaded",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const UpdateInstallProgress = {
    type: {
        name: "Composite",
        className: "UpdateInstallProgress",
        modelProperties: {
            percentComplete: {
                serializedName: "percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            numberOfUpdatesToInstall: {
                serializedName: "numberOfUpdatesToInstall",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            numberOfUpdatesInstalled: {
                serializedName: "numberOfUpdatesInstalled",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NetworkAdapter = {
    type: {
        name: "Composite",
        className: "NetworkAdapter",
        modelProperties: {
            adapterId: {
                serializedName: "adapterId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            adapterPosition: {
                serializedName: "adapterPosition",
                type: {
                    name: "Composite",
                    className: "NetworkAdapterPosition"
                }
            },
            index: {
                serializedName: "index",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            nodeId: {
                serializedName: "nodeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            networkAdapterName: {
                serializedName: "networkAdapterName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            macAddress: {
                serializedName: "macAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            linkSpeed: {
                serializedName: "linkSpeed",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rdmaStatus: {
                serializedName: "rdmaStatus",
                type: {
                    name: "String"
                }
            },
            dhcpStatus: {
                serializedName: "dhcpStatus",
                type: {
                    name: "String"
                }
            },
            ipv4Configuration: {
                serializedName: "ipv4Configuration",
                type: {
                    name: "Composite",
                    className: "Ipv4Config"
                }
            },
            ipv6Configuration: {
                serializedName: "ipv6Configuration",
                type: {
                    name: "Composite",
                    className: "Ipv6Config"
                }
            },
            ipv6LinkLocalAddress: {
                serializedName: "ipv6LinkLocalAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dnsServers: {
                serializedName: "dnsServers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NetworkAdapterPosition = {
    type: {
        name: "Composite",
        className: "NetworkAdapterPosition",
        modelProperties: {
            networkGroup: {
                serializedName: "networkGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Ipv4Config = {
    type: {
        name: "Composite",
        className: "Ipv4Config",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            gateway: {
                serializedName: "gateway",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Ipv6Config = {
    type: {
        name: "Composite",
        className: "Ipv6Config",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            prefixLength: {
                serializedName: "prefixLength",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            gateway: {
                serializedName: "gateway",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeList = {
    type: {
        name: "Composite",
        className: "NodeList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Node"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OrderList = {
    type: {
        name: "Composite",
        className: "OrderList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Order"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContactDetails = {
    type: {
        name: "Composite",
        className: "ContactDetails",
        modelProperties: {
            contactPerson: {
                serializedName: "contactPerson",
                required: true,
                type: {
                    name: "String"
                }
            },
            companyName: {
                serializedName: "companyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                required: true,
                type: {
                    name: "String"
                }
            },
            emailList: {
                serializedName: "emailList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Address = {
    type: {
        name: "Composite",
        className: "Address",
        modelProperties: {
            addressLine1: {
                serializedName: "addressLine1",
                type: {
                    name: "String"
                }
            },
            addressLine2: {
                serializedName: "addressLine2",
                type: {
                    name: "String"
                }
            },
            addressLine3: {
                serializedName: "addressLine3",
                type: {
                    name: "String"
                }
            },
            postalCode: {
                serializedName: "postalCode",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            country: {
                serializedName: "country",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OrderStatus = {
    type: {
        name: "Composite",
        className: "OrderStatus",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            updateDateTime: {
                serializedName: "updateDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            comments: {
                serializedName: "comments",
                type: {
                    name: "String"
                }
            },
            trackingInformation: {
                serializedName: "trackingInformation",
                type: {
                    name: "Composite",
                    className: "TrackingInfo"
                }
            },
            additionalOrderDetails: {
                serializedName: "additionalOrderDetails",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const TrackingInfo = {
    type: {
        name: "Composite",
        className: "TrackingInfo",
        modelProperties: {
            serialNumber: {
                serializedName: "serialNumber",
                type: {
                    name: "String"
                }
            },
            carrierName: {
                serializedName: "carrierName",
                type: {
                    name: "String"
                }
            },
            trackingId: {
                serializedName: "trackingId",
                type: {
                    name: "String"
                }
            },
            trackingUrl: {
                serializedName: "trackingUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DCAccessCode = {
    type: {
        name: "Composite",
        className: "DCAccessCode",
        modelProperties: {
            authCode: {
                serializedName: "properties.authCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleList = {
    type: {
        name: "Composite",
        className: "RoleList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddonList = {
    type: {
        name: "Composite",
        className: "AddonList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Addon"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MonitoringMetricConfigurationList = {
    type: {
        name: "Composite",
        className: "MonitoringMetricConfigurationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MonitoringMetricConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricConfiguration = {
    type: {
        name: "Composite",
        className: "MetricConfiguration",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            mdmAccount: {
                serializedName: "mdmAccount",
                type: {
                    name: "String"
                }
            },
            metricNameSpace: {
                serializedName: "metricNameSpace",
                type: {
                    name: "String"
                }
            },
            counterSets: {
                serializedName: "counterSets",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricCounterSet"
                        }
                    }
                }
            }
        }
    }
};
const MetricCounterSet = {
    type: {
        name: "Composite",
        className: "MetricCounterSet",
        modelProperties: {
            counters: {
                serializedName: "counters",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricCounter"
                        }
                    }
                }
            }
        }
    }
};
const MetricCounter = {
    type: {
        name: "Composite",
        className: "MetricCounter",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            instance: {
                serializedName: "instance",
                type: {
                    name: "String"
                }
            },
            dimensionFilter: {
                serializedName: "dimensionFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            },
            additionalDimensions: {
                serializedName: "additionalDimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            }
        }
    }
};
const MetricDimension = {
    type: {
        name: "Composite",
        className: "MetricDimension",
        modelProperties: {
            sourceType: {
                serializedName: "sourceType",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceName: {
                serializedName: "sourceName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareList = {
    type: {
        name: "Composite",
        className: "ShareList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Share"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureContainerInfo = {
    type: {
        name: "Composite",
        className: "AzureContainerInfo",
        modelProperties: {
            storageAccountCredentialId: {
                serializedName: "storageAccountCredentialId",
                required: true,
                type: {
                    name: "String"
                }
            },
            containerName: {
                serializedName: "containerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            dataFormat: {
                serializedName: "dataFormat",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserAccessRight = {
    type: {
        name: "Composite",
        className: "UserAccessRight",
        modelProperties: {
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessType: {
                serializedName: "accessType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientAccessRight = {
    type: {
        name: "Composite",
        className: "ClientAccessRight",
        modelProperties: {
            client: {
                serializedName: "client",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessPermission: {
                serializedName: "accessPermission",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RefreshDetails = {
    type: {
        name: "Composite",
        className: "RefreshDetails",
        modelProperties: {
            inProgressRefreshJobId: {
                serializedName: "inProgressRefreshJobId",
                type: {
                    name: "String"
                }
            },
            lastCompletedRefreshJobTimeInUTC: {
                serializedName: "lastCompletedRefreshJobTimeInUTC",
                type: {
                    name: "DateTime"
                }
            },
            errorManifestFile: {
                serializedName: "errorManifestFile",
                type: {
                    name: "String"
                }
            },
            lastJob: {
                serializedName: "lastJob",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MountPointMap = {
    type: {
        name: "Composite",
        className: "MountPointMap",
        modelProperties: {
            shareId: {
                serializedName: "shareId",
                required: true,
                type: {
                    name: "String"
                }
            },
            roleId: {
                serializedName: "roleId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            mountPoint: {
                serializedName: "mountPoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            mountType: {
                serializedName: "mountType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roleType: {
                serializedName: "roleType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountCredentialList = {
    type: {
        name: "Composite",
        className: "StorageAccountCredentialList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccountCredential"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageAccountList = {
    type: {
        name: "Composite",
        className: "StorageAccountList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerList = {
    type: {
        name: "Composite",
        className: "ContainerList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggerList = {
    type: {
        name: "Composite",
        className: "TriggerList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Trigger"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataBoxEdgeDeviceExtendedInfoPatch = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeDeviceExtendedInfoPatch",
        modelProperties: {
            clientSecretStoreId: {
                serializedName: "clientSecretStoreId",
                type: {
                    name: "String"
                }
            },
            clientSecretStoreUrl: {
                serializedName: "clientSecretStoreUrl",
                type: {
                    name: "String"
                }
            },
            channelIntegrityKeyName: {
                serializedName: "channelIntegrityKeyName",
                type: {
                    name: "String"
                }
            },
            channelIntegrityKeyVersion: {
                serializedName: "channelIntegrityKeyVersion",
                type: {
                    name: "String"
                }
            },
            syncStatus: {
                serializedName: "syncStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateDetails = {
    type: {
        name: "Composite",
        className: "UpdateDetails",
        modelProperties: {
            updateTitle: {
                serializedName: "updateTitle",
                type: {
                    name: "String"
                }
            },
            updateSize: {
                serializedName: "updateSize",
                type: {
                    name: "Number"
                }
            },
            updateType: {
                serializedName: "updateType",
                type: {
                    name: "String"
                }
            },
            targetVersion: {
                serializedName: "targetVersion",
                type: {
                    name: "String"
                }
            },
            friendlyVersionNumber: {
                serializedName: "friendlyVersionNumber",
                type: {
                    name: "String"
                }
            },
            estimatedInstallTimeInMins: {
                serializedName: "estimatedInstallTimeInMins",
                type: {
                    name: "Number"
                }
            },
            rebootBehavior: {
                serializedName: "rebootBehavior",
                type: {
                    name: "String"
                }
            },
            installationImpact: {
                serializedName: "installationImpact",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UploadCertificateRequest = {
    type: {
        name: "Composite",
        className: "UploadCertificateRequest",
        modelProperties: {
            authenticationType: {
                serializedName: "properties.authenticationType",
                type: {
                    name: "String"
                }
            },
            certificate: {
                serializedName: "properties.certificate",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UploadCertificateResponse = {
    type: {
        name: "Composite",
        className: "UploadCertificateResponse",
        modelProperties: {
            authType: {
                serializedName: "authType",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            aadAuthority: {
                serializedName: "aadAuthority",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            aadTenantId: {
                serializedName: "aadTenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            servicePrincipalClientId: {
                serializedName: "servicePrincipalClientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            servicePrincipalObjectId: {
                serializedName: "servicePrincipalObjectId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            azureManagementEndpointAudience: {
                serializedName: "azureManagementEndpointAudience",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            aadAudience: {
                serializedName: "aadAudience",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserList = {
    type: {
        name: "Composite",
        className: "UserList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "User"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShareAccessRight = {
    type: {
        name: "Composite",
        className: "ShareAccessRight",
        modelProperties: {
            shareId: {
                serializedName: "shareId",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessType: {
                serializedName: "accessType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Authentication = {
    type: {
        name: "Composite",
        className: "Authentication",
        modelProperties: {
            symmetricKey: {
                serializedName: "symmetricKey",
                type: {
                    name: "Composite",
                    className: "SymmetricKey"
                }
            }
        }
    }
};
const SymmetricKey = {
    type: {
        name: "Composite",
        className: "SymmetricKey",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            }
        }
    }
};
const CniConfig = {
    type: {
        name: "Composite",
        className: "CniConfig",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            podSubnet: {
                serializedName: "podSubnet",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceSubnet: {
                serializedName: "serviceSubnet",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeResource = {
    type: {
        name: "Composite",
        className: "ComputeResource",
        modelProperties: {
            processorCount: {
                serializedName: "processorCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            memoryInGB: {
                serializedName: "memoryInGB",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DataBoxEdgeMoveRequest = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeMoveRequest",
        modelProperties: {
            targetResourceGroup: {
                serializedName: "targetResourceGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            resources: {
                serializedName: "resources",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EtcdInfo = {
    type: {
        name: "Composite",
        className: "EtcdInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FileSourceInfo = {
    type: {
        name: "Composite",
        className: "FileSourceInfo",
        modelProperties: {
            shareId: {
                serializedName: "shareId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleSinkInfo = {
    type: {
        name: "Composite",
        className: "RoleSinkInfo",
        modelProperties: {
            roleId: {
                serializedName: "roleId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageRepositoryCredential = {
    type: {
        name: "Composite",
        className: "ImageRepositoryCredential",
        modelProperties: {
            imageRepositoryUrl: {
                serializedName: "imageRepositoryUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            userName: {
                serializedName: "userName",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            }
        }
    }
};
const IoTDeviceInfo = {
    type: {
        name: "Composite",
        className: "IoTDeviceInfo",
        modelProperties: {
            deviceId: {
                serializedName: "deviceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            ioTHostHub: {
                serializedName: "ioTHostHub",
                required: true,
                type: {
                    name: "String"
                }
            },
            ioTHostHubId: {
                serializedName: "ioTHostHubId",
                type: {
                    name: "String"
                }
            },
            authentication: {
                serializedName: "authentication",
                type: {
                    name: "Composite",
                    className: "Authentication"
                }
            }
        }
    }
};
const IoTEdgeAgentInfo = {
    type: {
        name: "Composite",
        className: "IoTEdgeAgentInfo",
        modelProperties: {
            imageName: {
                serializedName: "imageName",
                required: true,
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                required: true,
                type: {
                    name: "String"
                }
            },
            imageRepository: {
                serializedName: "imageRepository",
                type: {
                    name: "Composite",
                    className: "ImageRepositoryCredential"
                }
            }
        }
    }
};
const KubernetesClusterInfo = {
    type: {
        name: "Composite",
        className: "KubernetesClusterInfo",
        modelProperties: {
            etcdInfo: {
                serializedName: "etcdInfo",
                type: {
                    name: "Composite",
                    className: "EtcdInfo"
                }
            },
            nodes: {
                serializedName: "nodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NodeInfo"
                        }
                    }
                }
            },
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeInfo = {
    type: {
        name: "Composite",
        className: "NodeInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipConfiguration: {
                serializedName: "ipConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KubernetesIPConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const KubernetesIPConfiguration = {
    type: {
        name: "Composite",
        className: "KubernetesIPConfiguration",
        modelProperties: {
            port: {
                serializedName: "port",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubernetesRoleResources = {
    type: {
        name: "Composite",
        className: "KubernetesRoleResources",
        modelProperties: {
            storage: {
                serializedName: "storage",
                type: {
                    name: "Composite",
                    className: "KubernetesRoleStorage"
                }
            },
            compute: {
                serializedName: "compute",
                type: {
                    name: "Composite",
                    className: "KubernetesRoleCompute"
                }
            },
            network: {
                serializedName: "network",
                type: {
                    name: "Composite",
                    className: "KubernetesRoleNetwork"
                }
            }
        }
    }
};
const KubernetesRoleStorage = {
    type: {
        name: "Composite",
        className: "KubernetesRoleStorage",
        modelProperties: {
            storageClasses: {
                serializedName: "storageClasses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KubernetesRoleStorageClassInfo"
                        }
                    }
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountPointMap"
                        }
                    }
                }
            }
        }
    }
};
const KubernetesRoleStorageClassInfo = {
    type: {
        name: "Composite",
        className: "KubernetesRoleStorageClassInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            posixCompliant: {
                serializedName: "posixCompliant",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubernetesRoleCompute = {
    type: {
        name: "Composite",
        className: "KubernetesRoleCompute",
        modelProperties: {
            vmProfile: {
                serializedName: "vmProfile",
                required: true,
                type: {
                    name: "String"
                }
            },
            memoryInBytes: {
                serializedName: "memoryInBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            processorCount: {
                serializedName: "processorCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KubernetesRoleNetwork = {
    type: {
        name: "Composite",
        className: "KubernetesRoleNetwork",
        modelProperties: {
            cniConfig: {
                serializedName: "cniConfig",
                type: {
                    name: "Composite",
                    className: "CniConfig"
                }
            },
            loadBalancerConfig: {
                serializedName: "loadBalancerConfig",
                type: {
                    name: "Composite",
                    className: "LoadBalancerConfig"
                }
            }
        }
    }
};
const LoadBalancerConfig = {
    type: {
        name: "Composite",
        className: "LoadBalancerConfig",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeriodicTimerSourceInfo = {
    type: {
        name: "Composite",
        className: "PeriodicTimerSourceInfo",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            schedule: {
                serializedName: "schedule",
                required: true,
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceTypeSku = {
    type: {
        name: "Composite",
        className: "ResourceTypeSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            skus: {
                serializedName: "skus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuInformation"
                        }
                    }
                }
            }
        }
    }
};
const SkuInformation = {
    type: {
        name: "Composite",
        className: "SkuInformation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            costs: {
                serializedName: "costs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuCost"
                        }
                    }
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuLocationInfo"
                        }
                    }
                }
            },
            requiredQuotaIds: {
                serializedName: "requiredQuotaIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredFeatures: {
                serializedName: "requiredFeatures",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SkuInformationList = {
    type: {
        name: "Composite",
        className: "SkuInformationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceTypeSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataBoxEdgeDevice = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeDevice",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, systemDataPropertiesSystemData: {
                serializedName: "properties.systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, dataBoxEdgeDeviceStatus: {
                serializedName: "properties.dataBoxEdgeDeviceStatus",
                type: {
                    name: "String"
                }
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, modelDescription: {
                serializedName: "properties.modelDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deviceType: {
                serializedName: "properties.deviceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, culture: {
                serializedName: "properties.culture",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deviceModel: {
                serializedName: "properties.deviceModel",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deviceSoftwareVersion: {
                serializedName: "properties.deviceSoftwareVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deviceLocalCapacity: {
                serializedName: "properties.deviceLocalCapacity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, timeZone: {
                serializedName: "properties.timeZone",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deviceHcsVersion: {
                serializedName: "properties.deviceHcsVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, configuredRoleTypes: {
                serializedName: "properties.configuredRoleTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, nodeCount: {
                serializedName: "properties.nodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, resourceMoveDetails: {
                serializedName: "properties.resourceMoveDetails",
                type: {
                    name: "Composite",
                    className: "ResourceMoveDetails"
                }
            }, edgeProfile: {
                serializedName: "properties.edgeProfile",
                type: {
                    name: "Composite",
                    className: "EdgeProfile"
                }
            }, dataResidency: {
                serializedName: "properties.dataResidency",
                type: {
                    name: "Composite",
                    className: "DataResidency"
                }
            } })
    }
};
const Alert = {
    type: {
        name: "Composite",
        className: "Alert",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, title: {
                serializedName: "properties.title",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, alertType: {
                serializedName: "properties.alertType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, appearedAtDateTime: {
                serializedName: "properties.appearedAtDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, recommendation: {
                serializedName: "properties.recommendation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, severity: {
                serializedName: "properties.severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorDetails: {
                serializedName: "properties.errorDetails",
                type: {
                    name: "Composite",
                    className: "AlertErrorDetails"
                }
            }, detailedInformation: {
                serializedName: "properties.detailedInformation",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const BandwidthSchedule = {
    type: {
        name: "Composite",
        className: "BandwidthSchedule",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, start: {
                serializedName: "properties.start",
                required: true,
                type: {
                    name: "String"
                }
            }, stop: {
                serializedName: "properties.stop",
                required: true,
                type: {
                    name: "String"
                }
            }, rateInMbps: {
                serializedName: "properties.rateInMbps",
                required: true,
                type: {
                    name: "Number"
                }
            }, days: {
                serializedName: "properties.days",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const DiagnosticProactiveLogCollectionSettings = {
    type: {
        name: "Composite",
        className: "DiagnosticProactiveLogCollectionSettings",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, userConsent: {
                serializedName: "properties.userConsent",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DiagnosticRemoteSupportSettings = {
    type: {
        name: "Composite",
        className: "DiagnosticRemoteSupportSettings",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, remoteSupportSettingsList: {
                serializedName: "properties.remoteSupportSettingsList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RemoteSupportSettings"
                        }
                    }
                }
            } })
    }
};
const DataBoxEdgeDeviceExtendedInfo = {
    type: {
        name: "Composite",
        className: "DataBoxEdgeDeviceExtendedInfo",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { encryptionKeyThumbprint: {
                serializedName: "properties.encryptionKeyThumbprint",
                type: {
                    name: "String"
                }
            }, encryptionKey: {
                serializedName: "properties.encryptionKey",
                type: {
                    name: "String"
                }
            }, resourceKey: {
                serializedName: "properties.resourceKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clientSecretStoreId: {
                serializedName: "properties.clientSecretStoreId",
                type: {
                    name: "String"
                }
            }, clientSecretStoreUrl: {
                serializedName: "properties.clientSecretStoreUrl",
                type: {
                    name: "String"
                }
            }, channelIntegrityKeyName: {
                serializedName: "properties.channelIntegrityKeyName",
                type: {
                    name: "String"
                }
            }, channelIntegrityKeyVersion: {
                serializedName: "properties.channelIntegrityKeyVersion",
                type: {
                    name: "String"
                }
            }, keyVaultSyncStatus: {
                serializedName: "properties.keyVaultSyncStatus",
                type: {
                    name: "String"
                }
            }, deviceSecrets: {
                serializedName: "properties.deviceSecrets",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "Secret" } }
                }
            } })
    }
};
const NetworkSettings = {
    type: {
        name: "Composite",
        className: "NetworkSettings",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, networkAdapters: {
                serializedName: "properties.networkAdapters",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkAdapter"
                        }
                    }
                }
            } })
    }
};
const Node = {
    type: {
        name: "Composite",
        className: "Node",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { nodeStatus: {
                serializedName: "properties.nodeStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeChassisSerialNumber: {
                serializedName: "properties.nodeChassisSerialNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeSerialNumber: {
                serializedName: "properties.nodeSerialNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeDisplayName: {
                serializedName: "properties.nodeDisplayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeFriendlySoftwareVersion: {
                serializedName: "properties.nodeFriendlySoftwareVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeHcsVersion: {
                serializedName: "properties.nodeHcsVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeInstanceId: {
                serializedName: "properties.nodeInstanceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Order = {
    type: {
        name: "Composite",
        className: "Order",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, contactInformation: {
                serializedName: "properties.contactInformation",
                type: {
                    name: "Composite",
                    className: "ContactDetails"
                }
            }, shippingAddress: {
                serializedName: "properties.shippingAddress",
                type: {
                    name: "Composite",
                    className: "Address"
                }
            }, currentStatus: {
                serializedName: "properties.currentStatus",
                type: {
                    name: "Composite",
                    className: "OrderStatus"
                }
            }, orderHistory: {
                serializedName: "properties.orderHistory",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OrderStatus"
                        }
                    }
                }
            }, serialNumber: {
                serializedName: "properties.serialNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deliveryTrackingInfo: {
                serializedName: "properties.deliveryTrackingInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrackingInfo"
                        }
                    }
                }
            }, returnTrackingInfo: {
                serializedName: "properties.returnTrackingInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrackingInfo"
                        }
                    }
                }
            }, shipmentType: {
                serializedName: "properties.shipmentType",
                type: {
                    name: "String"
                }
            } })
    }
};
const Role = {
    serializedName: "Role",
    type: {
        name: "Composite",
        className: "Role",
        uberParent: "ARMBaseModel",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const Addon = {
    serializedName: "Addon",
    type: {
        name: "Composite",
        className: "Addon",
        uberParent: "ARMBaseModel",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const MonitoringMetricConfiguration = {
    type: {
        name: "Composite",
        className: "MonitoringMetricConfiguration",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, metricConfigurations: {
                serializedName: "properties.metricConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricConfiguration"
                        }
                    }
                }
            } })
    }
};
const SecuritySettings = {
    type: {
        name: "Composite",
        className: "SecuritySettings",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { deviceAdminPassword: {
                serializedName: "properties.deviceAdminPassword",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            } })
    }
};
const Share = {
    type: {
        name: "Composite",
        className: "Share",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, shareStatus: {
                serializedName: "properties.shareStatus",
                required: true,
                type: {
                    name: "String"
                }
            }, monitoringStatus: {
                serializedName: "properties.monitoringStatus",
                required: true,
                type: {
                    name: "String"
                }
            }, azureContainerInfo: {
                serializedName: "properties.azureContainerInfo",
                type: {
                    name: "Composite",
                    className: "AzureContainerInfo"
                }
            }, accessProtocol: {
                serializedName: "properties.accessProtocol",
                required: true,
                type: {
                    name: "String"
                }
            }, userAccessRights: {
                serializedName: "properties.userAccessRights",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserAccessRight"
                        }
                    }
                }
            }, clientAccessRights: {
                serializedName: "properties.clientAccessRights",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientAccessRight"
                        }
                    }
                }
            }, refreshDetails: {
                serializedName: "properties.refreshDetails",
                type: {
                    name: "Composite",
                    className: "RefreshDetails"
                }
            }, shareMappings: {
                serializedName: "properties.shareMappings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountPointMap"
                        }
                    }
                }
            }, dataPolicy: {
                serializedName: "properties.dataPolicy",
                type: {
                    name: "String"
                }
            } })
    }
};
const StorageAccountCredential = {
    type: {
        name: "Composite",
        className: "StorageAccountCredential",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, alias: {
                serializedName: "properties.alias",
                required: true,
                type: {
                    name: "String"
                }
            }, userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            }, accountKey: {
                serializedName: "properties.accountKey",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            }, connectionString: {
                serializedName: "properties.connectionString",
                type: {
                    name: "String"
                }
            }, sslStatus: {
                serializedName: "properties.sslStatus",
                required: true,
                type: {
                    name: "String"
                }
            }, blobDomainName: {
                serializedName: "properties.blobDomainName",
                type: {
                    name: "String"
                }
            }, accountType: {
                serializedName: "properties.accountType",
                required: true,
                type: {
                    name: "String"
                }
            }, storageAccountId: {
                serializedName: "properties.storageAccountId",
                type: {
                    name: "String"
                }
            } })
    }
};
const StorageAccount = {
    type: {
        name: "Composite",
        className: "StorageAccount",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, storageAccountStatus: {
                serializedName: "properties.storageAccountStatus",
                type: {
                    name: "String"
                }
            }, dataPolicy: {
                serializedName: "properties.dataPolicy",
                required: true,
                type: {
                    name: "String"
                }
            }, storageAccountCredentialId: {
                serializedName: "properties.storageAccountCredentialId",
                type: {
                    name: "String"
                }
            }, blobEndpoint: {
                serializedName: "properties.blobEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containerCount: {
                serializedName: "properties.containerCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const Container = {
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, containerStatus: {
                serializedName: "properties.containerStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataFormat: {
                serializedName: "properties.dataFormat",
                required: true,
                type: {
                    name: "String"
                }
            }, refreshDetails: {
                serializedName: "properties.refreshDetails",
                type: {
                    name: "Composite",
                    className: "RefreshDetails"
                }
            }, createdDateTime: {
                serializedName: "properties.createdDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const Trigger = {
    serializedName: "Trigger",
    type: {
        name: "Composite",
        className: "Trigger",
        uberParent: "ARMBaseModel",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const TriggerSupportPackageRequest = {
    type: {
        name: "Composite",
        className: "TriggerSupportPackageRequest",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { minimumTimeStamp: {
                serializedName: "properties.minimumTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, maximumTimeStamp: {
                serializedName: "properties.maximumTimeStamp",
                type: {
                    name: "DateTime"
                }
            }, include: {
                serializedName: "properties.include",
                type: {
                    name: "String"
                }
            } })
    }
};
const UpdateSummary = {
    type: {
        name: "Composite",
        className: "UpdateSummary",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, deviceVersionNumber: {
                serializedName: "properties.deviceVersionNumber",
                type: {
                    name: "String"
                }
            }, friendlyDeviceVersionName: {
                serializedName: "properties.friendlyDeviceVersionName",
                type: {
                    name: "String"
                }
            }, deviceLastScannedDateTime: {
                serializedName: "properties.deviceLastScannedDateTime",
                type: {
                    name: "DateTime"
                }
            }, lastCompletedScanJobDateTime: {
                serializedName: "properties.lastCompletedScanJobDateTime",
                type: {
                    name: "DateTime"
                }
            }, lastSuccessfulScanJobTime: {
                serializedName: "properties.lastSuccessfulScanJobTime",
                type: {
                    name: "DateTime"
                }
            }, lastCompletedDownloadJobDateTime: {
                serializedName: "properties.lastCompletedDownloadJobDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastCompletedDownloadJobId: {
                serializedName: "properties.lastCompletedDownloadJobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastDownloadJobStatus: {
                serializedName: "properties.lastDownloadJobStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastSuccessfulInstallJobDateTime: {
                serializedName: "properties.lastSuccessfulInstallJobDateTime",
                type: {
                    name: "DateTime"
                }
            }, lastCompletedInstallJobDateTime: {
                serializedName: "properties.lastCompletedInstallJobDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastCompletedInstallJobId: {
                serializedName: "properties.lastCompletedInstallJobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, lastInstallJobStatus: {
                serializedName: "properties.lastInstallJobStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, totalNumberOfUpdatesAvailable: {
                serializedName: "properties.totalNumberOfUpdatesAvailable",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, totalNumberOfUpdatesPendingDownload: {
                serializedName: "properties.totalNumberOfUpdatesPendingDownload",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, totalNumberOfUpdatesPendingInstall: {
                serializedName: "properties.totalNumberOfUpdatesPendingInstall",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, rebootBehavior: {
                serializedName: "properties.rebootBehavior",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ongoingUpdateOperation: {
                serializedName: "properties.ongoingUpdateOperation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inProgressDownloadJobId: {
                serializedName: "properties.inProgressDownloadJobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inProgressInstallJobId: {
                serializedName: "properties.inProgressInstallJobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inProgressDownloadJobStartedDateTime: {
                serializedName: "properties.inProgressDownloadJobStartedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, inProgressInstallJobStartedDateTime: {
                serializedName: "properties.inProgressInstallJobStartedDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, updateTitles: {
                serializedName: "properties.updateTitles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, updates: {
                serializedName: "properties.updates",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpdateDetails"
                        }
                    }
                }
            }, totalUpdateSizeInBytes: {
                serializedName: "properties.totalUpdateSizeInBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, totalTimeInMinutes: {
                serializedName: "properties.totalTimeInMinutes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const User = {
    type: {
        name: "Composite",
        className: "User",
        modelProperties: Object.assign(Object.assign({}, ARMBaseModel.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, encryptedPassword: {
                serializedName: "properties.encryptedPassword",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            }, shareAccessRights: {
                serializedName: "properties.shareAccessRights",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareAccessRight"
                        }
                    }
                }
            }, userType: {
                serializedName: "properties.userType",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CloudEdgeManagementRole = {
    serializedName: "CloudEdgeManagement",
    type: {
        name: "Composite",
        className: "CloudEdgeManagementRole",
        uberParent: "Role",
        polymorphicDiscriminator: Role.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Role.type.modelProperties), { localManagementStatus: {
                serializedName: "properties.localManagementStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, edgeProfile: {
                serializedName: "properties.edgeProfile",
                type: {
                    name: "Composite",
                    className: "EdgeProfile"
                }
            }, roleStatus: {
                serializedName: "properties.roleStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const IoTRole = {
    serializedName: "IOT",
    type: {
        name: "Composite",
        className: "IoTRole",
        uberParent: "Role",
        polymorphicDiscriminator: Role.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Role.type.modelProperties), { hostPlatform: {
                serializedName: "properties.hostPlatform",
                type: {
                    name: "String"
                }
            }, ioTDeviceDetails: {
                serializedName: "properties.ioTDeviceDetails",
                type: {
                    name: "Composite",
                    className: "IoTDeviceInfo"
                }
            }, ioTEdgeDeviceDetails: {
                serializedName: "properties.ioTEdgeDeviceDetails",
                type: {
                    name: "Composite",
                    className: "IoTDeviceInfo"
                }
            }, shareMappings: {
                serializedName: "properties.shareMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountPointMap"
                        }
                    }
                }
            }, ioTEdgeAgentInfo: {
                serializedName: "properties.ioTEdgeAgentInfo",
                type: {
                    name: "Composite",
                    className: "IoTEdgeAgentInfo"
                }
            }, hostPlatformType: {
                serializedName: "properties.hostPlatformType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, computeResource: {
                serializedName: "properties.computeResource",
                type: {
                    name: "Composite",
                    className: "ComputeResource"
                }
            }, roleStatus: {
                serializedName: "properties.roleStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const KubernetesRole = {
    serializedName: "Kubernetes",
    type: {
        name: "Composite",
        className: "KubernetesRole",
        uberParent: "Role",
        polymorphicDiscriminator: Role.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Role.type.modelProperties), { hostPlatform: {
                serializedName: "properties.hostPlatform",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostPlatformType: {
                serializedName: "properties.hostPlatformType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kubernetesClusterInfo: {
                serializedName: "properties.kubernetesClusterInfo",
                type: {
                    name: "Composite",
                    className: "KubernetesClusterInfo"
                }
            }, kubernetesRoleResources: {
                serializedName: "properties.kubernetesRoleResources",
                type: {
                    name: "Composite",
                    className: "KubernetesRoleResources"
                }
            }, roleStatus: {
                serializedName: "properties.roleStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const MECRole = {
    serializedName: "MEC",
    type: {
        name: "Composite",
        className: "MECRole",
        uberParent: "Role",
        polymorphicDiscriminator: Role.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Role.type.modelProperties), { connectionString: {
                serializedName: "properties.connectionString",
                type: {
                    name: "Composite",
                    className: "AsymmetricEncryptedSecret"
                }
            }, controllerEndpoint: {
                serializedName: "properties.controllerEndpoint",
                type: {
                    name: "String"
                }
            }, resourceUniqueId: {
                serializedName: "properties.resourceUniqueId",
                type: {
                    name: "String"
                }
            }, roleStatus: {
                serializedName: "properties.roleStatus",
                type: {
                    name: "String"
                }
            } })
    }
};
const ArcAddon = {
    serializedName: "ArcForKubernetes",
    type: {
        name: "Composite",
        className: "ArcAddon",
        uberParent: "Addon",
        polymorphicDiscriminator: Addon.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Addon.type.modelProperties), { subscriptionId: {
                serializedName: "properties.subscriptionId",
                required: true,
                type: {
                    name: "String"
                }
            }, resourceGroupName: {
                serializedName: "properties.resourceGroupName",
                required: true,
                type: {
                    name: "String"
                }
            }, resourceName: {
                serializedName: "properties.resourceName",
                required: true,
                type: {
                    name: "String"
                }
            }, resourceLocation: {
                serializedName: "properties.resourceLocation",
                required: true,
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostPlatform: {
                serializedName: "properties.hostPlatform",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostPlatformType: {
                serializedName: "properties.hostPlatformType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IoTAddon = {
    serializedName: "IotEdge",
    type: {
        name: "Composite",
        className: "IoTAddon",
        uberParent: "Addon",
        polymorphicDiscriminator: Addon.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Addon.type.modelProperties), { ioTDeviceDetails: {
                serializedName: "properties.ioTDeviceDetails",
                type: {
                    name: "Composite",
                    className: "IoTDeviceInfo"
                }
            }, ioTEdgeDeviceDetails: {
                serializedName: "properties.ioTEdgeDeviceDetails",
                type: {
                    name: "Composite",
                    className: "IoTDeviceInfo"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostPlatform: {
                serializedName: "properties.hostPlatform",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hostPlatformType: {
                serializedName: "properties.hostPlatformType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const FileEventTrigger = {
    serializedName: "FileEvent",
    type: {
        name: "Composite",
        className: "FileEventTrigger",
        uberParent: "Trigger",
        polymorphicDiscriminator: Trigger.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Trigger.type.modelProperties), { sourceInfo: {
                serializedName: "properties.sourceInfo",
                type: {
                    name: "Composite",
                    className: "FileSourceInfo"
                }
            }, sinkInfo: {
                serializedName: "properties.sinkInfo",
                type: {
                    name: "Composite",
                    className: "RoleSinkInfo"
                }
            }, customContextTag: {
                constraints: {
                    MaxLength: 192
                },
                serializedName: "properties.customContextTag",
                type: {
                    name: "String"
                }
            } })
    }
};
const PeriodicTimerEventTrigger = {
    serializedName: "PeriodicTimerEvent",
    type: {
        name: "Composite",
        className: "PeriodicTimerEventTrigger",
        uberParent: "Trigger",
        polymorphicDiscriminator: Trigger.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Trigger.type.modelProperties), { sourceInfo: {
                serializedName: "properties.sourceInfo",
                type: {
                    name: "Composite",
                    className: "PeriodicTimerSourceInfo"
                }
            }, sinkInfo: {
                serializedName: "properties.sinkInfo",
                type: {
                    name: "Composite",
                    className: "RoleSinkInfo"
                }
            }, customContextTag: {
                constraints: {
                    MaxLength: 192
                },
                serializedName: "properties.customContextTag",
                type: {
                    name: "String"
                }
            } })
    }
};
let discriminators = {
    "ARMBaseModel.Role": Role,
    "ARMBaseModel.Addon": Addon,
    "ARMBaseModel.Trigger": Trigger,
    "Role.CloudEdgeManagement": CloudEdgeManagementRole,
    "Role.IOT": IoTRole,
    "Role.Kubernetes": KubernetesRole,
    "Role.MEC": MECRole,
    "Addon.ArcForKubernetes": ArcAddon,
    "Addon.IotEdge": IoTAddon,
    "Trigger.FileEvent": FileEventTrigger,
    "Trigger.PeriodicTimerEvent": PeriodicTimerEventTrigger
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationsList: OperationsList,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ServiceSpecification: ServiceSpecification,
    MetricSpecificationV1: MetricSpecificationV1,
    MetricDimensionV1: MetricDimensionV1,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    DataBoxEdgeSkuList: DataBoxEdgeSkuList,
    DataBoxEdgeSku: DataBoxEdgeSku,
    SkuLocationInfo: SkuLocationInfo,
    SkuCost: SkuCost,
    SkuCapability: SkuCapability,
    DataBoxEdgeDeviceList: DataBoxEdgeDeviceList,
    Sku: Sku,
    ResourceIdentity: ResourceIdentity,
    SystemData: SystemData,
    ResourceMoveDetails: ResourceMoveDetails,
    EdgeProfile: EdgeProfile,
    EdgeProfileSubscription: EdgeProfileSubscription,
    SubscriptionRegisteredFeatures: SubscriptionRegisteredFeatures,
    DataResidency: DataResidency,
    ARMBaseModel: ARMBaseModel,
    DataBoxEdgeDevicePatch: DataBoxEdgeDevicePatch,
    EdgeProfilePatch: EdgeProfilePatch,
    EdgeProfileSubscriptionPatch: EdgeProfileSubscriptionPatch,
    AlertList: AlertList,
    AlertErrorDetails: AlertErrorDetails,
    BandwidthSchedulesList: BandwidthSchedulesList,
    RemoteSupportSettings: RemoteSupportSettings,
    GenerateCertResponse: GenerateCertResponse,
    Secret: Secret,
    AsymmetricEncryptedSecret: AsymmetricEncryptedSecret,
    Job: Job,
    JobErrorDetails: JobErrorDetails,
    JobErrorItem: JobErrorItem,
    UpdateDownloadProgress: UpdateDownloadProgress,
    UpdateInstallProgress: UpdateInstallProgress,
    NetworkAdapter: NetworkAdapter,
    NetworkAdapterPosition: NetworkAdapterPosition,
    Ipv4Config: Ipv4Config,
    Ipv6Config: Ipv6Config,
    NodeList: NodeList,
    OrderList: OrderList,
    ContactDetails: ContactDetails,
    Address: Address,
    OrderStatus: OrderStatus,
    TrackingInfo: TrackingInfo,
    DCAccessCode: DCAccessCode,
    RoleList: RoleList,
    AddonList: AddonList,
    MonitoringMetricConfigurationList: MonitoringMetricConfigurationList,
    MetricConfiguration: MetricConfiguration,
    MetricCounterSet: MetricCounterSet,
    MetricCounter: MetricCounter,
    MetricDimension: MetricDimension,
    ShareList: ShareList,
    AzureContainerInfo: AzureContainerInfo,
    UserAccessRight: UserAccessRight,
    ClientAccessRight: ClientAccessRight,
    RefreshDetails: RefreshDetails,
    MountPointMap: MountPointMap,
    StorageAccountCredentialList: StorageAccountCredentialList,
    StorageAccountList: StorageAccountList,
    ContainerList: ContainerList,
    TriggerList: TriggerList,
    DataBoxEdgeDeviceExtendedInfoPatch: DataBoxEdgeDeviceExtendedInfoPatch,
    UpdateDetails: UpdateDetails,
    UploadCertificateRequest: UploadCertificateRequest,
    UploadCertificateResponse: UploadCertificateResponse,
    UserList: UserList,
    ShareAccessRight: ShareAccessRight,
    Authentication: Authentication,
    SymmetricKey: SymmetricKey,
    CniConfig: CniConfig,
    ComputeResource: ComputeResource,
    DataBoxEdgeMoveRequest: DataBoxEdgeMoveRequest,
    EtcdInfo: EtcdInfo,
    FileSourceInfo: FileSourceInfo,
    RoleSinkInfo: RoleSinkInfo,
    ImageRepositoryCredential: ImageRepositoryCredential,
    IoTDeviceInfo: IoTDeviceInfo,
    IoTEdgeAgentInfo: IoTEdgeAgentInfo,
    KubernetesClusterInfo: KubernetesClusterInfo,
    NodeInfo: NodeInfo,
    KubernetesIPConfiguration: KubernetesIPConfiguration,
    KubernetesRoleResources: KubernetesRoleResources,
    KubernetesRoleStorage: KubernetesRoleStorage,
    KubernetesRoleStorageClassInfo: KubernetesRoleStorageClassInfo,
    KubernetesRoleCompute: KubernetesRoleCompute,
    KubernetesRoleNetwork: KubernetesRoleNetwork,
    LoadBalancerConfig: LoadBalancerConfig,
    PeriodicTimerSourceInfo: PeriodicTimerSourceInfo,
    ResourceTypeSku: ResourceTypeSku,
    SkuInformation: SkuInformation,
    SkuInformationList: SkuInformationList,
    DataBoxEdgeDevice: DataBoxEdgeDevice,
    Alert: Alert,
    BandwidthSchedule: BandwidthSchedule,
    DiagnosticProactiveLogCollectionSettings: DiagnosticProactiveLogCollectionSettings,
    DiagnosticRemoteSupportSettings: DiagnosticRemoteSupportSettings,
    DataBoxEdgeDeviceExtendedInfo: DataBoxEdgeDeviceExtendedInfo,
    NetworkSettings: NetworkSettings,
    Node: Node,
    Order: Order,
    Role: Role,
    Addon: Addon,
    MonitoringMetricConfiguration: MonitoringMetricConfiguration,
    SecuritySettings: SecuritySettings,
    Share: Share,
    StorageAccountCredential: StorageAccountCredential,
    StorageAccount: StorageAccount,
    Container: Container,
    Trigger: Trigger,
    TriggerSupportPackageRequest: TriggerSupportPackageRequest,
    UpdateSummary: UpdateSummary,
    User: User,
    CloudEdgeManagementRole: CloudEdgeManagementRole,
    IoTRole: IoTRole,
    KubernetesRole: KubernetesRole,
    MECRole: MECRole,
    ArcAddon: ArcAddon,
    IoTAddon: IoTAddon,
    FileEventTrigger: FileEventTrigger,
    PeriodicTimerEventTrigger: PeriodicTimerEventTrigger,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const deviceName = {
    parameterPath: "deviceName",
    mapper: {
        serializedName: "deviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const dataBoxEdgeDevice = {
    parameterPath: "dataBoxEdgeDevice",
    mapper: DataBoxEdgeDevice
};
const parameters = {
    parameterPath: "parameters",
    mapper: DataBoxEdgeDevicePatch
};
const securitySettings = {
    parameterPath: "securitySettings",
    mapper: SecuritySettings
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: DataBoxEdgeDeviceExtendedInfoPatch
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: UploadCertificateRequest
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: BandwidthSchedule
};
const proactiveLogCollectionSettings = {
    parameterPath: "proactiveLogCollectionSettings",
    mapper: DiagnosticProactiveLogCollectionSettings
};
const diagnosticRemoteSupportSettings = {
    parameterPath: "diagnosticRemoteSupportSettings",
    mapper: DiagnosticRemoteSupportSettings
};
const order = {
    parameterPath: "order",
    mapper: Order
};
const role = {
    parameterPath: "role",
    mapper: Role
};
const roleName = {
    parameterPath: "roleName",
    mapper: {
        serializedName: "roleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const addonName = {
    parameterPath: "addonName",
    mapper: {
        serializedName: "addonName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const addon = {
    parameterPath: "addon",
    mapper: Addon
};
const monitoringMetricConfiguration = {
    parameterPath: "monitoringMetricConfiguration",
    mapper: MonitoringMetricConfiguration
};
const share = {
    parameterPath: "share",
    mapper: Share
};
const storageAccountCredential = {
    parameterPath: "storageAccountCredential",
    mapper: StorageAccountCredential
};
const storageAccountName = {
    parameterPath: "storageAccountName",
    mapper: {
        serializedName: "storageAccountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const storageAccount = {
    parameterPath: "storageAccount",
    mapper: StorageAccount
};
const containerName = {
    parameterPath: "containerName",
    mapper: {
        serializedName: "containerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const container = {
    parameterPath: "container",
    mapper: Container
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const trigger = {
    parameterPath: "trigger",
    mapper: Trigger
};
const triggerSupportPackageRequest = {
    parameterPath: "triggerSupportPackageRequest",
    mapper: TriggerSupportPackageRequest
};
const user = {
    parameterPath: "user",
    mapper: User
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the supported operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the supported operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/providers/Microsoft.DataBoxEdge/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$j
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationsList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableSkus operations. */
class AvailableSkusImpl {
    /**
     * Initialize a new instance of the class AvailableSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the available Skus and information related to them.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the available Skus and information related to them.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataBoxEdge/availableSkus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeSkuList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeSkuList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Devices operations. */
class DevicesImpl {
    /**
     * Initialize a new instance of the class Devices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Data Box Edge/Data Box Gateway devices in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Data Box Edge/Data Box Gateway devices in a resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all the Data Box Edge/Data Box Gateway devices in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Gets all the Data Box Edge/Data Box Gateway devices in a resource group.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets the properties of the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getOperationSpec$e);
    }
    /**
     * Creates or updates a Data Box Edge/Data Box Gateway resource.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param dataBoxEdgeDevice The resource object.
     * @param options The options parameters.
     */
    createOrUpdate(deviceName, resourceGroupName, dataBoxEdgeDevice, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, dataBoxEdgeDevice, options }, createOrUpdateOperationSpec$b);
    }
    /**
     * Deletes the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, options }, deleteOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Modifies a Data Box Edge/Data Box Gateway resource.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param parameters The resource parameters.
     * @param options The options parameters.
     */
    update(deviceName, resourceGroupName, parameters, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, parameters, options }, updateOperationSpec);
    }
    /**
     * Downloads the updates on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDownloadUpdates(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, options }, downloadUpdatesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Downloads the updates on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDownloadUpdatesAndWait(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDownloadUpdates(deviceName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates certificate for activation key.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    generateCertificate(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, generateCertificateOperationSpec);
    }
    /**
     * Gets additional information for the specified Azure Stack Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    getExtendedInformation(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getExtendedInformationOperationSpec);
    }
    /**
     * Installs the updates on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginInstallUpdates(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, options }, installUpdatesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Installs the updates on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginInstallUpdatesAndWait(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInstallUpdates(deviceName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the network settings of the specified Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    getNetworkSettings(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getNetworkSettingsOperationSpec);
    }
    /**
     * Scans for updates on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginScanForUpdates(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, options }, scanForUpdatesOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Scans for updates on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginScanForUpdatesAndWait(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginScanForUpdates(deviceName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the security settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param securitySettings The security settings.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSecuritySettings(deviceName, resourceGroupName, securitySettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, securitySettings, options }, createOrUpdateSecuritySettingsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the security settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param securitySettings The security settings.
     * @param options The options parameters.
     */
    beginCreateOrUpdateSecuritySettingsAndWait(deviceName, resourceGroupName, securitySettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdateSecuritySettings(deviceName, resourceGroupName, securitySettings, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets additional information for the specified Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param parameters The patch object.
     * @param options The options parameters.
     */
    updateExtendedInformation(deviceName, resourceGroupName, parameters, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, parameters, options }, updateExtendedInformationOperationSpec);
    }
    /**
     * Gets information about the availability of updates based on the last scan of the device. It also
     * gets information about any ongoing download or install jobs on the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    getUpdateSummary(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getUpdateSummaryOperationSpec);
    }
    /**
     * Uploads registration certificate for the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param parameters The upload certificate request.
     * @param options The options parameters.
     */
    uploadCertificate(deviceName, resourceGroupName, parameters, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, parameters, options }, uploadCertificateOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDevice
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDevice
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: dataBoxEdgeDevice,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDevice
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const downloadUpdatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/downloadUpdates",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const generateCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/generateCertificate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateCertResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getExtendedInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/getExtendedInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const installUpdatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/installUpdates",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getNetworkSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/networkSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSettings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const scanForUpdatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/scanForUpdates",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateSecuritySettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/securitySettings/default/update",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securitySettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const updateExtendedInformationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/updateExtendedInformation",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceExtendedInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const getUpdateSummaryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/updateSummary/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UpdateSummary
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const uploadCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/uploadCertificate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UploadCertificateResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataBoxEdgeDeviceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Alerts operations. */
class AlertsImpl {
    /**
     * Initialize a new instance of the class Alerts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the alerts for a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the alerts for a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$9);
    }
    /**
     * Gets an alert by name.
     * @param deviceName The device name.
     * @param name The alert name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$d);
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/alerts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/alerts/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Alert
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByDataBoxEdgeDeviceNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AlertList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BandwidthSchedules operations. */
class BandwidthSchedulesImpl {
    /**
     * Initialize a new instance of the class BandwidthSchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the bandwidth schedules for a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the bandwidth schedules for a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$8);
    }
    /**
     * Gets the properties of the specified bandwidth schedule.
     * @param deviceName The device name.
     * @param name The bandwidth schedule name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$c);
    }
    /**
     * Creates or updates a bandwidth schedule.
     * @param deviceName The device name.
     * @param name The bandwidth schedule name which needs to be added/updated.
     * @param resourceGroupName The resource group name.
     * @param parameters The bandwidth schedule to be added or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, parameters, options }, createOrUpdateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a bandwidth schedule.
     * @param deviceName The device name.
     * @param name The bandwidth schedule name which needs to be added/updated.
     * @param resourceGroupName The resource group name.
     * @param parameters The bandwidth schedule to be added or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified bandwidth schedule.
     * @param deviceName The device name.
     * @param name The bandwidth schedule name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified bandwidth schedule.
     * @param deviceName The device name.
     * @param name The bandwidth schedule name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/bandwidthSchedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BandwidthSchedulesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/bandwidthSchedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BandwidthSchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/bandwidthSchedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BandwidthSchedule
        },
        201: {
            bodyMapper: BandwidthSchedule
        },
        202: {
            bodyMapper: BandwidthSchedule
        },
        204: {
            bodyMapper: BandwidthSchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/bandwidthSchedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByDataBoxEdgeDeviceNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BandwidthSchedulesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DiagnosticSettings operations. */
class DiagnosticSettingsImpl {
    /**
     * Initialize a new instance of the class DiagnosticSettings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the proactive log collection settings of the specified Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    getDiagnosticProactiveLogCollectionSettings(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getDiagnosticProactiveLogCollectionSettingsOperationSpec);
    }
    /**
     * Updates the proactive log collection settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param proactiveLogCollectionSettings The proactive log collection settings.
     * @param options The options parameters.
     */
    beginUpdateDiagnosticProactiveLogCollectionSettings(deviceName, resourceGroupName, proactiveLogCollectionSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                resourceGroupName,
                proactiveLogCollectionSettings,
                options
            }, updateDiagnosticProactiveLogCollectionSettingsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the proactive log collection settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param proactiveLogCollectionSettings The proactive log collection settings.
     * @param options The options parameters.
     */
    beginUpdateDiagnosticProactiveLogCollectionSettingsAndWait(deviceName, resourceGroupName, proactiveLogCollectionSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDiagnosticProactiveLogCollectionSettings(deviceName, resourceGroupName, proactiveLogCollectionSettings, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the diagnostic remote support settings of the specified Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    getDiagnosticRemoteSupportSettings(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getDiagnosticRemoteSupportSettingsOperationSpec);
    }
    /**
     * Updates the diagnostic remote support settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param diagnosticRemoteSupportSettings The diagnostic remote support settings.
     * @param options The options parameters.
     */
    beginUpdateDiagnosticRemoteSupportSettings(deviceName, resourceGroupName, diagnosticRemoteSupportSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                resourceGroupName,
                diagnosticRemoteSupportSettings,
                options
            }, updateDiagnosticRemoteSupportSettingsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the diagnostic remote support settings on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param diagnosticRemoteSupportSettings The diagnostic remote support settings.
     * @param options The options parameters.
     */
    beginUpdateDiagnosticRemoteSupportSettingsAndWait(deviceName, resourceGroupName, diagnosticRemoteSupportSettings, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDiagnosticRemoteSupportSettings(deviceName, resourceGroupName, diagnosticRemoteSupportSettings, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getDiagnosticProactiveLogCollectionSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/diagnosticProactiveLogCollectionSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticProactiveLogCollectionSettings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const updateDiagnosticProactiveLogCollectionSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/diagnosticProactiveLogCollectionSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiagnosticProactiveLogCollectionSettings
        },
        201: {
            bodyMapper: DiagnosticProactiveLogCollectionSettings
        },
        202: {
            bodyMapper: DiagnosticProactiveLogCollectionSettings
        },
        204: {
            bodyMapper: DiagnosticProactiveLogCollectionSettings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: proactiveLogCollectionSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const getDiagnosticRemoteSupportSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/diagnosticRemoteSupportSettings/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticRemoteSupportSettings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const updateDiagnosticRemoteSupportSettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/diagnosticRemoteSupportSettings/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiagnosticRemoteSupportSettings
        },
        201: {
            bodyMapper: DiagnosticRemoteSupportSettings
        },
        202: {
            bodyMapper: DiagnosticRemoteSupportSettings
        },
        204: {
            bodyMapper: DiagnosticRemoteSupportSettings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: diagnosticRemoteSupportSettings,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Jobs operations. */
class JobsImpl {
    /**
     * Initialize a new instance of the class Jobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the details of a specified job on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param name The job name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$b);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/jobs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Job
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Nodes operations. */
class NodesImpl {
    /**
     * Initialize a new instance of the class Nodes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the nodes currently configured under this Data Box Edge device
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the nodes currently configured under this Data Box Edge device
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$7);
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/nodes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NodeList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByDataBoxEdgeDeviceNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NodeList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationsStatus operations. */
class OperationsStatusImpl {
    /**
     * Initialize a new instance of the class OperationsStatus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the details of a specified job on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param name The job name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$a);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/operationsStatus/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Job
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Orders operations. */
class OrdersImpl {
    /**
     * Initialize a new instance of the class Orders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the orders related to a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the orders related to a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$6);
    }
    /**
     * Gets a specific order by name.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, getOperationSpec$9);
    }
    /**
     * Creates or updates an order.
     * @param deviceName The order details of a device.
     * @param resourceGroupName The resource group name.
     * @param order The order to be created or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, resourceGroupName, order, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, order, options }, createOrUpdateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an order.
     * @param deviceName The order details of a device.
     * @param resourceGroupName The resource group name.
     * @param order The order to be created or updated.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, resourceGroupName, order, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, resourceGroupName, order, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the order related to the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, options }, deleteOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the order related to the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the DCAccess Code
     * @param deviceName The device name
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listDCAccessCode(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listDCAccessCodeOperationSpec);
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/orders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OrderList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/orders/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Order
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/orders/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Order
        },
        201: {
            bodyMapper: Order
        },
        202: {
            bodyMapper: Order
        },
        204: {
            bodyMapper: Order
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: order,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/orders/default",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listDCAccessCodeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/orders/default/listDCAccessCode",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DCAccessCode
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByDataBoxEdgeDeviceNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OrderList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Roles operations. */
class RolesImpl {
    /**
     * Initialize a new instance of the class Roles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the roles configured in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the roles configured in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$5);
    }
    /**
     * Gets a specific role by name.
     * @param deviceName The device name.
     * @param name The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$8);
    }
    /**
     * Create or update a role.
     * @param deviceName The device name.
     * @param name The role name.
     * @param resourceGroupName The resource group name.
     * @param role The role properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, role, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, role, options }, createOrUpdateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a role.
     * @param deviceName The device name.
     * @param name The role name.
     * @param resourceGroupName The resource group name.
     * @param role The role properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, role, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, role, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the role on the device.
     * @param deviceName The device name.
     * @param name The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the role on the device.
     * @param deviceName The device name.
     * @param name The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Role
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Role
        },
        201: {
            bodyMapper: Role
        },
        202: {
            bodyMapper: Role
        },
        204: {
            bodyMapper: Role
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: role,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByDataBoxEdgeDeviceNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Addons operations. */
class AddonsImpl {
    /**
     * Initialize a new instance of the class Addons class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the addons configured in the role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByRole(deviceName, roleName, resourceGroupName, options) {
        const iter = this.listByRolePagingAll(deviceName, roleName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByRolePagingPage(deviceName, roleName, resourceGroupName, options, settings);
            }
        };
    }
    listByRolePagingPage(deviceName, roleName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByRolePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByRole(deviceName, roleName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByRoleNext(deviceName, roleName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByRolePagingAll(deviceName, roleName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRolePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRolePagingPage(deviceName, roleName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the addons configured in the role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByRole(deviceName, roleName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, resourceGroupName, options }, listByRoleOperationSpec);
    }
    /**
     * Gets a specific addon by name.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param addonName The addon name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, roleName, addonName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, addonName, resourceGroupName, options }, getOperationSpec$7);
    }
    /**
     * Create or update a addon.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param addonName The addon name.
     * @param resourceGroupName The resource group name.
     * @param addon The addon properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, roleName, addonName, resourceGroupName, addon, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, roleName, addonName, resourceGroupName, addon, options }, createOrUpdateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a addon.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param addonName The addon name.
     * @param resourceGroupName The resource group name.
     * @param addon The addon properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, roleName, addonName, resourceGroupName, addon, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, roleName, addonName, resourceGroupName, addon, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the addon on the device.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param addonName The addon name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, roleName, addonName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, roleName, addonName, resourceGroupName, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the addon on the device.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param addonName The addon name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, roleName, addonName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, roleName, addonName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByRoleNext
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByRole method.
     * @param options The options parameters.
     */
    _listByRoleNext(deviceName, roleName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, resourceGroupName, nextLink, options }, listByRoleNextOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByRoleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/addons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddonList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/addons/{addonName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Addon
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName,
        addonName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/addons/{addonName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Addon
        },
        201: {
            bodyMapper: Addon
        },
        202: {
            bodyMapper: Addon
        },
        204: {
            bodyMapper: Addon
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: addon,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName,
        addonName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/addons/{addonName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName,
        addonName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByRoleNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddonList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MonitoringConfig operations. */
class MonitoringConfigImpl {
    /**
     * Initialize a new instance of the class MonitoringConfig class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists metric configurations in a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    list(deviceName, roleName, resourceGroupName, options) {
        const iter = this.listPagingAll(deviceName, roleName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(deviceName, roleName, resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(deviceName, roleName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(deviceName, roleName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(deviceName, roleName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(deviceName, roleName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(deviceName, roleName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists metric configurations in a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _list(deviceName, roleName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, resourceGroupName, options }, listOperationSpec);
    }
    /**
     * Gets a  metric configuration of a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, roleName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, resourceGroupName, options }, getOperationSpec$6);
    }
    /**
     * Creates a new metric configuration or updates an existing one for a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param monitoringMetricConfiguration The metric configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, roleName, resourceGroupName, monitoringMetricConfiguration, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                roleName,
                resourceGroupName,
                monitoringMetricConfiguration,
                options
            }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new metric configuration or updates an existing one for a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param monitoringMetricConfiguration The metric configuration.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, roleName, resourceGroupName, monitoringMetricConfiguration, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, roleName, resourceGroupName, monitoringMetricConfiguration, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * deletes a new metric configuration for a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, roleName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, roleName, resourceGroupName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * deletes a new metric configuration for a role.
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, roleName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, roleName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param deviceName The device name.
     * @param roleName The role name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(deviceName, roleName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, roleName, resourceGroupName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/monitoringConfig",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MonitoringMetricConfigurationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/monitoringConfig/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MonitoringMetricConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/monitoringConfig/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MonitoringMetricConfiguration
        },
        201: {
            bodyMapper: MonitoringMetricConfiguration
        },
        202: {
            bodyMapper: MonitoringMetricConfiguration
        },
        204: {
            bodyMapper: MonitoringMetricConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: monitoringMetricConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/roles/{roleName}/monitoringConfig/default",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MonitoringMetricConfigurationList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName,
        roleName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Shares operations. */
class SharesImpl {
    /**
     * Initialize a new instance of the class Shares class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the shares in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the shares in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$4);
    }
    /**
     * Gets a share by name.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$5);
    }
    /**
     * Creates a new share or updates an existing share on the device.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param share The share properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, share, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, share, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new share or updates an existing share on the device.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param share The share properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, share, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, share, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the share on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the share on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Refreshes the share metadata with the data from the cloud.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginRefresh(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, refreshOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Refreshes the share metadata with the data from the cloud.
     * @param deviceName The device name.
     * @param name The share name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginRefreshAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefresh(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/shares",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/shares/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Share
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/shares/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Share
        },
        201: {
            bodyMapper: Share
        },
        202: {
            bodyMapper: Share
        },
        204: {
            bodyMapper: Share
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: share,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/shares/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const refreshOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/shares/{name}/refresh",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByDataBoxEdgeDeviceNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ShareList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StorageAccountCredentials operations. */
class StorageAccountCredentialsImpl {
    /**
     * Initialize a new instance of the class StorageAccountCredentials class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the storage account credentials in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the storage account credentials in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$3);
    }
    /**
     * Gets the properties of the specified storage account credential.
     * @param deviceName The device name.
     * @param name The storage account credential name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$4);
    }
    /**
     * Creates or updates the storage account credential.
     * @param deviceName The device name.
     * @param name The storage account credential name.
     * @param resourceGroupName The resource group name.
     * @param storageAccountCredential The storage account credential.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, storageAccountCredential, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                name,
                resourceGroupName,
                storageAccountCredential,
                options
            }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the storage account credential.
     * @param deviceName The device name.
     * @param name The storage account credential name.
     * @param resourceGroupName The resource group name.
     * @param storageAccountCredential The storage account credential.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, storageAccountCredential, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, storageAccountCredential, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the storage account credential.
     * @param deviceName The device name.
     * @param name The storage account credential name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the storage account credential.
     * @param deviceName The device name.
     * @param name The storage account credential name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccountCredentials",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountCredentialList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccountCredentials/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountCredential
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccountCredentials/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageAccountCredential
        },
        201: {
            bodyMapper: StorageAccountCredential
        },
        202: {
            bodyMapper: StorageAccountCredential
        },
        204: {
            bodyMapper: StorageAccountCredential
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: storageAccountCredential,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccountCredentials/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByDataBoxEdgeDeviceNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountCredentialList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StorageAccounts operations. */
class StorageAccountsImpl {
    /**
     * Initialize a new instance of the class StorageAccounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the StorageAccounts in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the StorageAccounts in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$2);
    }
    /**
     * Gets a StorageAccount by name.
     * @param deviceName The device name.
     * @param storageAccountName The storage account name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, storageAccountName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, storageAccountName, resourceGroupName, options }, getOperationSpec$3);
    }
    /**
     * Creates a new StorageAccount or updates an existing StorageAccount on the device.
     * @param deviceName The device name.
     * @param storageAccountName The StorageAccount name.
     * @param resourceGroupName The resource group name.
     * @param storageAccount The StorageAccount properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, storageAccountName, resourceGroupName, storageAccount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                storageAccountName,
                resourceGroupName,
                storageAccount,
                options
            }, createOrUpdateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new StorageAccount or updates an existing StorageAccount on the device.
     * @param deviceName The device name.
     * @param storageAccountName The StorageAccount name.
     * @param resourceGroupName The resource group name.
     * @param storageAccount The StorageAccount properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, storageAccountName, resourceGroupName, storageAccount, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, storageAccountName, resourceGroupName, storageAccount, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the StorageAccount on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The StorageAccount name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, storageAccountName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, storageAccountName, resourceGroupName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the StorageAccount on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The StorageAccount name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, storageAccountName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, storageAccountName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageAccount
        },
        201: {
            bodyMapper: StorageAccount
        },
        202: {
            bodyMapper: StorageAccount
        },
        204: {
            bodyMapper: StorageAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: storageAccount,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByDataBoxEdgeDeviceNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageAccountList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Containers operations. */
class ContainersImpl {
    /**
     * Initialize a new instance of the class Containers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the containers of a storage Account in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The storage Account name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByStorageAccount(deviceName, storageAccountName, resourceGroupName, options) {
        const iter = this.listByStorageAccountPagingAll(deviceName, storageAccountName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByStorageAccountPagingPage(deviceName, storageAccountName, resourceGroupName, options, settings);
            }
        };
    }
    listByStorageAccountPagingPage(deviceName, storageAccountName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByStorageAccountPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByStorageAccount(deviceName, storageAccountName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByStorageAccountNext(deviceName, storageAccountName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByStorageAccountPagingAll(deviceName, storageAccountName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByStorageAccountPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByStorageAccountPagingPage(deviceName, storageAccountName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the containers of a storage Account in a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The storage Account name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByStorageAccount(deviceName, storageAccountName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, storageAccountName, resourceGroupName, options }, listByStorageAccountOperationSpec);
    }
    /**
     * Gets a container by name.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container Name
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, storageAccountName, containerName, resourceGroupName, options) {
        return this.client.sendOperationRequest({
            deviceName,
            storageAccountName,
            containerName,
            resourceGroupName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Creates a new container or updates an existing container on the device.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param container The container properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, storageAccountName, containerName, resourceGroupName, container, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                storageAccountName,
                containerName,
                resourceGroupName,
                container,
                options
            }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new container or updates an existing container on the device.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param container The container properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, storageAccountName, containerName, resourceGroupName, container, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, storageAccountName, containerName, resourceGroupName, container, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the container on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, storageAccountName, containerName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                storageAccountName,
                containerName,
                resourceGroupName,
                options
            }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the container on the Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, storageAccountName, containerName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, storageAccountName, containerName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Refreshes the container metadata with the data from the cloud.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginRefresh(deviceName, storageAccountName, containerName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                deviceName,
                storageAccountName,
                containerName,
                resourceGroupName,
                options
            }, refreshOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Refreshes the container metadata with the data from the cloud.
     * @param deviceName The device name.
     * @param storageAccountName The Storage Account Name
     * @param containerName The container name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginRefreshAndWait(deviceName, storageAccountName, containerName, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRefresh(deviceName, storageAccountName, containerName, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByStorageAccountNext
     * @param deviceName The device name.
     * @param storageAccountName The storage Account name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByStorageAccount method.
     * @param options The options parameters.
     */
    _listByStorageAccountNext(deviceName, storageAccountName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, storageAccountName, resourceGroupName, nextLink, options }, listByStorageAccountNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByStorageAccountOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}/containers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}/containers/{containerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Container
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}/containers/{containerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Container
        },
        201: {
            bodyMapper: Container
        },
        202: {
            bodyMapper: Container
        },
        204: {
            bodyMapper: Container
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: container,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName,
        containerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}/containers/{containerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const refreshOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/storageAccounts/{storageAccountName}/containers/{containerName}/refresh",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName,
        containerName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByStorageAccountNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName,
        storageAccountName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Triggers operations. */
class TriggersImpl {
    /**
     * Initialize a new instance of the class Triggers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the triggers configured in the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the triggers configured in the device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec$1);
    }
    /**
     * Get a specific trigger by name.
     * @param deviceName The device name.
     * @param name The trigger name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec$1);
    }
    /**
     * Creates or updates a trigger.
     * @param deviceName Creates or updates a trigger
     * @param name The trigger name.
     * @param resourceGroupName The resource group name.
     * @param trigger The trigger.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, trigger, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, trigger, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a trigger.
     * @param deviceName Creates or updates a trigger
     * @param name The trigger name.
     * @param resourceGroupName The resource group name.
     * @param trigger The trigger.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, trigger, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, trigger, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the trigger on the gateway device.
     * @param deviceName The device name.
     * @param name The trigger name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the trigger on the gateway device.
     * @param deviceName The device name.
     * @param name The trigger name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/triggers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggerList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/triggers/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Trigger
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/triggers/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Trigger
        },
        201: {
            bodyMapper: Trigger
        },
        202: {
            bodyMapper: Trigger
        },
        204: {
            bodyMapper: Trigger
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: trigger,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/triggers/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByDataBoxEdgeDeviceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TriggerList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing SupportPackages operations. */
class SupportPackagesImpl {
    /**
     * Initialize a new instance of the class SupportPackages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Triggers support package on the device
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param triggerSupportPackageRequest The trigger support package request object
     * @param options The options parameters.
     */
    beginTriggerSupportPackage(deviceName, resourceGroupName, triggerSupportPackageRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, resourceGroupName, triggerSupportPackageRequest, options }, triggerSupportPackageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Triggers support package on the device
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param triggerSupportPackageRequest The trigger support package request object
     * @param options The options parameters.
     */
    beginTriggerSupportPackageAndWait(deviceName, resourceGroupName, triggerSupportPackageRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTriggerSupportPackage(deviceName, resourceGroupName, triggerSupportPackageRequest, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const triggerSupportPackageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/triggerSupportPackage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: triggerSupportPackageRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Users operations. */
class UsersImpl {
    /**
     * Initialize a new instance of the class Users class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the users registered on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        const iter = this.listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings);
            }
        };
    }
    listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDevice(deviceName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByDataBoxEdgeDevicePagingAll(deviceName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByDataBoxEdgeDevicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByDataBoxEdgeDevicePagingPage(deviceName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the users registered on a Data Box Edge/Data Box Gateway device.
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDevice(deviceName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, options }, listByDataBoxEdgeDeviceOperationSpec);
    }
    /**
     * Gets the properties of the specified user.
     * @param deviceName The device name.
     * @param name The user name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    get(deviceName, name, resourceGroupName, options) {
        return this.client.sendOperationRequest({ deviceName, name, resourceGroupName, options }, getOperationSpec);
    }
    /**
     * Creates a new user or updates an existing user's information on a Data Box Edge/Data Box Gateway
     * device.
     * @param deviceName The device name.
     * @param name The user name.
     * @param resourceGroupName The resource group name.
     * @param user The user details.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(deviceName, name, resourceGroupName, user, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, user, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new user or updates an existing user's information on a Data Box Edge/Data Box Gateway
     * device.
     * @param deviceName The device name.
     * @param name The user name.
     * @param resourceGroupName The resource group name.
     * @param user The user details.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(deviceName, name, resourceGroupName, user, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(deviceName, name, resourceGroupName, user, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the user on a databox edge/gateway device.
     * @param deviceName The device name.
     * @param name The user name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDelete(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { deviceName, name, resourceGroupName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the user on a databox edge/gateway device.
     * @param deviceName The device name.
     * @param name The user name.
     * @param resourceGroupName The resource group name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(deviceName, name, resourceGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(deviceName, name, resourceGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByDataBoxEdgeDeviceNext
     * @param deviceName The device name.
     * @param resourceGroupName The resource group name.
     * @param nextLink The nextLink from the previous successful call to the ListByDataBoxEdgeDevice
     *                 method.
     * @param options The options parameters.
     */
    _listByDataBoxEdgeDeviceNext(deviceName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ deviceName, resourceGroupName, nextLink, options }, listByDataBoxEdgeDeviceNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByDataBoxEdgeDeviceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/users",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/users/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/users/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: user,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DataBoxEdge/dataBoxEdgeDevices/{deviceName}/users/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        deviceName,
        name
    ],
    headerParameters: [accept],
    serializer
};
const listByDataBoxEdgeDeviceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        deviceName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class DataBoxEdgeManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the DataBoxEdgeManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-databoxedge/2.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-06-01";
        this.operations = new OperationsImpl(this);
        this.availableSkus = new AvailableSkusImpl(this);
        this.devices = new DevicesImpl(this);
        this.alerts = new AlertsImpl(this);
        this.bandwidthSchedules = new BandwidthSchedulesImpl(this);
        this.diagnosticSettings = new DiagnosticSettingsImpl(this);
        this.jobs = new JobsImpl(this);
        this.nodes = new NodesImpl(this);
        this.operationsStatus = new OperationsStatusImpl(this);
        this.orders = new OrdersImpl(this);
        this.roles = new RolesImpl(this);
        this.addons = new AddonsImpl(this);
        this.monitoringConfig = new MonitoringConfigImpl(this);
        this.shares = new SharesImpl(this);
        this.storageAccountCredentials = new StorageAccountCredentialsImpl(this);
        this.storageAccounts = new StorageAccountsImpl(this);
        this.containers = new ContainersImpl(this);
        this.triggers = new TriggersImpl(this);
        this.supportPackages = new SupportPackagesImpl(this);
        this.users = new UsersImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.DataBoxEdgeManagementClient = DataBoxEdgeManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
