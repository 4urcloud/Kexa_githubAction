'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AmlFilesystemHealthStateType} that the service accepts. */
exports.KnownAmlFilesystemHealthStateType = void 0;
(function (KnownAmlFilesystemHealthStateType) {
    /** Unavailable */
    KnownAmlFilesystemHealthStateType["Unavailable"] = "Unavailable";
    /** Available */
    KnownAmlFilesystemHealthStateType["Available"] = "Available";
    /** Degraded */
    KnownAmlFilesystemHealthStateType["Degraded"] = "Degraded";
    /** Transitioning */
    KnownAmlFilesystemHealthStateType["Transitioning"] = "Transitioning";
    /** Maintenance */
    KnownAmlFilesystemHealthStateType["Maintenance"] = "Maintenance";
})(exports.KnownAmlFilesystemHealthStateType || (exports.KnownAmlFilesystemHealthStateType = {}));
/** Known values of {@link AmlFilesystemProvisioningStateType} that the service accepts. */
exports.KnownAmlFilesystemProvisioningStateType = void 0;
(function (KnownAmlFilesystemProvisioningStateType) {
    /** Succeeded */
    KnownAmlFilesystemProvisioningStateType["Succeeded"] = "Succeeded";
    /** Failed */
    KnownAmlFilesystemProvisioningStateType["Failed"] = "Failed";
    /** Creating */
    KnownAmlFilesystemProvisioningStateType["Creating"] = "Creating";
    /** Deleting */
    KnownAmlFilesystemProvisioningStateType["Deleting"] = "Deleting";
    /** Updating */
    KnownAmlFilesystemProvisioningStateType["Updating"] = "Updating";
    /** Canceled */
    KnownAmlFilesystemProvisioningStateType["Canceled"] = "Canceled";
})(exports.KnownAmlFilesystemProvisioningStateType || (exports.KnownAmlFilesystemProvisioningStateType = {}));
/** Known values of {@link ArchiveStatusType} that the service accepts. */
exports.KnownArchiveStatusType = void 0;
(function (KnownArchiveStatusType) {
    /** NotConfigured */
    KnownArchiveStatusType["NotConfigured"] = "NotConfigured";
    /** Idle */
    KnownArchiveStatusType["Idle"] = "Idle";
    /** InProgress */
    KnownArchiveStatusType["InProgress"] = "InProgress";
    /** Canceled */
    KnownArchiveStatusType["Canceled"] = "Canceled";
    /** Completed */
    KnownArchiveStatusType["Completed"] = "Completed";
    /** Failed */
    KnownArchiveStatusType["Failed"] = "Failed";
    /** Cancelling */
    KnownArchiveStatusType["Cancelling"] = "Cancelling";
    /** FSScanInProgress */
    KnownArchiveStatusType["FSScanInProgress"] = "FSScanInProgress";
})(exports.KnownArchiveStatusType || (exports.KnownArchiveStatusType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link FilesystemSubnetStatusType} that the service accepts. */
exports.KnownFilesystemSubnetStatusType = void 0;
(function (KnownFilesystemSubnetStatusType) {
    /** Ok */
    KnownFilesystemSubnetStatusType["Ok"] = "Ok";
    /** Invalid */
    KnownFilesystemSubnetStatusType["Invalid"] = "Invalid";
})(exports.KnownFilesystemSubnetStatusType || (exports.KnownFilesystemSubnetStatusType = {}));
/** Known values of {@link MetricAggregationType} that the service accepts. */
exports.KnownMetricAggregationType = void 0;
(function (KnownMetricAggregationType) {
    /** NotSpecified */
    KnownMetricAggregationType["NotSpecified"] = "NotSpecified";
    /** None */
    KnownMetricAggregationType["None"] = "None";
    /** Average */
    KnownMetricAggregationType["Average"] = "Average";
    /** Minimum */
    KnownMetricAggregationType["Minimum"] = "Minimum";
    /** Maximum */
    KnownMetricAggregationType["Maximum"] = "Maximum";
    /** Total */
    KnownMetricAggregationType["Total"] = "Total";
    /** Count */
    KnownMetricAggregationType["Count"] = "Count";
})(exports.KnownMetricAggregationType || (exports.KnownMetricAggregationType = {}));
/** Known values of {@link ReasonCode} that the service accepts. */
exports.KnownReasonCode = void 0;
(function (KnownReasonCode) {
    /** QuotaId */
    KnownReasonCode["QuotaId"] = "QuotaId";
    /** NotAvailableForSubscription */
    KnownReasonCode["NotAvailableForSubscription"] = "NotAvailableForSubscription";
})(exports.KnownReasonCode || (exports.KnownReasonCode = {}));
/** Known values of {@link HealthStateType} that the service accepts. */
exports.KnownHealthStateType = void 0;
(function (KnownHealthStateType) {
    /** Unknown */
    KnownHealthStateType["Unknown"] = "Unknown";
    /** Healthy */
    KnownHealthStateType["Healthy"] = "Healthy";
    /** Degraded */
    KnownHealthStateType["Degraded"] = "Degraded";
    /** Down */
    KnownHealthStateType["Down"] = "Down";
    /** Transitioning */
    KnownHealthStateType["Transitioning"] = "Transitioning";
    /** Stopping */
    KnownHealthStateType["Stopping"] = "Stopping";
    /** Stopped */
    KnownHealthStateType["Stopped"] = "Stopped";
    /** Upgrading */
    KnownHealthStateType["Upgrading"] = "Upgrading";
    /** Flushing */
    KnownHealthStateType["Flushing"] = "Flushing";
    /** WaitingForKey */
    KnownHealthStateType["WaitingForKey"] = "WaitingForKey";
    /** StartFailed */
    KnownHealthStateType["StartFailed"] = "StartFailed";
    /** UpgradeFailed */
    KnownHealthStateType["UpgradeFailed"] = "UpgradeFailed";
})(exports.KnownHealthStateType || (exports.KnownHealthStateType = {}));
/** Known values of {@link ProvisioningStateType} that the service accepts. */
exports.KnownProvisioningStateType = void 0;
(function (KnownProvisioningStateType) {
    /** Succeeded */
    KnownProvisioningStateType["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningStateType["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningStateType["Canceled"] = "Canceled";
    /** Creating */
    KnownProvisioningStateType["Creating"] = "Creating";
    /** Deleting */
    KnownProvisioningStateType["Deleting"] = "Deleting";
    /** Updating */
    KnownProvisioningStateType["Updating"] = "Updating";
})(exports.KnownProvisioningStateType || (exports.KnownProvisioningStateType = {}));
/** Known values of {@link FirmwareStatusType} that the service accepts. */
exports.KnownFirmwareStatusType = void 0;
(function (KnownFirmwareStatusType) {
    /** Available */
    KnownFirmwareStatusType["Available"] = "available";
    /** Unavailable */
    KnownFirmwareStatusType["Unavailable"] = "unavailable";
})(exports.KnownFirmwareStatusType || (exports.KnownFirmwareStatusType = {}));
/** Known values of {@link NfsAccessRuleScope} that the service accepts. */
exports.KnownNfsAccessRuleScope = void 0;
(function (KnownNfsAccessRuleScope) {
    /** Default */
    KnownNfsAccessRuleScope["Default"] = "default";
    /** Network */
    KnownNfsAccessRuleScope["Network"] = "network";
    /** Host */
    KnownNfsAccessRuleScope["Host"] = "host";
})(exports.KnownNfsAccessRuleScope || (exports.KnownNfsAccessRuleScope = {}));
/** Known values of {@link NfsAccessRuleAccess} that the service accepts. */
exports.KnownNfsAccessRuleAccess = void 0;
(function (KnownNfsAccessRuleAccess) {
    /** No */
    KnownNfsAccessRuleAccess["No"] = "no";
    /** Ro */
    KnownNfsAccessRuleAccess["Ro"] = "ro";
    /** Rw */
    KnownNfsAccessRuleAccess["Rw"] = "rw";
})(exports.KnownNfsAccessRuleAccess || (exports.KnownNfsAccessRuleAccess = {}));
/** Known values of {@link DomainJoinedType} that the service accepts. */
exports.KnownDomainJoinedType = void 0;
(function (KnownDomainJoinedType) {
    /** Yes */
    KnownDomainJoinedType["Yes"] = "Yes";
    /** No */
    KnownDomainJoinedType["No"] = "No";
    /** Error */
    KnownDomainJoinedType["Error"] = "Error";
})(exports.KnownDomainJoinedType || (exports.KnownDomainJoinedType = {}));
/** Known values of {@link UsernameSource} that the service accepts. */
exports.KnownUsernameSource = void 0;
(function (KnownUsernameSource) {
    /** AD */
    KnownUsernameSource["AD"] = "AD";
    /** Ldap */
    KnownUsernameSource["Ldap"] = "LDAP";
    /** File */
    KnownUsernameSource["File"] = "File";
    /** None */
    KnownUsernameSource["None"] = "None";
})(exports.KnownUsernameSource || (exports.KnownUsernameSource = {}));
/** Known values of {@link UsernameDownloadedType} that the service accepts. */
exports.KnownUsernameDownloadedType = void 0;
(function (KnownUsernameDownloadedType) {
    /** Yes */
    KnownUsernameDownloadedType["Yes"] = "Yes";
    /** No */
    KnownUsernameDownloadedType["No"] = "No";
    /** Error */
    KnownUsernameDownloadedType["Error"] = "Error";
})(exports.KnownUsernameDownloadedType || (exports.KnownUsernameDownloadedType = {}));
/** Known values of {@link PrimingJobState} that the service accepts. */
exports.KnownPrimingJobState = void 0;
(function (KnownPrimingJobState) {
    /** Queued */
    KnownPrimingJobState["Queued"] = "Queued";
    /** Running */
    KnownPrimingJobState["Running"] = "Running";
    /** Paused */
    KnownPrimingJobState["Paused"] = "Paused";
    /** Complete */
    KnownPrimingJobState["Complete"] = "Complete";
})(exports.KnownPrimingJobState || (exports.KnownPrimingJobState = {}));
/** Known values of {@link StorageTargetType} that the service accepts. */
exports.KnownStorageTargetType = void 0;
(function (KnownStorageTargetType) {
    /** Nfs3 */
    KnownStorageTargetType["Nfs3"] = "nfs3";
    /** Clfs */
    KnownStorageTargetType["Clfs"] = "clfs";
    /** Unknown */
    KnownStorageTargetType["Unknown"] = "unknown";
    /** BlobNfs */
    KnownStorageTargetType["BlobNfs"] = "blobNfs";
})(exports.KnownStorageTargetType || (exports.KnownStorageTargetType = {}));
/** Known values of {@link OperationalStateType} that the service accepts. */
exports.KnownOperationalStateType = void 0;
(function (KnownOperationalStateType) {
    /** Ready */
    KnownOperationalStateType["Ready"] = "Ready";
    /** Busy */
    KnownOperationalStateType["Busy"] = "Busy";
    /** Suspended */
    KnownOperationalStateType["Suspended"] = "Suspended";
    /** Flushing */
    KnownOperationalStateType["Flushing"] = "Flushing";
})(exports.KnownOperationalStateType || (exports.KnownOperationalStateType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AmlFilesystemsListResult = {
    type: {
        name: "Composite",
        className: "AmlFilesystemsListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlFilesystem"
                        }
                    }
                }
            }
        }
    }
};
const AmlFilesystemIdentity = {
    type: {
        name: "Composite",
        className: "AmlFilesystemIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: ["UserAssigned", "None"]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentitiesValue = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentitiesValue",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuName = {
    type: {
        name: "Composite",
        className: "SkuName",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemHealth = {
    type: {
        name: "Composite",
        className: "AmlFilesystemHealth",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            statusDescription: {
                serializedName: "statusDescription",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemClientInfo = {
    type: {
        name: "Composite",
        className: "AmlFilesystemClientInfo",
        modelProperties: {
            mgsAddress: {
                serializedName: "mgsAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            mountCommand: {
                serializedName: "mountCommand",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lustreVersion: {
                serializedName: "lustreVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            containerStorageInterface: {
                serializedName: "containerStorageInterface",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemContainerStorageInterface"
                }
            }
        }
    }
};
const AmlFilesystemContainerStorageInterface = {
    type: {
        name: "Composite",
        className: "AmlFilesystemContainerStorageInterface",
        modelProperties: {
            persistentVolumeClaim: {
                serializedName: "persistentVolumeClaim",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            persistentVolume: {
                serializedName: "persistentVolume",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            storageClass: {
                serializedName: "storageClass",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemEncryptionSettings = {
    type: {
        name: "Composite",
        className: "AmlFilesystemEncryptionSettings",
        modelProperties: {
            keyEncryptionKey: {
                serializedName: "keyEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReference"
                }
            }
        }
    }
};
const KeyVaultKeyReference = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyReference",
        modelProperties: {
            keyUrl: {
                serializedName: "keyUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceVault: {
                serializedName: "sourceVault",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReferenceSourceVault"
                }
            }
        }
    }
};
const KeyVaultKeyReferenceSourceVault = {
    type: {
        name: "Composite",
        className: "KeyVaultKeyReferenceSourceVault",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemPropertiesMaintenanceWindow = {
    type: {
        name: "Composite",
        className: "AmlFilesystemPropertiesMaintenanceWindow",
        modelProperties: {
            dayOfWeek: {
                serializedName: "dayOfWeek",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    ]
                }
            },
            timeOfDayUTC: {
                constraints: {
                    Pattern: new RegExp("^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
                },
                serializedName: "timeOfDayUTC",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemPropertiesHsm = {
    type: {
        name: "Composite",
        className: "AmlFilesystemPropertiesHsm",
        modelProperties: {
            settings: {
                serializedName: "settings",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemHsmSettings"
                }
            },
            archiveStatus: {
                serializedName: "archiveStatus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlFilesystemArchive"
                        }
                    }
                }
            }
        }
    }
};
const AmlFilesystemHsmSettings = {
    type: {
        name: "Composite",
        className: "AmlFilesystemHsmSettings",
        modelProperties: {
            container: {
                serializedName: "container",
                required: true,
                type: {
                    name: "String"
                }
            },
            loggingContainer: {
                serializedName: "loggingContainer",
                required: true,
                type: {
                    name: "String"
                }
            },
            importPrefix: {
                defaultValue: "/",
                serializedName: "importPrefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemArchive = {
    type: {
        name: "Composite",
        className: "AmlFilesystemArchive",
        modelProperties: {
            filesystemPath: {
                serializedName: "filesystemPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemArchiveStatus"
                }
            }
        }
    }
};
const AmlFilesystemArchiveStatus = {
    type: {
        name: "Composite",
        className: "AmlFilesystemArchiveStatus",
        modelProperties: {
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastCompletionTime: {
                serializedName: "lastCompletionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastStartedTime: {
                serializedName: "lastStartedTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            percentComplete: {
                serializedName: "percentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            errorCode: {
                serializedName: "errorCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemUpdate = {
    type: {
        name: "Composite",
        className: "AmlFilesystemUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            encryptionSettings: {
                serializedName: "properties.encryptionSettings",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemEncryptionSettings"
                }
            },
            maintenanceWindow: {
                serializedName: "properties.maintenanceWindow",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemUpdatePropertiesMaintenanceWindow"
                }
            }
        }
    }
};
const AmlFilesystemUpdatePropertiesMaintenanceWindow = {
    type: {
        name: "Composite",
        className: "AmlFilesystemUpdatePropertiesMaintenanceWindow",
        modelProperties: {
            dayOfWeek: {
                serializedName: "dayOfWeek",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Monday",
                        "Tuesday",
                        "Wednesday",
                        "Thursday",
                        "Friday",
                        "Saturday",
                        "Sunday"
                    ]
                }
            },
            timeOfDayUTC: {
                constraints: {
                    Pattern: new RegExp("^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$")
                },
                serializedName: "timeOfDayUTC",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemArchiveInfo = {
    type: {
        name: "Composite",
        className: "AmlFilesystemArchiveInfo",
        modelProperties: {
            filesystemPath: {
                defaultValue: "/",
                serializedName: "filesystemPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemSubnetInfo = {
    type: {
        name: "Composite",
        className: "AmlFilesystemSubnetInfo",
        modelProperties: {
            filesystemSubnet: {
                serializedName: "filesystemSubnet",
                type: {
                    name: "String"
                }
            },
            storageCapacityTiB: {
                serializedName: "storageCapacityTiB",
                type: {
                    name: "Number"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuName"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemCheckSubnetError = {
    type: {
        name: "Composite",
        className: "AmlFilesystemCheckSubnetError",
        modelProperties: {
            filesystemSubnet: {
                serializedName: "filesystemSubnet",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemCheckSubnetErrorFilesystemSubnet"
                }
            }
        }
    }
};
const AmlFilesystemCheckSubnetErrorFilesystemSubnet = {
    type: {
        name: "Composite",
        className: "AmlFilesystemCheckSubnetErrorFilesystemSubnet",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RequiredAmlFilesystemSubnetsSizeInfo = {
    type: {
        name: "Composite",
        className: "RequiredAmlFilesystemSubnetsSizeInfo",
        modelProperties: {
            storageCapacityTiB: {
                serializedName: "storageCapacityTiB",
                type: {
                    name: "Number"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuName"
                }
            }
        }
    }
};
const RequiredAmlFilesystemSubnetsSize = {
    type: {
        name: "Composite",
        className: "RequiredAmlFilesystemSubnetsSize",
        modelProperties: {
            filesystemSubnetSize: {
                serializedName: "filesystemSubnetSize",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApiOperationListResult = {
    type: {
        name: "Composite",
        className: "ApiOperationListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApiOperation"
                        }
                    }
                }
            }
        }
    }
};
const ApiOperation = {
    type: {
        name: "Composite",
        className: "ApiOperation",
        modelProperties: {
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "ApiOperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ApiOperationPropertiesServiceSpecification"
                }
            }
        }
    }
};
const ApiOperationDisplay = {
    type: {
        name: "Composite",
        className: "ApiOperationDisplay",
        modelProperties: {
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApiOperationPropertiesServiceSpecification = {
    type: {
        name: "Composite",
        className: "ApiOperationPropertiesServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            metricClass: {
                serializedName: "metricClass",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            }
        }
    }
};
const MetricDimension = {
    type: {
        name: "Composite",
        className: "MetricDimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkusResult = {
    type: {
        name: "Composite",
        className: "ResourceSkusResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSku"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSku = {
    type: {
        name: "Composite",
        className: "ResourceSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuCapabilities"
                        }
                    }
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuLocationInfo"
                        }
                    }
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            restrictions: {
                serializedName: "restrictions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Restriction"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSkuCapabilities = {
    type: {
        name: "Composite",
        className: "ResourceSkuCapabilities",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSkuLocationInfo = {
    type: {
        name: "Composite",
        className: "ResourceSkuLocationInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Restriction = {
    type: {
        name: "Composite",
        className: "Restriction",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageModelsResult = {
    type: {
        name: "Composite",
        className: "UsageModelsResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UsageModel"
                        }
                    }
                }
            }
        }
    }
};
const UsageModel = {
    type: {
        name: "Composite",
        className: "UsageModel",
        modelProperties: {
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "UsageModelDisplay"
                }
            },
            modelName: {
                serializedName: "modelName",
                type: {
                    name: "String"
                }
            },
            targetType: {
                serializedName: "targetType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageModelDisplay = {
    type: {
        name: "Composite",
        className: "UsageModelDisplay",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AscOperation = {
    type: {
        name: "Composite",
        className: "AscOperation",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorResponse"
                }
            },
            output: {
                serializedName: "properties.output",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceUsagesListResult = {
    type: {
        name: "Composite",
        className: "ResourceUsagesListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceUsage"
                        }
                    }
                }
            }
        }
    }
};
const ResourceUsage = {
    type: {
        name: "Composite",
        className: "ResourceUsage",
        modelProperties: {
            limit: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "ResourceUsageName"
                }
            }
        }
    }
};
const ResourceUsageName = {
    type: {
        name: "Composite",
        className: "ResourceUsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesListResult = {
    type: {
        name: "Composite",
        className: "CachesListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cache"
                        }
                    }
                }
            }
        }
    }
};
const Cache = {
    type: {
        name: "Composite",
        className: "Cache",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "CacheIdentity"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "CacheSku"
                }
            },
            cacheSizeGB: {
                serializedName: "properties.cacheSizeGB",
                type: {
                    name: "Number"
                }
            },
            health: {
                serializedName: "properties.health",
                type: {
                    name: "Composite",
                    className: "CacheHealth"
                }
            },
            mountAddresses: {
                serializedName: "properties.mountAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "String"
                }
            },
            upgradeStatus: {
                serializedName: "properties.upgradeStatus",
                type: {
                    name: "Composite",
                    className: "CacheUpgradeStatus"
                }
            },
            upgradeSettings: {
                serializedName: "properties.upgradeSettings",
                type: {
                    name: "Composite",
                    className: "CacheUpgradeSettings"
                }
            },
            networkSettings: {
                serializedName: "properties.networkSettings",
                type: {
                    name: "Composite",
                    className: "CacheNetworkSettings"
                }
            },
            encryptionSettings: {
                serializedName: "properties.encryptionSettings",
                type: {
                    name: "Composite",
                    className: "CacheEncryptionSettings"
                }
            },
            securitySettings: {
                serializedName: "properties.securitySettings",
                type: {
                    name: "Composite",
                    className: "CacheSecuritySettings"
                }
            },
            directoryServicesSettings: {
                serializedName: "properties.directoryServicesSettings",
                type: {
                    name: "Composite",
                    className: "CacheDirectorySettings"
                }
            },
            zones: {
                serializedName: "properties.zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            primingJobs: {
                serializedName: "properties.primingJobs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrimingJob"
                        }
                    }
                }
            },
            spaceAllocation: {
                serializedName: "properties.spaceAllocation",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageTargetSpaceAllocation"
                        }
                    }
                }
            }
        }
    }
};
const CacheIdentity = {
    type: {
        name: "Composite",
        className: "CacheIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedIdentitiesValue"
                        }
                    }
                }
            }
        }
    }
};
const CacheHealth = {
    type: {
        name: "Composite",
        className: "CacheHealth",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            statusDescription: {
                serializedName: "statusDescription",
                type: {
                    name: "String"
                }
            },
            conditions: {
                serializedName: "conditions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Condition"
                        }
                    }
                }
            }
        }
    }
};
const Condition = {
    type: {
        name: "Composite",
        className: "Condition",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheUpgradeStatus = {
    type: {
        name: "Composite",
        className: "CacheUpgradeStatus",
        modelProperties: {
            currentFirmwareVersion: {
                serializedName: "currentFirmwareVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            firmwareUpdateStatus: {
                serializedName: "firmwareUpdateStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            firmwareUpdateDeadline: {
                serializedName: "firmwareUpdateDeadline",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastFirmwareUpdate: {
                serializedName: "lastFirmwareUpdate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            pendingFirmwareVersion: {
                serializedName: "pendingFirmwareVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheUpgradeSettings = {
    type: {
        name: "Composite",
        className: "CacheUpgradeSettings",
        modelProperties: {
            upgradeScheduleEnabled: {
                serializedName: "upgradeScheduleEnabled",
                type: {
                    name: "Boolean"
                }
            },
            scheduledTime: {
                serializedName: "scheduledTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CacheNetworkSettings = {
    type: {
        name: "Composite",
        className: "CacheNetworkSettings",
        modelProperties: {
            mtu: {
                defaultValue: 1500,
                constraints: {
                    InclusiveMaximum: 1500,
                    InclusiveMinimum: 576
                },
                serializedName: "mtu",
                type: {
                    name: "Number"
                }
            },
            utilityAddresses: {
                serializedName: "utilityAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dnsSearchDomain: {
                serializedName: "dnsSearchDomain",
                type: {
                    name: "String"
                }
            },
            ntpServer: {
                defaultValue: "time.windows.com",
                serializedName: "ntpServer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheEncryptionSettings = {
    type: {
        name: "Composite",
        className: "CacheEncryptionSettings",
        modelProperties: {
            keyEncryptionKey: {
                serializedName: "keyEncryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultKeyReference"
                }
            },
            rotationToLatestKeyVersionEnabled: {
                serializedName: "rotationToLatestKeyVersionEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CacheSecuritySettings = {
    type: {
        name: "Composite",
        className: "CacheSecuritySettings",
        modelProperties: {
            accessPolicies: {
                serializedName: "accessPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NfsAccessPolicy"
                        }
                    }
                }
            }
        }
    }
};
const NfsAccessPolicy = {
    type: {
        name: "Composite",
        className: "NfsAccessPolicy",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            accessRules: {
                serializedName: "accessRules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NfsAccessRule"
                        }
                    }
                }
            }
        }
    }
};
const NfsAccessRule = {
    type: {
        name: "Composite",
        className: "NfsAccessRule",
        modelProperties: {
            scope: {
                serializedName: "scope",
                required: true,
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            access: {
                serializedName: "access",
                required: true,
                type: {
                    name: "String"
                }
            },
            suid: {
                serializedName: "suid",
                type: {
                    name: "Boolean"
                }
            },
            submountAccess: {
                serializedName: "submountAccess",
                type: {
                    name: "Boolean"
                }
            },
            rootSquash: {
                serializedName: "rootSquash",
                type: {
                    name: "Boolean"
                }
            },
            anonymousUID: {
                serializedName: "anonymousUID",
                type: {
                    name: "String"
                }
            },
            anonymousGID: {
                serializedName: "anonymousGID",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheDirectorySettings = {
    type: {
        name: "Composite",
        className: "CacheDirectorySettings",
        modelProperties: {
            activeDirectory: {
                serializedName: "activeDirectory",
                type: {
                    name: "Composite",
                    className: "CacheActiveDirectorySettings"
                }
            },
            usernameDownload: {
                serializedName: "usernameDownload",
                type: {
                    name: "Composite",
                    className: "CacheUsernameDownloadSettings"
                }
            }
        }
    }
};
const CacheActiveDirectorySettings = {
    type: {
        name: "Composite",
        className: "CacheActiveDirectorySettings",
        modelProperties: {
            primaryDnsIpAddress: {
                serializedName: "primaryDnsIpAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            secondaryDnsIpAddress: {
                serializedName: "secondaryDnsIpAddress",
                type: {
                    name: "String"
                }
            },
            domainName: {
                serializedName: "domainName",
                required: true,
                type: {
                    name: "String"
                }
            },
            domainNetBiosName: {
                serializedName: "domainNetBiosName",
                required: true,
                type: {
                    name: "String"
                }
            },
            cacheNetBiosName: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z]{1,15}$")
                },
                serializedName: "cacheNetBiosName",
                required: true,
                type: {
                    name: "String"
                }
            },
            domainJoined: {
                serializedName: "domainJoined",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "CacheActiveDirectorySettingsCredentials"
                }
            }
        }
    }
};
const CacheActiveDirectorySettingsCredentials = {
    type: {
        name: "Composite",
        className: "CacheActiveDirectorySettingsCredentials",
        modelProperties: {
            username: {
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CacheUsernameDownloadSettings = {
    type: {
        name: "Composite",
        className: "CacheUsernameDownloadSettings",
        modelProperties: {
            extendedGroups: {
                serializedName: "extendedGroups",
                type: {
                    name: "Boolean"
                }
            },
            usernameSource: {
                defaultValue: "None",
                serializedName: "usernameSource",
                type: {
                    name: "String"
                }
            },
            groupFileURI: {
                serializedName: "groupFileURI",
                type: {
                    name: "String"
                }
            },
            userFileURI: {
                serializedName: "userFileURI",
                type: {
                    name: "String"
                }
            },
            ldapServer: {
                serializedName: "ldapServer",
                type: {
                    name: "String"
                }
            },
            ldapBaseDN: {
                serializedName: "ldapBaseDN",
                type: {
                    name: "String"
                }
            },
            encryptLdapConnection: {
                defaultValue: false,
                serializedName: "encryptLdapConnection",
                type: {
                    name: "Boolean"
                }
            },
            requireValidCertificate: {
                defaultValue: false,
                serializedName: "requireValidCertificate",
                type: {
                    name: "Boolean"
                }
            },
            autoDownloadCertificate: {
                defaultValue: false,
                serializedName: "autoDownloadCertificate",
                type: {
                    name: "Boolean"
                }
            },
            caCertificateURI: {
                serializedName: "caCertificateURI",
                type: {
                    name: "String"
                }
            },
            usernameDownloaded: {
                serializedName: "usernameDownloaded",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "CacheUsernameDownloadSettingsCredentials"
                }
            }
        }
    }
};
const CacheUsernameDownloadSettingsCredentials = {
    type: {
        name: "Composite",
        className: "CacheUsernameDownloadSettingsCredentials",
        modelProperties: {
            bindDn: {
                serializedName: "bindDn",
                type: {
                    name: "String"
                }
            },
            bindPassword: {
                serializedName: "bindPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrimingJob = {
    type: {
        name: "Composite",
        className: "PrimingJob",
        modelProperties: {
            primingJobName: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "primingJobName",
                required: true,
                type: {
                    name: "String"
                }
            },
            primingManifestUrl: {
                serializedName: "primingManifestUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            primingJobId: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "primingJobId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primingJobState: {
                serializedName: "primingJobState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primingJobStatus: {
                serializedName: "primingJobStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primingJobDetails: {
                serializedName: "primingJobDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primingJobPercentComplete: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "primingJobPercentComplete",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const StorageTargetSpaceAllocation = {
    type: {
        name: "Composite",
        className: "StorageTargetSpaceAllocation",
        modelProperties: {
            name: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            allocationPercentage: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "allocationPercentage",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CacheSku = {
    type: {
        name: "Composite",
        className: "CacheSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetsResult = {
    type: {
        name: "Composite",
        className: "StorageTargetsResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageTarget"
                        }
                    }
                }
            }
        }
    }
};
const NamespaceJunction = {
    type: {
        name: "Composite",
        className: "NamespaceJunction",
        modelProperties: {
            namespacePath: {
                serializedName: "namespacePath",
                type: {
                    name: "String"
                }
            },
            targetPath: {
                serializedName: "targetPath",
                type: {
                    name: "String"
                }
            },
            nfsExport: {
                serializedName: "nfsExport",
                type: {
                    name: "String"
                }
            },
            nfsAccessPolicy: {
                defaultValue: "default",
                serializedName: "nfsAccessPolicy",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Nfs3Target = {
    type: {
        name: "Composite",
        className: "Nfs3Target",
        modelProperties: {
            target: {
                constraints: {
                    Pattern: new RegExp("^[-.,0-9a-zA-Z]+$")
                },
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            usageModel: {
                serializedName: "usageModel",
                type: {
                    name: "String"
                }
            },
            verificationTimer: {
                serializedName: "verificationTimer",
                type: {
                    name: "Number"
                }
            },
            writeBackTimer: {
                serializedName: "writeBackTimer",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClfsTarget = {
    type: {
        name: "Composite",
        className: "ClfsTarget",
        modelProperties: {
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UnknownTarget = {
    type: {
        name: "Composite",
        className: "UnknownTarget",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const BlobNfsTarget = {
    type: {
        name: "Composite",
        className: "BlobNfsTarget",
        modelProperties: {
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            usageModel: {
                serializedName: "usageModel",
                type: {
                    name: "String"
                }
            },
            verificationTimer: {
                serializedName: "verificationTimer",
                type: {
                    name: "Number"
                }
            },
            writeBackTimer: {
                serializedName: "writeBackTimer",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const StorageTargetResource = {
    type: {
        name: "Composite",
        className: "StorageTargetResource",
        modelProperties: {
            name: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const PrimingJobIdParameter = {
    type: {
        name: "Composite",
        className: "PrimingJobIdParameter",
        modelProperties: {
            primingJobId: {
                constraints: {
                    Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
                },
                serializedName: "primingJobId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const StorageTarget = {
    type: {
        name: "Composite",
        className: "StorageTarget",
        modelProperties: Object.assign(Object.assign({}, StorageTargetResource.type.modelProperties), { junctions: {
                serializedName: "properties.junctions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NamespaceJunction"
                        }
                    }
                }
            }, targetType: {
                serializedName: "properties.targetType",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, nfs3: {
                serializedName: "properties.nfs3",
                type: {
                    name: "Composite",
                    className: "Nfs3Target"
                }
            }, clfs: {
                serializedName: "properties.clfs",
                type: {
                    name: "Composite",
                    className: "ClfsTarget"
                }
            }, unknown: {
                serializedName: "properties.unknown",
                type: {
                    name: "Composite",
                    className: "UnknownTarget"
                }
            }, blobNfs: {
                serializedName: "properties.blobNfs",
                type: {
                    name: "Composite",
                    className: "BlobNfsTarget"
                }
            }, allocationPercentage: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.allocationPercentage",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const AmlFilesystem = {
    type: {
        name: "Composite",
        className: "AmlFilesystem",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemIdentity"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuName"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, storageCapacityTiB: {
                serializedName: "properties.storageCapacityTiB",
                type: {
                    name: "Number"
                }
            }, health: {
                serializedName: "properties.health",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemHealth"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, filesystemSubnet: {
                serializedName: "properties.filesystemSubnet",
                type: {
                    name: "String"
                }
            }, clientInfo: {
                serializedName: "properties.clientInfo",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemClientInfo"
                }
            }, throughputProvisionedMBps: {
                serializedName: "properties.throughputProvisionedMBps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, encryptionSettings: {
                serializedName: "properties.encryptionSettings",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemEncryptionSettings"
                }
            }, maintenanceWindow: {
                serializedName: "properties.maintenanceWindow",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemPropertiesMaintenanceWindow"
                }
            }, hsm: {
                serializedName: "properties.hsm",
                type: {
                    name: "Composite",
                    className: "AmlFilesystemPropertiesHsm"
                }
            } })
    }
};
const AmlFilesystemsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "AmlFilesystemsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "AmlFilesystemsCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-async-operation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlFilesystemsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "AmlFilesystemsUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-async-operation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "CachesDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesUpdateHeaders = {
    type: {
        name: "Composite",
        className: "CachesUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesDebugInfoHeaders = {
    type: {
        name: "Composite",
        className: "CachesDebugInfoHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesFlushHeaders = {
    type: {
        name: "Composite",
        className: "CachesFlushHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesStartHeaders = {
    type: {
        name: "Composite",
        className: "CachesStartHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesStopHeaders = {
    type: {
        name: "Composite",
        className: "CachesStopHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesStartPrimingJobHeaders = {
    type: {
        name: "Composite",
        className: "CachesStartPrimingJobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesStopPrimingJobHeaders = {
    type: {
        name: "Composite",
        className: "CachesStopPrimingJobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesPausePrimingJobHeaders = {
    type: {
        name: "Composite",
        className: "CachesPausePrimingJobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesResumePrimingJobHeaders = {
    type: {
        name: "Composite",
        className: "CachesResumePrimingJobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesUpgradeFirmwareHeaders = {
    type: {
        name: "Composite",
        className: "CachesUpgradeFirmwareHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CachesSpaceAllocationHeaders = {
    type: {
        name: "Composite",
        className: "CachesSpaceAllocationHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetsDnsRefreshHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetsDnsRefreshHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetsRestoreDefaultsHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetsRestoreDefaultsHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetFlushHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetFlushHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetSuspendHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetSuspendHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetResumeHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetResumeHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageTargetInvalidateHeaders = {
    type: {
        name: "Composite",
        className: "StorageTargetInvalidateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AmlFilesystemsListResult: AmlFilesystemsListResult,
    AmlFilesystemIdentity: AmlFilesystemIdentity,
    UserAssignedIdentitiesValue: UserAssignedIdentitiesValue,
    SkuName: SkuName,
    AmlFilesystemHealth: AmlFilesystemHealth,
    AmlFilesystemClientInfo: AmlFilesystemClientInfo,
    AmlFilesystemContainerStorageInterface: AmlFilesystemContainerStorageInterface,
    AmlFilesystemEncryptionSettings: AmlFilesystemEncryptionSettings,
    KeyVaultKeyReference: KeyVaultKeyReference,
    KeyVaultKeyReferenceSourceVault: KeyVaultKeyReferenceSourceVault,
    AmlFilesystemPropertiesMaintenanceWindow: AmlFilesystemPropertiesMaintenanceWindow,
    AmlFilesystemPropertiesHsm: AmlFilesystemPropertiesHsm,
    AmlFilesystemHsmSettings: AmlFilesystemHsmSettings,
    AmlFilesystemArchive: AmlFilesystemArchive,
    AmlFilesystemArchiveStatus: AmlFilesystemArchiveStatus,
    Resource: Resource,
    SystemData: SystemData,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    AmlFilesystemUpdate: AmlFilesystemUpdate,
    AmlFilesystemUpdatePropertiesMaintenanceWindow: AmlFilesystemUpdatePropertiesMaintenanceWindow,
    AmlFilesystemArchiveInfo: AmlFilesystemArchiveInfo,
    AmlFilesystemSubnetInfo: AmlFilesystemSubnetInfo,
    AmlFilesystemCheckSubnetError: AmlFilesystemCheckSubnetError,
    AmlFilesystemCheckSubnetErrorFilesystemSubnet: AmlFilesystemCheckSubnetErrorFilesystemSubnet,
    RequiredAmlFilesystemSubnetsSizeInfo: RequiredAmlFilesystemSubnetsSizeInfo,
    RequiredAmlFilesystemSubnetsSize: RequiredAmlFilesystemSubnetsSize,
    ApiOperationListResult: ApiOperationListResult,
    ApiOperation: ApiOperation,
    ApiOperationDisplay: ApiOperationDisplay,
    ApiOperationPropertiesServiceSpecification: ApiOperationPropertiesServiceSpecification,
    MetricSpecification: MetricSpecification,
    MetricDimension: MetricDimension,
    LogSpecification: LogSpecification,
    ResourceSkusResult: ResourceSkusResult,
    ResourceSku: ResourceSku,
    ResourceSkuCapabilities: ResourceSkuCapabilities,
    ResourceSkuLocationInfo: ResourceSkuLocationInfo,
    Restriction: Restriction,
    UsageModelsResult: UsageModelsResult,
    UsageModel: UsageModel,
    UsageModelDisplay: UsageModelDisplay,
    AscOperation: AscOperation,
    ErrorResponse: ErrorResponse,
    ResourceUsagesListResult: ResourceUsagesListResult,
    ResourceUsage: ResourceUsage,
    ResourceUsageName: ResourceUsageName,
    CachesListResult: CachesListResult,
    Cache: Cache,
    CacheIdentity: CacheIdentity,
    CacheHealth: CacheHealth,
    Condition: Condition,
    CacheUpgradeStatus: CacheUpgradeStatus,
    CacheUpgradeSettings: CacheUpgradeSettings,
    CacheNetworkSettings: CacheNetworkSettings,
    CacheEncryptionSettings: CacheEncryptionSettings,
    CacheSecuritySettings: CacheSecuritySettings,
    NfsAccessPolicy: NfsAccessPolicy,
    NfsAccessRule: NfsAccessRule,
    CacheDirectorySettings: CacheDirectorySettings,
    CacheActiveDirectorySettings: CacheActiveDirectorySettings,
    CacheActiveDirectorySettingsCredentials: CacheActiveDirectorySettingsCredentials,
    CacheUsernameDownloadSettings: CacheUsernameDownloadSettings,
    CacheUsernameDownloadSettingsCredentials: CacheUsernameDownloadSettingsCredentials,
    PrimingJob: PrimingJob,
    StorageTargetSpaceAllocation: StorageTargetSpaceAllocation,
    CacheSku: CacheSku,
    StorageTargetsResult: StorageTargetsResult,
    NamespaceJunction: NamespaceJunction,
    Nfs3Target: Nfs3Target,
    ClfsTarget: ClfsTarget,
    UnknownTarget: UnknownTarget,
    BlobNfsTarget: BlobNfsTarget,
    StorageTargetResource: StorageTargetResource,
    PrimingJobIdParameter: PrimingJobIdParameter,
    TrackedResource: TrackedResource,
    StorageTarget: StorageTarget,
    AmlFilesystem: AmlFilesystem,
    AmlFilesystemsDeleteHeaders: AmlFilesystemsDeleteHeaders,
    AmlFilesystemsCreateOrUpdateHeaders: AmlFilesystemsCreateOrUpdateHeaders,
    AmlFilesystemsUpdateHeaders: AmlFilesystemsUpdateHeaders,
    CachesDeleteHeaders: CachesDeleteHeaders,
    CachesUpdateHeaders: CachesUpdateHeaders,
    CachesDebugInfoHeaders: CachesDebugInfoHeaders,
    CachesFlushHeaders: CachesFlushHeaders,
    CachesStartHeaders: CachesStartHeaders,
    CachesStopHeaders: CachesStopHeaders,
    CachesStartPrimingJobHeaders: CachesStartPrimingJobHeaders,
    CachesStopPrimingJobHeaders: CachesStopPrimingJobHeaders,
    CachesPausePrimingJobHeaders: CachesPausePrimingJobHeaders,
    CachesResumePrimingJobHeaders: CachesResumePrimingJobHeaders,
    CachesUpgradeFirmwareHeaders: CachesUpgradeFirmwareHeaders,
    CachesSpaceAllocationHeaders: CachesSpaceAllocationHeaders,
    StorageTargetsDnsRefreshHeaders: StorageTargetsDnsRefreshHeaders,
    StorageTargetsDeleteHeaders: StorageTargetsDeleteHeaders,
    StorageTargetsRestoreDefaultsHeaders: StorageTargetsRestoreDefaultsHeaders,
    StorageTargetFlushHeaders: StorageTargetFlushHeaders,
    StorageTargetSuspendHeaders: StorageTargetSuspendHeaders,
    StorageTargetResumeHeaders: StorageTargetResumeHeaders,
    StorageTargetInvalidateHeaders: StorageTargetInvalidateHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const amlFilesystemName = {
    parameterPath: "amlFilesystemName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[0-9a-zA-Z][-0-9a-zA-Z_]{0,78}[0-9a-zA-Z]$"),
            MaxLength: 80,
            MinLength: 2
        },
        serializedName: "amlFilesystemName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const amlFilesystem = {
    parameterPath: "amlFilesystem",
    mapper: AmlFilesystem
};
const amlFilesystem1 = {
    parameterPath: "amlFilesystem",
    mapper: AmlFilesystemUpdate
};
const archiveInfo = {
    parameterPath: ["options", "archiveInfo"],
    mapper: AmlFilesystemArchiveInfo
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const amlFilesystemSubnetInfo = {
    parameterPath: ["options", "amlFilesystemSubnetInfo"],
    mapper: AmlFilesystemSubnetInfo
};
const requiredAMLFilesystemSubnetsSizeInfo = {
    parameterPath: ["options", "requiredAMLFilesystemSubnetsSizeInfo"],
    mapper: RequiredAmlFilesystemSubnetsSizeInfo
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location1 = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cacheName = {
    parameterPath: "cacheName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
        },
        serializedName: "cacheName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cache = {
    parameterPath: "cache",
    mapper: Cache
};
const cache1 = {
    parameterPath: ["options", "cache"],
    mapper: Cache
};
const primingjob = {
    parameterPath: ["options", "primingjob"],
    mapper: PrimingJob
};
const primingJobId = {
    parameterPath: ["options", "primingJobId"],
    mapper: PrimingJobIdParameter
};
const spaceAllocation = {
    parameterPath: ["options", "spaceAllocation"],
    mapper: {
        serializedName: "spaceAllocation",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "Composite",
                    className: "StorageTargetSpaceAllocation"
                }
            }
        }
    }
};
const storageTargetName = {
    parameterPath: "storageTargetName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-0-9a-zA-Z_]{1,80}$")
        },
        serializedName: "storageTargetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const force = {
    parameterPath: ["options", "force"],
    mapper: {
        serializedName: "force",
        type: {
            name: "String"
        }
    }
};
const storagetarget = {
    parameterPath: "storagetarget",
    mapper: StorageTarget
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AmlFilesystems operations. */
class AmlFilesystemsImpl {
    /**
     * Initialize a new instance of the class AmlFilesystems class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns all AML file systems the user has access to under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns all AML file systems the user has access to under a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns all AML file systems the user has access to under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * Returns all AML file systems the user has access to under a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Schedules an AML file system for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, amlFilesystemName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, amlFilesystemName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Schedules an AML file system for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, amlFilesystemName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, amlFilesystemName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns an AML file system.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param options The options parameters.
     */
    get(resourceGroupName, amlFilesystemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, amlFilesystemName, options }, getOperationSpec$3);
    }
    /**
     * Create or update an AML file system.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param amlFilesystem Object containing the user-selectable properties of the AML file system. If
     *                      read-only properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, amlFilesystemName, amlFilesystem, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, amlFilesystemName, amlFilesystem, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an AML file system.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param amlFilesystem Object containing the user-selectable properties of the AML file system. If
     *                      read-only properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, amlFilesystemName, amlFilesystem, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, amlFilesystemName, amlFilesystem, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update an AML file system instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param amlFilesystem Object containing the user-selectable properties of the AML file system. If
     *                      read-only properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, amlFilesystemName, amlFilesystem, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, amlFilesystemName, amlFilesystem, options },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update an AML file system instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param amlFilesystem Object containing the user-selectable properties of the AML file system. If
     *                      read-only properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, amlFilesystemName, amlFilesystem, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, amlFilesystemName, amlFilesystem, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Archive data from the AML file system.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param options The options parameters.
     */
    archive(resourceGroupName, amlFilesystemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, amlFilesystemName, options }, archiveOperationSpec);
    }
    /**
     * Cancel archiving data from the AML file system.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param amlFilesystemName Name for the AML file system. Allows alphanumerics, underscores, and
     *                          hyphens. Start and end with alphanumeric.
     * @param options The options parameters.
     */
    cancelArchive(resourceGroupName, amlFilesystemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, amlFilesystemName, options }, cancelArchiveOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/amlFilesystems",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlFilesystemsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlFilesystemsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlFilesystem
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AmlFilesystem
        },
        201: {
            bodyMapper: AmlFilesystem
        },
        202: {
            bodyMapper: AmlFilesystem
        },
        204: {
            bodyMapper: AmlFilesystem
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: amlFilesystem,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AmlFilesystem
        },
        201: {
            bodyMapper: AmlFilesystem
        },
        202: {
            bodyMapper: AmlFilesystem
        },
        204: {
            bodyMapper: AmlFilesystem
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: amlFilesystem1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const archiveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}/archive",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: archiveInfo,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const cancelArchiveOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/amlFilesystems/{amlFilesystemName}/cancelArchive",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        amlFilesystemName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlFilesystemsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlFilesystemsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Resource Provider operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Resource Provider operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/providers/Microsoft.StorageCache/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiOperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApiOperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Skus operations. */
class SkusImpl {
    /**
     * Initialize a new instance of the class Skus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of StorageCache.Cache SKUs available to this subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the list of StorageCache.Cache SKUs available to this subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing UsageModels operations. */
class UsageModelsImpl {
    /**
     * Initialize a new instance of the class UsageModels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of cache usage models available to this subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the list of cache usage models available to this subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/usageModels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageModelsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageModelsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing AscOperations operations. */
class AscOperationsImpl {
    /**
     * Initialize a new instance of the class AscOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the status of an asynchronous operation for the Azure HPC Cache
     * @param location The name of Azure region.
     * @param operationId The ID of an ongoing async operation.
     * @param options The options parameters.
     */
    get(location, operationId, options) {
        return this.client.sendOperationRequest({ location, operationId, options }, getOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/locations/{location}/ascOperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AscOperation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AscUsages operations. */
class AscUsagesImpl {
    /**
     * Initialize a new instance of the class AscUsages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the quantity used and quota limit for resources
     * @param location The name of the region to query for usage information.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the quantity used and quota limit for resources
     * @param location The name of the region to query for usage information.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param location The name of the region to query for usage information.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceUsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Caches operations. */
class CachesImpl {
    /**
     * Initialize a new instance of the class Caches class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns all caches the user has access to under a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns all caches the user has access to under a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns all caches the user has access to under a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Returns all caches the user has access to under a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Schedules a cache for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Schedules a cache for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    get(resourceGroupName, cacheName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cacheName, options }, getOperationSpec$1);
    }
    /**
     * Create or update a cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param cache Object containing the user-selectable properties of the new cache. If read-only
     *              properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, cacheName, cache, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, cache, options },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param cache Object containing the user-selectable properties of the new cache. If read-only
     *              properties are included, they must match the existing values of those properties.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, cacheName, cache, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, cacheName, cache, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a cache instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a cache instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Tells a cache to write generate debug info for support to process.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginDebugInfo(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: debugInfoOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells a cache to write generate debug info for support to process.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginDebugInfoAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDebugInfo(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Tells a cache to write all dirty data to the Storage Target(s). During the flush, clients will see
     * errors returned until the flush is complete.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginFlush(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: flushOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells a cache to write all dirty data to the Storage Target(s). During the flush, clients will see
     * errors returned until the flush is complete.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginFlushAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFlush(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Tells a Stopped state cache to transition to Active state.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: startOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells a Stopped state cache to transition to Active state.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Tells an Active cache to transition to Stopped state.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: stopOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells an Active cache to transition to Stopped state.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create a priming job. This operation is only allowed when the cache is healthy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStartPrimingJob(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: startPrimingJobOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a priming job. This operation is only allowed when the cache is healthy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStartPrimingJobAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPrimingJob(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Schedule a priming job for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStopPrimingJob(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: stopPrimingJobOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Schedule a priming job for deletion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginStopPrimingJobAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPrimingJob(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Schedule a priming job to be paused.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginPausePrimingJob(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: pausePrimingJobOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Schedule a priming job to be paused.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginPausePrimingJobAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPausePrimingJob(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resumes a paused priming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginResumePrimingJob(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: resumePrimingJobOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resumes a paused priming job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginResumePrimingJobAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResumePrimingJob(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Upgrade a cache's firmware if a new version is available. Otherwise, this operation has no effect.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginUpgradeFirmware(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: upgradeFirmwareOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Upgrade a cache's firmware if a new version is available. Otherwise, this operation has no effect.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginUpgradeFirmwareAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgradeFirmware(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update cache space allocation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginSpaceAllocation(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, options },
                spec: spaceAllocationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update cache space allocation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    beginSpaceAllocationAndWait(resourceGroupName, cacheName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSpaceAllocation(resourceGroupName, cacheName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/caches",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cache
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cache
        },
        201: {
            bodyMapper: Cache
        },
        202: {
            bodyMapper: Cache
        },
        204: {
            bodyMapper: Cache
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: cache,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cache
        },
        201: {
            bodyMapper: Cache
        },
        202: {
            bodyMapper: Cache
        },
        204: {
            bodyMapper: Cache
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: cache1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const debugInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/debugInfo",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const flushOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/flush",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const startPrimingJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/startPrimingJob",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: CachesStartPrimingJobHeaders
        },
        201: {
            headersMapper: CachesStartPrimingJobHeaders
        },
        202: {
            headersMapper: CachesStartPrimingJobHeaders
        },
        204: {
            headersMapper: CachesStartPrimingJobHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: primingjob,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const stopPrimingJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/stopPrimingJob",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: CachesStopPrimingJobHeaders
        },
        201: {
            headersMapper: CachesStopPrimingJobHeaders
        },
        202: {
            headersMapper: CachesStopPrimingJobHeaders
        },
        204: {
            headersMapper: CachesStopPrimingJobHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: primingJobId,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const pausePrimingJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/pausePrimingJob",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: CachesPausePrimingJobHeaders
        },
        201: {
            headersMapper: CachesPausePrimingJobHeaders
        },
        202: {
            headersMapper: CachesPausePrimingJobHeaders
        },
        204: {
            headersMapper: CachesPausePrimingJobHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: primingJobId,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const resumePrimingJobOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/resumePrimingJob",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: CachesResumePrimingJobHeaders
        },
        201: {
            headersMapper: CachesResumePrimingJobHeaders
        },
        202: {
            headersMapper: CachesResumePrimingJobHeaders
        },
        204: {
            headersMapper: CachesResumePrimingJobHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: primingJobId,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const upgradeFirmwareOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/upgrade",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const spaceAllocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/spaceAllocation",
    httpMethod: "POST",
    responses: {
        200: {
            headersMapper: CachesSpaceAllocationHeaders
        },
        201: {
            headersMapper: CachesSpaceAllocationHeaders
        },
        202: {
            headersMapper: CachesSpaceAllocationHeaders
        },
        204: {
            headersMapper: CachesSpaceAllocationHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: spaceAllocation,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CachesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StorageTargets operations. */
class StorageTargetsImpl {
    /**
     * Initialize a new instance of the class StorageTargets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of Storage Targets for the specified cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    listByCache(resourceGroupName, cacheName, options) {
        const iter = this.listByCachePagingAll(resourceGroupName, cacheName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByCachePagingPage(resourceGroupName, cacheName, options, settings);
            }
        };
    }
    listByCachePagingPage(resourceGroupName, cacheName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByCachePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCache(resourceGroupName, cacheName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByCacheNext(resourceGroupName, cacheName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByCachePagingAll(resourceGroupName, cacheName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByCachePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByCachePagingPage(resourceGroupName, cacheName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Tells a storage target to refresh its DNS information.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginDnsRefresh(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: dnsRefreshOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells a storage target to refresh its DNS information.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginDnsRefreshAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDnsRefresh(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a list of Storage Targets for the specified cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param options The options parameters.
     */
    _listByCache(resourceGroupName, cacheName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cacheName, options }, listByCacheOperationSpec);
    }
    /**
     * Removes a Storage Target from a cache. This operation is allowed at any time, but if the cache is
     * down or unhealthy, the actual removal of the Storage Target may be delayed until the cache is
     * healthy again. Note that if the cache has data to flush to the Storage Target, the data will be
     * flushed before the Storage Target will be deleted.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Removes a Storage Target from a cache. This operation is allowed at any time, but if the cache is
     * down or unhealthy, the actual removal of the Storage Target may be delayed until the cache is
     * healthy again. Note that if the cache has data to flush to the Storage Target, the data will be
     * flushed before the Storage Target will be deleted.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a Storage Target from a cache.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    get(resourceGroupName, cacheName, storageTargetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cacheName, storageTargetName, options }, getOperationSpec);
    }
    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the cache is down
     * or unhealthy, the actual creation/modification of the Storage Target may be delayed until the cache
     * is healthy again.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, cacheName, storageTargetName, storagetarget, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    cacheName,
                    storageTargetName,
                    storagetarget,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Storage Target. This operation is allowed at any time, but if the cache is down
     * or unhealthy, the actual creation/modification of the Storage Target may be delayed until the cache
     * is healthy again.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param storagetarget Object containing the definition of a Storage Target.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, cacheName, storageTargetName, storagetarget, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, cacheName, storageTargetName, storagetarget, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Tells a storage target to restore its settings to their default values.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginRestoreDefaults(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: restoreDefaultsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells a storage target to restore its settings to their default values.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginRestoreDefaultsAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreDefaults(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByCacheNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param nextLink The nextLink from the previous successful call to the ListByCache method.
     * @param options The options parameters.
     */
    _listByCacheNext(resourceGroupName, cacheName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cacheName, nextLink, options }, listByCacheNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const dnsRefreshOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/dnsRefresh",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByCacheOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageTargetsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageTarget
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StorageTarget
        },
        201: {
            bodyMapper: StorageTarget
        },
        202: {
            bodyMapper: StorageTarget
        },
        204: {
            bodyMapper: StorageTarget
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: storagetarget,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const restoreDefaultsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/restoreDefaults",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByCacheNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StorageTargetsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        cacheName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing StorageTargetOperations operations. */
class StorageTargetOperationsImpl {
    /**
     * Initialize a new instance of the class StorageTargetOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Tells the cache to write all dirty data to the Storage Target's backend storage. Client requests to
     * this storage target's namespace will return errors until the flush operation completes.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginFlush(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: flushOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Tells the cache to write all dirty data to the Storage Target's backend storage. Client requests to
     * this storage target's namespace will return errors until the flush operation completes.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginFlushAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFlush(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Suspends client access to a storage target.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginSuspend(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: suspendOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Suspends client access to a storage target.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginSuspendAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSuspend(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resumes client access to a previously suspended storage target.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginResume(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: resumeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resumes client access to a previously suspended storage target.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginResumeAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResume(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Invalidate all cached data for a storage target. Cached files are discarded and fetched from the
     * back end on the next request.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginInvalidate(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, cacheName, storageTargetName, options },
                spec: invalidateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Invalidate all cached data for a storage target. Cached files are discarded and fetched from the
     * back end on the next request.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param cacheName Name of cache. Length of name must not be greater than 80 and chars must be from
     *                  the [-0-9a-zA-Z_] char class.
     * @param storageTargetName Name of Storage Target.
     * @param options The options parameters.
     */
    beginInvalidateAndWait(resourceGroupName, cacheName, storageTargetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInvalidate(resourceGroupName, cacheName, storageTargetName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const flushOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/flush",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const suspendOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/suspend",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const resumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/resume",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const invalidateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.StorageCache/caches/{cacheName}/storageTargets/{storageTargetName}/invalidate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cacheName,
        storageTargetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class StorageCacheManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the StorageCacheManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-storagecache/7.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-05-01";
        this.amlFilesystems = new AmlFilesystemsImpl(this);
        this.operations = new OperationsImpl(this);
        this.skus = new SkusImpl(this);
        this.usageModels = new UsageModelsImpl(this);
        this.ascOperations = new AscOperationsImpl(this);
        this.ascUsages = new AscUsagesImpl(this);
        this.caches = new CachesImpl(this);
        this.storageTargets = new StorageTargetsImpl(this);
        this.storageTargetOperations = new StorageTargetOperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Check that subnets will be valid for AML file system create calls.
     * @param options The options parameters.
     */
    checkAmlFSSubnets(options) {
        return this.sendOperationRequest({ options }, checkAmlFSSubnetsOperationSpec);
    }
    /**
     * Get the number of available IP addresses needed for the AML file system information provided.
     * @param options The options parameters.
     */
    getRequiredAmlFSSubnetsSize(options) {
        return this.sendOperationRequest({ options }, getRequiredAmlFSSubnetsSizeOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkAmlFSSubnetsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/checkAmlFSSubnets",
    httpMethod: "POST",
    responses: {
        200: {},
        400: {
            bodyMapper: AmlFilesystemCheckSubnetError,
            isError: true
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: amlFilesystemSubnetInfo,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getRequiredAmlFSSubnetsSizeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.StorageCache/getRequiredAmlFSSubnetsSize",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RequiredAmlFilesystemSubnetsSize
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: requiredAMLFilesystemSubnetsSizeInfo,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};

exports.StorageCacheManagementClient = StorageCacheManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
