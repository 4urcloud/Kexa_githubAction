'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link Applicability} that the service accepts. */
exports.KnownApplicability = void 0;
(function (KnownApplicability) {
    /** LocationDefault */
    KnownApplicability["LocationDefault"] = "LocationDefault";
    /** Custom */
    KnownApplicability["Custom"] = "Custom";
})(exports.KnownApplicability || (exports.KnownApplicability = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
exports.KnownExtendedLocationTypes = void 0;
(function (KnownExtendedLocationTypes) {
    /** CustomLocation */
    KnownExtendedLocationTypes["CustomLocation"] = "CustomLocation";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
/** Known values of {@link ConnectedEnvironmentProvisioningState} that the service accepts. */
exports.KnownConnectedEnvironmentProvisioningState = void 0;
(function (KnownConnectedEnvironmentProvisioningState) {
    /** Succeeded */
    KnownConnectedEnvironmentProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownConnectedEnvironmentProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownConnectedEnvironmentProvisioningState["Canceled"] = "Canceled";
    /** Waiting */
    KnownConnectedEnvironmentProvisioningState["Waiting"] = "Waiting";
    /** InitializationInProgress */
    KnownConnectedEnvironmentProvisioningState["InitializationInProgress"] = "InitializationInProgress";
    /** InfrastructureSetupInProgress */
    KnownConnectedEnvironmentProvisioningState["InfrastructureSetupInProgress"] = "InfrastructureSetupInProgress";
    /** InfrastructureSetupComplete */
    KnownConnectedEnvironmentProvisioningState["InfrastructureSetupComplete"] = "InfrastructureSetupComplete";
    /** ScheduledForDelete */
    KnownConnectedEnvironmentProvisioningState["ScheduledForDelete"] = "ScheduledForDelete";
})(exports.KnownConnectedEnvironmentProvisioningState || (exports.KnownConnectedEnvironmentProvisioningState = {}));
/** Known values of {@link CheckNameAvailabilityReason} that the service accepts. */
exports.KnownCheckNameAvailabilityReason = void 0;
(function (KnownCheckNameAvailabilityReason) {
    /** Invalid */
    KnownCheckNameAvailabilityReason["Invalid"] = "Invalid";
    /** AlreadyExists */
    KnownCheckNameAvailabilityReason["AlreadyExists"] = "AlreadyExists";
})(exports.KnownCheckNameAvailabilityReason || (exports.KnownCheckNameAvailabilityReason = {}));
/** Known values of {@link CertificateProvisioningState} that the service accepts. */
exports.KnownCertificateProvisioningState = void 0;
(function (KnownCertificateProvisioningState) {
    /** Succeeded */
    KnownCertificateProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownCertificateProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownCertificateProvisioningState["Canceled"] = "Canceled";
    /** DeleteFailed */
    KnownCertificateProvisioningState["DeleteFailed"] = "DeleteFailed";
    /** Pending */
    KnownCertificateProvisioningState["Pending"] = "Pending";
})(exports.KnownCertificateProvisioningState || (exports.KnownCertificateProvisioningState = {}));
/** Known values of {@link AccessMode} that the service accepts. */
exports.KnownAccessMode = void 0;
(function (KnownAccessMode) {
    /** ReadOnly */
    KnownAccessMode["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownAccessMode["ReadWrite"] = "ReadWrite";
})(exports.KnownAccessMode || (exports.KnownAccessMode = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));
/** Known values of {@link ContainerAppProvisioningState} that the service accepts. */
exports.KnownContainerAppProvisioningState = void 0;
(function (KnownContainerAppProvisioningState) {
    /** InProgress */
    KnownContainerAppProvisioningState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownContainerAppProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownContainerAppProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownContainerAppProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownContainerAppProvisioningState["Deleting"] = "Deleting";
})(exports.KnownContainerAppProvisioningState || (exports.KnownContainerAppProvisioningState = {}));
/** Known values of {@link ActiveRevisionsMode} that the service accepts. */
exports.KnownActiveRevisionsMode = void 0;
(function (KnownActiveRevisionsMode) {
    /** Multiple */
    KnownActiveRevisionsMode["Multiple"] = "Multiple";
    /** Single */
    KnownActiveRevisionsMode["Single"] = "Single";
})(exports.KnownActiveRevisionsMode || (exports.KnownActiveRevisionsMode = {}));
/** Known values of {@link IngressTransportMethod} that the service accepts. */
exports.KnownIngressTransportMethod = void 0;
(function (KnownIngressTransportMethod) {
    /** Auto */
    KnownIngressTransportMethod["Auto"] = "auto";
    /** Http */
    KnownIngressTransportMethod["Http"] = "http";
    /** Http2 */
    KnownIngressTransportMethod["Http2"] = "http2";
    /** Tcp */
    KnownIngressTransportMethod["Tcp"] = "tcp";
})(exports.KnownIngressTransportMethod || (exports.KnownIngressTransportMethod = {}));
/** Known values of {@link BindingType} that the service accepts. */
exports.KnownBindingType = void 0;
(function (KnownBindingType) {
    /** Disabled */
    KnownBindingType["Disabled"] = "Disabled";
    /** SniEnabled */
    KnownBindingType["SniEnabled"] = "SniEnabled";
})(exports.KnownBindingType || (exports.KnownBindingType = {}));
/** Known values of {@link Action} that the service accepts. */
exports.KnownAction = void 0;
(function (KnownAction) {
    /** Allow */
    KnownAction["Allow"] = "Allow";
    /** Deny */
    KnownAction["Deny"] = "Deny";
})(exports.KnownAction || (exports.KnownAction = {}));
/** Known values of {@link Affinity} that the service accepts. */
exports.KnownAffinity = void 0;
(function (KnownAffinity) {
    /** Sticky */
    KnownAffinity["Sticky"] = "sticky";
    /** None */
    KnownAffinity["None"] = "none";
})(exports.KnownAffinity || (exports.KnownAffinity = {}));
/** Known values of {@link IngressClientCertificateMode} that the service accepts. */
exports.KnownIngressClientCertificateMode = void 0;
(function (KnownIngressClientCertificateMode) {
    /** Ignore */
    KnownIngressClientCertificateMode["Ignore"] = "ignore";
    /** Accept */
    KnownIngressClientCertificateMode["Accept"] = "accept";
    /** Require */
    KnownIngressClientCertificateMode["Require"] = "require";
})(exports.KnownIngressClientCertificateMode || (exports.KnownIngressClientCertificateMode = {}));
/** Known values of {@link AppProtocol} that the service accepts. */
exports.KnownAppProtocol = void 0;
(function (KnownAppProtocol) {
    /** Http */
    KnownAppProtocol["Http"] = "http";
    /** Grpc */
    KnownAppProtocol["Grpc"] = "grpc";
})(exports.KnownAppProtocol || (exports.KnownAppProtocol = {}));
/** Known values of {@link LogLevel} that the service accepts. */
exports.KnownLogLevel = void 0;
(function (KnownLogLevel) {
    /** Info */
    KnownLogLevel["Info"] = "info";
    /** Debug */
    KnownLogLevel["Debug"] = "debug";
    /** Warn */
    KnownLogLevel["Warn"] = "warn";
    /** Error */
    KnownLogLevel["Error"] = "error";
})(exports.KnownLogLevel || (exports.KnownLogLevel = {}));
/** Known values of {@link Scheme} that the service accepts. */
exports.KnownScheme = void 0;
(function (KnownScheme) {
    /** Http */
    KnownScheme["Http"] = "HTTP";
    /** Https */
    KnownScheme["Https"] = "HTTPS";
})(exports.KnownScheme || (exports.KnownScheme = {}));
/** Known values of {@link Type} that the service accepts. */
exports.KnownType = void 0;
(function (KnownType) {
    /** Liveness */
    KnownType["Liveness"] = "Liveness";
    /** Readiness */
    KnownType["Readiness"] = "Readiness";
    /** Startup */
    KnownType["Startup"] = "Startup";
})(exports.KnownType || (exports.KnownType = {}));
/** Known values of {@link StorageType} that the service accepts. */
exports.KnownStorageType = void 0;
(function (KnownStorageType) {
    /** AzureFile */
    KnownStorageType["AzureFile"] = "AzureFile";
    /** EmptyDir */
    KnownStorageType["EmptyDir"] = "EmptyDir";
    /** Secret */
    KnownStorageType["Secret"] = "Secret";
})(exports.KnownStorageType || (exports.KnownStorageType = {}));
/** Known values of {@link RevisionHealthState} that the service accepts. */
exports.KnownRevisionHealthState = void 0;
(function (KnownRevisionHealthState) {
    /** Healthy */
    KnownRevisionHealthState["Healthy"] = "Healthy";
    /** Unhealthy */
    KnownRevisionHealthState["Unhealthy"] = "Unhealthy";
    /** None */
    KnownRevisionHealthState["None"] = "None";
})(exports.KnownRevisionHealthState || (exports.KnownRevisionHealthState = {}));
/** Known values of {@link RevisionProvisioningState} that the service accepts. */
exports.KnownRevisionProvisioningState = void 0;
(function (KnownRevisionProvisioningState) {
    /** Provisioning */
    KnownRevisionProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioned */
    KnownRevisionProvisioningState["Provisioned"] = "Provisioned";
    /** Failed */
    KnownRevisionProvisioningState["Failed"] = "Failed";
    /** Deprovisioning */
    KnownRevisionProvisioningState["Deprovisioning"] = "Deprovisioning";
    /** Deprovisioned */
    KnownRevisionProvisioningState["Deprovisioned"] = "Deprovisioned";
})(exports.KnownRevisionProvisioningState || (exports.KnownRevisionProvisioningState = {}));
/** Known values of {@link RevisionRunningState} that the service accepts. */
exports.KnownRevisionRunningState = void 0;
(function (KnownRevisionRunningState) {
    /** Running */
    KnownRevisionRunningState["Running"] = "Running";
    /** Processing */
    KnownRevisionRunningState["Processing"] = "Processing";
    /** Stopped */
    KnownRevisionRunningState["Stopped"] = "Stopped";
    /** Degraded */
    KnownRevisionRunningState["Degraded"] = "Degraded";
    /** Failed */
    KnownRevisionRunningState["Failed"] = "Failed";
    /** Unknown */
    KnownRevisionRunningState["Unknown"] = "Unknown";
})(exports.KnownRevisionRunningState || (exports.KnownRevisionRunningState = {}));
/** Known values of {@link ContainerAppReplicaRunningState} that the service accepts. */
exports.KnownContainerAppReplicaRunningState = void 0;
(function (KnownContainerAppReplicaRunningState) {
    /** Running */
    KnownContainerAppReplicaRunningState["Running"] = "Running";
    /** NotRunning */
    KnownContainerAppReplicaRunningState["NotRunning"] = "NotRunning";
    /** Unknown */
    KnownContainerAppReplicaRunningState["Unknown"] = "Unknown";
})(exports.KnownContainerAppReplicaRunningState || (exports.KnownContainerAppReplicaRunningState = {}));
/** Known values of {@link ContainerAppContainerRunningState} that the service accepts. */
exports.KnownContainerAppContainerRunningState = void 0;
(function (KnownContainerAppContainerRunningState) {
    /** Running */
    KnownContainerAppContainerRunningState["Running"] = "Running";
    /** Terminated */
    KnownContainerAppContainerRunningState["Terminated"] = "Terminated";
    /** Waiting */
    KnownContainerAppContainerRunningState["Waiting"] = "Waiting";
})(exports.KnownContainerAppContainerRunningState || (exports.KnownContainerAppContainerRunningState = {}));
/** Known values of {@link EnvironmentProvisioningState} that the service accepts. */
exports.KnownEnvironmentProvisioningState = void 0;
(function (KnownEnvironmentProvisioningState) {
    /** Succeeded */
    KnownEnvironmentProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownEnvironmentProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownEnvironmentProvisioningState["Canceled"] = "Canceled";
    /** Waiting */
    KnownEnvironmentProvisioningState["Waiting"] = "Waiting";
    /** InitializationInProgress */
    KnownEnvironmentProvisioningState["InitializationInProgress"] = "InitializationInProgress";
    /** InfrastructureSetupInProgress */
    KnownEnvironmentProvisioningState["InfrastructureSetupInProgress"] = "InfrastructureSetupInProgress";
    /** InfrastructureSetupComplete */
    KnownEnvironmentProvisioningState["InfrastructureSetupComplete"] = "InfrastructureSetupComplete";
    /** ScheduledForDelete */
    KnownEnvironmentProvisioningState["ScheduledForDelete"] = "ScheduledForDelete";
    /** UpgradeRequested */
    KnownEnvironmentProvisioningState["UpgradeRequested"] = "UpgradeRequested";
    /** UpgradeFailed */
    KnownEnvironmentProvisioningState["UpgradeFailed"] = "UpgradeFailed";
})(exports.KnownEnvironmentProvisioningState || (exports.KnownEnvironmentProvisioningState = {}));
/** Known values of {@link JobProvisioningState} that the service accepts. */
exports.KnownJobProvisioningState = void 0;
(function (KnownJobProvisioningState) {
    /** InProgress */
    KnownJobProvisioningState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownJobProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownJobProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownJobProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownJobProvisioningState["Deleting"] = "Deleting";
})(exports.KnownJobProvisioningState || (exports.KnownJobProvisioningState = {}));
/** Known values of {@link TriggerType} that the service accepts. */
exports.KnownTriggerType = void 0;
(function (KnownTriggerType) {
    /** Schedule */
    KnownTriggerType["Schedule"] = "Schedule";
    /** Event */
    KnownTriggerType["Event"] = "Event";
    /** Manual */
    KnownTriggerType["Manual"] = "Manual";
})(exports.KnownTriggerType || (exports.KnownTriggerType = {}));
/** Known values of {@link JobExecutionRunningState} that the service accepts. */
exports.KnownJobExecutionRunningState = void 0;
(function (KnownJobExecutionRunningState) {
    /** Running */
    KnownJobExecutionRunningState["Running"] = "Running";
    /** Processing */
    KnownJobExecutionRunningState["Processing"] = "Processing";
    /** Stopped */
    KnownJobExecutionRunningState["Stopped"] = "Stopped";
    /** Degraded */
    KnownJobExecutionRunningState["Degraded"] = "Degraded";
    /** Failed */
    KnownJobExecutionRunningState["Failed"] = "Failed";
    /** Unknown */
    KnownJobExecutionRunningState["Unknown"] = "Unknown";
    /** Succeeded */
    KnownJobExecutionRunningState["Succeeded"] = "Succeeded";
})(exports.KnownJobExecutionRunningState || (exports.KnownJobExecutionRunningState = {}));
/** Known values of {@link ManagedCertificateDomainControlValidation} that the service accepts. */
exports.KnownManagedCertificateDomainControlValidation = void 0;
(function (KnownManagedCertificateDomainControlValidation) {
    /** Cname */
    KnownManagedCertificateDomainControlValidation["Cname"] = "CNAME";
    /** Http */
    KnownManagedCertificateDomainControlValidation["Http"] = "HTTP";
    /** TXT */
    KnownManagedCertificateDomainControlValidation["TXT"] = "TXT";
})(exports.KnownManagedCertificateDomainControlValidation || (exports.KnownManagedCertificateDomainControlValidation = {}));
/** Known values of {@link SourceControlOperationState} that the service accepts. */
exports.KnownSourceControlOperationState = void 0;
(function (KnownSourceControlOperationState) {
    /** InProgress */
    KnownSourceControlOperationState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownSourceControlOperationState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownSourceControlOperationState["Failed"] = "Failed";
    /** Canceled */
    KnownSourceControlOperationState["Canceled"] = "Canceled";
})(exports.KnownSourceControlOperationState || (exports.KnownSourceControlOperationState = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AuthConfigCollection = {
    type: {
        name: "Composite",
        className: "AuthConfigCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AuthConfig"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthPlatform = {
    type: {
        name: "Composite",
        className: "AuthPlatform",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GlobalValidation = {
    type: {
        name: "Composite",
        className: "GlobalValidation",
        modelProperties: {
            unauthenticatedClientAction: {
                serializedName: "unauthenticatedClientAction",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "RedirectToLoginPage",
                        "AllowAnonymous",
                        "Return401",
                        "Return403"
                    ]
                }
            },
            redirectToProvider: {
                serializedName: "redirectToProvider",
                type: {
                    name: "String"
                }
            },
            excludedPaths: {
                serializedName: "excludedPaths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const IdentityProviders = {
    type: {
        name: "Composite",
        className: "IdentityProviders",
        modelProperties: {
            azureActiveDirectory: {
                serializedName: "azureActiveDirectory",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectory"
                }
            },
            facebook: {
                serializedName: "facebook",
                type: {
                    name: "Composite",
                    className: "Facebook"
                }
            },
            gitHub: {
                serializedName: "gitHub",
                type: {
                    name: "Composite",
                    className: "GitHub"
                }
            },
            google: {
                serializedName: "google",
                type: {
                    name: "Composite",
                    className: "Google"
                }
            },
            twitter: {
                serializedName: "twitter",
                type: {
                    name: "Composite",
                    className: "Twitter"
                }
            },
            apple: {
                serializedName: "apple",
                type: {
                    name: "Composite",
                    className: "Apple"
                }
            },
            azureStaticWebApps: {
                serializedName: "azureStaticWebApps",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebApps"
                }
            },
            customOpenIdConnectProviders: {
                serializedName: "customOpenIdConnectProviders",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "CustomOpenIdConnectProvider"
                        }
                    }
                }
            }
        }
    }
};
const AzureActiveDirectory = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectory",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryRegistration"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryLogin"
                }
            },
            validation: {
                serializedName: "validation",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectoryValidation"
                }
            },
            isAutoProvisioned: {
                serializedName: "isAutoProvisioned",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AzureActiveDirectoryRegistration = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryRegistration",
        modelProperties: {
            openIdIssuer: {
                serializedName: "openIdIssuer",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateThumbprint: {
                serializedName: "clientSecretCertificateThumbprint",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateSubjectAlternativeName: {
                serializedName: "clientSecretCertificateSubjectAlternativeName",
                type: {
                    name: "String"
                }
            },
            clientSecretCertificateIssuer: {
                serializedName: "clientSecretCertificateIssuer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureActiveDirectoryLogin = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryLogin",
        modelProperties: {
            loginParameters: {
                serializedName: "loginParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            disableWWWAuthenticate: {
                serializedName: "disableWWWAuthenticate",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AzureActiveDirectoryValidation = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectoryValidation",
        modelProperties: {
            jwtClaimChecks: {
                serializedName: "jwtClaimChecks",
                type: {
                    name: "Composite",
                    className: "JwtClaimChecks"
                }
            },
            allowedAudiences: {
                serializedName: "allowedAudiences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            defaultAuthorizationPolicy: {
                serializedName: "defaultAuthorizationPolicy",
                type: {
                    name: "Composite",
                    className: "DefaultAuthorizationPolicy"
                }
            }
        }
    }
};
const JwtClaimChecks = {
    type: {
        name: "Composite",
        className: "JwtClaimChecks",
        modelProperties: {
            allowedGroups: {
                serializedName: "allowedGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedClientApplications: {
                serializedName: "allowedClientApplications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DefaultAuthorizationPolicy = {
    type: {
        name: "Composite",
        className: "DefaultAuthorizationPolicy",
        modelProperties: {
            allowedPrincipals: {
                serializedName: "allowedPrincipals",
                type: {
                    name: "Composite",
                    className: "AllowedPrincipals"
                }
            },
            allowedApplications: {
                serializedName: "allowedApplications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AllowedPrincipals = {
    type: {
        name: "Composite",
        className: "AllowedPrincipals",
        modelProperties: {
            groups: {
                serializedName: "groups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            identities: {
                serializedName: "identities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Facebook = {
    type: {
        name: "Composite",
        className: "Facebook",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "AppRegistration"
                }
            },
            graphApiVersion: {
                serializedName: "graphApiVersion",
                type: {
                    name: "String"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const AppRegistration = {
    type: {
        name: "Composite",
        className: "AppRegistration",
        modelProperties: {
            appId: {
                serializedName: "appId",
                type: {
                    name: "String"
                }
            },
            appSecretSettingName: {
                serializedName: "appSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoginScopes = {
    type: {
        name: "Composite",
        className: "LoginScopes",
        modelProperties: {
            scopes: {
                serializedName: "scopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const GitHub = {
    type: {
        name: "Composite",
        className: "GitHub",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const ClientRegistration = {
    type: {
        name: "Composite",
        className: "ClientRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Google = {
    type: {
        name: "Composite",
        className: "Google",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "ClientRegistration"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            },
            validation: {
                serializedName: "validation",
                type: {
                    name: "Composite",
                    className: "AllowedAudiencesValidation"
                }
            }
        }
    }
};
const AllowedAudiencesValidation = {
    type: {
        name: "Composite",
        className: "AllowedAudiencesValidation",
        modelProperties: {
            allowedAudiences: {
                serializedName: "allowedAudiences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Twitter = {
    type: {
        name: "Composite",
        className: "Twitter",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "TwitterRegistration"
                }
            }
        }
    }
};
const TwitterRegistration = {
    type: {
        name: "Composite",
        className: "TwitterRegistration",
        modelProperties: {
            consumerKey: {
                serializedName: "consumerKey",
                type: {
                    name: "String"
                }
            },
            consumerSecretSettingName: {
                serializedName: "consumerSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Apple = {
    type: {
        name: "Composite",
        className: "Apple",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "AppleRegistration"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "LoginScopes"
                }
            }
        }
    }
};
const AppleRegistration = {
    type: {
        name: "Composite",
        className: "AppleRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureStaticWebApps = {
    type: {
        name: "Composite",
        className: "AzureStaticWebApps",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "AzureStaticWebAppsRegistration"
                }
            }
        }
    }
};
const AzureStaticWebAppsRegistration = {
    type: {
        name: "Composite",
        className: "AzureStaticWebAppsRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomOpenIdConnectProvider = {
    type: {
        name: "Composite",
        className: "CustomOpenIdConnectProvider",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            registration: {
                serializedName: "registration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectRegistration"
                }
            },
            login: {
                serializedName: "login",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectLogin"
                }
            }
        }
    }
};
const OpenIdConnectRegistration = {
    type: {
        name: "Composite",
        className: "OpenIdConnectRegistration",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientCredential: {
                serializedName: "clientCredential",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectClientCredential"
                }
            },
            openIdConnectConfiguration: {
                serializedName: "openIdConnectConfiguration",
                type: {
                    name: "Composite",
                    className: "OpenIdConnectConfig"
                }
            }
        }
    }
};
const OpenIdConnectClientCredential = {
    type: {
        name: "Composite",
        className: "OpenIdConnectClientCredential",
        modelProperties: {
            method: {
                defaultValue: "ClientSecretPost",
                isConstant: true,
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            clientSecretSettingName: {
                serializedName: "clientSecretSettingName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectConfig = {
    type: {
        name: "Composite",
        className: "OpenIdConnectConfig",
        modelProperties: {
            authorizationEndpoint: {
                serializedName: "authorizationEndpoint",
                type: {
                    name: "String"
                }
            },
            tokenEndpoint: {
                serializedName: "tokenEndpoint",
                type: {
                    name: "String"
                }
            },
            issuer: {
                serializedName: "issuer",
                type: {
                    name: "String"
                }
            },
            certificationUri: {
                serializedName: "certificationUri",
                type: {
                    name: "String"
                }
            },
            wellKnownOpenIdConfiguration: {
                serializedName: "wellKnownOpenIdConfiguration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OpenIdConnectLogin = {
    type: {
        name: "Composite",
        className: "OpenIdConnectLogin",
        modelProperties: {
            nameClaimType: {
                serializedName: "nameClaimType",
                type: {
                    name: "String"
                }
            },
            scopes: {
                serializedName: "scopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Login = {
    type: {
        name: "Composite",
        className: "Login",
        modelProperties: {
            routes: {
                serializedName: "routes",
                type: {
                    name: "Composite",
                    className: "LoginRoutes"
                }
            },
            preserveUrlFragmentsForLogins: {
                serializedName: "preserveUrlFragmentsForLogins",
                type: {
                    name: "Boolean"
                }
            },
            allowedExternalRedirectUrls: {
                serializedName: "allowedExternalRedirectUrls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cookieExpiration: {
                serializedName: "cookieExpiration",
                type: {
                    name: "Composite",
                    className: "CookieExpiration"
                }
            },
            nonce: {
                serializedName: "nonce",
                type: {
                    name: "Composite",
                    className: "Nonce"
                }
            }
        }
    }
};
const LoginRoutes = {
    type: {
        name: "Composite",
        className: "LoginRoutes",
        modelProperties: {
            logoutEndpoint: {
                serializedName: "logoutEndpoint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CookieExpiration = {
    type: {
        name: "Composite",
        className: "CookieExpiration",
        modelProperties: {
            convention: {
                serializedName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["FixedTime", "IdentityProviderDerived"]
                }
            },
            timeToExpiration: {
                serializedName: "timeToExpiration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Nonce = {
    type: {
        name: "Composite",
        className: "Nonce",
        modelProperties: {
            validateNonce: {
                serializedName: "validateNonce",
                type: {
                    name: "Boolean"
                }
            },
            nonceExpirationInterval: {
                serializedName: "nonceExpirationInterval",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HttpSettings = {
    type: {
        name: "Composite",
        className: "HttpSettings",
        modelProperties: {
            requireHttps: {
                serializedName: "requireHttps",
                type: {
                    name: "Boolean"
                }
            },
            routes: {
                serializedName: "routes",
                type: {
                    name: "Composite",
                    className: "HttpSettingsRoutes"
                }
            },
            forwardProxy: {
                serializedName: "forwardProxy",
                type: {
                    name: "Composite",
                    className: "ForwardProxy"
                }
            }
        }
    }
};
const HttpSettingsRoutes = {
    type: {
        name: "Composite",
        className: "HttpSettingsRoutes",
        modelProperties: {
            apiPrefix: {
                serializedName: "apiPrefix",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForwardProxy = {
    type: {
        name: "Composite",
        className: "ForwardProxy",
        modelProperties: {
            convention: {
                serializedName: "convention",
                type: {
                    name: "Enum",
                    allowedValues: ["NoProxy", "Standard", "Custom"]
                }
            },
            customHostHeaderName: {
                serializedName: "customHostHeaderName",
                type: {
                    name: "String"
                }
            },
            customProtoHeaderName: {
                serializedName: "customProtoHeaderName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DefaultErrorResponse = {
    type: {
        name: "Composite",
        className: "DefaultErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "DefaultErrorResponseError"
                }
            }
        }
    }
};
const DefaultErrorResponseError = {
    type: {
        name: "Composite",
        className: "DefaultErrorResponseError",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DefaultErrorResponseErrorDetailsItem"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DefaultErrorResponseErrorDetailsItem = {
    type: {
        name: "Composite",
        className: "DefaultErrorResponseErrorDetailsItem",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableWorkloadProfilesCollection = {
    type: {
        name: "Composite",
        className: "AvailableWorkloadProfilesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableWorkloadProfile"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableWorkloadProfileProperties = {
    type: {
        name: "Composite",
        className: "AvailableWorkloadProfileProperties",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            applicability: {
                serializedName: "applicability",
                type: {
                    name: "String"
                }
            },
            cores: {
                serializedName: "cores",
                type: {
                    name: "Number"
                }
            },
            memoryGiB: {
                serializedName: "memoryGiB",
                type: {
                    name: "Number"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const BillingMeterCollection = {
    type: {
        name: "Composite",
        className: "BillingMeterCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BillingMeter"
                        }
                    }
                }
            }
        }
    }
};
const BillingMeterProperties = {
    type: {
        name: "Composite",
        className: "BillingMeterProperties",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            meterType: {
                serializedName: "meterType",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectedEnvironmentCollection = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironmentCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectedEnvironment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomDomainConfiguration = {
    type: {
        name: "Composite",
        className: "CustomDomainConfiguration",
        modelProperties: {
            customDomainVerificationId: {
                serializedName: "customDomainVerificationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dnsSuffix: {
                serializedName: "dnsSuffix",
                type: {
                    name: "String"
                }
            },
            certificateValue: {
                serializedName: "certificateValue",
                type: {
                    name: "ByteArray"
                }
            },
            certificatePassword: {
                serializedName: "certificatePassword",
                type: {
                    name: "String"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subjectName: {
                serializedName: "subjectName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResponse",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateCollection = {
    type: {
        name: "Composite",
        className: "CertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateProperties = {
    type: {
        name: "Composite",
        className: "CertificateProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            subjectName: {
                serializedName: "subjectName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subjectAlternativeNames: {
                serializedName: "subjectAlternativeNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "ByteArray"
                }
            },
            issuer: {
                serializedName: "issuer",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            issueDate: {
                serializedName: "issueDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            valid: {
                serializedName: "valid",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            publicKeyHash: {
                serializedName: "publicKeyHash",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificatePatch = {
    type: {
        name: "Composite",
        className: "CertificatePatch",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DaprComponentsCollection = {
    type: {
        name: "Composite",
        className: "DaprComponentsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprComponent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "String"
                }
            },
            keyVaultUrl: {
                serializedName: "keyVaultUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DaprMetadata = {
    type: {
        name: "Composite",
        className: "DaprMetadata",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            secretRef: {
                serializedName: "secretRef",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DaprSecretsCollection = {
    type: {
        name: "Composite",
        className: "DaprSecretsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprSecret"
                        }
                    }
                }
            }
        }
    }
};
const DaprSecret = {
    type: {
        name: "Composite",
        className: "DaprSecret",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectedEnvironmentStoragesCollection = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironmentStoragesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectedEnvironmentStorage"
                        }
                    }
                }
            }
        }
    }
};
const ConnectedEnvironmentStorageProperties = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironmentStorageProperties",
        modelProperties: {
            azureFile: {
                serializedName: "azureFile",
                type: {
                    name: "Composite",
                    className: "AzureFileProperties"
                }
            }
        }
    }
};
const AzureFileProperties = {
    type: {
        name: "Composite",
        className: "AzureFileProperties",
        modelProperties: {
            accountName: {
                serializedName: "accountName",
                type: {
                    name: "String"
                }
            },
            accountKey: {
                serializedName: "accountKey",
                type: {
                    name: "String"
                }
            },
            accessMode: {
                serializedName: "accessMode",
                type: {
                    name: "String"
                }
            },
            shareName: {
                serializedName: "shareName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppCollection = {
    type: {
        name: "Composite",
        className: "ContainerAppCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerApp"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const Configuration = {
    type: {
        name: "Composite",
        className: "Configuration",
        modelProperties: {
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            activeRevisionsMode: {
                defaultValue: "Single",
                serializedName: "activeRevisionsMode",
                type: {
                    name: "String"
                }
            },
            ingress: {
                serializedName: "ingress",
                type: {
                    name: "Composite",
                    className: "Ingress"
                }
            },
            registries: {
                serializedName: "registries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryCredentials"
                        }
                    }
                }
            },
            dapr: {
                serializedName: "dapr",
                type: {
                    name: "Composite",
                    className: "Dapr"
                }
            },
            maxInactiveRevisions: {
                serializedName: "maxInactiveRevisions",
                type: {
                    name: "Number"
                }
            },
            service: {
                serializedName: "service",
                type: {
                    name: "Composite",
                    className: "Service"
                }
            }
        }
    }
};
const Ingress = {
    type: {
        name: "Composite",
        className: "Ingress",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            external: {
                defaultValue: false,
                serializedName: "external",
                type: {
                    name: "Boolean"
                }
            },
            targetPort: {
                serializedName: "targetPort",
                type: {
                    name: "Number"
                }
            },
            exposedPort: {
                serializedName: "exposedPort",
                type: {
                    name: "Number"
                }
            },
            transport: {
                defaultValue: "auto",
                serializedName: "transport",
                type: {
                    name: "String"
                }
            },
            traffic: {
                serializedName: "traffic",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficWeight"
                        }
                    }
                }
            },
            customDomains: {
                serializedName: "customDomains",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomDomain"
                        }
                    }
                }
            },
            allowInsecure: {
                defaultValue: false,
                serializedName: "allowInsecure",
                type: {
                    name: "Boolean"
                }
            },
            ipSecurityRestrictions: {
                serializedName: "ipSecurityRestrictions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpSecurityRestrictionRule"
                        }
                    }
                }
            },
            stickySessions: {
                serializedName: "stickySessions",
                type: {
                    name: "Composite",
                    className: "IngressStickySessions"
                }
            },
            clientCertificateMode: {
                serializedName: "clientCertificateMode",
                type: {
                    name: "String"
                }
            },
            corsPolicy: {
                serializedName: "corsPolicy",
                type: {
                    name: "Composite",
                    className: "CorsPolicy"
                }
            }
        }
    }
};
const TrafficWeight = {
    type: {
        name: "Composite",
        className: "TrafficWeight",
        modelProperties: {
            revisionName: {
                serializedName: "revisionName",
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            },
            latestRevision: {
                defaultValue: false,
                serializedName: "latestRevision",
                type: {
                    name: "Boolean"
                }
            },
            label: {
                serializedName: "label",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomDomain = {
    type: {
        name: "Composite",
        className: "CustomDomain",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            bindingType: {
                serializedName: "bindingType",
                type: {
                    name: "String"
                }
            },
            certificateId: {
                serializedName: "certificateId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpSecurityRestrictionRule = {
    type: {
        name: "Composite",
        className: "IpSecurityRestrictionRule",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            ipAddressRange: {
                serializedName: "ipAddressRange",
                required: true,
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IngressStickySessions = {
    type: {
        name: "Composite",
        className: "IngressStickySessions",
        modelProperties: {
            affinity: {
                serializedName: "affinity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CorsPolicy = {
    type: {
        name: "Composite",
        className: "CorsPolicy",
        modelProperties: {
            allowedOrigins: {
                serializedName: "allowedOrigins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedMethods: {
                serializedName: "allowedMethods",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedHeaders: {
                serializedName: "allowedHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            exposeHeaders: {
                serializedName: "exposeHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            maxAge: {
                serializedName: "maxAge",
                type: {
                    name: "Number"
                }
            },
            allowCredentials: {
                serializedName: "allowCredentials",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RegistryCredentials = {
    type: {
        name: "Composite",
        className: "RegistryCredentials",
        modelProperties: {
            server: {
                serializedName: "server",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            passwordSecretRef: {
                serializedName: "passwordSecretRef",
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Dapr = {
    type: {
        name: "Composite",
        className: "Dapr",
        modelProperties: {
            enabled: {
                defaultValue: false,
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            appId: {
                serializedName: "appId",
                type: {
                    name: "String"
                }
            },
            appProtocol: {
                defaultValue: "http",
                serializedName: "appProtocol",
                type: {
                    name: "String"
                }
            },
            appPort: {
                serializedName: "appPort",
                type: {
                    name: "Number"
                }
            },
            httpReadBufferSize: {
                serializedName: "httpReadBufferSize",
                type: {
                    name: "Number"
                }
            },
            httpMaxRequestSize: {
                serializedName: "httpMaxRequestSize",
                type: {
                    name: "Number"
                }
            },
            logLevel: {
                serializedName: "logLevel",
                type: {
                    name: "String"
                }
            },
            enableApiLogging: {
                serializedName: "enableApiLogging",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Service = {
    type: {
        name: "Composite",
        className: "Service",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Template = {
    type: {
        name: "Composite",
        className: "Template",
        modelProperties: {
            revisionSuffix: {
                serializedName: "revisionSuffix",
                type: {
                    name: "String"
                }
            },
            terminationGracePeriodSeconds: {
                serializedName: "terminationGracePeriodSeconds",
                type: {
                    name: "Number"
                }
            },
            initContainers: {
                serializedName: "initContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InitContainer"
                        }
                    }
                }
            },
            containers: {
                serializedName: "containers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container"
                        }
                    }
                }
            },
            scale: {
                serializedName: "scale",
                type: {
                    name: "Composite",
                    className: "Scale"
                }
            },
            volumes: {
                serializedName: "volumes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Volume"
                        }
                    }
                }
            },
            serviceBinds: {
                serializedName: "serviceBinds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceBind"
                        }
                    }
                }
            }
        }
    }
};
const BaseContainer = {
    type: {
        name: "Composite",
        className: "BaseContainer",
        modelProperties: {
            image: {
                serializedName: "image",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            command: {
                serializedName: "command",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            args: {
                serializedName: "args",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            env: {
                serializedName: "env",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVar"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "ContainerResources"
                }
            },
            volumeMounts: {
                serializedName: "volumeMounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeMount"
                        }
                    }
                }
            }
        }
    }
};
const EnvironmentVar = {
    type: {
        name: "Composite",
        className: "EnvironmentVar",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            secretRef: {
                serializedName: "secretRef",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerResources = {
    type: {
        name: "Composite",
        className: "ContainerResources",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                type: {
                    name: "Number"
                }
            },
            memory: {
                serializedName: "memory",
                type: {
                    name: "String"
                }
            },
            ephemeralStorage: {
                serializedName: "ephemeralStorage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumeMount = {
    type: {
        name: "Composite",
        className: "VolumeMount",
        modelProperties: {
            volumeName: {
                serializedName: "volumeName",
                type: {
                    name: "String"
                }
            },
            mountPath: {
                serializedName: "mountPath",
                type: {
                    name: "String"
                }
            },
            subPath: {
                serializedName: "subPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppProbe = {
    type: {
        name: "Composite",
        className: "ContainerAppProbe",
        modelProperties: {
            failureThreshold: {
                serializedName: "failureThreshold",
                type: {
                    name: "Number"
                }
            },
            httpGet: {
                serializedName: "httpGet",
                type: {
                    name: "Composite",
                    className: "ContainerAppProbeHttpGet"
                }
            },
            initialDelaySeconds: {
                serializedName: "initialDelaySeconds",
                type: {
                    name: "Number"
                }
            },
            periodSeconds: {
                serializedName: "periodSeconds",
                type: {
                    name: "Number"
                }
            },
            successThreshold: {
                serializedName: "successThreshold",
                type: {
                    name: "Number"
                }
            },
            tcpSocket: {
                serializedName: "tcpSocket",
                type: {
                    name: "Composite",
                    className: "ContainerAppProbeTcpSocket"
                }
            },
            terminationGracePeriodSeconds: {
                serializedName: "terminationGracePeriodSeconds",
                type: {
                    name: "Number"
                }
            },
            timeoutSeconds: {
                serializedName: "timeoutSeconds",
                type: {
                    name: "Number"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppProbeHttpGet = {
    type: {
        name: "Composite",
        className: "ContainerAppProbeHttpGet",
        modelProperties: {
            host: {
                serializedName: "host",
                type: {
                    name: "String"
                }
            },
            httpHeaders: {
                serializedName: "httpHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerAppProbeHttpGetHttpHeadersItem"
                        }
                    }
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            },
            scheme: {
                serializedName: "scheme",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppProbeHttpGetHttpHeadersItem = {
    type: {
        name: "Composite",
        className: "ContainerAppProbeHttpGetHttpHeadersItem",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppProbeTcpSocket = {
    type: {
        name: "Composite",
        className: "ContainerAppProbeTcpSocket",
        modelProperties: {
            host: {
                serializedName: "host",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Scale = {
    type: {
        name: "Composite",
        className: "Scale",
        modelProperties: {
            minReplicas: {
                serializedName: "minReplicas",
                type: {
                    name: "Number"
                }
            },
            maxReplicas: {
                defaultValue: 10,
                serializedName: "maxReplicas",
                type: {
                    name: "Number"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRule"
                        }
                    }
                }
            }
        }
    }
};
const ScaleRule = {
    type: {
        name: "Composite",
        className: "ScaleRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            azureQueue: {
                serializedName: "azureQueue",
                type: {
                    name: "Composite",
                    className: "QueueScaleRule"
                }
            },
            custom: {
                serializedName: "custom",
                type: {
                    name: "Composite",
                    className: "CustomScaleRule"
                }
            },
            http: {
                serializedName: "http",
                type: {
                    name: "Composite",
                    className: "HttpScaleRule"
                }
            },
            tcp: {
                serializedName: "tcp",
                type: {
                    name: "Composite",
                    className: "TcpScaleRule"
                }
            }
        }
    }
};
const QueueScaleRule = {
    type: {
        name: "Composite",
        className: "QueueScaleRule",
        modelProperties: {
            queueName: {
                serializedName: "queueName",
                type: {
                    name: "String"
                }
            },
            queueLength: {
                serializedName: "queueLength",
                type: {
                    name: "Number"
                }
            },
            auth: {
                serializedName: "auth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const ScaleRuleAuth = {
    type: {
        name: "Composite",
        className: "ScaleRuleAuth",
        modelProperties: {
            secretRef: {
                serializedName: "secretRef",
                type: {
                    name: "String"
                }
            },
            triggerParameter: {
                serializedName: "triggerParameter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomScaleRule = {
    type: {
        name: "Composite",
        className: "CustomScaleRule",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            auth: {
                serializedName: "auth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const HttpScaleRule = {
    type: {
        name: "Composite",
        className: "HttpScaleRule",
        modelProperties: {
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            auth: {
                serializedName: "auth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const TcpScaleRule = {
    type: {
        name: "Composite",
        className: "TcpScaleRule",
        modelProperties: {
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            auth: {
                serializedName: "auth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const Volume = {
    type: {
        name: "Composite",
        className: "Volume",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            storageType: {
                serializedName: "storageType",
                type: {
                    name: "String"
                }
            },
            storageName: {
                serializedName: "storageName",
                type: {
                    name: "String"
                }
            },
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecretVolumeItem"
                        }
                    }
                }
            },
            mountOptions: {
                serializedName: "mountOptions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretVolumeItem = {
    type: {
        name: "Composite",
        className: "SecretVolumeItem",
        modelProperties: {
            secretRef: {
                serializedName: "secretRef",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceBind = {
    type: {
        name: "Composite",
        className: "ServiceBind",
        modelProperties: {
            serviceId: {
                serializedName: "serviceId",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomHostnameAnalysisResult = {
    type: {
        name: "Composite",
        className: "CustomHostnameAnalysisResult",
        modelProperties: {
            hostName: {
                serializedName: "hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isHostnameAlreadyVerified: {
                serializedName: "isHostnameAlreadyVerified",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            customDomainVerificationTest: {
                serializedName: "customDomainVerificationTest",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Passed", "Failed", "Skipped"]
                }
            },
            customDomainVerificationFailureInfo: {
                serializedName: "customDomainVerificationFailureInfo",
                type: {
                    name: "Composite",
                    className: "CustomHostnameAnalysisResultCustomDomainVerificationFailureInfo"
                }
            },
            hasConflictOnManagedEnvironment: {
                serializedName: "hasConflictOnManagedEnvironment",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            conflictWithEnvironmentCustomDomain: {
                serializedName: "conflictWithEnvironmentCustomDomain",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            conflictingContainerAppResourceId: {
                serializedName: "conflictingContainerAppResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cNameRecords: {
                serializedName: "cNameRecords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            txtRecords: {
                serializedName: "txtRecords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            aRecords: {
                serializedName: "aRecords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            alternateCNameRecords: {
                serializedName: "alternateCNameRecords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            alternateTxtRecords: {
                serializedName: "alternateTxtRecords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CustomHostnameAnalysisResultCustomDomainVerificationFailureInfo = {
    type: {
        name: "Composite",
        className: "CustomHostnameAnalysisResultCustomDomainVerificationFailureInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomHostnameAnalysisResultCustomDomainVerificationFailureInfoDetailsItem"
                        }
                    }
                }
            }
        }
    }
};
const CustomHostnameAnalysisResultCustomDomainVerificationFailureInfoDetailsItem = {
    type: {
        name: "Composite",
        className: "CustomHostnameAnalysisResultCustomDomainVerificationFailureInfoDetailsItem",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretsCollection = {
    type: {
        name: "Composite",
        className: "SecretsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerAppSecret"
                        }
                    }
                }
            }
        }
    }
};
const ContainerAppSecret = {
    type: {
        name: "Composite",
        className: "ContainerAppSecret",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyVaultUrl: {
                serializedName: "keyVaultUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RevisionCollection = {
    type: {
        name: "Composite",
        className: "RevisionCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Revision"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicaContainer = {
    type: {
        name: "Composite",
        className: "ReplicaContainer",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            containerId: {
                serializedName: "containerId",
                type: {
                    name: "String"
                }
            },
            ready: {
                serializedName: "ready",
                type: {
                    name: "Boolean"
                }
            },
            started: {
                serializedName: "started",
                type: {
                    name: "Boolean"
                }
            },
            restartCount: {
                serializedName: "restartCount",
                type: {
                    name: "Number"
                }
            },
            runningState: {
                serializedName: "runningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            runningStateDetails: {
                serializedName: "runningStateDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            logStreamEndpoint: {
                serializedName: "logStreamEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            execEndpoint: {
                serializedName: "execEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicaCollection = {
    type: {
        name: "Composite",
        className: "ReplicaCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Replica"
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticsCollection = {
    type: {
        name: "Composite",
        className: "DiagnosticsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Diagnostics"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsProperties = {
    type: {
        name: "Composite",
        className: "DiagnosticsProperties",
        modelProperties: {
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Composite",
                    className: "DiagnosticsDefinition"
                }
            },
            dataset: {
                serializedName: "dataset",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticsDataApiResponse"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "DiagnosticsStatus"
                }
            },
            dataProviderMetadata: {
                serializedName: "dataProviderMetadata",
                type: {
                    name: "Composite",
                    className: "DiagnosticDataProviderMetadata"
                }
            }
        }
    }
};
const DiagnosticsDefinition = {
    type: {
        name: "Composite",
        className: "DiagnosticsDefinition",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            author: {
                serializedName: "author",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportTopicList: {
                serializedName: "supportTopicList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticSupportTopic"
                        }
                    }
                }
            },
            analysisTypes: {
                serializedName: "analysisTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            score: {
                serializedName: "score",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DiagnosticSupportTopic = {
    type: {
        name: "Composite",
        className: "DiagnosticSupportTopic",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            pesId: {
                serializedName: "pesId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsDataApiResponse = {
    type: {
        name: "Composite",
        className: "DiagnosticsDataApiResponse",
        modelProperties: {
            table: {
                serializedName: "table",
                type: {
                    name: "Composite",
                    className: "DiagnosticDataTableResponseObject"
                }
            },
            renderingProperties: {
                serializedName: "renderingProperties",
                type: {
                    name: "Composite",
                    className: "DiagnosticRendering"
                }
            }
        }
    }
};
const DiagnosticDataTableResponseObject = {
    type: {
        name: "Composite",
        className: "DiagnosticDataTableResponseObject",
        modelProperties: {
            tableName: {
                serializedName: "tableName",
                type: {
                    name: "String"
                }
            },
            columns: {
                serializedName: "columns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticDataTableResponseColumn"
                        }
                    }
                }
            },
            rows: {
                serializedName: "rows",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "any" } }
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticDataTableResponseColumn = {
    type: {
        name: "Composite",
        className: "DiagnosticDataTableResponseColumn",
        modelProperties: {
            columnName: {
                serializedName: "columnName",
                type: {
                    name: "String"
                }
            },
            dataType: {
                serializedName: "dataType",
                type: {
                    name: "String"
                }
            },
            columnType: {
                serializedName: "columnType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticRendering = {
    type: {
        name: "Composite",
        className: "DiagnosticRendering",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "Number"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            isVisible: {
                serializedName: "isVisible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DiagnosticsStatus = {
    type: {
        name: "Composite",
        className: "DiagnosticsStatus",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            statusId: {
                serializedName: "statusId",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DiagnosticDataProviderMetadata = {
    type: {
        name: "Composite",
        className: "DiagnosticDataProviderMetadata",
        modelProperties: {
            providerName: {
                serializedName: "providerName",
                type: {
                    name: "String"
                }
            },
            propertyBag: {
                serializedName: "propertyBag",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticDataProviderMetadataPropertyBagItem"
                        }
                    }
                }
            }
        }
    }
};
const DiagnosticDataProviderMetadataPropertyBagItem = {
    type: {
        name: "Composite",
        className: "DiagnosticDataProviderMetadataPropertyBagItem",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VnetConfiguration = {
    type: {
        name: "Composite",
        className: "VnetConfiguration",
        modelProperties: {
            internal: {
                serializedName: "internal",
                type: {
                    name: "Boolean"
                }
            },
            infrastructureSubnetId: {
                serializedName: "infrastructureSubnetId",
                type: {
                    name: "String"
                }
            },
            dockerBridgeCidr: {
                serializedName: "dockerBridgeCidr",
                type: {
                    name: "String"
                }
            },
            platformReservedCidr: {
                serializedName: "platformReservedCidr",
                type: {
                    name: "String"
                }
            },
            platformReservedDnsIP: {
                serializedName: "platformReservedDnsIP",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AppLogsConfiguration = {
    type: {
        name: "Composite",
        className: "AppLogsConfiguration",
        modelProperties: {
            destination: {
                serializedName: "destination",
                type: {
                    name: "String"
                }
            },
            logAnalyticsConfiguration: {
                serializedName: "logAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "LogAnalyticsConfiguration"
                }
            }
        }
    }
};
const LogAnalyticsConfiguration = {
    type: {
        name: "Composite",
        className: "LogAnalyticsConfiguration",
        modelProperties: {
            customerId: {
                serializedName: "customerId",
                type: {
                    name: "String"
                }
            },
            sharedKey: {
                serializedName: "sharedKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadProfile = {
    type: {
        name: "Composite",
        className: "WorkloadProfile",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            workloadProfileType: {
                serializedName: "workloadProfileType",
                required: true,
                type: {
                    name: "String"
                }
            },
            minimumCount: {
                serializedName: "minimumCount",
                type: {
                    name: "Number"
                }
            },
            maximumCount: {
                serializedName: "maximumCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KedaConfiguration = {
    type: {
        name: "Composite",
        className: "KedaConfiguration",
        modelProperties: {
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DaprConfiguration = {
    type: {
        name: "Composite",
        className: "DaprConfiguration",
        modelProperties: {
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedEnvironmentPropertiesPeerAuthentication = {
    type: {
        name: "Composite",
        className: "ManagedEnvironmentPropertiesPeerAuthentication",
        modelProperties: {
            mtls: {
                serializedName: "mtls",
                type: {
                    name: "Composite",
                    className: "Mtls"
                }
            }
        }
    }
};
const Mtls = {
    type: {
        name: "Composite",
        className: "Mtls",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AvailableOperations = {
    type: {
        name: "Composite",
        className: "AvailableOperations",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationDetail"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDetail = {
    type: {
        name: "Composite",
        className: "OperationDetail",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsCollection = {
    type: {
        name: "Composite",
        className: "JobsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Job"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobConfiguration = {
    type: {
        name: "Composite",
        className: "JobConfiguration",
        modelProperties: {
            secrets: {
                serializedName: "secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            triggerType: {
                defaultValue: "Manual",
                serializedName: "triggerType",
                required: true,
                type: {
                    name: "String"
                }
            },
            replicaTimeout: {
                serializedName: "replicaTimeout",
                required: true,
                type: {
                    name: "Number"
                }
            },
            replicaRetryLimit: {
                serializedName: "replicaRetryLimit",
                type: {
                    name: "Number"
                }
            },
            manualTriggerConfig: {
                serializedName: "manualTriggerConfig",
                type: {
                    name: "Composite",
                    className: "JobConfigurationManualTriggerConfig"
                }
            },
            scheduleTriggerConfig: {
                serializedName: "scheduleTriggerConfig",
                type: {
                    name: "Composite",
                    className: "JobConfigurationScheduleTriggerConfig"
                }
            },
            eventTriggerConfig: {
                serializedName: "eventTriggerConfig",
                type: {
                    name: "Composite",
                    className: "JobConfigurationEventTriggerConfig"
                }
            },
            registries: {
                serializedName: "registries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegistryCredentials"
                        }
                    }
                }
            }
        }
    }
};
const JobConfigurationManualTriggerConfig = {
    type: {
        name: "Composite",
        className: "JobConfigurationManualTriggerConfig",
        modelProperties: {
            replicaCompletionCount: {
                serializedName: "replicaCompletionCount",
                type: {
                    name: "Number"
                }
            },
            parallelism: {
                serializedName: "parallelism",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobConfigurationScheduleTriggerConfig = {
    type: {
        name: "Composite",
        className: "JobConfigurationScheduleTriggerConfig",
        modelProperties: {
            replicaCompletionCount: {
                serializedName: "replicaCompletionCount",
                type: {
                    name: "Number"
                }
            },
            cronExpression: {
                serializedName: "cronExpression",
                required: true,
                type: {
                    name: "String"
                }
            },
            parallelism: {
                serializedName: "parallelism",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobConfigurationEventTriggerConfig = {
    type: {
        name: "Composite",
        className: "JobConfigurationEventTriggerConfig",
        modelProperties: {
            replicaCompletionCount: {
                serializedName: "replicaCompletionCount",
                type: {
                    name: "Number"
                }
            },
            parallelism: {
                serializedName: "parallelism",
                type: {
                    name: "Number"
                }
            },
            scale: {
                serializedName: "scale",
                type: {
                    name: "Composite",
                    className: "JobScale"
                }
            }
        }
    }
};
const JobScale = {
    type: {
        name: "Composite",
        className: "JobScale",
        modelProperties: {
            pollingInterval: {
                serializedName: "pollingInterval",
                type: {
                    name: "Number"
                }
            },
            minExecutions: {
                defaultValue: 0,
                serializedName: "minExecutions",
                type: {
                    name: "Number"
                }
            },
            maxExecutions: {
                defaultValue: 100,
                serializedName: "maxExecutions",
                type: {
                    name: "Number"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobScaleRule"
                        }
                    }
                }
            }
        }
    }
};
const JobScaleRule = {
    type: {
        name: "Composite",
        className: "JobScaleRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            metadata: {
                serializedName: "metadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            auth: {
                serializedName: "auth",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScaleRuleAuth"
                        }
                    }
                }
            }
        }
    }
};
const JobTemplate = {
    type: {
        name: "Composite",
        className: "JobTemplate",
        modelProperties: {
            initContainers: {
                serializedName: "initContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InitContainer"
                        }
                    }
                }
            },
            containers: {
                serializedName: "containers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Container"
                        }
                    }
                }
            },
            volumes: {
                serializedName: "volumes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Volume"
                        }
                    }
                }
            }
        }
    }
};
const JobPatchProperties = {
    type: {
        name: "Composite",
        className: "JobPatchProperties",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "JobPatchPropertiesProperties"
                }
            }
        }
    }
};
const JobPatchPropertiesProperties = {
    type: {
        name: "Composite",
        className: "JobPatchPropertiesProperties",
        modelProperties: {
            environmentId: {
                serializedName: "environmentId",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "JobConfiguration"
                }
            },
            template: {
                serializedName: "template",
                type: {
                    name: "Composite",
                    className: "JobTemplate"
                }
            },
            outboundIpAddresses: {
                serializedName: "outboundIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            eventStreamEndpoint: {
                serializedName: "eventStreamEndpoint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExecutionTemplate = {
    type: {
        name: "Composite",
        className: "JobExecutionTemplate",
        modelProperties: {
            containers: {
                serializedName: "containers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobExecutionContainer"
                        }
                    }
                }
            },
            initContainers: {
                serializedName: "initContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobExecutionContainer"
                        }
                    }
                }
            }
        }
    }
};
const JobExecutionContainer = {
    type: {
        name: "Composite",
        className: "JobExecutionContainer",
        modelProperties: {
            image: {
                serializedName: "image",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            command: {
                serializedName: "command",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            args: {
                serializedName: "args",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            env: {
                serializedName: "env",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVar"
                        }
                    }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "ContainerResources"
                }
            }
        }
    }
};
const JobExecutionBase = {
    type: {
        name: "Composite",
        className: "JobExecutionBase",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppJobExecutions = {
    type: {
        name: "Composite",
        className: "ContainerAppJobExecutions",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobExecution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExecution = {
    type: {
        name: "Composite",
        className: "JobExecution",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            template: {
                serializedName: "template",
                type: {
                    name: "Composite",
                    className: "JobExecutionTemplate"
                }
            }
        }
    }
};
const JobSecretsCollection = {
    type: {
        name: "Composite",
        className: "JobSecretsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            }
        }
    }
};
const ManagedEnvironmentsCollection = {
    type: {
        name: "Composite",
        className: "ManagedEnvironmentsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedEnvironment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedCertificateProperties = {
    type: {
        name: "Composite",
        className: "ManagedCertificateProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subjectName: {
                serializedName: "subjectName",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            domainControlValidation: {
                serializedName: "domainControlValidation",
                type: {
                    name: "String"
                }
            },
            validationToken: {
                serializedName: "validationToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedCertificatePatch = {
    type: {
        name: "Composite",
        className: "ManagedCertificatePatch",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ManagedCertificateCollection = {
    type: {
        name: "Composite",
        className: "ManagedCertificateCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedCertificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadProfileStatesCollection = {
    type: {
        name: "Composite",
        className: "WorkloadProfileStatesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadProfileStates"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadProfileStatesProperties = {
    type: {
        name: "Composite",
        className: "WorkloadProfileStatesProperties",
        modelProperties: {
            minimumCount: {
                serializedName: "minimumCount",
                type: {
                    name: "Number"
                }
            },
            maximumCount: {
                serializedName: "maximumCount",
                type: {
                    name: "Number"
                }
            },
            currentCount: {
                serializedName: "currentCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagedEnvironmentStoragesCollection = {
    type: {
        name: "Composite",
        className: "ManagedEnvironmentStoragesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedEnvironmentStorage"
                        }
                    }
                }
            }
        }
    }
};
const ManagedEnvironmentStorageProperties = {
    type: {
        name: "Composite",
        className: "ManagedEnvironmentStorageProperties",
        modelProperties: {
            azureFile: {
                serializedName: "azureFile",
                type: {
                    name: "Composite",
                    className: "AzureFileProperties"
                }
            }
        }
    }
};
const SourceControlCollection = {
    type: {
        name: "Composite",
        className: "SourceControlCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceControl"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GithubActionConfiguration = {
    type: {
        name: "Composite",
        className: "GithubActionConfiguration",
        modelProperties: {
            registryInfo: {
                serializedName: "registryInfo",
                type: {
                    name: "Composite",
                    className: "RegistryInfo"
                }
            },
            azureCredentials: {
                serializedName: "azureCredentials",
                type: {
                    name: "Composite",
                    className: "AzureCredentials"
                }
            },
            contextPath: {
                serializedName: "contextPath",
                type: {
                    name: "String"
                }
            },
            githubPersonalAccessToken: {
                serializedName: "githubPersonalAccessToken",
                type: {
                    name: "String"
                }
            },
            image: {
                serializedName: "image",
                type: {
                    name: "String"
                }
            },
            publishType: {
                serializedName: "publishType",
                type: {
                    name: "String"
                }
            },
            os: {
                serializedName: "os",
                type: {
                    name: "String"
                }
            },
            runtimeStack: {
                serializedName: "runtimeStack",
                type: {
                    name: "String"
                }
            },
            runtimeVersion: {
                serializedName: "runtimeVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RegistryInfo = {
    type: {
        name: "Composite",
        className: "RegistryInfo",
        modelProperties: {
            registryUrl: {
                serializedName: "registryUrl",
                type: {
                    name: "String"
                }
            },
            registryUserName: {
                serializedName: "registryUserName",
                type: {
                    name: "String"
                }
            },
            registryPassword: {
                serializedName: "registryPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureCredentials = {
    type: {
        name: "Composite",
        className: "AzureCredentials",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            },
            clientSecret: {
                serializedName: "clientSecret",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobExecutionNamesCollection = {
    type: {
        name: "Composite",
        className: "JobExecutionNamesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobExecutionBase"
                        }
                    }
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InitContainer = {
    type: {
        name: "Composite",
        className: "InitContainer",
        modelProperties: Object.assign({}, BaseContainer.type.modelProperties)
    }
};
const Container = {
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: Object.assign(Object.assign({}, BaseContainer.type.modelProperties), { probes: {
                serializedName: "probes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerAppProbe"
                        }
                    }
                }
            } })
    }
};
const AuthConfig = {
    type: {
        name: "Composite",
        className: "AuthConfig",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { platform: {
                serializedName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "AuthPlatform"
                }
            }, globalValidation: {
                serializedName: "properties.globalValidation",
                type: {
                    name: "Composite",
                    className: "GlobalValidation"
                }
            }, identityProviders: {
                serializedName: "properties.identityProviders",
                type: {
                    name: "Composite",
                    className: "IdentityProviders"
                }
            }, login: {
                serializedName: "properties.login",
                type: {
                    name: "Composite",
                    className: "Login"
                }
            }, httpSettings: {
                serializedName: "properties.httpSettings",
                type: {
                    name: "Composite",
                    className: "HttpSettings"
                }
            } })
    }
};
const AvailableWorkloadProfile = {
    type: {
        name: "Composite",
        className: "AvailableWorkloadProfile",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AvailableWorkloadProfileProperties"
                }
            } })
    }
};
const BillingMeter = {
    type: {
        name: "Composite",
        className: "BillingMeter",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BillingMeterProperties"
                }
            } })
    }
};
const DaprComponent = {
    type: {
        name: "Composite",
        className: "DaprComponent",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { componentType: {
                serializedName: "properties.componentType",
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            }, ignoreErrors: {
                defaultValue: false,
                serializedName: "properties.ignoreErrors",
                type: {
                    name: "Boolean"
                }
            }, initTimeout: {
                serializedName: "properties.initTimeout",
                type: {
                    name: "String"
                }
            }, secrets: {
                serializedName: "properties.secrets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            }, secretStoreComponent: {
                serializedName: "properties.secretStoreComponent",
                type: {
                    name: "String"
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DaprMetadata"
                        }
                    }
                }
            }, scopes: {
                serializedName: "properties.scopes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ConnectedEnvironmentStorage = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironmentStorage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ConnectedEnvironmentStorageProperties"
                }
            } })
    }
};
const Revision = {
    type: {
        name: "Composite",
        className: "Revision",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastActiveTime: {
                serializedName: "properties.lastActiveTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, template: {
                serializedName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template"
                }
            }, active: {
                serializedName: "properties.active",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, replicas: {
                serializedName: "properties.replicas",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, trafficWeight: {
                serializedName: "properties.trafficWeight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, provisioningError: {
                serializedName: "properties.provisioningError",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, healthState: {
                serializedName: "properties.healthState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, runningState: {
                serializedName: "properties.runningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Replica = {
    type: {
        name: "Composite",
        className: "Replica",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { createdTime: {
                serializedName: "properties.createdTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, runningState: {
                serializedName: "properties.runningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, runningStateDetails: {
                serializedName: "properties.runningStateDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containers: {
                serializedName: "properties.containers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReplicaContainer"
                        }
                    }
                }
            }, initContainers: {
                serializedName: "properties.initContainers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReplicaContainer"
                        }
                    }
                }
            } })
    }
};
const Diagnostics = {
    type: {
        name: "Composite",
        className: "Diagnostics",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DiagnosticsProperties"
                }
            } })
    }
};
const WorkloadProfileStates = {
    type: {
        name: "Composite",
        className: "WorkloadProfileStates",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "WorkloadProfileStatesProperties"
                }
            } })
    }
};
const ManagedEnvironmentStorage = {
    type: {
        name: "Composite",
        className: "ManagedEnvironmentStorage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedEnvironmentStorageProperties"
                }
            } })
    }
};
const SourceControl = {
    type: {
        name: "Composite",
        className: "SourceControl",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { operationState: {
                serializedName: "properties.operationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, repoUrl: {
                serializedName: "properties.repoUrl",
                type: {
                    name: "String"
                }
            }, branch: {
                serializedName: "properties.branch",
                type: {
                    name: "String"
                }
            }, githubActionConfiguration: {
                serializedName: "properties.githubActionConfiguration",
                type: {
                    name: "Composite",
                    className: "GithubActionConfiguration"
                }
            } })
    }
};
const ConnectedEnvironment = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironment",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, staticIp: {
                serializedName: "properties.staticIp",
                type: {
                    name: "String"
                }
            }, daprAIConnectionString: {
                serializedName: "properties.daprAIConnectionString",
                type: {
                    name: "String"
                }
            }, customDomainConfiguration: {
                serializedName: "properties.customDomainConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDomainConfiguration"
                }
            } })
    }
};
const Certificate = {
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CertificateProperties"
                }
            } })
    }
};
const ContainerApp = {
    type: {
        name: "Composite",
        className: "ContainerApp",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, managedBy: {
                serializedName: "managedBy",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedEnvironmentId: {
                serializedName: "properties.managedEnvironmentId",
                type: {
                    name: "String"
                }
            }, environmentId: {
                serializedName: "properties.environmentId",
                type: {
                    name: "String"
                }
            }, workloadProfileName: {
                serializedName: "properties.workloadProfileName",
                type: {
                    name: "String"
                }
            }, latestRevisionName: {
                serializedName: "properties.latestRevisionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, latestReadyRevisionName: {
                serializedName: "properties.latestReadyRevisionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, latestRevisionFqdn: {
                serializedName: "properties.latestRevisionFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customDomainVerificationId: {
                serializedName: "properties.customDomainVerificationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, configuration: {
                serializedName: "properties.configuration",
                type: {
                    name: "Composite",
                    className: "Configuration"
                }
            }, template: {
                serializedName: "properties.template",
                type: {
                    name: "Composite",
                    className: "Template"
                }
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, eventStreamEndpoint: {
                serializedName: "properties.eventStreamEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ContainerAppAuthToken = {
    type: {
        name: "Composite",
        className: "ContainerAppAuthToken",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { token: {
                serializedName: "properties.token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expires: {
                serializedName: "properties.expires",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const ManagedEnvironment = {
    type: {
        name: "Composite",
        className: "ManagedEnvironment",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, daprAIInstrumentationKey: {
                serializedName: "properties.daprAIInstrumentationKey",
                type: {
                    name: "String"
                }
            }, daprAIConnectionString: {
                serializedName: "properties.daprAIConnectionString",
                type: {
                    name: "String"
                }
            }, vnetConfiguration: {
                serializedName: "properties.vnetConfiguration",
                type: {
                    name: "Composite",
                    className: "VnetConfiguration"
                }
            }, deploymentErrors: {
                serializedName: "properties.deploymentErrors",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultDomain: {
                serializedName: "properties.defaultDomain",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, staticIp: {
                serializedName: "properties.staticIp",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, appLogsConfiguration: {
                serializedName: "properties.appLogsConfiguration",
                type: {
                    name: "Composite",
                    className: "AppLogsConfiguration"
                }
            }, zoneRedundant: {
                serializedName: "properties.zoneRedundant",
                type: {
                    name: "Boolean"
                }
            }, customDomainConfiguration: {
                serializedName: "properties.customDomainConfiguration",
                type: {
                    name: "Composite",
                    className: "CustomDomainConfiguration"
                }
            }, eventStreamEndpoint: {
                serializedName: "properties.eventStreamEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workloadProfiles: {
                serializedName: "properties.workloadProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadProfile"
                        }
                    }
                }
            }, kedaConfiguration: {
                serializedName: "properties.kedaConfiguration",
                type: {
                    name: "Composite",
                    className: "KedaConfiguration"
                }
            }, daprConfiguration: {
                serializedName: "properties.daprConfiguration",
                type: {
                    name: "Composite",
                    className: "DaprConfiguration"
                }
            }, infrastructureResourceGroup: {
                serializedName: "properties.infrastructureResourceGroup",
                type: {
                    name: "String"
                }
            }, peerAuthentication: {
                serializedName: "properties.peerAuthentication",
                type: {
                    name: "Composite",
                    className: "ManagedEnvironmentPropertiesPeerAuthentication"
                }
            } })
    }
};
const Job = {
    type: {
        name: "Composite",
        className: "Job",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, environmentId: {
                serializedName: "properties.environmentId",
                type: {
                    name: "String"
                }
            }, workloadProfileName: {
                serializedName: "properties.workloadProfileName",
                type: {
                    name: "String"
                }
            }, configuration: {
                serializedName: "properties.configuration",
                type: {
                    name: "Composite",
                    className: "JobConfiguration"
                }
            }, template: {
                serializedName: "properties.template",
                type: {
                    name: "Composite",
                    className: "JobTemplate"
                }
            }, outboundIpAddresses: {
                serializedName: "properties.outboundIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, eventStreamEndpoint: {
                serializedName: "properties.eventStreamEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagedCertificate = {
    type: {
        name: "Composite",
        className: "ManagedCertificate",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ManagedCertificateProperties"
                }
            } })
    }
};
const EnvironmentAuthToken = {
    type: {
        name: "Composite",
        className: "EnvironmentAuthToken",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { token: {
                serializedName: "properties.token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expires: {
                serializedName: "properties.expires",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const ConnectedEnvironmentsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ConnectedEnvironmentsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ContainerAppsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "ContainerAppsUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppsStartHeaders = {
    type: {
        name: "Composite",
        className: "ContainerAppsStartHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerAppsStopHeaders = {
    type: {
        name: "Composite",
        className: "ContainerAppsStopHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "JobsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "JobsUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsStartHeaders = {
    type: {
        name: "Composite",
        className: "JobsStartHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsStopExecutionHeaders = {
    type: {
        name: "Composite",
        className: "JobsStopExecutionHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsStopMultipleExecutionsHeaders = {
    type: {
        name: "Composite",
        className: "JobsStopMultipleExecutionsHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AuthConfigCollection: AuthConfigCollection,
    AuthPlatform: AuthPlatform,
    GlobalValidation: GlobalValidation,
    IdentityProviders: IdentityProviders,
    AzureActiveDirectory: AzureActiveDirectory,
    AzureActiveDirectoryRegistration: AzureActiveDirectoryRegistration,
    AzureActiveDirectoryLogin: AzureActiveDirectoryLogin,
    AzureActiveDirectoryValidation: AzureActiveDirectoryValidation,
    JwtClaimChecks: JwtClaimChecks,
    DefaultAuthorizationPolicy: DefaultAuthorizationPolicy,
    AllowedPrincipals: AllowedPrincipals,
    Facebook: Facebook,
    AppRegistration: AppRegistration,
    LoginScopes: LoginScopes,
    GitHub: GitHub,
    ClientRegistration: ClientRegistration,
    Google: Google,
    AllowedAudiencesValidation: AllowedAudiencesValidation,
    Twitter: Twitter,
    TwitterRegistration: TwitterRegistration,
    Apple: Apple,
    AppleRegistration: AppleRegistration,
    AzureStaticWebApps: AzureStaticWebApps,
    AzureStaticWebAppsRegistration: AzureStaticWebAppsRegistration,
    CustomOpenIdConnectProvider: CustomOpenIdConnectProvider,
    OpenIdConnectRegistration: OpenIdConnectRegistration,
    OpenIdConnectClientCredential: OpenIdConnectClientCredential,
    OpenIdConnectConfig: OpenIdConnectConfig,
    OpenIdConnectLogin: OpenIdConnectLogin,
    Login: Login,
    LoginRoutes: LoginRoutes,
    CookieExpiration: CookieExpiration,
    Nonce: Nonce,
    HttpSettings: HttpSettings,
    HttpSettingsRoutes: HttpSettingsRoutes,
    ForwardProxy: ForwardProxy,
    Resource: Resource,
    SystemData: SystemData,
    DefaultErrorResponse: DefaultErrorResponse,
    DefaultErrorResponseError: DefaultErrorResponseError,
    DefaultErrorResponseErrorDetailsItem: DefaultErrorResponseErrorDetailsItem,
    AvailableWorkloadProfilesCollection: AvailableWorkloadProfilesCollection,
    AvailableWorkloadProfileProperties: AvailableWorkloadProfileProperties,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    BillingMeterCollection: BillingMeterCollection,
    BillingMeterProperties: BillingMeterProperties,
    ConnectedEnvironmentCollection: ConnectedEnvironmentCollection,
    ExtendedLocation: ExtendedLocation,
    CustomDomainConfiguration: CustomDomainConfiguration,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResponse: CheckNameAvailabilityResponse,
    CertificateCollection: CertificateCollection,
    CertificateProperties: CertificateProperties,
    CertificatePatch: CertificatePatch,
    DaprComponentsCollection: DaprComponentsCollection,
    Secret: Secret,
    DaprMetadata: DaprMetadata,
    DaprSecretsCollection: DaprSecretsCollection,
    DaprSecret: DaprSecret,
    ConnectedEnvironmentStoragesCollection: ConnectedEnvironmentStoragesCollection,
    ConnectedEnvironmentStorageProperties: ConnectedEnvironmentStorageProperties,
    AzureFileProperties: AzureFileProperties,
    ContainerAppCollection: ContainerAppCollection,
    ManagedServiceIdentity: ManagedServiceIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    Configuration: Configuration,
    Ingress: Ingress,
    TrafficWeight: TrafficWeight,
    CustomDomain: CustomDomain,
    IpSecurityRestrictionRule: IpSecurityRestrictionRule,
    IngressStickySessions: IngressStickySessions,
    CorsPolicy: CorsPolicy,
    RegistryCredentials: RegistryCredentials,
    Dapr: Dapr,
    Service: Service,
    Template: Template,
    BaseContainer: BaseContainer,
    EnvironmentVar: EnvironmentVar,
    ContainerResources: ContainerResources,
    VolumeMount: VolumeMount,
    ContainerAppProbe: ContainerAppProbe,
    ContainerAppProbeHttpGet: ContainerAppProbeHttpGet,
    ContainerAppProbeHttpGetHttpHeadersItem: ContainerAppProbeHttpGetHttpHeadersItem,
    ContainerAppProbeTcpSocket: ContainerAppProbeTcpSocket,
    Scale: Scale,
    ScaleRule: ScaleRule,
    QueueScaleRule: QueueScaleRule,
    ScaleRuleAuth: ScaleRuleAuth,
    CustomScaleRule: CustomScaleRule,
    HttpScaleRule: HttpScaleRule,
    TcpScaleRule: TcpScaleRule,
    Volume: Volume,
    SecretVolumeItem: SecretVolumeItem,
    ServiceBind: ServiceBind,
    CustomHostnameAnalysisResult: CustomHostnameAnalysisResult,
    CustomHostnameAnalysisResultCustomDomainVerificationFailureInfo: CustomHostnameAnalysisResultCustomDomainVerificationFailureInfo,
    CustomHostnameAnalysisResultCustomDomainVerificationFailureInfoDetailsItem: CustomHostnameAnalysisResultCustomDomainVerificationFailureInfoDetailsItem,
    SecretsCollection: SecretsCollection,
    ContainerAppSecret: ContainerAppSecret,
    RevisionCollection: RevisionCollection,
    ReplicaContainer: ReplicaContainer,
    ReplicaCollection: ReplicaCollection,
    DiagnosticsCollection: DiagnosticsCollection,
    DiagnosticsProperties: DiagnosticsProperties,
    DiagnosticsDefinition: DiagnosticsDefinition,
    DiagnosticSupportTopic: DiagnosticSupportTopic,
    DiagnosticsDataApiResponse: DiagnosticsDataApiResponse,
    DiagnosticDataTableResponseObject: DiagnosticDataTableResponseObject,
    DiagnosticDataTableResponseColumn: DiagnosticDataTableResponseColumn,
    DiagnosticRendering: DiagnosticRendering,
    DiagnosticsStatus: DiagnosticsStatus,
    DiagnosticDataProviderMetadata: DiagnosticDataProviderMetadata,
    DiagnosticDataProviderMetadataPropertyBagItem: DiagnosticDataProviderMetadataPropertyBagItem,
    VnetConfiguration: VnetConfiguration,
    AppLogsConfiguration: AppLogsConfiguration,
    LogAnalyticsConfiguration: LogAnalyticsConfiguration,
    WorkloadProfile: WorkloadProfile,
    KedaConfiguration: KedaConfiguration,
    DaprConfiguration: DaprConfiguration,
    ManagedEnvironmentPropertiesPeerAuthentication: ManagedEnvironmentPropertiesPeerAuthentication,
    Mtls: Mtls,
    AvailableOperations: AvailableOperations,
    OperationDetail: OperationDetail,
    OperationDisplay: OperationDisplay,
    JobsCollection: JobsCollection,
    JobConfiguration: JobConfiguration,
    JobConfigurationManualTriggerConfig: JobConfigurationManualTriggerConfig,
    JobConfigurationScheduleTriggerConfig: JobConfigurationScheduleTriggerConfig,
    JobConfigurationEventTriggerConfig: JobConfigurationEventTriggerConfig,
    JobScale: JobScale,
    JobScaleRule: JobScaleRule,
    JobTemplate: JobTemplate,
    JobPatchProperties: JobPatchProperties,
    JobPatchPropertiesProperties: JobPatchPropertiesProperties,
    JobExecutionTemplate: JobExecutionTemplate,
    JobExecutionContainer: JobExecutionContainer,
    JobExecutionBase: JobExecutionBase,
    ContainerAppJobExecutions: ContainerAppJobExecutions,
    JobExecution: JobExecution,
    JobSecretsCollection: JobSecretsCollection,
    ManagedEnvironmentsCollection: ManagedEnvironmentsCollection,
    ManagedCertificateProperties: ManagedCertificateProperties,
    ManagedCertificatePatch: ManagedCertificatePatch,
    ManagedCertificateCollection: ManagedCertificateCollection,
    WorkloadProfileStatesCollection: WorkloadProfileStatesCollection,
    WorkloadProfileStatesProperties: WorkloadProfileStatesProperties,
    ManagedEnvironmentStoragesCollection: ManagedEnvironmentStoragesCollection,
    ManagedEnvironmentStorageProperties: ManagedEnvironmentStorageProperties,
    SourceControlCollection: SourceControlCollection,
    GithubActionConfiguration: GithubActionConfiguration,
    RegistryInfo: RegistryInfo,
    AzureCredentials: AzureCredentials,
    JobExecutionNamesCollection: JobExecutionNamesCollection,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    InitContainer: InitContainer,
    Container: Container,
    AuthConfig: AuthConfig,
    AvailableWorkloadProfile: AvailableWorkloadProfile,
    BillingMeter: BillingMeter,
    DaprComponent: DaprComponent,
    ConnectedEnvironmentStorage: ConnectedEnvironmentStorage,
    Revision: Revision,
    Replica: Replica,
    Diagnostics: Diagnostics,
    WorkloadProfileStates: WorkloadProfileStates,
    ManagedEnvironmentStorage: ManagedEnvironmentStorage,
    SourceControl: SourceControl,
    ConnectedEnvironment: ConnectedEnvironment,
    Certificate: Certificate,
    ContainerApp: ContainerApp,
    ContainerAppAuthToken: ContainerAppAuthToken,
    ManagedEnvironment: ManagedEnvironment,
    Job: Job,
    ManagedCertificate: ManagedCertificate,
    EnvironmentAuthToken: EnvironmentAuthToken,
    ConnectedEnvironmentsDeleteHeaders: ConnectedEnvironmentsDeleteHeaders,
    ContainerAppsDeleteHeaders: ContainerAppsDeleteHeaders,
    ContainerAppsUpdateHeaders: ContainerAppsUpdateHeaders,
    ContainerAppsStartHeaders: ContainerAppsStartHeaders,
    ContainerAppsStopHeaders: ContainerAppsStopHeaders,
    JobsDeleteHeaders: JobsDeleteHeaders,
    JobsUpdateHeaders: JobsUpdateHeaders,
    JobsStartHeaders: JobsStartHeaders,
    JobsStopExecutionHeaders: JobsStopExecutionHeaders,
    JobsStopMultipleExecutionsHeaders: JobsStopMultipleExecutionsHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const containerAppName = {
    parameterPath: "containerAppName",
    mapper: {
        serializedName: "containerAppName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const authConfigName = {
    parameterPath: "authConfigName",
    mapper: {
        serializedName: "authConfigName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const authConfigEnvelope = {
    parameterPath: "authConfigEnvelope",
    mapper: AuthConfig
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectedEnvironmentName = {
    parameterPath: "connectedEnvironmentName",
    mapper: {
        serializedName: "connectedEnvironmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const environmentEnvelope = {
    parameterPath: "environmentEnvelope",
    mapper: ConnectedEnvironment
};
const checkNameAvailabilityRequest = {
    parameterPath: "checkNameAvailabilityRequest",
    mapper: CheckNameAvailabilityRequest
};
const certificateName = {
    parameterPath: "certificateName",
    mapper: {
        serializedName: "certificateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const certificateEnvelope = {
    parameterPath: ["options", "certificateEnvelope"],
    mapper: Certificate
};
const certificateEnvelope1 = {
    parameterPath: "certificateEnvelope",
    mapper: CertificatePatch
};
const componentName = {
    parameterPath: "componentName",
    mapper: {
        serializedName: "componentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const daprComponentEnvelope = {
    parameterPath: "daprComponentEnvelope",
    mapper: DaprComponent
};
const storageName = {
    parameterPath: "storageName",
    mapper: {
        serializedName: "storageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const storageEnvelope = {
    parameterPath: "storageEnvelope",
    mapper: ConnectedEnvironmentStorage
};
const containerAppEnvelope = {
    parameterPath: "containerAppEnvelope",
    mapper: ContainerApp
};
const customHostname = {
    parameterPath: ["options", "customHostname"],
    mapper: {
        serializedName: "customHostname",
        type: {
            name: "String"
        }
    }
};
const containerAppName1 = {
    parameterPath: "containerAppName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$")
        },
        serializedName: "containerAppName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const revisionName = {
    parameterPath: "revisionName",
    mapper: {
        serializedName: "revisionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const replicaName = {
    parameterPath: "replicaName",
    mapper: {
        serializedName: "replicaName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const detectorName = {
    parameterPath: "detectorName",
    mapper: {
        serializedName: "detectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const environmentName = {
    parameterPath: "environmentName",
    mapper: {
        serializedName: "environmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobName = {
    parameterPath: "jobName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$")
        },
        serializedName: "jobName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const jobEnvelope = {
    parameterPath: "jobEnvelope",
    mapper: Job
};
const jobEnvelope1 = {
    parameterPath: "jobEnvelope",
    mapper: JobPatchProperties
};
const template = {
    parameterPath: ["options", "template"],
    mapper: JobExecutionTemplate
};
const jobExecutionName = {
    parameterPath: "jobExecutionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$")
        },
        serializedName: "jobExecutionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const environmentEnvelope1 = {
    parameterPath: "environmentEnvelope",
    mapper: ManagedEnvironment
};
const managedCertificateName = {
    parameterPath: "managedCertificateName",
    mapper: {
        serializedName: "managedCertificateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const managedCertificateEnvelope = {
    parameterPath: ["options", "managedCertificateEnvelope"],
    mapper: ManagedCertificate
};
const managedCertificateEnvelope1 = {
    parameterPath: "managedCertificateEnvelope",
    mapper: ManagedCertificatePatch
};
const storageEnvelope1 = {
    parameterPath: "storageEnvelope",
    mapper: ManagedEnvironmentStorage
};
const sourceControlName = {
    parameterPath: "sourceControlName",
    mapper: {
        serializedName: "sourceControlName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sourceControlEnvelope = {
    parameterPath: "sourceControlEnvelope",
    mapper: SourceControl
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsAuthConfigs operations. */
class ContainerAppsAuthConfigsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsAuthConfigs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container App AuthConfigs in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    listByContainerApp(resourceGroupName, containerAppName, options) {
        const iter = this.listByContainerAppPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByContainerAppPagingPage(resourceGroupName, containerAppName, options, settings);
            }
        };
    }
    listByContainerAppPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByContainerAppPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByContainerApp(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByContainerAppNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByContainerAppPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByContainerAppPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByContainerAppPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container App AuthConfigs in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    _listByContainerApp(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listByContainerAppOperationSpec$1);
    }
    /**
     * Get a AuthConfig of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param authConfigName Name of the Container App AuthConfig.
     * @param options The options parameters.
     */
    get(resourceGroupName, containerAppName, authConfigName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, authConfigName, options }, getOperationSpec$e);
    }
    /**
     * Create or update the AuthConfig for a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param authConfigName Name of the Container App AuthConfig.
     * @param authConfigEnvelope Properties used to create a Container App AuthConfig
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, containerAppName, authConfigName, authConfigEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            containerAppName,
            authConfigName,
            authConfigEnvelope,
            options
        }, createOrUpdateOperationSpec$c);
    }
    /**
     * Delete a Container App AuthConfig.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param authConfigName Name of the Container App AuthConfig.
     * @param options The options parameters.
     */
    delete(resourceGroupName, containerAppName, authConfigName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, authConfigName, options }, deleteOperationSpec$c);
    }
    /**
     * ListByContainerAppNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param nextLink The nextLink from the previous successful call to the ListByContainerApp method.
     * @param options The options parameters.
     */
    _listByContainerAppNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listByContainerAppNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByContainerAppOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthConfigCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        authConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AuthConfig
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: authConfigEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        authConfigName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/authConfigs/{authConfigName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        authConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByContainerAppNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthConfigCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableWorkloadProfiles operations. */
class AvailableWorkloadProfilesImpl {
    /**
     * Initialize a new instance of the class AvailableWorkloadProfiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all available workload profiles for a location.
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.getPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPagingPage(location, options, settings);
            }
        };
    }
    getPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._get(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.getPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all available workload profiles for a location.
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    _get(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOperationSpec$d);
    }
    /**
     * GetNext
     * @param location The name of Azure region.
     * @param nextLink The nextLink from the previous successful call to the Get method.
     * @param options The options parameters.
     */
    _getNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getNextOperationSpec);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/locations/{location}/availableManagedEnvironmentsWorkloadProfileTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableWorkloadProfilesCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const getNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableWorkloadProfilesCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing BillingMeters operations. */
class BillingMetersImpl {
    /**
     * Initialize a new instance of the class BillingMeters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all billingMeters for a location.
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    get(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOperationSpec$c);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/locations/{location}/billingMeters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingMeterCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectedEnvironments operations. */
class ConnectedEnvironmentsImpl {
    /**
     * Initialize a new instance of the class ConnectedEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all connectedEnvironments for a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all connectedEnvironments in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all connectedEnvironments for a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * Get all connectedEnvironments in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Get the properties of an connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param options The options parameters.
     */
    get(resourceGroupName, connectedEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, options }, getOperationSpec$b);
    }
    /**
     * Creates or updates an connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param environmentEnvelope Configuration details of the connectedEnvironment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, connectedEnvironmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    connectedEnvironmentName,
                    environmentEnvelope,
                    options
                },
                spec: createOrUpdateOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param environmentEnvelope Configuration details of the connectedEnvironment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, connectedEnvironmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, connectedEnvironmentName, environmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, connectedEnvironmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, connectedEnvironmentName, options },
                spec: deleteOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, connectedEnvironmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, connectedEnvironmentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patches a Managed Environment. Only patching of tags is supported currently
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connectedEnvironment.
     * @param options The options parameters.
     */
    update(resourceGroupName, connectedEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, options }, updateOperationSpec$6);
    }
    /**
     * Checks if resource connectedEnvironmentName is available.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Managed Environment.
     * @param checkNameAvailabilityRequest The check connectedEnvironmentName availability request.
     * @param options The options parameters.
     */
    checkNameAvailability(resourceGroupName, connectedEnvironmentName, checkNameAvailabilityRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            connectedEnvironmentName,
            checkNameAvailabilityRequest,
            options
        }, checkNameAvailabilityOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/connectedEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironment
        },
        201: {
            bodyMapper: ConnectedEnvironment
        },
        202: {
            bodyMapper: ConnectedEnvironment
        },
        204: {
            bodyMapper: ConnectedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: environmentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const checkNameAvailabilityOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: checkNameAvailabilityRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectedEnvironmentsCertificates operations. */
class ConnectedEnvironmentsCertificatesImpl {
    /**
     * Initialize a new instance of the class ConnectedEnvironmentsCertificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Certificates in a given connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, connectedEnvironmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, connectedEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, connectedEnvironmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, connectedEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, connectedEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, connectedEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, connectedEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, connectedEnvironmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Certificates in a given connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, connectedEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, options }, listOperationSpec$8);
    }
    /**
     * Get the specified Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    get(resourceGroupName, connectedEnvironmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, certificateName, options }, getOperationSpec$a);
    }
    /**
     * Create or Update a Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, connectedEnvironmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, certificateName, options }, createOrUpdateOperationSpec$a);
    }
    /**
     * Deletes the specified Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    delete(resourceGroupName, connectedEnvironmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, certificateName, options }, deleteOperationSpec$a);
    }
    /**
     * Patches a certificate. Currently only patching of tags is supported
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param certificateName Name of the Certificate.
     * @param certificateEnvelope Properties of a certificate that need to be updated
     * @param options The options parameters.
     */
    update(resourceGroupName, connectedEnvironmentName, certificateName, certificateEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            connectedEnvironmentName,
            certificateName,
            certificateEnvelope,
            options
        }, updateOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Connected Environment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, connectedEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/certificates/{certificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/certificates/{certificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        certificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/certificates/{certificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/certificates/{certificateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        certificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectedEnvironmentsDaprComponents operations. */
class ConnectedEnvironmentsDaprComponentsImpl {
    /**
     * Initialize a new instance of the class ConnectedEnvironmentsDaprComponents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Dapr Components for a connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, connectedEnvironmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, connectedEnvironmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, connectedEnvironmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, connectedEnvironmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, connectedEnvironmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, connectedEnvironmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, connectedEnvironmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, connectedEnvironmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Dapr Components for a connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, connectedEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, options }, listOperationSpec$7);
    }
    /**
     * Get a dapr component.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    get(resourceGroupName, connectedEnvironmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, componentName, options }, getOperationSpec$9);
    }
    /**
     * Creates or updates a Dapr Component in a connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param componentName Name of the Dapr Component.
     * @param daprComponentEnvelope Configuration details of the Dapr Component.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, connectedEnvironmentName, componentName, daprComponentEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            connectedEnvironmentName,
            componentName,
            daprComponentEnvelope,
            options
        }, createOrUpdateOperationSpec$9);
    }
    /**
     * Delete a Dapr Component from a connected environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    delete(resourceGroupName, connectedEnvironmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, componentName, options }, deleteOperationSpec$9);
    }
    /**
     * List secrets for a dapr component
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, connectedEnvironmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, componentName, options }, listSecretsOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the connected environment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, connectedEnvironmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/daprComponents",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/daprComponents/{componentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponent
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        componentName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/daprComponents/{componentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DaprComponent
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: daprComponentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        componentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/daprComponents/{componentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        componentName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listSecretsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/daprComponents/{componentName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DaprSecretsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        componentName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ConnectedEnvironmentsStorages operations. */
class ConnectedEnvironmentsStoragesImpl {
    /**
     * Initialize a new instance of the class ConnectedEnvironmentsStorages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all storages for a connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, connectedEnvironmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, options }, listOperationSpec$6);
    }
    /**
     * Get storage for a connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param options The options parameters.
     */
    get(resourceGroupName, connectedEnvironmentName, storageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, storageName, options }, getOperationSpec$8);
    }
    /**
     * Create or update storage for a connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param storageEnvelope Configuration details of storage.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, connectedEnvironmentName, storageName, storageEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            connectedEnvironmentName,
            storageName,
            storageEnvelope,
            options
        }, createOrUpdateOperationSpec$8);
    }
    /**
     * Delete storage for a connectedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectedEnvironmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param options The options parameters.
     */
    delete(resourceGroupName, connectedEnvironmentName, storageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectedEnvironmentName, storageName, options }, deleteOperationSpec$8);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/storages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentStoragesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/storages/{storageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentStorage
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        storageName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/storages/{storageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectedEnvironmentStorage
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: storageEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        storageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/connectedEnvironments/{connectedEnvironmentName}/storages/{storageName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        connectedEnvironmentName,
        storageName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerApps operations. */
class ContainerAppsImpl {
    /**
     * Initialize a new instance of the class ContainerApps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the Container Apps in a given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Get the Container Apps in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Get the properties of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    get(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, getOperationSpec$7);
    }
    /**
     * Create or update a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param containerAppEnvelope Properties used to create a container app
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, containerAppName, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    containerAppName,
                    containerAppEnvelope,
                    options
                },
                spec: createOrUpdateOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param containerAppEnvelope Properties used to create a container app
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, containerAppName, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, containerAppName, containerAppEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, containerAppName, options },
                spec: deleteOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, containerAppName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patches a Container App using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param containerAppEnvelope Properties of a Container App that need to be updated
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, containerAppName, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    containerAppName,
                    containerAppEnvelope,
                    options
                },
                spec: updateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patches a Container App using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param containerAppEnvelope Properties of a Container App that need to be updated
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, containerAppName, containerAppEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, containerAppName, containerAppEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Analyzes a custom hostname for a Container App
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    listCustomHostNameAnalysis(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listCustomHostNameAnalysisOperationSpec);
    }
    /**
     * List secrets for a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listSecretsOperationSpec$2);
    }
    /**
     * Get auth token for a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    getAuthToken(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, getAuthTokenOperationSpec$1);
    }
    /**
     * Start a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, containerAppName, options },
                spec: startOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, containerAppName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, containerAppName, options },
                spec: stopOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stop a container app
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, containerAppName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, containerAppName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        201: {
            bodyMapper: ContainerApp
        },
        202: {
            bodyMapper: ContainerApp
        },
        204: {
            bodyMapper: ContainerApp
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: containerAppEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        201: {
            bodyMapper: ContainerApp
        },
        202: {
            bodyMapper: ContainerApp
        },
        204: {
            bodyMapper: ContainerApp
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: containerAppEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listCustomHostNameAnalysisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/listCustomHostNameAnalysis",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CustomHostnameAnalysisResult
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, customHostname],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listSecretsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SecretsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getAuthTokenOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/getAuthtoken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerAppAuthToken
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        201: {
            bodyMapper: ContainerApp
        },
        202: {
            bodyMapper: ContainerApp
        },
        204: {
            bodyMapper: ContainerApp
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName1
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/stop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        201: {
            bodyMapper: ContainerApp
        },
        202: {
            bodyMapper: ContainerApp
        },
        204: {
            bodyMapper: ContainerApp
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName1
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsRevisions operations. */
class ContainerAppsRevisionsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsRevisions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    listRevisions(resourceGroupName, containerAppName, options) {
        const iter = this.listRevisionsPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings);
            }
        };
    }
    listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRevisions(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRevisionsNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRevisionsPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRevisionsPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    _listRevisions(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listRevisionsOperationSpec$1);
    }
    /**
     * Get a revision of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    getRevision(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, getRevisionOperationSpec$1);
    }
    /**
     * Activates a revision for a Container App
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    activateRevision(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, activateRevisionOperationSpec);
    }
    /**
     * Deactivates a revision for a Container App
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    deactivateRevision(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, deactivateRevisionOperationSpec);
    }
    /**
     * Restarts a revision for a Container App
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    restartRevision(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, restartRevisionOperationSpec);
    }
    /**
     * ListRevisionsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param nextLink The nextLink from the previous successful call to the ListRevisions method.
     * @param options The options parameters.
     */
    _listRevisionsNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listRevisionsNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listRevisionsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getRevisionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Revision
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const activateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}/activate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const deactivateRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}/deactivate",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const restartRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listRevisionsNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ContainerAppsRevisionReplicas operations. */
class ContainerAppsRevisionReplicasImpl {
    /**
     * Initialize a new instance of the class ContainerAppsRevisionReplicas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a replica for a Container App Revision.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param replicaName Name of the Container App Revision Replica.
     * @param options The options parameters.
     */
    getReplica(resourceGroupName, containerAppName, revisionName, replicaName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            containerAppName,
            revisionName,
            replicaName,
            options
        }, getReplicaOperationSpec);
    }
    /**
     * List replicas for a Container App Revision.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    listReplicas(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, listReplicasOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getReplicaOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}/replicas/{replicaName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Replica
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName,
        replicaName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listReplicasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/revisions/{revisionName}/replicas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicaCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsDiagnostics operations. */
class ContainerAppsDiagnosticsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsDiagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of diagnostics for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which detector info is needed.
     * @param options The options parameters.
     */
    listDetectors(resourceGroupName, containerAppName, options) {
        const iter = this.listDetectorsPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDetectorsPagingPage(resourceGroupName, containerAppName, options, settings);
            }
        };
    }
    listDetectorsPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDetectorsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDetectors(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDetectorsNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDetectorsPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDetectorsPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDetectorsPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    listRevisions(resourceGroupName, containerAppName, options) {
        const iter = this.listRevisionsPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings);
            }
        };
    }
    listRevisionsPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listRevisions(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listRevisionsNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listRevisionsPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRevisionsPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the list of diagnostics for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which detector info is needed.
     * @param options The options parameters.
     */
    _listDetectors(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listDetectorsOperationSpec$1);
    }
    /**
     * Get a diagnostics result of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param detectorName Name of the Container App Detector.
     * @param options The options parameters.
     */
    getDetector(resourceGroupName, containerAppName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, detectorName, options }, getDetectorOperationSpec$1);
    }
    /**
     * Get the Revisions for a given Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param options The options parameters.
     */
    _listRevisions(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listRevisionsOperationSpec);
    }
    /**
     * Get a revision of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param revisionName Name of the Container App Revision.
     * @param options The options parameters.
     */
    getRevision(resourceGroupName, containerAppName, revisionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, revisionName, options }, getRevisionOperationSpec);
    }
    /**
     * Get the properties of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    getRoot(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, getRootOperationSpec$1);
    }
    /**
     * ListDetectorsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which detector info is needed.
     * @param nextLink The nextLink from the previous successful call to the ListDetectors method.
     * @param options The options parameters.
     */
    _listDetectorsNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listDetectorsNextOperationSpec);
    }
    /**
     * ListRevisionsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App for which Revisions are needed.
     * @param nextLink The nextLink from the previous successful call to the ListRevisions method.
     * @param options The options parameters.
     */
    _listRevisionsNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listRevisionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listDetectorsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getDetectorOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Diagnostics
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        detectorName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRevisionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/detectorProperties/revisionsApi/revisions/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getRevisionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/detectorProperties/revisionsApi/revisions/{revisionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Revision
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        revisionName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getRootOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/detectorProperties/rootApi/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerApp
        },
        404: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listDetectorsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listRevisionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RevisionCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedEnvironmentDiagnostics operations. */
class ManagedEnvironmentDiagnosticsImpl {
    /**
     * Initialize a new instance of the class ManagedEnvironmentDiagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of diagnostics for a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    listDetectors(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listDetectorsOperationSpec);
    }
    /**
     * Get the diagnostics data for a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param detectorName Name of the Managed Environment detector.
     * @param options The options parameters.
     */
    getDetector(resourceGroupName, environmentName, detectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, detectorName, options }, getDetectorOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listDetectorsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/detectors/{detectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Diagnostics
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        detectorName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedEnvironmentsDiagnostics operations. */
class ManagedEnvironmentsDiagnosticsImpl {
    /**
     * Initialize a new instance of the class ManagedEnvironmentsDiagnostics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the properties of a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    getRoot(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, getRootOperationSpec);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getRootOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/detectorProperties/rootApi/",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available RP operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available RP operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$5);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/providers/Microsoft.App/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableOperations
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableOperations
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Jobs operations. */
class JobsImpl {
    /**
     * Initialize a new instance of the class Jobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container Apps Jobs in a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container Apps Jobs in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the Container Apps Jobs in a given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Get the Container Apps Jobs in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Get the properties of a Container Apps Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    get(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, getOperationSpec$6);
    }
    /**
     * Create or Update a Container Apps Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobEnvelope Properties used to create a container apps job
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, jobName, jobEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, jobEnvelope, options },
                spec: createOrUpdateOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or Update a Container Apps Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobEnvelope Properties used to create a container apps job
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, jobName, jobEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, jobName, jobEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Container Apps Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, options },
                spec: deleteOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Container Apps Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patches a Container Apps Job using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobEnvelope Properties used to create a container apps job
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, jobName, jobEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, jobEnvelope, options },
                spec: updateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patches a Container Apps Job using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobEnvelope Properties used to create a container apps job
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, jobName, jobEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, jobName, jobEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Start a Container Apps Job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, options },
                spec: startOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start a Container Apps Job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Terminates execution of a running container apps job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobExecutionName Job execution name.
     * @param options The options parameters.
     */
    beginStopExecution(resourceGroupName, jobName, jobExecutionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, jobExecutionName, options },
                spec: stopExecutionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Terminates execution of a running container apps job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobExecutionName Job execution name.
     * @param options The options parameters.
     */
    beginStopExecutionAndWait(resourceGroupName, jobName, jobExecutionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopExecution(resourceGroupName, jobName, jobExecutionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Terminates execution of a running container apps job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginStopMultipleExecutions(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, jobName, options },
                spec: stopMultipleExecutionsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Terminates execution of a running container apps job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    beginStopMultipleExecutionsAndWait(resourceGroupName, jobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopMultipleExecutions(resourceGroupName, jobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List secrets for a container apps job
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, listSecretsOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/jobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Job
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Job
        },
        201: {
            bodyMapper: Job
        },
        202: {
            bodyMapper: Job
        },
        204: {
            bodyMapper: Job
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: jobEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Job
        },
        201: {
            bodyMapper: Job
        },
        202: {
            bodyMapper: Job
        },
        204: {
            bodyMapper: Job
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: jobEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/start",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: JobExecutionBase
        },
        201: {
            bodyMapper: JobExecutionBase
        },
        202: {
            bodyMapper: JobExecutionBase
        },
        204: {
            bodyMapper: JobExecutionBase
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: template,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const stopExecutionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/executions/{jobExecutionName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        jobExecutionName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const stopMultipleExecutionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/stop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ContainerAppJobExecutions
        },
        201: {
            bodyMapper: ContainerAppJobExecutions
        },
        202: {
            bodyMapper: ContainerAppJobExecutions
        },
        204: {
            bodyMapper: ContainerAppJobExecutions
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listSecretsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: JobSecretsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing JobsExecutions operations. */
class JobsExecutionsImpl {
    /**
     * Initialize a new instance of the class JobsExecutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get a Container Apps Job's executions
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    list(resourceGroupName, jobName, options) {
        const iter = this.listPagingAll(resourceGroupName, jobName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, jobName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, jobName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, jobName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, jobName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, jobName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, jobName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Container Apps Job's executions
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param options The options parameters.
     */
    _list(resourceGroupName, jobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, jobName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, jobName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/executions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppJobExecutions
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerAppJobExecutions
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        jobName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedEnvironments operations. */
class ManagedEnvironmentsImpl {
    /**
     * Initialize a new instance of the class ManagedEnvironments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all Managed Environments for a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the Managed Environments in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get all workload Profile States for a Managed Environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    listWorkloadProfileStates(resourceGroupName, environmentName, options) {
        const iter = this.listWorkloadProfileStatesPagingAll(resourceGroupName, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listWorkloadProfileStatesPagingPage(resourceGroupName, environmentName, options, settings);
            }
        };
    }
    listWorkloadProfileStatesPagingPage(resourceGroupName, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkloadProfileStatesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listWorkloadProfileStates(resourceGroupName, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listWorkloadProfileStatesNext(resourceGroupName, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listWorkloadProfileStatesPagingAll(resourceGroupName, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listWorkloadProfileStatesPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listWorkloadProfileStatesPagingPage(resourceGroupName, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Get all Managed Environments for a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Get all the Managed Environments in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Get the properties of a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, getOperationSpec$5);
    }
    /**
     * Creates or updates a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param environmentEnvelope Configuration details of the Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, environmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    environmentName,
                    environmentEnvelope,
                    options
                },
                spec: createOrUpdateOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a Managed Environment used to host container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param environmentEnvelope Configuration details of the Environment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, environmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, environmentName, environmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Managed Environment if it does not have any container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, environmentName, options },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Managed Environment if it does not have any container apps.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, environmentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, environmentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patches a Managed Environment using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param environmentEnvelope Configuration details of the Environment.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, environmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    environmentName,
                    environmentEnvelope,
                    options
                },
                spec: updateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patches a Managed Environment using JSON Merge Patch
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param environmentEnvelope Configuration details of the Environment.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, environmentName, environmentEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, environmentName, environmentEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks if resource name is available.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    getAuthToken(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, getAuthTokenOperationSpec);
    }
    /**
     * Get all workload Profile States for a Managed Environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    _listWorkloadProfileStates(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listWorkloadProfileStatesOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListWorkloadProfileStatesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param nextLink The nextLink from the previous successful call to the ListWorkloadProfileStates
     *                 method.
     * @param options The options parameters.
     */
    _listWorkloadProfileStatesNext(resourceGroupName, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, nextLink, options }, listWorkloadProfileStatesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.App/managedEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedEnvironment
        },
        201: {
            bodyMapper: ManagedEnvironment
        },
        202: {
            bodyMapper: ManagedEnvironment
        },
        204: {
            bodyMapper: ManagedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: environmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedEnvironment
        },
        201: {
            bodyMapper: ManagedEnvironment
        },
        202: {
            bodyMapper: ManagedEnvironment
        },
        204: {
            bodyMapper: ManagedEnvironment
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: environmentEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const getAuthTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/getAuthtoken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EnvironmentAuthToken
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listWorkloadProfileStatesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/workloadProfileStates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadProfileStatesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listWorkloadProfileStatesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadProfileStatesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Certificates operations. */
class CertificatesImpl {
    /**
     * Initialize a new instance of the class Certificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Certificates in a given managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, environmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, environmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Certificates in a given managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listOperationSpec$3);
    }
    /**
     * Get the specified Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    get(resourceGroupName, environmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, certificateName, options }, getOperationSpec$4);
    }
    /**
     * Create or Update a Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, environmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, certificateName, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes the specified Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param certificateName Name of the Certificate.
     * @param options The options parameters.
     */
    delete(resourceGroupName, environmentName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, certificateName, options }, deleteOperationSpec$4);
    }
    /**
     * Patches a certificate. Currently only patching of tags is supported
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param certificateName Name of the Certificate.
     * @param certificateEnvelope Properties of a certificate that need to be updated
     * @param options The options parameters.
     */
    update(resourceGroupName, environmentName, certificateName, certificateEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            certificateName,
            certificateEnvelope,
            options
        }, updateOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/certificates/{certificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/certificates/{certificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/certificates/{certificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/certificates/{certificateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Certificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: certificateEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        certificateName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagedCertificates operations. */
class ManagedCertificatesImpl {
    /**
     * Initialize a new instance of the class ManagedCertificates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Managed Certificates in a given managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, environmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, environmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the specified Managed Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param managedCertificateName Name of the Managed Certificate.
     * @param options The options parameters.
     */
    get(resourceGroupName, environmentName, managedCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, managedCertificateName, options }, getOperationSpec$3);
    }
    /**
     * Create or Update a Managed Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param managedCertificateName Name of the Managed Certificate.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, environmentName, managedCertificateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    environmentName,
                    managedCertificateName,
                    options
                },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or Update a Managed Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param managedCertificateName Name of the Managed Certificate.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, environmentName, managedCertificateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, environmentName, managedCertificateName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified Managed Certificate.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param managedCertificateName Name of the Managed Certificate.
     * @param options The options parameters.
     */
    delete(resourceGroupName, environmentName, managedCertificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, managedCertificateName, options }, deleteOperationSpec$3);
    }
    /**
     * Patches a managed certificate. Oly patching of tags is supported
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param managedCertificateName Name of the Managed Certificate.
     * @param managedCertificateEnvelope Properties of a managed certificate that need to be updated
     * @param options The options parameters.
     */
    update(resourceGroupName, environmentName, managedCertificateName, managedCertificateEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            managedCertificateName,
            managedCertificateEnvelope,
            options
        }, updateOperationSpec);
    }
    /**
     * Get the Managed Certificates in a given managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/managedCertificates/{managedCertificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName,
        managedCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/managedCertificates/{managedCertificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedCertificate
        },
        201: {
            bodyMapper: ManagedCertificate
        },
        202: {
            bodyMapper: ManagedCertificate
        },
        204: {
            bodyMapper: ManagedCertificate
        },
        400: {
            isError: true
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: managedCertificateEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName,
        managedCertificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/managedCertificates/{managedCertificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName,
        managedCertificateName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/managedCertificates/{managedCertificateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ManagedCertificate
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: managedCertificateEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName,
        managedCertificateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/managedCertificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedCertificateCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Namespaces operations. */
class NamespacesImpl {
    /**
     * Initialize a new instance of the class Namespaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Checks if resource name is available.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param checkNameAvailabilityRequest The check name availability request.
     * @param options The options parameters.
     */
    checkNameAvailability(resourceGroupName, environmentName, checkNameAvailabilityRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            checkNameAvailabilityRequest,
            options
        }, checkNameAvailabilityOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: checkNameAvailabilityRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DaprComponents operations. */
class DaprComponentsImpl {
    /**
     * Initialize a new instance of the class DaprComponents class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Dapr Components for a managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, environmentName, options) {
        const iter = this.listPagingAll(resourceGroupName, environmentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, environmentName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, environmentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, environmentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, environmentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, environmentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, environmentName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Dapr Components for a managed environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param options The options parameters.
     */
    _list(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listOperationSpec$1);
    }
    /**
     * Get a dapr component.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    get(resourceGroupName, environmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, componentName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates a Dapr Component in a Managed Environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param componentName Name of the Dapr Component.
     * @param daprComponentEnvelope Configuration details of the Dapr Component.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, environmentName, componentName, daprComponentEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            componentName,
            daprComponentEnvelope,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Delete a Dapr Component from a Managed Environment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    delete(resourceGroupName, environmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, componentName, options }, deleteOperationSpec$2);
    }
    /**
     * List secrets for a dapr component
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param componentName Name of the Dapr Component.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, environmentName, componentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, componentName, options }, listSecretsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Managed Environment.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, environmentName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/daprComponents",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/daprComponents/{componentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponent
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        componentName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/daprComponents/{componentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DaprComponent
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: daprComponentEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        componentName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/daprComponents/{componentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        componentName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/daprComponents/{componentName}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DaprSecretsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        componentName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DaprComponentsCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ManagedEnvironmentsStorages operations. */
class ManagedEnvironmentsStoragesImpl {
    /**
     * Initialize a new instance of the class ManagedEnvironmentsStorages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all storages for a managedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param options The options parameters.
     */
    list(resourceGroupName, environmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, options }, listOperationSpec);
    }
    /**
     * Get storage for a managedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param options The options parameters.
     */
    get(resourceGroupName, environmentName, storageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, storageName, options }, getOperationSpec$1);
    }
    /**
     * Create or update storage for a managedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param storageEnvelope Configuration details of storage.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, environmentName, storageName, storageEnvelope, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            environmentName,
            storageName,
            storageEnvelope,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Delete storage for a managedEnvironment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param environmentName Name of the Environment.
     * @param storageName Name of the storage.
     * @param options The options parameters.
     */
    delete(resourceGroupName, environmentName, storageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, environmentName, storageName, options }, deleteOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/storages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentStoragesCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/storages/{storageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentStorage
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        storageName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/storages/{storageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ManagedEnvironmentStorage
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: storageEnvelope1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        storageName,
        environmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/managedEnvironments/{environmentName}/storages/{storageName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        storageName,
        environmentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ContainerAppsSourceControls operations. */
class ContainerAppsSourceControlsImpl {
    /**
     * Initialize a new instance of the class ContainerAppsSourceControls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the Container App SourceControls in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    listByContainerApp(resourceGroupName, containerAppName, options) {
        const iter = this.listByContainerAppPagingAll(resourceGroupName, containerAppName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByContainerAppPagingPage(resourceGroupName, containerAppName, options, settings);
            }
        };
    }
    listByContainerAppPagingPage(resourceGroupName, containerAppName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByContainerAppPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByContainerApp(resourceGroupName, containerAppName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByContainerAppNext(resourceGroupName, containerAppName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByContainerAppPagingAll(resourceGroupName, containerAppName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByContainerAppPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByContainerAppPagingPage(resourceGroupName, containerAppName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the Container App SourceControls in a given resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param options The options parameters.
     */
    _listByContainerApp(resourceGroupName, containerAppName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, options }, listByContainerAppOperationSpec);
    }
    /**
     * Get a SourceControl of a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param sourceControlName Name of the Container App SourceControl.
     * @param options The options parameters.
     */
    get(resourceGroupName, containerAppName, sourceControlName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, sourceControlName, options }, getOperationSpec);
    }
    /**
     * Create or update the SourceControl for a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param sourceControlName Name of the Container App SourceControl.
     * @param sourceControlEnvelope Properties used to create a Container App SourceControl
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, containerAppName, sourceControlName, sourceControlEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    containerAppName,
                    sourceControlName,
                    sourceControlEnvelope,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update the SourceControl for a Container App.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param sourceControlName Name of the Container App SourceControl.
     * @param sourceControlEnvelope Properties used to create a Container App SourceControl
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, containerAppName, sourceControlName, sourceControlEnvelope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, containerAppName, sourceControlName, sourceControlEnvelope, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Container App SourceControl.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param sourceControlName Name of the Container App SourceControl.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, containerAppName, sourceControlName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, containerAppName, sourceControlName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Container App SourceControl.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param sourceControlName Name of the Container App SourceControl.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, containerAppName, sourceControlName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, containerAppName, sourceControlName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByContainerAppNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param containerAppName Name of the Container App.
     * @param nextLink The nextLink from the previous successful call to the ListByContainerApp method.
     * @param options The options parameters.
     */
    _listByContainerAppNext(resourceGroupName, containerAppName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, containerAppName, nextLink, options }, listByContainerAppNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByContainerAppOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/sourcecontrols",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/sourcecontrols/{sourceControlName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        sourceControlName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/sourcecontrols/{sourceControlName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SourceControl
        },
        201: {
            bodyMapper: SourceControl
        },
        202: {
            bodyMapper: SourceControl
        },
        204: {
            bodyMapper: SourceControl
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    requestBody: sourceControlEnvelope,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        sourceControlName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/containerApps/{containerAppName}/sourcecontrols/{sourceControlName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        sourceControlName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByContainerAppNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SourceControlCollection
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        containerAppName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ContainerAppsAPIClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ContainerAppsAPIClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-appcontainers/2.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-05-01";
        this.containerAppsAuthConfigs = new ContainerAppsAuthConfigsImpl(this);
        this.availableWorkloadProfiles = new AvailableWorkloadProfilesImpl(this);
        this.billingMeters = new BillingMetersImpl(this);
        this.connectedEnvironments = new ConnectedEnvironmentsImpl(this);
        this.connectedEnvironmentsCertificates = new ConnectedEnvironmentsCertificatesImpl(this);
        this.connectedEnvironmentsDaprComponents = new ConnectedEnvironmentsDaprComponentsImpl(this);
        this.connectedEnvironmentsStorages = new ConnectedEnvironmentsStoragesImpl(this);
        this.containerApps = new ContainerAppsImpl(this);
        this.containerAppsRevisions = new ContainerAppsRevisionsImpl(this);
        this.containerAppsRevisionReplicas = new ContainerAppsRevisionReplicasImpl(this);
        this.containerAppsDiagnostics = new ContainerAppsDiagnosticsImpl(this);
        this.managedEnvironmentDiagnostics = new ManagedEnvironmentDiagnosticsImpl(this);
        this.managedEnvironmentsDiagnostics = new ManagedEnvironmentsDiagnosticsImpl(this);
        this.operations = new OperationsImpl(this);
        this.jobs = new JobsImpl(this);
        this.jobsExecutions = new JobsExecutionsImpl(this);
        this.managedEnvironments = new ManagedEnvironmentsImpl(this);
        this.certificates = new CertificatesImpl(this);
        this.managedCertificates = new ManagedCertificatesImpl(this);
        this.namespaces = new NamespacesImpl(this);
        this.daprComponents = new DaprComponentsImpl(this);
        this.managedEnvironmentsStorages = new ManagedEnvironmentsStoragesImpl(this);
        this.containerAppsSourceControls = new ContainerAppsSourceControlsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Get details of a single job execution
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param jobName Job Name
     * @param jobExecutionName Job execution name.
     * @param options The options parameters.
     */
    jobExecution(resourceGroupName, jobName, jobExecutionName, options) {
        return this.sendOperationRequest({ resourceGroupName, jobName, jobExecutionName, options }, jobExecutionOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const jobExecutionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.App/jobs/{jobName}/executions/{jobExecutionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobExecution
        },
        default: {
            bodyMapper: DefaultErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        jobName,
        jobExecutionName
    ],
    headerParameters: [accept],
    serializer
};

exports.ContainerAppsAPIClient = ContainerAppsAPIClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
