'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownInstanceViewTypes) {
    KnownInstanceViewTypes["InstanceView"] = "instanceView";
})(exports.KnownInstanceViewTypes || (exports.KnownInstanceViewTypes = {}));
(function (KnownStatusTypes) {
    KnownStatusTypes["Connected"] = "Connected";
    KnownStatusTypes["Disconnected"] = "Disconnected";
    KnownStatusTypes["Error"] = "Error";
})(exports.KnownStatusTypes || (exports.KnownStatusTypes = {}));
(function (KnownStatusLevelTypes) {
    KnownStatusLevelTypes["Info"] = "Info";
    KnownStatusLevelTypes["Warning"] = "Warning";
    KnownStatusLevelTypes["Error"] = "Error";
})(exports.KnownStatusLevelTypes || (exports.KnownStatusLevelTypes = {}));
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
(function (KnownPublicNetworkAccessType) {
    /** Allows Azure Arc agents to communicate with Azure Arc services over both public (internet) and private endpoints. */
    KnownPublicNetworkAccessType["Enabled"] = "Enabled";
    /** Does not allow Azure Arc agents to communicate with Azure Arc services over public (internet) endpoints. The agents must use the private link. */
    KnownPublicNetworkAccessType["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccessType || (exports.KnownPublicNetworkAccessType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const MachineProperties = {
    type: {
        name: "Composite",
        className: "MachineProperties",
        modelProperties: {
            locationData: {
                serializedName: "locationData",
                type: {
                    name: "Composite",
                    className: "LocationData"
                }
            },
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "OSProfile"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lastStatusChange: {
                serializedName: "lastStatusChange",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            errorDetails: {
                serializedName: "errorDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            agentVersion: {
                serializedName: "agentVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vmId: {
                serializedName: "vmId",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            machineFqdn: {
                serializedName: "machineFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientPublicKey: {
                serializedName: "clientPublicKey",
                type: {
                    name: "String"
                }
            },
            osName: {
                serializedName: "osName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            osVersion: {
                serializedName: "osVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vmUuid: {
                serializedName: "vmUuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MachineExtensionInstanceView"
                        }
                    }
                }
            },
            osSku: {
                serializedName: "osSku",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            domainName: {
                serializedName: "domainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            adFqdn: {
                serializedName: "adFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dnsFqdn: {
                serializedName: "dnsFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateLinkScopeResourceId: {
                serializedName: "privateLinkScopeResourceId",
                type: {
                    name: "String"
                }
            },
            parentClusterResourceId: {
                serializedName: "parentClusterResourceId",
                type: {
                    name: "String"
                }
            },
            detectedProperties: {
                serializedName: "detectedProperties",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const LocationData = {
    type: {
        name: "Composite",
        className: "LocationData",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 256
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            },
            district: {
                serializedName: "district",
                type: {
                    name: "String"
                }
            },
            countryOrRegion: {
                serializedName: "countryOrRegion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OSProfile = {
    type: {
        name: "Composite",
        className: "OSProfile",
        modelProperties: {
            computerName: {
                serializedName: "computerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MachineExtensionInstanceView = {
    type: {
        name: "Composite",
        className: "MachineExtensionInstanceView",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Composite",
                    className: "MachineExtensionInstanceViewStatus"
                }
            }
        }
    }
};
const MachineExtensionInstanceViewStatus = {
    type: {
        name: "Composite",
        className: "MachineExtensionInstanceViewStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                type: {
                    name: "String"
                }
            },
            displayStatus: {
                serializedName: "displayStatus",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            time: {
                serializedName: "time",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "SystemAssigned",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MachineListResult = {
    type: {
        name: "Composite",
        className: "MachineListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Machine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MachineExtensionProperties = {
    type: {
        name: "Composite",
        className: "MachineExtensionProperties",
        modelProperties: {
            forceUpdateTag: {
                serializedName: "forceUpdateTag",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            autoUpgradeMinorVersion: {
                serializedName: "autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            },
            settings: {
                serializedName: "settings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            protectedSettings: {
                serializedName: "protectedSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            instanceView: {
                serializedName: "instanceView",
                type: {
                    name: "Composite",
                    className: "MachineExtensionInstanceView"
                }
            }
        }
    }
};
const MachineExtensionUpdateProperties = {
    type: {
        name: "Composite",
        className: "MachineExtensionUpdateProperties",
        modelProperties: {
            forceUpdateTag: {
                serializedName: "forceUpdateTag",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            autoUpgradeMinorVersion: {
                serializedName: "autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            },
            settings: {
                serializedName: "settings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            protectedSettings: {
                serializedName: "protectedSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ResourceUpdate = {
    type: {
        name: "Composite",
        className: "ResourceUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const MachineExtensionsListResult = {
    type: {
        name: "Composite",
        className: "MachineExtensionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MachineExtension"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MachineExtensionUpgrade = {
    type: {
        name: "Composite",
        className: "MachineExtensionUpgrade",
        modelProperties: {
            extensionTargets: {
                serializedName: "extensionTargets",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ExtensionTargetProperties" }
                    }
                }
            }
        }
    }
};
const ExtensionTargetProperties = {
    type: {
        name: "Composite",
        className: "ExtensionTargetProperties",
        modelProperties: {
            targetVersion: {
                serializedName: "targetVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationValue"
                        }
                    }
                }
            }
        }
    }
};
const OperationValue = {
    type: {
        name: "Composite",
        className: "OperationValue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationValueDisplay"
                }
            }
        }
    }
};
const OperationValueDisplay = {
    type: {
        name: "Composite",
        className: "OperationValueDisplay",
        modelProperties: {
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HybridComputePrivateLinkScopeListResult = {
    type: {
        name: "Composite",
        className: "HybridComputePrivateLinkScopeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HybridComputePrivateLinkScope"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HybridComputePrivateLinkScopeProperties = {
    type: {
        name: "Composite",
        className: "HybridComputePrivateLinkScopeProperties",
        modelProperties: {
            publicNetworkAccess: {
                defaultValue: "Disabled",
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateLinkScopeId: {
                serializedName: "privateLinkScopeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkScopesResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkScopesResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const TagsResource = {
    type: {
        name: "Composite",
        className: "TagsResource",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointProperty"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionStateProperty"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointProperty = {
    type: {
        name: "Composite",
        className: "PrivateEndpointProperty",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionStateProperty = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionStateProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                required: true,
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkScopeValidationDetails = {
    type: {
        name: "Composite",
        className: "PrivateLinkScopeValidationDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                defaultValue: "Disabled",
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            connectionDetails: {
                serializedName: "connectionDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionDetail"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionDetail = {
    type: {
        name: "Composite",
        className: "ConnectionDetail",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            linkIdentifier: {
                serializedName: "linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            memberName: {
                serializedName: "memberName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MachineUpdateProperties = {
    type: {
        name: "Composite",
        className: "MachineUpdateProperties",
        modelProperties: {
            locationData: {
                serializedName: "locationData",
                type: {
                    name: "Composite",
                    className: "LocationData"
                }
            },
            parentClusterResourceId: {
                serializedName: "parentClusterResourceId",
                type: {
                    name: "String"
                }
            },
            privateLinkScopeResourceId: {
                serializedName: "privateLinkScopeResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const MachineExtensionUpdate = {
    type: {
        name: "Composite",
        className: "MachineExtensionUpdate",
        modelProperties: Object.assign(Object.assign({}, ResourceUpdate.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MachineExtensionUpdateProperties"
                }
            } })
    }
};
const MachineUpdate = {
    type: {
        name: "Composite",
        className: "MachineUpdate",
        modelProperties: Object.assign(Object.assign({}, ResourceUpdate.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MachineUpdateProperties"
                }
            } })
    }
};
const HybridComputePrivateLinkScope = {
    type: {
        name: "Composite",
        className: "HybridComputePrivateLinkScope",
        modelProperties: Object.assign(Object.assign({}, PrivateLinkScopesResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "HybridComputePrivateLinkScopeProperties"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const Machine = {
    type: {
        name: "Composite",
        className: "Machine",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MachineProperties"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const MachineExtension = {
    type: {
        name: "Composite",
        className: "MachineExtension",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "MachineExtensionProperties"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionProperties"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    MachineProperties: MachineProperties,
    LocationData: LocationData,
    OSProfile: OSProfile,
    MachineExtensionInstanceView: MachineExtensionInstanceView,
    MachineExtensionInstanceViewStatus: MachineExtensionInstanceViewStatus,
    Identity: Identity,
    SystemData: SystemData,
    Resource: Resource,
    MachineListResult: MachineListResult,
    MachineExtensionProperties: MachineExtensionProperties,
    MachineExtensionUpdateProperties: MachineExtensionUpdateProperties,
    ResourceUpdate: ResourceUpdate,
    MachineExtensionsListResult: MachineExtensionsListResult,
    MachineExtensionUpgrade: MachineExtensionUpgrade,
    ExtensionTargetProperties: ExtensionTargetProperties,
    OperationListResult: OperationListResult,
    OperationValue: OperationValue,
    OperationValueDisplay: OperationValueDisplay,
    HybridComputePrivateLinkScopeListResult: HybridComputePrivateLinkScopeListResult,
    HybridComputePrivateLinkScopeProperties: HybridComputePrivateLinkScopeProperties,
    PrivateLinkScopesResource: PrivateLinkScopesResource,
    TagsResource: TagsResource,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    PrivateEndpointConnectionProperties: PrivateEndpointConnectionProperties,
    PrivateEndpointProperty: PrivateEndpointProperty,
    PrivateLinkServiceConnectionStateProperty: PrivateLinkServiceConnectionStateProperty,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkScopeValidationDetails: PrivateLinkScopeValidationDetails,
    ConnectionDetail: ConnectionDetail,
    MachineUpdateProperties: MachineUpdateProperties,
    TrackedResource: TrackedResource,
    ProxyResource: ProxyResource,
    MachineExtensionUpdate: MachineExtensionUpdate,
    MachineUpdate: MachineUpdate,
    HybridComputePrivateLinkScope: HybridComputePrivateLinkScope,
    Machine: Machine,
    MachineExtension: MachineExtension,
    PrivateLinkResource: PrivateLinkResource,
    PrivateEndpointConnection: PrivateEndpointConnection
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-05-20",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const machineName = {
    parameterPath: "machineName",
    mapper: {
        serializedName: "machineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const extensionParameters = {
    parameterPath: "extensionParameters",
    mapper: MachineExtension
};
const extensionName = {
    parameterPath: "extensionName",
    mapper: {
        serializedName: "extensionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const extensionParameters1 = {
    parameterPath: "extensionParameters",
    mapper: MachineExtensionUpdate
};
const expand1 = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const extensionUpgradeParameters = {
    parameterPath: "extensionUpgradeParameters",
    mapper: MachineExtensionUpgrade
};
const scopeName = {
    parameterPath: "scopeName",
    mapper: {
        serializedName: "scopeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: HybridComputePrivateLinkScope
};
const privateLinkScopeTags = {
    parameterPath: "privateLinkScopeTags",
    mapper: TagsResource
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateLinkScopeId = {
    parameterPath: "privateLinkScopeId",
    mapper: {
        serializedName: "privateLinkScopeId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const machineName1 = {
    parameterPath: "machineName",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "machineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Machines operations. */
class MachinesImpl {
    /**
     * Initialize a new instance of the class Machines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the hybrid machines in the specified resource group. Use the nextLink property in the
     * response to get the next page of hybrid machines.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the hybrid machines in the specified subscription. Use the nextLink property in the
     * response to get the next page of hybrid machines.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * The operation to remove a hybrid machine identity in Azure.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the hybrid machine.
     * @param options The options parameters.
     */
    delete(resourceGroupName, machineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, options }, deleteOperationSpec);
    }
    /**
     * Retrieves information about the model view or the instance view of a hybrid machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the hybrid machine.
     * @param options The options parameters.
     */
    get(resourceGroupName, machineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, options }, getOperationSpec);
    }
    /**
     * Lists all the hybrid machines in the specified resource group. Use the nextLink property in the
     * response to get the next page of hybrid machines.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Lists all the hybrid machines in the specified subscription. Use the nextLink property in the
     * response to get the next page of hybrid machines.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Machine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName
    ],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HybridCompute/machines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MachineExtensions operations. */
class MachineExtensionsImpl {
    /**
     * Initialize a new instance of the class MachineExtensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The operation to get all extensions of a non-Azure machine
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine containing the extension.
     * @param options The options parameters.
     */
    list(resourceGroupName, machineName, options) {
        const iter = this.listPagingAll(resourceGroupName, machineName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, machineName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, machineName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, machineName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, machineName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, machineName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, machineName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be created or updated.
     * @param extensionName The name of the machine extension.
     * @param extensionParameters Parameters supplied to the Create Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, machineName, extensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                machineName,
                extensionName,
                extensionParameters,
                options
            }, createOrUpdateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be created or updated.
     * @param extensionName The name of the machine extension.
     * @param extensionParameters Parameters supplied to the Create Machine Extension operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, machineName, extensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, machineName, extensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be created or updated.
     * @param extensionName The name of the machine extension.
     * @param extensionParameters Parameters supplied to the Create Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, machineName, extensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                machineName,
                extensionName,
                extensionParameters,
                options
            }, updateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * The operation to create or update the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be created or updated.
     * @param extensionName The name of the machine extension.
     * @param extensionParameters Parameters supplied to the Create Machine Extension operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, machineName, extensionName, extensionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, machineName, extensionName, extensionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be deleted.
     * @param extensionName The name of the machine extension.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, machineName, extensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, machineName, extensionName, options }, deleteOperationSpec$1);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * The operation to delete the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine where the extension should be deleted.
     * @param extensionName The name of the machine extension.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, machineName, extensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, machineName, extensionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The operation to get the extension.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine containing the extension.
     * @param extensionName The name of the machine extension.
     * @param options The options parameters.
     */
    get(resourceGroupName, machineName, extensionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, extensionName, options }, getOperationSpec$1);
    }
    /**
     * The operation to get all extensions of a non-Azure machine
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine containing the extension.
     * @param options The options parameters.
     */
    _list(resourceGroupName, machineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the machine containing the extension.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, machineName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/extensions/{extensionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MachineExtension
        },
        201: {
            bodyMapper: MachineExtension
        },
        202: {
            bodyMapper: MachineExtension
        },
        204: {
            bodyMapper: MachineExtension
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: extensionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName,
        extensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/extensions/{extensionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: MachineExtension
        },
        201: {
            bodyMapper: MachineExtension
        },
        202: {
            bodyMapper: MachineExtension
        },
        204: {
            bodyMapper: MachineExtension
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: extensionParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName,
        extensionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/extensions/{extensionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName,
        extensionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/extensions/{extensionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineExtension
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName,
        extensionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/extensions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineExtensionsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MachineExtensionsListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand1],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of hybrid compute operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of hybrid compute operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.HybridCompute/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkScopes operations. */
class PrivateLinkScopesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkScopes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all Azure Arc PrivateLinkScopes within a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of Azure Arc PrivateLinkScopes within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets a list of all Azure Arc PrivateLinkScopes within a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Gets a list of Azure Arc PrivateLinkScopes within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Deletes a Azure Arc PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, scopeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, scopeName, options }, deleteOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a Azure Arc PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, scopeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, scopeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns a Azure Arc PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, scopeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, options }, getOperationSpec$2);
    }
    /**
     * Creates (or updates) a Azure Arc PrivateLinkScope. Note: You cannot specify a different value for
     * InstrumentationKey nor AppId in the Put operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param parameters Properties that need to be specified to create or update a Azure Arc for Servers
     *                   and Clusters PrivateLinkScope.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, scopeName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, parameters, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Updates an existing PrivateLinkScope's tags. To update other fields use the CreateOrUpdate method.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateLinkScopeTags Updated tag information to set into the PrivateLinkScope instance.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, scopeName, privateLinkScopeTags, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, privateLinkScopeTags, options }, updateTagsOperationSpec);
    }
    /**
     * Returns a Azure Arc PrivateLinkScope's validation details.
     * @param location The location of the target resource.
     * @param privateLinkScopeId The id (Guid) of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    getValidationDetails(location, privateLinkScopeId, options) {
        return this.client.sendOperationRequest({ location, privateLinkScopeId, options }, getValidationDetailsOperationSpec);
    }
    /**
     * Returns a Azure Arc PrivateLinkScope's validation details for a given machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the target machine to get the private link scope validation details
     *                    for.
     * @param options The options parameters.
     */
    getValidationDetailsForMachine(resourceGroupName, machineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, machineName, options }, getValidationDetailsForMachineOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HybridCompute/privateLinkScopes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScopeListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScopeListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScope
        },
        201: {
            bodyMapper: HybridComputePrivateLinkScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScope
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateLinkScopeTags,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getValidationDetailsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HybridCompute/locations/{location}/privateLinkScopes/{privateLinkScopeId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkScopeValidationDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        privateLinkScopeId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getValidationDetailsForMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/privateLinkScopes/current",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkScopeValidationDetails
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScopeListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HybridComputePrivateLinkScopeListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources that need to be created for a Azure Monitor PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    listByPrivateLinkScope(resourceGroupName, scopeName, options) {
        const iter = this.listByPrivateLinkScopePagingAll(resourceGroupName, scopeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options);
            }
        };
    }
    listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPrivateLinkScopePagingPage_1() {
            let result = yield tslib.__await(this._listByPrivateLinkScope(resourceGroupName, scopeName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByPrivateLinkScopeNext(resourceGroupName, scopeName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByPrivateLinkScopePagingAll(resourceGroupName, scopeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPrivateLinkScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the private link resources that need to be created for a Azure Monitor PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    _listByPrivateLinkScope(resourceGroupName, scopeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, options }, listByPrivateLinkScopeOperationSpec);
    }
    /**
     * Gets the private link resources that need to be created for a Azure Monitor PrivateLinkScope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param groupName The name of the private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, scopeName, groupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, groupName, options }, getOperationSpec$3);
    }
    /**
     * ListByPrivateLinkScopeNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param nextLink The nextLink from the previous successful call to the ListByPrivateLinkScope method.
     * @param options The options parameters.
     */
    _listByPrivateLinkScopeNext(resourceGroupName, scopeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, nextLink, options }, listByPrivateLinkScopeNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listByPrivateLinkScopeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateLinkResources/{groupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName,
        groupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByPrivateLinkScopeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private endpoint connections on a private link scope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    listByPrivateLinkScope(resourceGroupName, scopeName, options) {
        const iter = this.listByPrivateLinkScopePagingAll(resourceGroupName, scopeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options);
            }
        };
    }
    listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPrivateLinkScopePagingPage_1() {
            let result = yield tslib.__await(this._listByPrivateLinkScope(resourceGroupName, scopeName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByPrivateLinkScopeNext(resourceGroupName, scopeName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByPrivateLinkScopePagingAll(resourceGroupName, scopeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPrivateLinkScopePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPrivateLinkScopePagingPage(resourceGroupName, scopeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a private endpoint connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, scopeName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, privateEndpointConnectionName, options }, getOperationSpec$4);
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, scopeName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                scopeName,
                privateEndpointConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec$2);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Approve or reject a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters A private endpoint connection
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, scopeName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, scopeName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, scopeName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, scopeName, privateEndpointConnectionName, options }, deleteOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deletes a private endpoint connection with a given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, scopeName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, scopeName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private endpoint connections on a private link scope.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param options The options parameters.
     */
    _listByPrivateLinkScope(resourceGroupName, scopeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, options }, listByPrivateLinkScopeOperationSpec$1);
    }
    /**
     * ListByPrivateLinkScopeNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param scopeName The name of the Azure Arc PrivateLinkScope resource.
     * @param nextLink The nextLink from the previous successful call to the ListByPrivateLinkScope method.
     * @param options The options parameters.
     */
    _listByPrivateLinkScopeNext(resourceGroupName, scopeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, scopeName, nextLink, options }, listByPrivateLinkScopeNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByPrivateLinkScopeOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/privateLinkScopes/{scopeName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByPrivateLinkScopeNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        scopeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class HybridComputeManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the HybridComputeManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-hybridcompute/3.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-05-20";
        this.machines = new MachinesImpl(this);
        this.machineExtensions = new MachineExtensionsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateLinkScopes = new PrivateLinkScopesImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
    }
    /**
     * The operation to Upgrade Machine Extensions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the hybrid machine.
     * @param extensionUpgradeParameters Parameters supplied to the Upgrade Extensions operation.
     * @param options The options parameters.
     */
    beginUpgradeExtensions(resourceGroupName, machineName, extensionUpgradeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, machineName, extensionUpgradeParameters, options }, upgradeExtensionsOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * The operation to Upgrade Machine Extensions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param machineName The name of the hybrid machine.
     * @param extensionUpgradeParameters Parameters supplied to the Upgrade Extensions operation.
     * @param options The options parameters.
     */
    beginUpgradeExtensionsAndWait(resourceGroupName, machineName, extensionUpgradeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpgradeExtensions(resourceGroupName, machineName, extensionUpgradeParameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const upgradeExtensionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HybridCompute/machines/{machineName}/upgradeExtensions",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: extensionUpgradeParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        machineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};

exports.HybridComputeManagementClient = HybridComputeManagementClient;
//# sourceMappingURL=index.js.map
