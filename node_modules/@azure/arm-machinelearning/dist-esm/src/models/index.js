/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ProvisioningState} that the service accepts. */
export var KnownProvisioningState;
(function (KnownProvisioningState) {
    /** Unknown */
    KnownProvisioningState["Unknown"] = "Unknown";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Creating */
    KnownProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
})(KnownProvisioningState || (KnownProvisioningState = {}));
/** Known values of {@link EncryptionStatus} that the service accepts. */
export var KnownEncryptionStatus;
(function (KnownEncryptionStatus) {
    /** Enabled */
    KnownEncryptionStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownEncryptionStatus["Disabled"] = "Disabled";
})(KnownEncryptionStatus || (KnownEncryptionStatus = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
export var KnownPublicNetworkAccess;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(KnownPublicNetworkAccess || (KnownPublicNetworkAccess = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
export var KnownPrivateEndpointServiceConnectionStatus;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateEndpointServiceConnectionStatus["Disconnected"] = "Disconnected";
    /** Timeout */
    KnownPrivateEndpointServiceConnectionStatus["Timeout"] = "Timeout";
})(KnownPrivateEndpointServiceConnectionStatus || (KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
export var KnownPrivateEndpointConnectionProvisioningState;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(KnownPrivateEndpointConnectionProvisioningState || (KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
export var KnownManagedServiceIdentityType;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(KnownManagedServiceIdentityType || (KnownManagedServiceIdentityType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
export var KnownCreatedByType;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(KnownCreatedByType || (KnownCreatedByType = {}));
/** Known values of {@link DiagnoseResultLevel} that the service accepts. */
export var KnownDiagnoseResultLevel;
(function (KnownDiagnoseResultLevel) {
    /** Warning */
    KnownDiagnoseResultLevel["Warning"] = "Warning";
    /** Error */
    KnownDiagnoseResultLevel["Error"] = "Error";
    /** Information */
    KnownDiagnoseResultLevel["Information"] = "Information";
})(KnownDiagnoseResultLevel || (KnownDiagnoseResultLevel = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
export var KnownUsageUnit;
(function (KnownUsageUnit) {
    /** Count */
    KnownUsageUnit["Count"] = "Count";
})(KnownUsageUnit || (KnownUsageUnit = {}));
/** Known values of {@link BillingCurrency} that the service accepts. */
export var KnownBillingCurrency;
(function (KnownBillingCurrency) {
    /** USD */
    KnownBillingCurrency["USD"] = "USD";
})(KnownBillingCurrency || (KnownBillingCurrency = {}));
/** Known values of {@link UnitOfMeasure} that the service accepts. */
export var KnownUnitOfMeasure;
(function (KnownUnitOfMeasure) {
    /** OneHour */
    KnownUnitOfMeasure["OneHour"] = "OneHour";
})(KnownUnitOfMeasure || (KnownUnitOfMeasure = {}));
/** Known values of {@link VMPriceOSType} that the service accepts. */
export var KnownVMPriceOSType;
(function (KnownVMPriceOSType) {
    /** Linux */
    KnownVMPriceOSType["Linux"] = "Linux";
    /** Windows */
    KnownVMPriceOSType["Windows"] = "Windows";
})(KnownVMPriceOSType || (KnownVMPriceOSType = {}));
/** Known values of {@link VMTier} that the service accepts. */
export var KnownVMTier;
(function (KnownVMTier) {
    /** Standard */
    KnownVMTier["Standard"] = "Standard";
    /** LowPriority */
    KnownVMTier["LowPriority"] = "LowPriority";
    /** Spot */
    KnownVMTier["Spot"] = "Spot";
})(KnownVMTier || (KnownVMTier = {}));
/** Known values of {@link QuotaUnit} that the service accepts. */
export var KnownQuotaUnit;
(function (KnownQuotaUnit) {
    /** Count */
    KnownQuotaUnit["Count"] = "Count";
})(KnownQuotaUnit || (KnownQuotaUnit = {}));
/** Known values of {@link Status} that the service accepts. */
export var KnownStatus;
(function (KnownStatus) {
    /** Undefined */
    KnownStatus["Undefined"] = "Undefined";
    /** Success */
    KnownStatus["Success"] = "Success";
    /** Failure */
    KnownStatus["Failure"] = "Failure";
    /** InvalidQuotaBelowClusterMinimum */
    KnownStatus["InvalidQuotaBelowClusterMinimum"] = "InvalidQuotaBelowClusterMinimum";
    /** InvalidQuotaExceedsSubscriptionLimit */
    KnownStatus["InvalidQuotaExceedsSubscriptionLimit"] = "InvalidQuotaExceedsSubscriptionLimit";
    /** InvalidVMFamilyName */
    KnownStatus["InvalidVMFamilyName"] = "InvalidVMFamilyName";
    /** OperationNotSupportedForSku */
    KnownStatus["OperationNotSupportedForSku"] = "OperationNotSupportedForSku";
    /** OperationNotEnabledForRegion */
    KnownStatus["OperationNotEnabledForRegion"] = "OperationNotEnabledForRegion";
})(KnownStatus || (KnownStatus = {}));
/** Known values of {@link ComputeType} that the service accepts. */
export var KnownComputeType;
(function (KnownComputeType) {
    /** AKS */
    KnownComputeType["AKS"] = "AKS";
    /** Kubernetes */
    KnownComputeType["Kubernetes"] = "Kubernetes";
    /** AmlCompute */
    KnownComputeType["AmlCompute"] = "AmlCompute";
    /** ComputeInstance */
    KnownComputeType["ComputeInstance"] = "ComputeInstance";
    /** DataFactory */
    KnownComputeType["DataFactory"] = "DataFactory";
    /** VirtualMachine */
    KnownComputeType["VirtualMachine"] = "VirtualMachine";
    /** HDInsight */
    KnownComputeType["HDInsight"] = "HDInsight";
    /** Databricks */
    KnownComputeType["Databricks"] = "Databricks";
    /** DataLakeAnalytics */
    KnownComputeType["DataLakeAnalytics"] = "DataLakeAnalytics";
    /** SynapseSpark */
    KnownComputeType["SynapseSpark"] = "SynapseSpark";
})(KnownComputeType || (KnownComputeType = {}));
/** Known values of {@link UnderlyingResourceAction} that the service accepts. */
export var KnownUnderlyingResourceAction;
(function (KnownUnderlyingResourceAction) {
    /** Delete */
    KnownUnderlyingResourceAction["Delete"] = "Delete";
    /** Detach */
    KnownUnderlyingResourceAction["Detach"] = "Detach";
})(KnownUnderlyingResourceAction || (KnownUnderlyingResourceAction = {}));
/** Known values of {@link NodeState} that the service accepts. */
export var KnownNodeState;
(function (KnownNodeState) {
    /** Idle */
    KnownNodeState["Idle"] = "idle";
    /** Running */
    KnownNodeState["Running"] = "running";
    /** Preparing */
    KnownNodeState["Preparing"] = "preparing";
    /** Unusable */
    KnownNodeState["Unusable"] = "unusable";
    /** Leaving */
    KnownNodeState["Leaving"] = "leaving";
    /** Preempted */
    KnownNodeState["Preempted"] = "preempted";
})(KnownNodeState || (KnownNodeState = {}));
/** Known values of {@link ConnectionAuthType} that the service accepts. */
export var KnownConnectionAuthType;
(function (KnownConnectionAuthType) {
    /** PAT */
    KnownConnectionAuthType["PAT"] = "PAT";
    /** ManagedIdentity */
    KnownConnectionAuthType["ManagedIdentity"] = "ManagedIdentity";
    /** UsernamePassword */
    KnownConnectionAuthType["UsernamePassword"] = "UsernamePassword";
    /** None */
    KnownConnectionAuthType["None"] = "None";
    /** SAS */
    KnownConnectionAuthType["SAS"] = "SAS";
})(KnownConnectionAuthType || (KnownConnectionAuthType = {}));
/** Known values of {@link ConnectionCategory} that the service accepts. */
export var KnownConnectionCategory;
(function (KnownConnectionCategory) {
    /** PythonFeed */
    KnownConnectionCategory["PythonFeed"] = "PythonFeed";
    /** ContainerRegistry */
    KnownConnectionCategory["ContainerRegistry"] = "ContainerRegistry";
    /** Git */
    KnownConnectionCategory["Git"] = "Git";
})(KnownConnectionCategory || (KnownConnectionCategory = {}));
/** Known values of {@link ValueFormat} that the service accepts. */
export var KnownValueFormat;
(function (KnownValueFormat) {
    /** Json */
    KnownValueFormat["Json"] = "JSON";
})(KnownValueFormat || (KnownValueFormat = {}));
/** Known values of {@link EndpointProvisioningState} that the service accepts. */
export var KnownEndpointProvisioningState;
(function (KnownEndpointProvisioningState) {
    /** Creating */
    KnownEndpointProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownEndpointProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownEndpointProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownEndpointProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownEndpointProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownEndpointProvisioningState["Canceled"] = "Canceled";
})(KnownEndpointProvisioningState || (KnownEndpointProvisioningState = {}));
/** Known values of {@link EndpointAuthMode} that the service accepts. */
export var KnownEndpointAuthMode;
(function (KnownEndpointAuthMode) {
    /** AMLToken */
    KnownEndpointAuthMode["AMLToken"] = "AMLToken";
    /** Key */
    KnownEndpointAuthMode["Key"] = "Key";
    /** AADToken */
    KnownEndpointAuthMode["AADToken"] = "AADToken";
})(KnownEndpointAuthMode || (KnownEndpointAuthMode = {}));
/** Known values of {@link BatchLoggingLevel} that the service accepts. */
export var KnownBatchLoggingLevel;
(function (KnownBatchLoggingLevel) {
    /** Info */
    KnownBatchLoggingLevel["Info"] = "Info";
    /** Warning */
    KnownBatchLoggingLevel["Warning"] = "Warning";
    /** Debug */
    KnownBatchLoggingLevel["Debug"] = "Debug";
})(KnownBatchLoggingLevel || (KnownBatchLoggingLevel = {}));
/** Known values of {@link ReferenceType} that the service accepts. */
export var KnownReferenceType;
(function (KnownReferenceType) {
    /** Id */
    KnownReferenceType["Id"] = "Id";
    /** DataPath */
    KnownReferenceType["DataPath"] = "DataPath";
    /** OutputPath */
    KnownReferenceType["OutputPath"] = "OutputPath";
})(KnownReferenceType || (KnownReferenceType = {}));
/** Known values of {@link BatchOutputAction} that the service accepts. */
export var KnownBatchOutputAction;
(function (KnownBatchOutputAction) {
    /** SummaryOnly */
    KnownBatchOutputAction["SummaryOnly"] = "SummaryOnly";
    /** AppendRow */
    KnownBatchOutputAction["AppendRow"] = "AppendRow";
})(KnownBatchOutputAction || (KnownBatchOutputAction = {}));
/** Known values of {@link DeploymentProvisioningState} that the service accepts. */
export var KnownDeploymentProvisioningState;
(function (KnownDeploymentProvisioningState) {
    /** Creating */
    KnownDeploymentProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownDeploymentProvisioningState["Deleting"] = "Deleting";
    /** Scaling */
    KnownDeploymentProvisioningState["Scaling"] = "Scaling";
    /** Updating */
    KnownDeploymentProvisioningState["Updating"] = "Updating";
    /** Succeeded */
    KnownDeploymentProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownDeploymentProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownDeploymentProvisioningState["Canceled"] = "Canceled";
})(KnownDeploymentProvisioningState || (KnownDeploymentProvisioningState = {}));
/** Known values of {@link ListViewType} that the service accepts. */
export var KnownListViewType;
(function (KnownListViewType) {
    /** ActiveOnly */
    KnownListViewType["ActiveOnly"] = "ActiveOnly";
    /** ArchivedOnly */
    KnownListViewType["ArchivedOnly"] = "ArchivedOnly";
    /** All */
    KnownListViewType["All"] = "All";
})(KnownListViewType || (KnownListViewType = {}));
/** Known values of {@link DataType} that the service accepts. */
export var KnownDataType;
(function (KnownDataType) {
    /** UriFile */
    KnownDataType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownDataType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownDataType["Mltable"] = "mltable";
})(KnownDataType || (KnownDataType = {}));
/** Known values of {@link CredentialsType} that the service accepts. */
export var KnownCredentialsType;
(function (KnownCredentialsType) {
    /** AccountKey */
    KnownCredentialsType["AccountKey"] = "AccountKey";
    /** Certificate */
    KnownCredentialsType["Certificate"] = "Certificate";
    /** None */
    KnownCredentialsType["None"] = "None";
    /** Sas */
    KnownCredentialsType["Sas"] = "Sas";
    /** ServicePrincipal */
    KnownCredentialsType["ServicePrincipal"] = "ServicePrincipal";
})(KnownCredentialsType || (KnownCredentialsType = {}));
/** Known values of {@link DatastoreType} that the service accepts. */
export var KnownDatastoreType;
(function (KnownDatastoreType) {
    /** AzureBlob */
    KnownDatastoreType["AzureBlob"] = "AzureBlob";
    /** AzureDataLakeGen1 */
    KnownDatastoreType["AzureDataLakeGen1"] = "AzureDataLakeGen1";
    /** AzureDataLakeGen2 */
    KnownDatastoreType["AzureDataLakeGen2"] = "AzureDataLakeGen2";
    /** AzureFile */
    KnownDatastoreType["AzureFile"] = "AzureFile";
})(KnownDatastoreType || (KnownDatastoreType = {}));
/** Known values of {@link SecretsType} that the service accepts. */
export var KnownSecretsType;
(function (KnownSecretsType) {
    /** AccountKey */
    KnownSecretsType["AccountKey"] = "AccountKey";
    /** Certificate */
    KnownSecretsType["Certificate"] = "Certificate";
    /** Sas */
    KnownSecretsType["Sas"] = "Sas";
    /** ServicePrincipal */
    KnownSecretsType["ServicePrincipal"] = "ServicePrincipal";
})(KnownSecretsType || (KnownSecretsType = {}));
/** Known values of {@link AutoRebuildSetting} that the service accepts. */
export var KnownAutoRebuildSetting;
(function (KnownAutoRebuildSetting) {
    /** Disabled */
    KnownAutoRebuildSetting["Disabled"] = "Disabled";
    /** OnBaseImageUpdate */
    KnownAutoRebuildSetting["OnBaseImageUpdate"] = "OnBaseImageUpdate";
})(KnownAutoRebuildSetting || (KnownAutoRebuildSetting = {}));
/** Known values of {@link EnvironmentType} that the service accepts. */
export var KnownEnvironmentType;
(function (KnownEnvironmentType) {
    /** Curated */
    KnownEnvironmentType["Curated"] = "Curated";
    /** UserCreated */
    KnownEnvironmentType["UserCreated"] = "UserCreated";
})(KnownEnvironmentType || (KnownEnvironmentType = {}));
/** Known values of {@link OperatingSystemType} that the service accepts. */
export var KnownOperatingSystemType;
(function (KnownOperatingSystemType) {
    /** Linux */
    KnownOperatingSystemType["Linux"] = "Linux";
    /** Windows */
    KnownOperatingSystemType["Windows"] = "Windows";
})(KnownOperatingSystemType || (KnownOperatingSystemType = {}));
/** Known values of {@link IdentityConfigurationType} that the service accepts. */
export var KnownIdentityConfigurationType;
(function (KnownIdentityConfigurationType) {
    /** Managed */
    KnownIdentityConfigurationType["Managed"] = "Managed";
    /** AMLToken */
    KnownIdentityConfigurationType["AMLToken"] = "AMLToken";
    /** UserIdentity */
    KnownIdentityConfigurationType["UserIdentity"] = "UserIdentity";
})(KnownIdentityConfigurationType || (KnownIdentityConfigurationType = {}));
/** Known values of {@link JobType} that the service accepts. */
export var KnownJobType;
(function (KnownJobType) {
    /** AutoML */
    KnownJobType["AutoML"] = "AutoML";
    /** Command */
    KnownJobType["Command"] = "Command";
    /** Sweep */
    KnownJobType["Sweep"] = "Sweep";
    /** Pipeline */
    KnownJobType["Pipeline"] = "Pipeline";
})(KnownJobType || (KnownJobType = {}));
/** Known values of {@link JobStatus} that the service accepts. */
export var KnownJobStatus;
(function (KnownJobStatus) {
    /** Run hasn't started yet. */
    KnownJobStatus["NotStarted"] = "NotStarted";
    /** Run has started. The user has a run ID. */
    KnownJobStatus["Starting"] = "Starting";
    /** (Not used currently) It will be used if ES is creating the compute target. */
    KnownJobStatus["Provisioning"] = "Provisioning";
    /** The run environment is being prepared. */
    KnownJobStatus["Preparing"] = "Preparing";
    /** The job is queued in the compute target. For example, in BatchAI the job is in queued state, while waiting for all required nodes to be ready. */
    KnownJobStatus["Queued"] = "Queued";
    /** The job started to run in the compute target. */
    KnownJobStatus["Running"] = "Running";
    /** Job is completed in the target. It is in output collection state now. */
    KnownJobStatus["Finalizing"] = "Finalizing";
    /** Cancellation has been requested for the job. */
    KnownJobStatus["CancelRequested"] = "CancelRequested";
    /** Job completed successfully. This reflects that both the job itself and output collection states completed successfully */
    KnownJobStatus["Completed"] = "Completed";
    /** Job failed. */
    KnownJobStatus["Failed"] = "Failed";
    /** Following cancellation request, the job is now successfully canceled. */
    KnownJobStatus["Canceled"] = "Canceled";
    /**
     * When heartbeat is enabled, if the run isn't updating any information to RunHistory then the run goes to NotResponding state.
     * NotResponding is the only state that is exempt from strict transition orders. A run can go from NotResponding to any of the previous states.
     */
    KnownJobStatus["NotResponding"] = "NotResponding";
    /** The job is paused by users. Some adjustment to labeling jobs can be made only in paused state. */
    KnownJobStatus["Paused"] = "Paused";
    /** Default job status if not mapped to all other statuses */
    KnownJobStatus["Unknown"] = "Unknown";
})(KnownJobStatus || (KnownJobStatus = {}));
/** Known values of {@link EndpointComputeType} that the service accepts. */
export var KnownEndpointComputeType;
(function (KnownEndpointComputeType) {
    /** Managed */
    KnownEndpointComputeType["Managed"] = "Managed";
    /** Kubernetes */
    KnownEndpointComputeType["Kubernetes"] = "Kubernetes";
    /** AzureMLCompute */
    KnownEndpointComputeType["AzureMLCompute"] = "AzureMLCompute";
})(KnownEndpointComputeType || (KnownEndpointComputeType = {}));
/** Known values of {@link OrderString} that the service accepts. */
export var KnownOrderString;
(function (KnownOrderString) {
    /** CreatedAtDesc */
    KnownOrderString["CreatedAtDesc"] = "CreatedAtDesc";
    /** CreatedAtAsc */
    KnownOrderString["CreatedAtAsc"] = "CreatedAtAsc";
    /** UpdatedAtDesc */
    KnownOrderString["UpdatedAtDesc"] = "UpdatedAtDesc";
    /** UpdatedAtAsc */
    KnownOrderString["UpdatedAtAsc"] = "UpdatedAtAsc";
})(KnownOrderString || (KnownOrderString = {}));
/** Known values of {@link PublicNetworkAccessType} that the service accepts. */
export var KnownPublicNetworkAccessType;
(function (KnownPublicNetworkAccessType) {
    /** Enabled */
    KnownPublicNetworkAccessType["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccessType["Disabled"] = "Disabled";
})(KnownPublicNetworkAccessType || (KnownPublicNetworkAccessType = {}));
/** Known values of {@link EgressPublicNetworkAccessType} that the service accepts. */
export var KnownEgressPublicNetworkAccessType;
(function (KnownEgressPublicNetworkAccessType) {
    /** Enabled */
    KnownEgressPublicNetworkAccessType["Enabled"] = "Enabled";
    /** Disabled */
    KnownEgressPublicNetworkAccessType["Disabled"] = "Disabled";
})(KnownEgressPublicNetworkAccessType || (KnownEgressPublicNetworkAccessType = {}));
/** Known values of {@link ScaleType} that the service accepts. */
export var KnownScaleType;
(function (KnownScaleType) {
    /** Default */
    KnownScaleType["Default"] = "Default";
    /** TargetUtilization */
    KnownScaleType["TargetUtilization"] = "TargetUtilization";
})(KnownScaleType || (KnownScaleType = {}));
/** Known values of {@link ContainerType} that the service accepts. */
export var KnownContainerType;
(function (KnownContainerType) {
    /** StorageInitializer */
    KnownContainerType["StorageInitializer"] = "StorageInitializer";
    /** InferenceServer */
    KnownContainerType["InferenceServer"] = "InferenceServer";
})(KnownContainerType || (KnownContainerType = {}));
/** Known values of {@link SkuScaleType} that the service accepts. */
export var KnownSkuScaleType;
(function (KnownSkuScaleType) {
    /** Automatically scales node count. */
    KnownSkuScaleType["Automatic"] = "Automatic";
    /** Node count scaled upon user request. */
    KnownSkuScaleType["Manual"] = "Manual";
    /** Fixed set of nodes. */
    KnownSkuScaleType["None"] = "None";
})(KnownSkuScaleType || (KnownSkuScaleType = {}));
/** Known values of {@link KeyType} that the service accepts. */
export var KnownKeyType;
(function (KnownKeyType) {
    /** Primary */
    KnownKeyType["Primary"] = "Primary";
    /** Secondary */
    KnownKeyType["Secondary"] = "Secondary";
})(KnownKeyType || (KnownKeyType = {}));
/** Known values of {@link ScheduleListViewType} that the service accepts. */
export var KnownScheduleListViewType;
(function (KnownScheduleListViewType) {
    /** EnabledOnly */
    KnownScheduleListViewType["EnabledOnly"] = "EnabledOnly";
    /** DisabledOnly */
    KnownScheduleListViewType["DisabledOnly"] = "DisabledOnly";
    /** All */
    KnownScheduleListViewType["All"] = "All";
})(KnownScheduleListViewType || (KnownScheduleListViewType = {}));
/** Known values of {@link ScheduleActionType} that the service accepts. */
export var KnownScheduleActionType;
(function (KnownScheduleActionType) {
    /** CreateJob */
    KnownScheduleActionType["CreateJob"] = "CreateJob";
    /** InvokeBatchEndpoint */
    KnownScheduleActionType["InvokeBatchEndpoint"] = "InvokeBatchEndpoint";
})(KnownScheduleActionType || (KnownScheduleActionType = {}));
/** Known values of {@link ScheduleProvisioningStatus} that the service accepts. */
export var KnownScheduleProvisioningStatus;
(function (KnownScheduleProvisioningStatus) {
    /** Creating */
    KnownScheduleProvisioningStatus["Creating"] = "Creating";
    /** Updating */
    KnownScheduleProvisioningStatus["Updating"] = "Updating";
    /** Deleting */
    KnownScheduleProvisioningStatus["Deleting"] = "Deleting";
    /** Succeeded */
    KnownScheduleProvisioningStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownScheduleProvisioningStatus["Failed"] = "Failed";
    /** Canceled */
    KnownScheduleProvisioningStatus["Canceled"] = "Canceled";
})(KnownScheduleProvisioningStatus || (KnownScheduleProvisioningStatus = {}));
/** Known values of {@link TriggerType} that the service accepts. */
export var KnownTriggerType;
(function (KnownTriggerType) {
    /** Recurrence */
    KnownTriggerType["Recurrence"] = "Recurrence";
    /** Cron */
    KnownTriggerType["Cron"] = "Cron";
})(KnownTriggerType || (KnownTriggerType = {}));
/** Known values of {@link ClusterPurpose} that the service accepts. */
export var KnownClusterPurpose;
(function (KnownClusterPurpose) {
    /** FastProd */
    KnownClusterPurpose["FastProd"] = "FastProd";
    /** DenseProd */
    KnownClusterPurpose["DenseProd"] = "DenseProd";
    /** DevTest */
    KnownClusterPurpose["DevTest"] = "DevTest";
})(KnownClusterPurpose || (KnownClusterPurpose = {}));
/** Known values of {@link SslConfigStatus} that the service accepts. */
export var KnownSslConfigStatus;
(function (KnownSslConfigStatus) {
    /** Disabled */
    KnownSslConfigStatus["Disabled"] = "Disabled";
    /** Enabled */
    KnownSslConfigStatus["Enabled"] = "Enabled";
    /** Auto */
    KnownSslConfigStatus["Auto"] = "Auto";
})(KnownSslConfigStatus || (KnownSslConfigStatus = {}));
/** Known values of {@link LoadBalancerType} that the service accepts. */
export var KnownLoadBalancerType;
(function (KnownLoadBalancerType) {
    /** PublicIp */
    KnownLoadBalancerType["PublicIp"] = "PublicIp";
    /** InternalLoadBalancer */
    KnownLoadBalancerType["InternalLoadBalancer"] = "InternalLoadBalancer";
})(KnownLoadBalancerType || (KnownLoadBalancerType = {}));
/** Known values of {@link OsType} that the service accepts. */
export var KnownOsType;
(function (KnownOsType) {
    /** Linux */
    KnownOsType["Linux"] = "Linux";
    /** Windows */
    KnownOsType["Windows"] = "Windows";
})(KnownOsType || (KnownOsType = {}));
/** Known values of {@link VmPriority} that the service accepts. */
export var KnownVmPriority;
(function (KnownVmPriority) {
    /** Dedicated */
    KnownVmPriority["Dedicated"] = "Dedicated";
    /** LowPriority */
    KnownVmPriority["LowPriority"] = "LowPriority";
})(KnownVmPriority || (KnownVmPriority = {}));
/** Known values of {@link RemoteLoginPortPublicAccess} that the service accepts. */
export var KnownRemoteLoginPortPublicAccess;
(function (KnownRemoteLoginPortPublicAccess) {
    /** Enabled */
    KnownRemoteLoginPortPublicAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownRemoteLoginPortPublicAccess["Disabled"] = "Disabled";
    /** NotSpecified */
    KnownRemoteLoginPortPublicAccess["NotSpecified"] = "NotSpecified";
})(KnownRemoteLoginPortPublicAccess || (KnownRemoteLoginPortPublicAccess = {}));
/** Known values of {@link AllocationState} that the service accepts. */
export var KnownAllocationState;
(function (KnownAllocationState) {
    /** Steady */
    KnownAllocationState["Steady"] = "Steady";
    /** Resizing */
    KnownAllocationState["Resizing"] = "Resizing";
})(KnownAllocationState || (KnownAllocationState = {}));
/** Known values of {@link ApplicationSharingPolicy} that the service accepts. */
export var KnownApplicationSharingPolicy;
(function (KnownApplicationSharingPolicy) {
    /** Personal */
    KnownApplicationSharingPolicy["Personal"] = "Personal";
    /** Shared */
    KnownApplicationSharingPolicy["Shared"] = "Shared";
})(KnownApplicationSharingPolicy || (KnownApplicationSharingPolicy = {}));
/** Known values of {@link SshPublicAccess} that the service accepts. */
export var KnownSshPublicAccess;
(function (KnownSshPublicAccess) {
    /** Enabled */
    KnownSshPublicAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownSshPublicAccess["Disabled"] = "Disabled";
})(KnownSshPublicAccess || (KnownSshPublicAccess = {}));
/** Known values of {@link ComputeInstanceState} that the service accepts. */
export var KnownComputeInstanceState;
(function (KnownComputeInstanceState) {
    /** Creating */
    KnownComputeInstanceState["Creating"] = "Creating";
    /** CreateFailed */
    KnownComputeInstanceState["CreateFailed"] = "CreateFailed";
    /** Deleting */
    KnownComputeInstanceState["Deleting"] = "Deleting";
    /** Running */
    KnownComputeInstanceState["Running"] = "Running";
    /** Restarting */
    KnownComputeInstanceState["Restarting"] = "Restarting";
    /** JobRunning */
    KnownComputeInstanceState["JobRunning"] = "JobRunning";
    /** SettingUp */
    KnownComputeInstanceState["SettingUp"] = "SettingUp";
    /** SetupFailed */
    KnownComputeInstanceState["SetupFailed"] = "SetupFailed";
    /** Starting */
    KnownComputeInstanceState["Starting"] = "Starting";
    /** Stopped */
    KnownComputeInstanceState["Stopped"] = "Stopped";
    /** Stopping */
    KnownComputeInstanceState["Stopping"] = "Stopping";
    /** UserSettingUp */
    KnownComputeInstanceState["UserSettingUp"] = "UserSettingUp";
    /** UserSetupFailed */
    KnownComputeInstanceState["UserSetupFailed"] = "UserSetupFailed";
    /** Unknown */
    KnownComputeInstanceState["Unknown"] = "Unknown";
    /** Unusable */
    KnownComputeInstanceState["Unusable"] = "Unusable";
})(KnownComputeInstanceState || (KnownComputeInstanceState = {}));
/** Known values of {@link ComputeInstanceAuthorizationType} that the service accepts. */
export var KnownComputeInstanceAuthorizationType;
(function (KnownComputeInstanceAuthorizationType) {
    /** Personal */
    KnownComputeInstanceAuthorizationType["Personal"] = "personal";
})(KnownComputeInstanceAuthorizationType || (KnownComputeInstanceAuthorizationType = {}));
/** Known values of {@link OperationName} that the service accepts. */
export var KnownOperationName;
(function (KnownOperationName) {
    /** Create */
    KnownOperationName["Create"] = "Create";
    /** Start */
    KnownOperationName["Start"] = "Start";
    /** Stop */
    KnownOperationName["Stop"] = "Stop";
    /** Restart */
    KnownOperationName["Restart"] = "Restart";
    /** Reimage */
    KnownOperationName["Reimage"] = "Reimage";
    /** Delete */
    KnownOperationName["Delete"] = "Delete";
})(KnownOperationName || (KnownOperationName = {}));
/** Known values of {@link OperationStatus} that the service accepts. */
export var KnownOperationStatus;
(function (KnownOperationStatus) {
    /** InProgress */
    KnownOperationStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownOperationStatus["Succeeded"] = "Succeeded";
    /** CreateFailed */
    KnownOperationStatus["CreateFailed"] = "CreateFailed";
    /** StartFailed */
    KnownOperationStatus["StartFailed"] = "StartFailed";
    /** StopFailed */
    KnownOperationStatus["StopFailed"] = "StopFailed";
    /** RestartFailed */
    KnownOperationStatus["RestartFailed"] = "RestartFailed";
    /** ReimageFailed */
    KnownOperationStatus["ReimageFailed"] = "ReimageFailed";
    /** DeleteFailed */
    KnownOperationStatus["DeleteFailed"] = "DeleteFailed";
})(KnownOperationStatus || (KnownOperationStatus = {}));
/** Known values of {@link OperationTrigger} that the service accepts. */
export var KnownOperationTrigger;
(function (KnownOperationTrigger) {
    /** User */
    KnownOperationTrigger["User"] = "User";
    /** Schedule */
    KnownOperationTrigger["Schedule"] = "Schedule";
    /** IdleShutdown */
    KnownOperationTrigger["IdleShutdown"] = "IdleShutdown";
})(KnownOperationTrigger || (KnownOperationTrigger = {}));
/** Known values of {@link ProvisioningStatus} that the service accepts. */
export var KnownProvisioningStatus;
(function (KnownProvisioningStatus) {
    /** Completed */
    KnownProvisioningStatus["Completed"] = "Completed";
    /** Provisioning */
    KnownProvisioningStatus["Provisioning"] = "Provisioning";
    /** Failed */
    KnownProvisioningStatus["Failed"] = "Failed";
})(KnownProvisioningStatus || (KnownProvisioningStatus = {}));
/** Known values of {@link ScheduleStatus} that the service accepts. */
export var KnownScheduleStatus;
(function (KnownScheduleStatus) {
    /** Enabled */
    KnownScheduleStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownScheduleStatus["Disabled"] = "Disabled";
})(KnownScheduleStatus || (KnownScheduleStatus = {}));
/** Known values of {@link ComputePowerAction} that the service accepts. */
export var KnownComputePowerAction;
(function (KnownComputePowerAction) {
    /** Start */
    KnownComputePowerAction["Start"] = "Start";
    /** Stop */
    KnownComputePowerAction["Stop"] = "Stop";
})(KnownComputePowerAction || (KnownComputePowerAction = {}));
/** Known values of {@link RecurrenceFrequency} that the service accepts. */
export var KnownRecurrenceFrequency;
(function (KnownRecurrenceFrequency) {
    /** Minute frequency */
    KnownRecurrenceFrequency["Minute"] = "Minute";
    /** Hour frequency */
    KnownRecurrenceFrequency["Hour"] = "Hour";
    /** Day frequency */
    KnownRecurrenceFrequency["Day"] = "Day";
    /** Week frequency */
    KnownRecurrenceFrequency["Week"] = "Week";
    /** Month frequency */
    KnownRecurrenceFrequency["Month"] = "Month";
})(KnownRecurrenceFrequency || (KnownRecurrenceFrequency = {}));
/** Known values of {@link WeekDay} that the service accepts. */
export var KnownWeekDay;
(function (KnownWeekDay) {
    /** Monday weekday */
    KnownWeekDay["Monday"] = "Monday";
    /** Tuesday weekday */
    KnownWeekDay["Tuesday"] = "Tuesday";
    /** Wednesday weekday */
    KnownWeekDay["Wednesday"] = "Wednesday";
    /** Thursday weekday */
    KnownWeekDay["Thursday"] = "Thursday";
    /** Friday weekday */
    KnownWeekDay["Friday"] = "Friday";
    /** Saturday weekday */
    KnownWeekDay["Saturday"] = "Saturday";
    /** Sunday weekday */
    KnownWeekDay["Sunday"] = "Sunday";
})(KnownWeekDay || (KnownWeekDay = {}));
/** Known values of {@link ScheduleProvisioningState} that the service accepts. */
export var KnownScheduleProvisioningState;
(function (KnownScheduleProvisioningState) {
    /** Completed */
    KnownScheduleProvisioningState["Completed"] = "Completed";
    /** Provisioning */
    KnownScheduleProvisioningState["Provisioning"] = "Provisioning";
    /** Failed */
    KnownScheduleProvisioningState["Failed"] = "Failed";
})(KnownScheduleProvisioningState || (KnownScheduleProvisioningState = {}));
/** Known values of {@link Autosave} that the service accepts. */
export var KnownAutosave;
(function (KnownAutosave) {
    /** None */
    KnownAutosave["None"] = "None";
    /** Local */
    KnownAutosave["Local"] = "Local";
    /** Remote */
    KnownAutosave["Remote"] = "Remote";
})(KnownAutosave || (KnownAutosave = {}));
/** Known values of {@link Network} that the service accepts. */
export var KnownNetwork;
(function (KnownNetwork) {
    /** Bridge */
    KnownNetwork["Bridge"] = "Bridge";
    /** Host */
    KnownNetwork["Host"] = "Host";
})(KnownNetwork || (KnownNetwork = {}));
/** Known values of {@link Caching} that the service accepts. */
export var KnownCaching;
(function (KnownCaching) {
    /** None */
    KnownCaching["None"] = "None";
    /** ReadOnly */
    KnownCaching["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownCaching["ReadWrite"] = "ReadWrite";
})(KnownCaching || (KnownCaching = {}));
/** Known values of {@link StorageAccountType} that the service accepts. */
export var KnownStorageAccountType;
(function (KnownStorageAccountType) {
    /** StandardLRS */
    KnownStorageAccountType["StandardLRS"] = "Standard_LRS";
    /** PremiumLRS */
    KnownStorageAccountType["PremiumLRS"] = "Premium_LRS";
})(KnownStorageAccountType || (KnownStorageAccountType = {}));
/** Known values of {@link SourceType} that the service accepts. */
export var KnownSourceType;
(function (KnownSourceType) {
    /** Dataset */
    KnownSourceType["Dataset"] = "Dataset";
    /** Datastore */
    KnownSourceType["Datastore"] = "Datastore";
    /** URI */
    KnownSourceType["URI"] = "URI";
})(KnownSourceType || (KnownSourceType = {}));
/** Known values of {@link MountAction} that the service accepts. */
export var KnownMountAction;
(function (KnownMountAction) {
    /** Mount */
    KnownMountAction["Mount"] = "Mount";
    /** Unmount */
    KnownMountAction["Unmount"] = "Unmount";
})(KnownMountAction || (KnownMountAction = {}));
/** Known values of {@link MountState} that the service accepts. */
export var KnownMountState;
(function (KnownMountState) {
    /** MountRequested */
    KnownMountState["MountRequested"] = "MountRequested";
    /** Mounted */
    KnownMountState["Mounted"] = "Mounted";
    /** MountFailed */
    KnownMountState["MountFailed"] = "MountFailed";
    /** UnmountRequested */
    KnownMountState["UnmountRequested"] = "UnmountRequested";
    /** UnmountFailed */
    KnownMountState["UnmountFailed"] = "UnmountFailed";
    /** Unmounted */
    KnownMountState["Unmounted"] = "Unmounted";
})(KnownMountState || (KnownMountState = {}));
/** Known values of {@link InputDeliveryMode} that the service accepts. */
export var KnownInputDeliveryMode;
(function (KnownInputDeliveryMode) {
    /** ReadOnlyMount */
    KnownInputDeliveryMode["ReadOnlyMount"] = "ReadOnlyMount";
    /** ReadWriteMount */
    KnownInputDeliveryMode["ReadWriteMount"] = "ReadWriteMount";
    /** Download */
    KnownInputDeliveryMode["Download"] = "Download";
    /** Direct */
    KnownInputDeliveryMode["Direct"] = "Direct";
    /** EvalMount */
    KnownInputDeliveryMode["EvalMount"] = "EvalMount";
    /** EvalDownload */
    KnownInputDeliveryMode["EvalDownload"] = "EvalDownload";
})(KnownInputDeliveryMode || (KnownInputDeliveryMode = {}));
/** Known values of {@link OutputDeliveryMode} that the service accepts. */
export var KnownOutputDeliveryMode;
(function (KnownOutputDeliveryMode) {
    /** ReadWriteMount */
    KnownOutputDeliveryMode["ReadWriteMount"] = "ReadWriteMount";
    /** Upload */
    KnownOutputDeliveryMode["Upload"] = "Upload";
})(KnownOutputDeliveryMode || (KnownOutputDeliveryMode = {}));
/** Known values of {@link ForecastHorizonMode} that the service accepts. */
export var KnownForecastHorizonMode;
(function (KnownForecastHorizonMode) {
    /** Forecast horizon to be determined automatically. */
    KnownForecastHorizonMode["Auto"] = "Auto";
    /** Use the custom forecast horizon. */
    KnownForecastHorizonMode["Custom"] = "Custom";
})(KnownForecastHorizonMode || (KnownForecastHorizonMode = {}));
/** Known values of {@link JobOutputType} that the service accepts. */
export var KnownJobOutputType;
(function (KnownJobOutputType) {
    /** UriFile */
    KnownJobOutputType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownJobOutputType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownJobOutputType["Mltable"] = "mltable";
    /** CustomModel */
    KnownJobOutputType["CustomModel"] = "custom_model";
    /** MlflowModel */
    KnownJobOutputType["MlflowModel"] = "mlflow_model";
    /** TritonModel */
    KnownJobOutputType["TritonModel"] = "triton_model";
})(KnownJobOutputType || (KnownJobOutputType = {}));
/** Known values of {@link LogVerbosity} that the service accepts. */
export var KnownLogVerbosity;
(function (KnownLogVerbosity) {
    /** No logs emitted. */
    KnownLogVerbosity["NotSet"] = "NotSet";
    /** Debug and above log statements logged. */
    KnownLogVerbosity["Debug"] = "Debug";
    /** Info and above log statements logged. */
    KnownLogVerbosity["Info"] = "Info";
    /** Warning and above log statements logged. */
    KnownLogVerbosity["Warning"] = "Warning";
    /** Error and above log statements logged. */
    KnownLogVerbosity["Error"] = "Error";
    /** Only critical statements logged. */
    KnownLogVerbosity["Critical"] = "Critical";
})(KnownLogVerbosity || (KnownLogVerbosity = {}));
/** Known values of {@link TaskType} that the service accepts. */
export var KnownTaskType;
(function (KnownTaskType) {
    /**
     * Classification in machine learning and statistics is a supervised learning approach in which
     * the computer program learns from the data given to it and make new observations or classifications.
     */
    KnownTaskType["Classification"] = "Classification";
    /** Regression means to predict the value using the input data. Regression models are used to predict a continuous value. */
    KnownTaskType["Regression"] = "Regression";
    /**
     * Forecasting is a special kind of regression task that deals with time-series data and creates forecasting model
     * that can be used to predict the near future values based on the inputs.
     */
    KnownTaskType["Forecasting"] = "Forecasting";
    /**
     * Image Classification. Multi-class image classification is used when an image is classified with only a single label
     * from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
     */
    KnownTaskType["ImageClassification"] = "ImageClassification";
    /**
     * Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
     * from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
     */
    KnownTaskType["ImageClassificationMultilabel"] = "ImageClassificationMultilabel";
    /**
     * Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
     * bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
     */
    KnownTaskType["ImageObjectDetection"] = "ImageObjectDetection";
    /**
     * Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
     * drawing a polygon around each object in the image.
     */
    KnownTaskType["ImageInstanceSegmentation"] = "ImageInstanceSegmentation";
    /**
     * Text classification (also known as text tagging or text categorization) is the process of sorting texts into categories.
     * Categories are mutually exclusive.
     */
    KnownTaskType["TextClassification"] = "TextClassification";
    /** Multilabel classification task assigns each sample to a group (zero or more) of target labels. */
    KnownTaskType["TextClassificationMultilabel"] = "TextClassificationMultilabel";
    /**
     * Text Named Entity Recognition a.k.a. TextNER.
     * Named Entity Recognition (NER) is the ability to take free-form text and identify the occurrences of entities such as people, locations, organizations, and more.
     */
    KnownTaskType["TextNER"] = "TextNER";
})(KnownTaskType || (KnownTaskType = {}));
/** Known values of {@link JobInputType} that the service accepts. */
export var KnownJobInputType;
(function (KnownJobInputType) {
    /** Literal */
    KnownJobInputType["Literal"] = "literal";
    /** UriFile */
    KnownJobInputType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownJobInputType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownJobInputType["Mltable"] = "mltable";
    /** CustomModel */
    KnownJobInputType["CustomModel"] = "custom_model";
    /** MlflowModel */
    KnownJobInputType["MlflowModel"] = "mlflow_model";
    /** TritonModel */
    KnownJobInputType["TritonModel"] = "triton_model";
})(KnownJobInputType || (KnownJobInputType = {}));
/** Known values of {@link NCrossValidationsMode} that the service accepts. */
export var KnownNCrossValidationsMode;
(function (KnownNCrossValidationsMode) {
    /** Determine N-Cross validations value automatically. Supported only for 'Forecasting' AutoML task. */
    KnownNCrossValidationsMode["Auto"] = "Auto";
    /** Use custom N-Cross validations value. */
    KnownNCrossValidationsMode["Custom"] = "Custom";
})(KnownNCrossValidationsMode || (KnownNCrossValidationsMode = {}));
/** Known values of {@link SeasonalityMode} that the service accepts. */
export var KnownSeasonalityMode;
(function (KnownSeasonalityMode) {
    /** Seasonality to be determined automatically. */
    KnownSeasonalityMode["Auto"] = "Auto";
    /** Use the custom seasonality value. */
    KnownSeasonalityMode["Custom"] = "Custom";
})(KnownSeasonalityMode || (KnownSeasonalityMode = {}));
/** Known values of {@link TargetLagsMode} that the service accepts. */
export var KnownTargetLagsMode;
(function (KnownTargetLagsMode) {
    /** Target lags to be determined automatically. */
    KnownTargetLagsMode["Auto"] = "Auto";
    /** Use the custom target lags. */
    KnownTargetLagsMode["Custom"] = "Custom";
})(KnownTargetLagsMode || (KnownTargetLagsMode = {}));
/** Known values of {@link TargetRollingWindowSizeMode} that the service accepts. */
export var KnownTargetRollingWindowSizeMode;
(function (KnownTargetRollingWindowSizeMode) {
    /** Determine rolling windows size automatically. */
    KnownTargetRollingWindowSizeMode["Auto"] = "Auto";
    /** Use the specified rolling window size. */
    KnownTargetRollingWindowSizeMode["Custom"] = "Custom";
})(KnownTargetRollingWindowSizeMode || (KnownTargetRollingWindowSizeMode = {}));
/** Known values of {@link ServiceDataAccessAuthIdentity} that the service accepts. */
export var KnownServiceDataAccessAuthIdentity;
(function (KnownServiceDataAccessAuthIdentity) {
    /** Do not use any identity for service data access. */
    KnownServiceDataAccessAuthIdentity["None"] = "None";
    /** Use the system assigned managed identity of the Workspace to authenticate service data access. */
    KnownServiceDataAccessAuthIdentity["WorkspaceSystemAssignedIdentity"] = "WorkspaceSystemAssignedIdentity";
    /** Use the user assigned managed identity of the Workspace to authenticate service data access. */
    KnownServiceDataAccessAuthIdentity["WorkspaceUserAssignedIdentity"] = "WorkspaceUserAssignedIdentity";
})(KnownServiceDataAccessAuthIdentity || (KnownServiceDataAccessAuthIdentity = {}));
/** Known values of {@link EarlyTerminationPolicyType} that the service accepts. */
export var KnownEarlyTerminationPolicyType;
(function (KnownEarlyTerminationPolicyType) {
    /** Bandit */
    KnownEarlyTerminationPolicyType["Bandit"] = "Bandit";
    /** MedianStopping */
    KnownEarlyTerminationPolicyType["MedianStopping"] = "MedianStopping";
    /** TruncationSelection */
    KnownEarlyTerminationPolicyType["TruncationSelection"] = "TruncationSelection";
})(KnownEarlyTerminationPolicyType || (KnownEarlyTerminationPolicyType = {}));
/** Known values of {@link SamplingAlgorithmType} that the service accepts. */
export var KnownSamplingAlgorithmType;
(function (KnownSamplingAlgorithmType) {
    /** Grid */
    KnownSamplingAlgorithmType["Grid"] = "Grid";
    /** Random */
    KnownSamplingAlgorithmType["Random"] = "Random";
    /** Bayesian */
    KnownSamplingAlgorithmType["Bayesian"] = "Bayesian";
})(KnownSamplingAlgorithmType || (KnownSamplingAlgorithmType = {}));
/** Known values of {@link ClassificationPrimaryMetrics} that the service accepts. */
export var KnownClassificationPrimaryMetrics;
(function (KnownClassificationPrimaryMetrics) {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    KnownClassificationPrimaryMetrics["AUCWeighted"] = "AUCWeighted";
    /** Accuracy is the ratio of predictions that exactly match the true class labels. */
    KnownClassificationPrimaryMetrics["Accuracy"] = "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    KnownClassificationPrimaryMetrics["NormMacroRecall"] = "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    KnownClassificationPrimaryMetrics["AveragePrecisionScoreWeighted"] = "AveragePrecisionScoreWeighted";
    /** The arithmetic mean of precision for each class, weighted by number of true instances in each class. */
    KnownClassificationPrimaryMetrics["PrecisionScoreWeighted"] = "PrecisionScoreWeighted";
})(KnownClassificationPrimaryMetrics || (KnownClassificationPrimaryMetrics = {}));
/** Known values of {@link ClassificationModels} that the service accepts. */
export var KnownClassificationModels;
(function (KnownClassificationModels) {
    /**
     * Logistic regression is a fundamental classification technique.
     * It belongs to the group of linear classifiers and is somewhat similar to polynomial and linear regression.
     * Logistic regression is fast and relatively uncomplicated, and it's convenient for you to interpret the results.
     * Although it's essentially a method for binary classification, it can also be applied to multiclass problems.
     */
    KnownClassificationModels["LogisticRegression"] = "LogisticRegression";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     */
    KnownClassificationModels["SGD"] = "SGD";
    /**
     * The multinomial Naive Bayes classifier is suitable for classification with discrete features (e.g., word counts for text classification).
     * The multinomial distribution normally requires integer feature counts. However, in practice, fractional counts such as tf-idf may also work.
     */
    KnownClassificationModels["MultinomialNaiveBayes"] = "MultinomialNaiveBayes";
    /** Naive Bayes classifier for multivariate Bernoulli models. */
    KnownClassificationModels["BernoulliNaiveBayes"] = "BernoulliNaiveBayes";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     */
    KnownClassificationModels["SVM"] = "SVM";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     * Linear SVM performs best when input data is linear, i.e., data can be easily classified by drawing the straight line between classified values on a plotted graph.
     */
    KnownClassificationModels["LinearSVM"] = "LinearSVM";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownClassificationModels["KNN"] = "KNN";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownClassificationModels["DecisionTree"] = "DecisionTree";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownClassificationModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownClassificationModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownClassificationModels["LightGBM"] = "LightGBM";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownClassificationModels["GradientBoosting"] = "GradientBoosting";
    /** XGBoost: Extreme Gradient Boosting Algorithm. This algorithm is used for structured data where target column values can be divided into distinct class values. */
    KnownClassificationModels["XGBoostClassifier"] = "XGBoostClassifier";
})(KnownClassificationModels || (KnownClassificationModels = {}));
/** Known values of {@link StackMetaLearnerType} that the service accepts. */
export var KnownStackMetaLearnerType;
(function (KnownStackMetaLearnerType) {
    /** None */
    KnownStackMetaLearnerType["None"] = "None";
    /** Default meta-learners are LogisticRegression for classification tasks. */
    KnownStackMetaLearnerType["LogisticRegression"] = "LogisticRegression";
    /** Default meta-learners are LogisticRegression for classification task when CV is on. */
    KnownStackMetaLearnerType["LogisticRegressionCV"] = "LogisticRegressionCV";
    /** LightGBMClassifier */
    KnownStackMetaLearnerType["LightGBMClassifier"] = "LightGBMClassifier";
    /** Default meta-learners are LogisticRegression for regression task. */
    KnownStackMetaLearnerType["ElasticNet"] = "ElasticNet";
    /** Default meta-learners are LogisticRegression for regression task when CV is on. */
    KnownStackMetaLearnerType["ElasticNetCV"] = "ElasticNetCV";
    /** LightGBMRegressor */
    KnownStackMetaLearnerType["LightGBMRegressor"] = "LightGBMRegressor";
    /** LinearRegression */
    KnownStackMetaLearnerType["LinearRegression"] = "LinearRegression";
})(KnownStackMetaLearnerType || (KnownStackMetaLearnerType = {}));
/** Known values of {@link BlockedTransformers} that the service accepts. */
export var KnownBlockedTransformers;
(function (KnownBlockedTransformers) {
    /** Target encoding for text data. */
    KnownBlockedTransformers["TextTargetEncoder"] = "TextTargetEncoder";
    /** Ohe hot encoding creates a binary feature transformation. */
    KnownBlockedTransformers["OneHotEncoder"] = "OneHotEncoder";
    /** Target encoding for categorical data. */
    KnownBlockedTransformers["CatTargetEncoder"] = "CatTargetEncoder";
    /** Tf-Idf stands for, term-frequency times inverse document-frequency. This is a common term weighting scheme for identifying information from documents. */
    KnownBlockedTransformers["TfIdf"] = "TfIdf";
    /** Weight of Evidence encoding is a technique used to encode categorical variables. It uses the natural log of the P(1)/P(0) to create weights. */
    KnownBlockedTransformers["WoETargetEncoder"] = "WoETargetEncoder";
    /** Label encoder converts labels/categorical variables in a numerical form. */
    KnownBlockedTransformers["LabelEncoder"] = "LabelEncoder";
    /** Word embedding helps represents words or phrases as a vector, or a series of numbers. */
    KnownBlockedTransformers["WordEmbedding"] = "WordEmbedding";
    /** Naive Bayes is a classified that is used for classification of discrete features that are categorically distributed. */
    KnownBlockedTransformers["NaiveBayes"] = "NaiveBayes";
    /** Count Vectorizer converts a collection of text documents to a matrix of token counts. */
    KnownBlockedTransformers["CountVectorizer"] = "CountVectorizer";
    /** Hashing One Hot Encoder can turn categorical variables into a limited number of new features. This is often used for high-cardinality categorical features. */
    KnownBlockedTransformers["HashOneHotEncoder"] = "HashOneHotEncoder";
})(KnownBlockedTransformers || (KnownBlockedTransformers = {}));
/** Known values of {@link FeaturizationMode} that the service accepts. */
export var KnownFeaturizationMode;
(function (KnownFeaturizationMode) {
    /** Auto mode, system performs featurization without any custom featurization inputs. */
    KnownFeaturizationMode["Auto"] = "Auto";
    /** Custom featurization. */
    KnownFeaturizationMode["Custom"] = "Custom";
    /** Featurization off. 'Forecasting' task cannot use this value. */
    KnownFeaturizationMode["Off"] = "Off";
})(KnownFeaturizationMode || (KnownFeaturizationMode = {}));
/** Known values of {@link DistributionType} that the service accepts. */
export var KnownDistributionType;
(function (KnownDistributionType) {
    /** PyTorch */
    KnownDistributionType["PyTorch"] = "PyTorch";
    /** TensorFlow */
    KnownDistributionType["TensorFlow"] = "TensorFlow";
    /** Mpi */
    KnownDistributionType["Mpi"] = "Mpi";
})(KnownDistributionType || (KnownDistributionType = {}));
/** Known values of {@link JobLimitsType} that the service accepts. */
export var KnownJobLimitsType;
(function (KnownJobLimitsType) {
    /** Command */
    KnownJobLimitsType["Command"] = "Command";
    /** Sweep */
    KnownJobLimitsType["Sweep"] = "Sweep";
})(KnownJobLimitsType || (KnownJobLimitsType = {}));
/** Known values of {@link FeatureLags} that the service accepts. */
export var KnownFeatureLags;
(function (KnownFeatureLags) {
    /** No feature lags generated. */
    KnownFeatureLags["None"] = "None";
    /** System auto-generates feature lags. */
    KnownFeatureLags["Auto"] = "Auto";
})(KnownFeatureLags || (KnownFeatureLags = {}));
/** Known values of {@link ShortSeriesHandlingConfiguration} that the service accepts. */
export var KnownShortSeriesHandlingConfiguration;
(function (KnownShortSeriesHandlingConfiguration) {
    /** Represents no/null value. */
    KnownShortSeriesHandlingConfiguration["None"] = "None";
    /** Short series will be padded if there are no long series, otherwise short series will be dropped. */
    KnownShortSeriesHandlingConfiguration["Auto"] = "Auto";
    /** All the short series will be padded. */
    KnownShortSeriesHandlingConfiguration["Pad"] = "Pad";
    /** All the short series will be dropped. */
    KnownShortSeriesHandlingConfiguration["Drop"] = "Drop";
})(KnownShortSeriesHandlingConfiguration || (KnownShortSeriesHandlingConfiguration = {}));
/** Known values of {@link TargetAggregationFunction} that the service accepts. */
export var KnownTargetAggregationFunction;
(function (KnownTargetAggregationFunction) {
    /** Represent no value set. */
    KnownTargetAggregationFunction["None"] = "None";
    /** Sum */
    KnownTargetAggregationFunction["Sum"] = "Sum";
    /** Max */
    KnownTargetAggregationFunction["Max"] = "Max";
    /** Min */
    KnownTargetAggregationFunction["Min"] = "Min";
    /** Mean */
    KnownTargetAggregationFunction["Mean"] = "Mean";
})(KnownTargetAggregationFunction || (KnownTargetAggregationFunction = {}));
/** Known values of {@link UseStl} that the service accepts. */
export var KnownUseStl;
(function (KnownUseStl) {
    /** No stl decomposition. */
    KnownUseStl["None"] = "None";
    /** Season */
    KnownUseStl["Season"] = "Season";
    /** SeasonTrend */
    KnownUseStl["SeasonTrend"] = "SeasonTrend";
})(KnownUseStl || (KnownUseStl = {}));
/** Known values of {@link ForecastingPrimaryMetrics} that the service accepts. */
export var KnownForecastingPrimaryMetrics;
(function (KnownForecastingPrimaryMetrics) {
    /** The Spearman's rank coefficient of correlation is a non-parametric measure of rank correlation. */
    KnownForecastingPrimaryMetrics["SpearmanCorrelation"] = "SpearmanCorrelation";
    /** The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales. */
    KnownForecastingPrimaryMetrics["NormalizedRootMeanSquaredError"] = "NormalizedRootMeanSquaredError";
    /** The R2 score is one of the performance evaluation measures for forecasting-based machine learning models. */
    KnownForecastingPrimaryMetrics["R2Score"] = "R2Score";
    /** The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales. */
    KnownForecastingPrimaryMetrics["NormalizedMeanAbsoluteError"] = "NormalizedMeanAbsoluteError";
})(KnownForecastingPrimaryMetrics || (KnownForecastingPrimaryMetrics = {}));
/** Known values of {@link ForecastingModels} that the service accepts. */
export var KnownForecastingModels;
(function (KnownForecastingModels) {
    /**
     * Auto-Autoregressive Integrated Moving Average (ARIMA) model uses time-series data and statistical analysis to interpret the data and make future predictions.
     * This model aims to explain data by using time series data on its past values and uses linear regression to make predictions.
     */
    KnownForecastingModels["AutoArima"] = "AutoArima";
    /**
     * Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects.
     * It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.
     */
    KnownForecastingModels["Prophet"] = "Prophet";
    /** The Naive forecasting model makes predictions by carrying forward the latest target value for each time-series in the training data. */
    KnownForecastingModels["Naive"] = "Naive";
    /** The Seasonal Naive forecasting model makes predictions by carrying forward the latest season of target values for each time-series in the training data. */
    KnownForecastingModels["SeasonalNaive"] = "SeasonalNaive";
    /** The Average forecasting model makes predictions by carrying forward the average of the target values for each time-series in the training data. */
    KnownForecastingModels["Average"] = "Average";
    /** The Seasonal Average forecasting model makes predictions by carrying forward the average value of the latest season of data for each time-series in the training data. */
    KnownForecastingModels["SeasonalAverage"] = "SeasonalAverage";
    /** Exponential smoothing is a time series forecasting method for univariate data that can be extended to support data with a systematic trend or seasonal component. */
    KnownForecastingModels["ExponentialSmoothing"] = "ExponentialSmoothing";
    /**
     * An Autoregressive Integrated Moving Average with Explanatory Variable (ARIMAX) model can be viewed as a multiple regression model with one or more autoregressive (AR) terms and/or one or more moving average (MA) terms.
     * This method is suitable for forecasting when data is stationary/non stationary, and multivariate with any type of data pattern, i.e., level/trend /seasonality/cyclicity.
     */
    KnownForecastingModels["Arimax"] = "Arimax";
    /** TCNForecaster: Temporal Convolutional Networks Forecaster. //TODO: Ask forecasting team for brief intro. */
    KnownForecastingModels["TCNForecaster"] = "TCNForecaster";
    /** Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions. */
    KnownForecastingModels["ElasticNet"] = "ElasticNet";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownForecastingModels["GradientBoosting"] = "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownForecastingModels["DecisionTree"] = "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownForecastingModels["KNN"] = "KNN";
    /** Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer. */
    KnownForecastingModels["LassoLars"] = "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    KnownForecastingModels["SGD"] = "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownForecastingModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownForecastingModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownForecastingModels["LightGBM"] = "LightGBM";
    /** XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners. */
    KnownForecastingModels["XGBoostRegressor"] = "XGBoostRegressor";
})(KnownForecastingModels || (KnownForecastingModels = {}));
/** Known values of {@link LearningRateScheduler} that the service accepts. */
export var KnownLearningRateScheduler;
(function (KnownLearningRateScheduler) {
    /** No learning rate scheduler selected. */
    KnownLearningRateScheduler["None"] = "None";
    /** Cosine Annealing With Warmup. */
    KnownLearningRateScheduler["WarmupCosine"] = "WarmupCosine";
    /** Step learning rate scheduler. */
    KnownLearningRateScheduler["Step"] = "Step";
})(KnownLearningRateScheduler || (KnownLearningRateScheduler = {}));
/** Known values of {@link StochasticOptimizer} that the service accepts. */
export var KnownStochasticOptimizer;
(function (KnownStochasticOptimizer) {
    /** No optimizer selected. */
    KnownStochasticOptimizer["None"] = "None";
    /** Stochastic Gradient Descent optimizer. */
    KnownStochasticOptimizer["Sgd"] = "Sgd";
    /** Adam is algorithm the optimizes stochastic objective functions based on adaptive estimates of moments */
    KnownStochasticOptimizer["Adam"] = "Adam";
    /** AdamW is a variant of the optimizer Adam that has an improved implementation of weight decay. */
    KnownStochasticOptimizer["Adamw"] = "Adamw";
})(KnownStochasticOptimizer || (KnownStochasticOptimizer = {}));
/** Known values of {@link ClassificationMultilabelPrimaryMetrics} that the service accepts. */
export var KnownClassificationMultilabelPrimaryMetrics;
(function (KnownClassificationMultilabelPrimaryMetrics) {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    KnownClassificationMultilabelPrimaryMetrics["AUCWeighted"] = "AUCWeighted";
    /** Accuracy is the ratio of predictions that exactly match the true class labels. */
    KnownClassificationMultilabelPrimaryMetrics["Accuracy"] = "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    KnownClassificationMultilabelPrimaryMetrics["NormMacroRecall"] = "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    KnownClassificationMultilabelPrimaryMetrics["AveragePrecisionScoreWeighted"] = "AveragePrecisionScoreWeighted";
    /** The arithmetic mean of precision for each class, weighted by number of true instances in each class. */
    KnownClassificationMultilabelPrimaryMetrics["PrecisionScoreWeighted"] = "PrecisionScoreWeighted";
    /** Intersection Over Union. Intersection of predictions divided by union of predictions. */
    KnownClassificationMultilabelPrimaryMetrics["IOU"] = "IOU";
})(KnownClassificationMultilabelPrimaryMetrics || (KnownClassificationMultilabelPrimaryMetrics = {}));
/** Known values of {@link InstanceSegmentationPrimaryMetrics} that the service accepts. */
export var KnownInstanceSegmentationPrimaryMetrics;
(function (KnownInstanceSegmentationPrimaryMetrics) {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    KnownInstanceSegmentationPrimaryMetrics["MeanAveragePrecision"] = "MeanAveragePrecision";
})(KnownInstanceSegmentationPrimaryMetrics || (KnownInstanceSegmentationPrimaryMetrics = {}));
/** Known values of {@link ModelSize} that the service accepts. */
export var KnownModelSize;
(function (KnownModelSize) {
    /** No value selected. */
    KnownModelSize["None"] = "None";
    /** Small size. */
    KnownModelSize["Small"] = "Small";
    /** Medium size. */
    KnownModelSize["Medium"] = "Medium";
    /** Large size. */
    KnownModelSize["Large"] = "Large";
    /** Extra large size. */
    KnownModelSize["ExtraLarge"] = "ExtraLarge";
})(KnownModelSize || (KnownModelSize = {}));
/** Known values of {@link ValidationMetricType} that the service accepts. */
export var KnownValidationMetricType;
(function (KnownValidationMetricType) {
    /** No metric. */
    KnownValidationMetricType["None"] = "None";
    /** Coco metric. */
    KnownValidationMetricType["Coco"] = "Coco";
    /** Voc metric. */
    KnownValidationMetricType["Voc"] = "Voc";
    /** CocoVoc metric. */
    KnownValidationMetricType["CocoVoc"] = "CocoVoc";
})(KnownValidationMetricType || (KnownValidationMetricType = {}));
/** Known values of {@link ObjectDetectionPrimaryMetrics} that the service accepts. */
export var KnownObjectDetectionPrimaryMetrics;
(function (KnownObjectDetectionPrimaryMetrics) {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    KnownObjectDetectionPrimaryMetrics["MeanAveragePrecision"] = "MeanAveragePrecision";
})(KnownObjectDetectionPrimaryMetrics || (KnownObjectDetectionPrimaryMetrics = {}));
/** Known values of {@link Goal} that the service accepts. */
export var KnownGoal;
(function (KnownGoal) {
    /** Minimize */
    KnownGoal["Minimize"] = "Minimize";
    /** Maximize */
    KnownGoal["Maximize"] = "Maximize";
})(KnownGoal || (KnownGoal = {}));
/** Known values of {@link RandomSamplingAlgorithmRule} that the service accepts. */
export var KnownRandomSamplingAlgorithmRule;
(function (KnownRandomSamplingAlgorithmRule) {
    /** Random */
    KnownRandomSamplingAlgorithmRule["Random"] = "Random";
    /** Sobol */
    KnownRandomSamplingAlgorithmRule["Sobol"] = "Sobol";
})(KnownRandomSamplingAlgorithmRule || (KnownRandomSamplingAlgorithmRule = {}));
/** Known values of {@link RegressionPrimaryMetrics} that the service accepts. */
export var KnownRegressionPrimaryMetrics;
(function (KnownRegressionPrimaryMetrics) {
    /** The Spearman's rank coefficient of correlation is a nonparametric measure of rank correlation. */
    KnownRegressionPrimaryMetrics["SpearmanCorrelation"] = "SpearmanCorrelation";
    /** The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales. */
    KnownRegressionPrimaryMetrics["NormalizedRootMeanSquaredError"] = "NormalizedRootMeanSquaredError";
    /** The R2 score is one of the performance evaluation measures for forecasting-based machine learning models. */
    KnownRegressionPrimaryMetrics["R2Score"] = "R2Score";
    /** The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales. */
    KnownRegressionPrimaryMetrics["NormalizedMeanAbsoluteError"] = "NormalizedMeanAbsoluteError";
})(KnownRegressionPrimaryMetrics || (KnownRegressionPrimaryMetrics = {}));
/** Known values of {@link RegressionModels} that the service accepts. */
export var KnownRegressionModels;
(function (KnownRegressionModels) {
    /** Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions. */
    KnownRegressionModels["ElasticNet"] = "ElasticNet";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownRegressionModels["GradientBoosting"] = "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownRegressionModels["DecisionTree"] = "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownRegressionModels["KNN"] = "KNN";
    /** Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer. */
    KnownRegressionModels["LassoLars"] = "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    KnownRegressionModels["SGD"] = "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownRegressionModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownRegressionModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownRegressionModels["LightGBM"] = "LightGBM";
    /** XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners. */
    KnownRegressionModels["XGBoostRegressor"] = "XGBoostRegressor";
})(KnownRegressionModels || (KnownRegressionModels = {}));
//# sourceMappingURL=index.js.map