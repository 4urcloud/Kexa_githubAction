'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Unknown */
    KnownProvisioningState["Unknown"] = "Unknown";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Creating */
    KnownProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link EncryptionStatus} that the service accepts. */
exports.KnownEncryptionStatus = void 0;
(function (KnownEncryptionStatus) {
    /** Enabled */
    KnownEncryptionStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownEncryptionStatus["Disabled"] = "Disabled";
})(exports.KnownEncryptionStatus || (exports.KnownEncryptionStatus = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    /** Pending */
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateEndpointServiceConnectionStatus["Disconnected"] = "Disconnected";
    /** Timeout */
    KnownPrivateEndpointServiceConnectionStatus["Timeout"] = "Timeout";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DiagnoseResultLevel} that the service accepts. */
exports.KnownDiagnoseResultLevel = void 0;
(function (KnownDiagnoseResultLevel) {
    /** Warning */
    KnownDiagnoseResultLevel["Warning"] = "Warning";
    /** Error */
    KnownDiagnoseResultLevel["Error"] = "Error";
    /** Information */
    KnownDiagnoseResultLevel["Information"] = "Information";
})(exports.KnownDiagnoseResultLevel || (exports.KnownDiagnoseResultLevel = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
exports.KnownUsageUnit = void 0;
(function (KnownUsageUnit) {
    /** Count */
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));
/** Known values of {@link BillingCurrency} that the service accepts. */
exports.KnownBillingCurrency = void 0;
(function (KnownBillingCurrency) {
    /** USD */
    KnownBillingCurrency["USD"] = "USD";
})(exports.KnownBillingCurrency || (exports.KnownBillingCurrency = {}));
/** Known values of {@link UnitOfMeasure} that the service accepts. */
exports.KnownUnitOfMeasure = void 0;
(function (KnownUnitOfMeasure) {
    /** OneHour */
    KnownUnitOfMeasure["OneHour"] = "OneHour";
})(exports.KnownUnitOfMeasure || (exports.KnownUnitOfMeasure = {}));
/** Known values of {@link VMPriceOSType} that the service accepts. */
exports.KnownVMPriceOSType = void 0;
(function (KnownVMPriceOSType) {
    /** Linux */
    KnownVMPriceOSType["Linux"] = "Linux";
    /** Windows */
    KnownVMPriceOSType["Windows"] = "Windows";
})(exports.KnownVMPriceOSType || (exports.KnownVMPriceOSType = {}));
/** Known values of {@link VMTier} that the service accepts. */
exports.KnownVMTier = void 0;
(function (KnownVMTier) {
    /** Standard */
    KnownVMTier["Standard"] = "Standard";
    /** LowPriority */
    KnownVMTier["LowPriority"] = "LowPriority";
    /** Spot */
    KnownVMTier["Spot"] = "Spot";
})(exports.KnownVMTier || (exports.KnownVMTier = {}));
/** Known values of {@link QuotaUnit} that the service accepts. */
exports.KnownQuotaUnit = void 0;
(function (KnownQuotaUnit) {
    /** Count */
    KnownQuotaUnit["Count"] = "Count";
})(exports.KnownQuotaUnit || (exports.KnownQuotaUnit = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** Undefined */
    KnownStatus["Undefined"] = "Undefined";
    /** Success */
    KnownStatus["Success"] = "Success";
    /** Failure */
    KnownStatus["Failure"] = "Failure";
    /** InvalidQuotaBelowClusterMinimum */
    KnownStatus["InvalidQuotaBelowClusterMinimum"] = "InvalidQuotaBelowClusterMinimum";
    /** InvalidQuotaExceedsSubscriptionLimit */
    KnownStatus["InvalidQuotaExceedsSubscriptionLimit"] = "InvalidQuotaExceedsSubscriptionLimit";
    /** InvalidVMFamilyName */
    KnownStatus["InvalidVMFamilyName"] = "InvalidVMFamilyName";
    /** OperationNotSupportedForSku */
    KnownStatus["OperationNotSupportedForSku"] = "OperationNotSupportedForSku";
    /** OperationNotEnabledForRegion */
    KnownStatus["OperationNotEnabledForRegion"] = "OperationNotEnabledForRegion";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link ComputeType} that the service accepts. */
exports.KnownComputeType = void 0;
(function (KnownComputeType) {
    /** AKS */
    KnownComputeType["AKS"] = "AKS";
    /** Kubernetes */
    KnownComputeType["Kubernetes"] = "Kubernetes";
    /** AmlCompute */
    KnownComputeType["AmlCompute"] = "AmlCompute";
    /** ComputeInstance */
    KnownComputeType["ComputeInstance"] = "ComputeInstance";
    /** DataFactory */
    KnownComputeType["DataFactory"] = "DataFactory";
    /** VirtualMachine */
    KnownComputeType["VirtualMachine"] = "VirtualMachine";
    /** HDInsight */
    KnownComputeType["HDInsight"] = "HDInsight";
    /** Databricks */
    KnownComputeType["Databricks"] = "Databricks";
    /** DataLakeAnalytics */
    KnownComputeType["DataLakeAnalytics"] = "DataLakeAnalytics";
    /** SynapseSpark */
    KnownComputeType["SynapseSpark"] = "SynapseSpark";
})(exports.KnownComputeType || (exports.KnownComputeType = {}));
/** Known values of {@link UnderlyingResourceAction} that the service accepts. */
exports.KnownUnderlyingResourceAction = void 0;
(function (KnownUnderlyingResourceAction) {
    /** Delete */
    KnownUnderlyingResourceAction["Delete"] = "Delete";
    /** Detach */
    KnownUnderlyingResourceAction["Detach"] = "Detach";
})(exports.KnownUnderlyingResourceAction || (exports.KnownUnderlyingResourceAction = {}));
/** Known values of {@link NodeState} that the service accepts. */
exports.KnownNodeState = void 0;
(function (KnownNodeState) {
    /** Idle */
    KnownNodeState["Idle"] = "idle";
    /** Running */
    KnownNodeState["Running"] = "running";
    /** Preparing */
    KnownNodeState["Preparing"] = "preparing";
    /** Unusable */
    KnownNodeState["Unusable"] = "unusable";
    /** Leaving */
    KnownNodeState["Leaving"] = "leaving";
    /** Preempted */
    KnownNodeState["Preempted"] = "preempted";
})(exports.KnownNodeState || (exports.KnownNodeState = {}));
/** Known values of {@link ConnectionAuthType} that the service accepts. */
exports.KnownConnectionAuthType = void 0;
(function (KnownConnectionAuthType) {
    /** PAT */
    KnownConnectionAuthType["PAT"] = "PAT";
    /** ManagedIdentity */
    KnownConnectionAuthType["ManagedIdentity"] = "ManagedIdentity";
    /** UsernamePassword */
    KnownConnectionAuthType["UsernamePassword"] = "UsernamePassword";
    /** None */
    KnownConnectionAuthType["None"] = "None";
    /** SAS */
    KnownConnectionAuthType["SAS"] = "SAS";
})(exports.KnownConnectionAuthType || (exports.KnownConnectionAuthType = {}));
/** Known values of {@link ConnectionCategory} that the service accepts. */
exports.KnownConnectionCategory = void 0;
(function (KnownConnectionCategory) {
    /** PythonFeed */
    KnownConnectionCategory["PythonFeed"] = "PythonFeed";
    /** ContainerRegistry */
    KnownConnectionCategory["ContainerRegistry"] = "ContainerRegistry";
    /** Git */
    KnownConnectionCategory["Git"] = "Git";
})(exports.KnownConnectionCategory || (exports.KnownConnectionCategory = {}));
/** Known values of {@link ValueFormat} that the service accepts. */
exports.KnownValueFormat = void 0;
(function (KnownValueFormat) {
    /** Json */
    KnownValueFormat["Json"] = "JSON";
})(exports.KnownValueFormat || (exports.KnownValueFormat = {}));
/** Known values of {@link EndpointProvisioningState} that the service accepts. */
exports.KnownEndpointProvisioningState = void 0;
(function (KnownEndpointProvisioningState) {
    /** Creating */
    KnownEndpointProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownEndpointProvisioningState["Deleting"] = "Deleting";
    /** Succeeded */
    KnownEndpointProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownEndpointProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownEndpointProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownEndpointProvisioningState["Canceled"] = "Canceled";
})(exports.KnownEndpointProvisioningState || (exports.KnownEndpointProvisioningState = {}));
/** Known values of {@link EndpointAuthMode} that the service accepts. */
exports.KnownEndpointAuthMode = void 0;
(function (KnownEndpointAuthMode) {
    /** AMLToken */
    KnownEndpointAuthMode["AMLToken"] = "AMLToken";
    /** Key */
    KnownEndpointAuthMode["Key"] = "Key";
    /** AADToken */
    KnownEndpointAuthMode["AADToken"] = "AADToken";
})(exports.KnownEndpointAuthMode || (exports.KnownEndpointAuthMode = {}));
/** Known values of {@link BatchLoggingLevel} that the service accepts. */
exports.KnownBatchLoggingLevel = void 0;
(function (KnownBatchLoggingLevel) {
    /** Info */
    KnownBatchLoggingLevel["Info"] = "Info";
    /** Warning */
    KnownBatchLoggingLevel["Warning"] = "Warning";
    /** Debug */
    KnownBatchLoggingLevel["Debug"] = "Debug";
})(exports.KnownBatchLoggingLevel || (exports.KnownBatchLoggingLevel = {}));
/** Known values of {@link ReferenceType} that the service accepts. */
exports.KnownReferenceType = void 0;
(function (KnownReferenceType) {
    /** Id */
    KnownReferenceType["Id"] = "Id";
    /** DataPath */
    KnownReferenceType["DataPath"] = "DataPath";
    /** OutputPath */
    KnownReferenceType["OutputPath"] = "OutputPath";
})(exports.KnownReferenceType || (exports.KnownReferenceType = {}));
/** Known values of {@link BatchOutputAction} that the service accepts. */
exports.KnownBatchOutputAction = void 0;
(function (KnownBatchOutputAction) {
    /** SummaryOnly */
    KnownBatchOutputAction["SummaryOnly"] = "SummaryOnly";
    /** AppendRow */
    KnownBatchOutputAction["AppendRow"] = "AppendRow";
})(exports.KnownBatchOutputAction || (exports.KnownBatchOutputAction = {}));
/** Known values of {@link DeploymentProvisioningState} that the service accepts. */
exports.KnownDeploymentProvisioningState = void 0;
(function (KnownDeploymentProvisioningState) {
    /** Creating */
    KnownDeploymentProvisioningState["Creating"] = "Creating";
    /** Deleting */
    KnownDeploymentProvisioningState["Deleting"] = "Deleting";
    /** Scaling */
    KnownDeploymentProvisioningState["Scaling"] = "Scaling";
    /** Updating */
    KnownDeploymentProvisioningState["Updating"] = "Updating";
    /** Succeeded */
    KnownDeploymentProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownDeploymentProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownDeploymentProvisioningState["Canceled"] = "Canceled";
})(exports.KnownDeploymentProvisioningState || (exports.KnownDeploymentProvisioningState = {}));
/** Known values of {@link ListViewType} that the service accepts. */
exports.KnownListViewType = void 0;
(function (KnownListViewType) {
    /** ActiveOnly */
    KnownListViewType["ActiveOnly"] = "ActiveOnly";
    /** ArchivedOnly */
    KnownListViewType["ArchivedOnly"] = "ArchivedOnly";
    /** All */
    KnownListViewType["All"] = "All";
})(exports.KnownListViewType || (exports.KnownListViewType = {}));
/** Known values of {@link DataType} that the service accepts. */
exports.KnownDataType = void 0;
(function (KnownDataType) {
    /** UriFile */
    KnownDataType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownDataType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownDataType["Mltable"] = "mltable";
})(exports.KnownDataType || (exports.KnownDataType = {}));
/** Known values of {@link CredentialsType} that the service accepts. */
exports.KnownCredentialsType = void 0;
(function (KnownCredentialsType) {
    /** AccountKey */
    KnownCredentialsType["AccountKey"] = "AccountKey";
    /** Certificate */
    KnownCredentialsType["Certificate"] = "Certificate";
    /** None */
    KnownCredentialsType["None"] = "None";
    /** Sas */
    KnownCredentialsType["Sas"] = "Sas";
    /** ServicePrincipal */
    KnownCredentialsType["ServicePrincipal"] = "ServicePrincipal";
})(exports.KnownCredentialsType || (exports.KnownCredentialsType = {}));
/** Known values of {@link DatastoreType} that the service accepts. */
exports.KnownDatastoreType = void 0;
(function (KnownDatastoreType) {
    /** AzureBlob */
    KnownDatastoreType["AzureBlob"] = "AzureBlob";
    /** AzureDataLakeGen1 */
    KnownDatastoreType["AzureDataLakeGen1"] = "AzureDataLakeGen1";
    /** AzureDataLakeGen2 */
    KnownDatastoreType["AzureDataLakeGen2"] = "AzureDataLakeGen2";
    /** AzureFile */
    KnownDatastoreType["AzureFile"] = "AzureFile";
})(exports.KnownDatastoreType || (exports.KnownDatastoreType = {}));
/** Known values of {@link SecretsType} that the service accepts. */
exports.KnownSecretsType = void 0;
(function (KnownSecretsType) {
    /** AccountKey */
    KnownSecretsType["AccountKey"] = "AccountKey";
    /** Certificate */
    KnownSecretsType["Certificate"] = "Certificate";
    /** Sas */
    KnownSecretsType["Sas"] = "Sas";
    /** ServicePrincipal */
    KnownSecretsType["ServicePrincipal"] = "ServicePrincipal";
})(exports.KnownSecretsType || (exports.KnownSecretsType = {}));
/** Known values of {@link AutoRebuildSetting} that the service accepts. */
exports.KnownAutoRebuildSetting = void 0;
(function (KnownAutoRebuildSetting) {
    /** Disabled */
    KnownAutoRebuildSetting["Disabled"] = "Disabled";
    /** OnBaseImageUpdate */
    KnownAutoRebuildSetting["OnBaseImageUpdate"] = "OnBaseImageUpdate";
})(exports.KnownAutoRebuildSetting || (exports.KnownAutoRebuildSetting = {}));
/** Known values of {@link EnvironmentType} that the service accepts. */
exports.KnownEnvironmentType = void 0;
(function (KnownEnvironmentType) {
    /** Curated */
    KnownEnvironmentType["Curated"] = "Curated";
    /** UserCreated */
    KnownEnvironmentType["UserCreated"] = "UserCreated";
})(exports.KnownEnvironmentType || (exports.KnownEnvironmentType = {}));
/** Known values of {@link OperatingSystemType} that the service accepts. */
exports.KnownOperatingSystemType = void 0;
(function (KnownOperatingSystemType) {
    /** Linux */
    KnownOperatingSystemType["Linux"] = "Linux";
    /** Windows */
    KnownOperatingSystemType["Windows"] = "Windows";
})(exports.KnownOperatingSystemType || (exports.KnownOperatingSystemType = {}));
/** Known values of {@link IdentityConfigurationType} that the service accepts. */
exports.KnownIdentityConfigurationType = void 0;
(function (KnownIdentityConfigurationType) {
    /** Managed */
    KnownIdentityConfigurationType["Managed"] = "Managed";
    /** AMLToken */
    KnownIdentityConfigurationType["AMLToken"] = "AMLToken";
    /** UserIdentity */
    KnownIdentityConfigurationType["UserIdentity"] = "UserIdentity";
})(exports.KnownIdentityConfigurationType || (exports.KnownIdentityConfigurationType = {}));
/** Known values of {@link JobType} that the service accepts. */
exports.KnownJobType = void 0;
(function (KnownJobType) {
    /** AutoML */
    KnownJobType["AutoML"] = "AutoML";
    /** Command */
    KnownJobType["Command"] = "Command";
    /** Sweep */
    KnownJobType["Sweep"] = "Sweep";
    /** Pipeline */
    KnownJobType["Pipeline"] = "Pipeline";
})(exports.KnownJobType || (exports.KnownJobType = {}));
/** Known values of {@link JobStatus} that the service accepts. */
exports.KnownJobStatus = void 0;
(function (KnownJobStatus) {
    /** Run hasn't started yet. */
    KnownJobStatus["NotStarted"] = "NotStarted";
    /** Run has started. The user has a run ID. */
    KnownJobStatus["Starting"] = "Starting";
    /** (Not used currently) It will be used if ES is creating the compute target. */
    KnownJobStatus["Provisioning"] = "Provisioning";
    /** The run environment is being prepared. */
    KnownJobStatus["Preparing"] = "Preparing";
    /** The job is queued in the compute target. For example, in BatchAI the job is in queued state, while waiting for all required nodes to be ready. */
    KnownJobStatus["Queued"] = "Queued";
    /** The job started to run in the compute target. */
    KnownJobStatus["Running"] = "Running";
    /** Job is completed in the target. It is in output collection state now. */
    KnownJobStatus["Finalizing"] = "Finalizing";
    /** Cancellation has been requested for the job. */
    KnownJobStatus["CancelRequested"] = "CancelRequested";
    /** Job completed successfully. This reflects that both the job itself and output collection states completed successfully */
    KnownJobStatus["Completed"] = "Completed";
    /** Job failed. */
    KnownJobStatus["Failed"] = "Failed";
    /** Following cancellation request, the job is now successfully canceled. */
    KnownJobStatus["Canceled"] = "Canceled";
    /**
     * When heartbeat is enabled, if the run isn't updating any information to RunHistory then the run goes to NotResponding state.
     * NotResponding is the only state that is exempt from strict transition orders. A run can go from NotResponding to any of the previous states.
     */
    KnownJobStatus["NotResponding"] = "NotResponding";
    /** The job is paused by users. Some adjustment to labeling jobs can be made only in paused state. */
    KnownJobStatus["Paused"] = "Paused";
    /** Default job status if not mapped to all other statuses */
    KnownJobStatus["Unknown"] = "Unknown";
})(exports.KnownJobStatus || (exports.KnownJobStatus = {}));
/** Known values of {@link EndpointComputeType} that the service accepts. */
exports.KnownEndpointComputeType = void 0;
(function (KnownEndpointComputeType) {
    /** Managed */
    KnownEndpointComputeType["Managed"] = "Managed";
    /** Kubernetes */
    KnownEndpointComputeType["Kubernetes"] = "Kubernetes";
    /** AzureMLCompute */
    KnownEndpointComputeType["AzureMLCompute"] = "AzureMLCompute";
})(exports.KnownEndpointComputeType || (exports.KnownEndpointComputeType = {}));
/** Known values of {@link OrderString} that the service accepts. */
exports.KnownOrderString = void 0;
(function (KnownOrderString) {
    /** CreatedAtDesc */
    KnownOrderString["CreatedAtDesc"] = "CreatedAtDesc";
    /** CreatedAtAsc */
    KnownOrderString["CreatedAtAsc"] = "CreatedAtAsc";
    /** UpdatedAtDesc */
    KnownOrderString["UpdatedAtDesc"] = "UpdatedAtDesc";
    /** UpdatedAtAsc */
    KnownOrderString["UpdatedAtAsc"] = "UpdatedAtAsc";
})(exports.KnownOrderString || (exports.KnownOrderString = {}));
/** Known values of {@link PublicNetworkAccessType} that the service accepts. */
exports.KnownPublicNetworkAccessType = void 0;
(function (KnownPublicNetworkAccessType) {
    /** Enabled */
    KnownPublicNetworkAccessType["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccessType["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccessType || (exports.KnownPublicNetworkAccessType = {}));
/** Known values of {@link EgressPublicNetworkAccessType} that the service accepts. */
exports.KnownEgressPublicNetworkAccessType = void 0;
(function (KnownEgressPublicNetworkAccessType) {
    /** Enabled */
    KnownEgressPublicNetworkAccessType["Enabled"] = "Enabled";
    /** Disabled */
    KnownEgressPublicNetworkAccessType["Disabled"] = "Disabled";
})(exports.KnownEgressPublicNetworkAccessType || (exports.KnownEgressPublicNetworkAccessType = {}));
/** Known values of {@link ScaleType} that the service accepts. */
exports.KnownScaleType = void 0;
(function (KnownScaleType) {
    /** Default */
    KnownScaleType["Default"] = "Default";
    /** TargetUtilization */
    KnownScaleType["TargetUtilization"] = "TargetUtilization";
})(exports.KnownScaleType || (exports.KnownScaleType = {}));
/** Known values of {@link ContainerType} that the service accepts. */
exports.KnownContainerType = void 0;
(function (KnownContainerType) {
    /** StorageInitializer */
    KnownContainerType["StorageInitializer"] = "StorageInitializer";
    /** InferenceServer */
    KnownContainerType["InferenceServer"] = "InferenceServer";
})(exports.KnownContainerType || (exports.KnownContainerType = {}));
/** Known values of {@link SkuScaleType} that the service accepts. */
exports.KnownSkuScaleType = void 0;
(function (KnownSkuScaleType) {
    /** Automatically scales node count. */
    KnownSkuScaleType["Automatic"] = "Automatic";
    /** Node count scaled upon user request. */
    KnownSkuScaleType["Manual"] = "Manual";
    /** Fixed set of nodes. */
    KnownSkuScaleType["None"] = "None";
})(exports.KnownSkuScaleType || (exports.KnownSkuScaleType = {}));
/** Known values of {@link KeyType} that the service accepts. */
exports.KnownKeyType = void 0;
(function (KnownKeyType) {
    /** Primary */
    KnownKeyType["Primary"] = "Primary";
    /** Secondary */
    KnownKeyType["Secondary"] = "Secondary";
})(exports.KnownKeyType || (exports.KnownKeyType = {}));
/** Known values of {@link ScheduleListViewType} that the service accepts. */
exports.KnownScheduleListViewType = void 0;
(function (KnownScheduleListViewType) {
    /** EnabledOnly */
    KnownScheduleListViewType["EnabledOnly"] = "EnabledOnly";
    /** DisabledOnly */
    KnownScheduleListViewType["DisabledOnly"] = "DisabledOnly";
    /** All */
    KnownScheduleListViewType["All"] = "All";
})(exports.KnownScheduleListViewType || (exports.KnownScheduleListViewType = {}));
/** Known values of {@link ScheduleActionType} that the service accepts. */
exports.KnownScheduleActionType = void 0;
(function (KnownScheduleActionType) {
    /** CreateJob */
    KnownScheduleActionType["CreateJob"] = "CreateJob";
    /** InvokeBatchEndpoint */
    KnownScheduleActionType["InvokeBatchEndpoint"] = "InvokeBatchEndpoint";
})(exports.KnownScheduleActionType || (exports.KnownScheduleActionType = {}));
/** Known values of {@link ScheduleProvisioningStatus} that the service accepts. */
exports.KnownScheduleProvisioningStatus = void 0;
(function (KnownScheduleProvisioningStatus) {
    /** Creating */
    KnownScheduleProvisioningStatus["Creating"] = "Creating";
    /** Updating */
    KnownScheduleProvisioningStatus["Updating"] = "Updating";
    /** Deleting */
    KnownScheduleProvisioningStatus["Deleting"] = "Deleting";
    /** Succeeded */
    KnownScheduleProvisioningStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownScheduleProvisioningStatus["Failed"] = "Failed";
    /** Canceled */
    KnownScheduleProvisioningStatus["Canceled"] = "Canceled";
})(exports.KnownScheduleProvisioningStatus || (exports.KnownScheduleProvisioningStatus = {}));
/** Known values of {@link TriggerType} that the service accepts. */
exports.KnownTriggerType = void 0;
(function (KnownTriggerType) {
    /** Recurrence */
    KnownTriggerType["Recurrence"] = "Recurrence";
    /** Cron */
    KnownTriggerType["Cron"] = "Cron";
})(exports.KnownTriggerType || (exports.KnownTriggerType = {}));
/** Known values of {@link ClusterPurpose} that the service accepts. */
exports.KnownClusterPurpose = void 0;
(function (KnownClusterPurpose) {
    /** FastProd */
    KnownClusterPurpose["FastProd"] = "FastProd";
    /** DenseProd */
    KnownClusterPurpose["DenseProd"] = "DenseProd";
    /** DevTest */
    KnownClusterPurpose["DevTest"] = "DevTest";
})(exports.KnownClusterPurpose || (exports.KnownClusterPurpose = {}));
/** Known values of {@link SslConfigStatus} that the service accepts. */
exports.KnownSslConfigStatus = void 0;
(function (KnownSslConfigStatus) {
    /** Disabled */
    KnownSslConfigStatus["Disabled"] = "Disabled";
    /** Enabled */
    KnownSslConfigStatus["Enabled"] = "Enabled";
    /** Auto */
    KnownSslConfigStatus["Auto"] = "Auto";
})(exports.KnownSslConfigStatus || (exports.KnownSslConfigStatus = {}));
/** Known values of {@link LoadBalancerType} that the service accepts. */
exports.KnownLoadBalancerType = void 0;
(function (KnownLoadBalancerType) {
    /** PublicIp */
    KnownLoadBalancerType["PublicIp"] = "PublicIp";
    /** InternalLoadBalancer */
    KnownLoadBalancerType["InternalLoadBalancer"] = "InternalLoadBalancer";
})(exports.KnownLoadBalancerType || (exports.KnownLoadBalancerType = {}));
/** Known values of {@link OsType} that the service accepts. */
exports.KnownOsType = void 0;
(function (KnownOsType) {
    /** Linux */
    KnownOsType["Linux"] = "Linux";
    /** Windows */
    KnownOsType["Windows"] = "Windows";
})(exports.KnownOsType || (exports.KnownOsType = {}));
/** Known values of {@link VmPriority} that the service accepts. */
exports.KnownVmPriority = void 0;
(function (KnownVmPriority) {
    /** Dedicated */
    KnownVmPriority["Dedicated"] = "Dedicated";
    /** LowPriority */
    KnownVmPriority["LowPriority"] = "LowPriority";
})(exports.KnownVmPriority || (exports.KnownVmPriority = {}));
/** Known values of {@link RemoteLoginPortPublicAccess} that the service accepts. */
exports.KnownRemoteLoginPortPublicAccess = void 0;
(function (KnownRemoteLoginPortPublicAccess) {
    /** Enabled */
    KnownRemoteLoginPortPublicAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownRemoteLoginPortPublicAccess["Disabled"] = "Disabled";
    /** NotSpecified */
    KnownRemoteLoginPortPublicAccess["NotSpecified"] = "NotSpecified";
})(exports.KnownRemoteLoginPortPublicAccess || (exports.KnownRemoteLoginPortPublicAccess = {}));
/** Known values of {@link AllocationState} that the service accepts. */
exports.KnownAllocationState = void 0;
(function (KnownAllocationState) {
    /** Steady */
    KnownAllocationState["Steady"] = "Steady";
    /** Resizing */
    KnownAllocationState["Resizing"] = "Resizing";
})(exports.KnownAllocationState || (exports.KnownAllocationState = {}));
/** Known values of {@link ApplicationSharingPolicy} that the service accepts. */
exports.KnownApplicationSharingPolicy = void 0;
(function (KnownApplicationSharingPolicy) {
    /** Personal */
    KnownApplicationSharingPolicy["Personal"] = "Personal";
    /** Shared */
    KnownApplicationSharingPolicy["Shared"] = "Shared";
})(exports.KnownApplicationSharingPolicy || (exports.KnownApplicationSharingPolicy = {}));
/** Known values of {@link SshPublicAccess} that the service accepts. */
exports.KnownSshPublicAccess = void 0;
(function (KnownSshPublicAccess) {
    /** Enabled */
    KnownSshPublicAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownSshPublicAccess["Disabled"] = "Disabled";
})(exports.KnownSshPublicAccess || (exports.KnownSshPublicAccess = {}));
/** Known values of {@link ComputeInstanceState} that the service accepts. */
exports.KnownComputeInstanceState = void 0;
(function (KnownComputeInstanceState) {
    /** Creating */
    KnownComputeInstanceState["Creating"] = "Creating";
    /** CreateFailed */
    KnownComputeInstanceState["CreateFailed"] = "CreateFailed";
    /** Deleting */
    KnownComputeInstanceState["Deleting"] = "Deleting";
    /** Running */
    KnownComputeInstanceState["Running"] = "Running";
    /** Restarting */
    KnownComputeInstanceState["Restarting"] = "Restarting";
    /** JobRunning */
    KnownComputeInstanceState["JobRunning"] = "JobRunning";
    /** SettingUp */
    KnownComputeInstanceState["SettingUp"] = "SettingUp";
    /** SetupFailed */
    KnownComputeInstanceState["SetupFailed"] = "SetupFailed";
    /** Starting */
    KnownComputeInstanceState["Starting"] = "Starting";
    /** Stopped */
    KnownComputeInstanceState["Stopped"] = "Stopped";
    /** Stopping */
    KnownComputeInstanceState["Stopping"] = "Stopping";
    /** UserSettingUp */
    KnownComputeInstanceState["UserSettingUp"] = "UserSettingUp";
    /** UserSetupFailed */
    KnownComputeInstanceState["UserSetupFailed"] = "UserSetupFailed";
    /** Unknown */
    KnownComputeInstanceState["Unknown"] = "Unknown";
    /** Unusable */
    KnownComputeInstanceState["Unusable"] = "Unusable";
})(exports.KnownComputeInstanceState || (exports.KnownComputeInstanceState = {}));
/** Known values of {@link ComputeInstanceAuthorizationType} that the service accepts. */
exports.KnownComputeInstanceAuthorizationType = void 0;
(function (KnownComputeInstanceAuthorizationType) {
    /** Personal */
    KnownComputeInstanceAuthorizationType["Personal"] = "personal";
})(exports.KnownComputeInstanceAuthorizationType || (exports.KnownComputeInstanceAuthorizationType = {}));
/** Known values of {@link OperationName} that the service accepts. */
exports.KnownOperationName = void 0;
(function (KnownOperationName) {
    /** Create */
    KnownOperationName["Create"] = "Create";
    /** Start */
    KnownOperationName["Start"] = "Start";
    /** Stop */
    KnownOperationName["Stop"] = "Stop";
    /** Restart */
    KnownOperationName["Restart"] = "Restart";
    /** Reimage */
    KnownOperationName["Reimage"] = "Reimage";
    /** Delete */
    KnownOperationName["Delete"] = "Delete";
})(exports.KnownOperationName || (exports.KnownOperationName = {}));
/** Known values of {@link OperationStatus} that the service accepts. */
exports.KnownOperationStatus = void 0;
(function (KnownOperationStatus) {
    /** InProgress */
    KnownOperationStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownOperationStatus["Succeeded"] = "Succeeded";
    /** CreateFailed */
    KnownOperationStatus["CreateFailed"] = "CreateFailed";
    /** StartFailed */
    KnownOperationStatus["StartFailed"] = "StartFailed";
    /** StopFailed */
    KnownOperationStatus["StopFailed"] = "StopFailed";
    /** RestartFailed */
    KnownOperationStatus["RestartFailed"] = "RestartFailed";
    /** ReimageFailed */
    KnownOperationStatus["ReimageFailed"] = "ReimageFailed";
    /** DeleteFailed */
    KnownOperationStatus["DeleteFailed"] = "DeleteFailed";
})(exports.KnownOperationStatus || (exports.KnownOperationStatus = {}));
/** Known values of {@link OperationTrigger} that the service accepts. */
exports.KnownOperationTrigger = void 0;
(function (KnownOperationTrigger) {
    /** User */
    KnownOperationTrigger["User"] = "User";
    /** Schedule */
    KnownOperationTrigger["Schedule"] = "Schedule";
    /** IdleShutdown */
    KnownOperationTrigger["IdleShutdown"] = "IdleShutdown";
})(exports.KnownOperationTrigger || (exports.KnownOperationTrigger = {}));
/** Known values of {@link ProvisioningStatus} that the service accepts. */
exports.KnownProvisioningStatus = void 0;
(function (KnownProvisioningStatus) {
    /** Completed */
    KnownProvisioningStatus["Completed"] = "Completed";
    /** Provisioning */
    KnownProvisioningStatus["Provisioning"] = "Provisioning";
    /** Failed */
    KnownProvisioningStatus["Failed"] = "Failed";
})(exports.KnownProvisioningStatus || (exports.KnownProvisioningStatus = {}));
/** Known values of {@link ScheduleStatus} that the service accepts. */
exports.KnownScheduleStatus = void 0;
(function (KnownScheduleStatus) {
    /** Enabled */
    KnownScheduleStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownScheduleStatus["Disabled"] = "Disabled";
})(exports.KnownScheduleStatus || (exports.KnownScheduleStatus = {}));
/** Known values of {@link ComputePowerAction} that the service accepts. */
exports.KnownComputePowerAction = void 0;
(function (KnownComputePowerAction) {
    /** Start */
    KnownComputePowerAction["Start"] = "Start";
    /** Stop */
    KnownComputePowerAction["Stop"] = "Stop";
})(exports.KnownComputePowerAction || (exports.KnownComputePowerAction = {}));
/** Known values of {@link RecurrenceFrequency} that the service accepts. */
exports.KnownRecurrenceFrequency = void 0;
(function (KnownRecurrenceFrequency) {
    /** Minute frequency */
    KnownRecurrenceFrequency["Minute"] = "Minute";
    /** Hour frequency */
    KnownRecurrenceFrequency["Hour"] = "Hour";
    /** Day frequency */
    KnownRecurrenceFrequency["Day"] = "Day";
    /** Week frequency */
    KnownRecurrenceFrequency["Week"] = "Week";
    /** Month frequency */
    KnownRecurrenceFrequency["Month"] = "Month";
})(exports.KnownRecurrenceFrequency || (exports.KnownRecurrenceFrequency = {}));
/** Known values of {@link WeekDay} that the service accepts. */
exports.KnownWeekDay = void 0;
(function (KnownWeekDay) {
    /** Monday weekday */
    KnownWeekDay["Monday"] = "Monday";
    /** Tuesday weekday */
    KnownWeekDay["Tuesday"] = "Tuesday";
    /** Wednesday weekday */
    KnownWeekDay["Wednesday"] = "Wednesday";
    /** Thursday weekday */
    KnownWeekDay["Thursday"] = "Thursday";
    /** Friday weekday */
    KnownWeekDay["Friday"] = "Friday";
    /** Saturday weekday */
    KnownWeekDay["Saturday"] = "Saturday";
    /** Sunday weekday */
    KnownWeekDay["Sunday"] = "Sunday";
})(exports.KnownWeekDay || (exports.KnownWeekDay = {}));
/** Known values of {@link ScheduleProvisioningState} that the service accepts. */
exports.KnownScheduleProvisioningState = void 0;
(function (KnownScheduleProvisioningState) {
    /** Completed */
    KnownScheduleProvisioningState["Completed"] = "Completed";
    /** Provisioning */
    KnownScheduleProvisioningState["Provisioning"] = "Provisioning";
    /** Failed */
    KnownScheduleProvisioningState["Failed"] = "Failed";
})(exports.KnownScheduleProvisioningState || (exports.KnownScheduleProvisioningState = {}));
/** Known values of {@link Autosave} that the service accepts. */
exports.KnownAutosave = void 0;
(function (KnownAutosave) {
    /** None */
    KnownAutosave["None"] = "None";
    /** Local */
    KnownAutosave["Local"] = "Local";
    /** Remote */
    KnownAutosave["Remote"] = "Remote";
})(exports.KnownAutosave || (exports.KnownAutosave = {}));
/** Known values of {@link Network} that the service accepts. */
exports.KnownNetwork = void 0;
(function (KnownNetwork) {
    /** Bridge */
    KnownNetwork["Bridge"] = "Bridge";
    /** Host */
    KnownNetwork["Host"] = "Host";
})(exports.KnownNetwork || (exports.KnownNetwork = {}));
/** Known values of {@link Caching} that the service accepts. */
exports.KnownCaching = void 0;
(function (KnownCaching) {
    /** None */
    KnownCaching["None"] = "None";
    /** ReadOnly */
    KnownCaching["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownCaching["ReadWrite"] = "ReadWrite";
})(exports.KnownCaching || (exports.KnownCaching = {}));
/** Known values of {@link StorageAccountType} that the service accepts. */
exports.KnownStorageAccountType = void 0;
(function (KnownStorageAccountType) {
    /** StandardLRS */
    KnownStorageAccountType["StandardLRS"] = "Standard_LRS";
    /** PremiumLRS */
    KnownStorageAccountType["PremiumLRS"] = "Premium_LRS";
})(exports.KnownStorageAccountType || (exports.KnownStorageAccountType = {}));
/** Known values of {@link SourceType} that the service accepts. */
exports.KnownSourceType = void 0;
(function (KnownSourceType) {
    /** Dataset */
    KnownSourceType["Dataset"] = "Dataset";
    /** Datastore */
    KnownSourceType["Datastore"] = "Datastore";
    /** URI */
    KnownSourceType["URI"] = "URI";
})(exports.KnownSourceType || (exports.KnownSourceType = {}));
/** Known values of {@link MountAction} that the service accepts. */
exports.KnownMountAction = void 0;
(function (KnownMountAction) {
    /** Mount */
    KnownMountAction["Mount"] = "Mount";
    /** Unmount */
    KnownMountAction["Unmount"] = "Unmount";
})(exports.KnownMountAction || (exports.KnownMountAction = {}));
/** Known values of {@link MountState} that the service accepts. */
exports.KnownMountState = void 0;
(function (KnownMountState) {
    /** MountRequested */
    KnownMountState["MountRequested"] = "MountRequested";
    /** Mounted */
    KnownMountState["Mounted"] = "Mounted";
    /** MountFailed */
    KnownMountState["MountFailed"] = "MountFailed";
    /** UnmountRequested */
    KnownMountState["UnmountRequested"] = "UnmountRequested";
    /** UnmountFailed */
    KnownMountState["UnmountFailed"] = "UnmountFailed";
    /** Unmounted */
    KnownMountState["Unmounted"] = "Unmounted";
})(exports.KnownMountState || (exports.KnownMountState = {}));
/** Known values of {@link InputDeliveryMode} that the service accepts. */
exports.KnownInputDeliveryMode = void 0;
(function (KnownInputDeliveryMode) {
    /** ReadOnlyMount */
    KnownInputDeliveryMode["ReadOnlyMount"] = "ReadOnlyMount";
    /** ReadWriteMount */
    KnownInputDeliveryMode["ReadWriteMount"] = "ReadWriteMount";
    /** Download */
    KnownInputDeliveryMode["Download"] = "Download";
    /** Direct */
    KnownInputDeliveryMode["Direct"] = "Direct";
    /** EvalMount */
    KnownInputDeliveryMode["EvalMount"] = "EvalMount";
    /** EvalDownload */
    KnownInputDeliveryMode["EvalDownload"] = "EvalDownload";
})(exports.KnownInputDeliveryMode || (exports.KnownInputDeliveryMode = {}));
/** Known values of {@link OutputDeliveryMode} that the service accepts. */
exports.KnownOutputDeliveryMode = void 0;
(function (KnownOutputDeliveryMode) {
    /** ReadWriteMount */
    KnownOutputDeliveryMode["ReadWriteMount"] = "ReadWriteMount";
    /** Upload */
    KnownOutputDeliveryMode["Upload"] = "Upload";
})(exports.KnownOutputDeliveryMode || (exports.KnownOutputDeliveryMode = {}));
/** Known values of {@link ForecastHorizonMode} that the service accepts. */
exports.KnownForecastHorizonMode = void 0;
(function (KnownForecastHorizonMode) {
    /** Forecast horizon to be determined automatically. */
    KnownForecastHorizonMode["Auto"] = "Auto";
    /** Use the custom forecast horizon. */
    KnownForecastHorizonMode["Custom"] = "Custom";
})(exports.KnownForecastHorizonMode || (exports.KnownForecastHorizonMode = {}));
/** Known values of {@link JobOutputType} that the service accepts. */
exports.KnownJobOutputType = void 0;
(function (KnownJobOutputType) {
    /** UriFile */
    KnownJobOutputType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownJobOutputType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownJobOutputType["Mltable"] = "mltable";
    /** CustomModel */
    KnownJobOutputType["CustomModel"] = "custom_model";
    /** MlflowModel */
    KnownJobOutputType["MlflowModel"] = "mlflow_model";
    /** TritonModel */
    KnownJobOutputType["TritonModel"] = "triton_model";
})(exports.KnownJobOutputType || (exports.KnownJobOutputType = {}));
/** Known values of {@link LogVerbosity} that the service accepts. */
exports.KnownLogVerbosity = void 0;
(function (KnownLogVerbosity) {
    /** No logs emitted. */
    KnownLogVerbosity["NotSet"] = "NotSet";
    /** Debug and above log statements logged. */
    KnownLogVerbosity["Debug"] = "Debug";
    /** Info and above log statements logged. */
    KnownLogVerbosity["Info"] = "Info";
    /** Warning and above log statements logged. */
    KnownLogVerbosity["Warning"] = "Warning";
    /** Error and above log statements logged. */
    KnownLogVerbosity["Error"] = "Error";
    /** Only critical statements logged. */
    KnownLogVerbosity["Critical"] = "Critical";
})(exports.KnownLogVerbosity || (exports.KnownLogVerbosity = {}));
/** Known values of {@link TaskType} that the service accepts. */
exports.KnownTaskType = void 0;
(function (KnownTaskType) {
    /**
     * Classification in machine learning and statistics is a supervised learning approach in which
     * the computer program learns from the data given to it and make new observations or classifications.
     */
    KnownTaskType["Classification"] = "Classification";
    /** Regression means to predict the value using the input data. Regression models are used to predict a continuous value. */
    KnownTaskType["Regression"] = "Regression";
    /**
     * Forecasting is a special kind of regression task that deals with time-series data and creates forecasting model
     * that can be used to predict the near future values based on the inputs.
     */
    KnownTaskType["Forecasting"] = "Forecasting";
    /**
     * Image Classification. Multi-class image classification is used when an image is classified with only a single label
     * from a set of classes - e.g. each image is classified as either an image of a 'cat' or a 'dog' or a 'duck'.
     */
    KnownTaskType["ImageClassification"] = "ImageClassification";
    /**
     * Image Classification Multilabel. Multi-label image classification is used when an image could have one or more labels
     * from a set of labels - e.g. an image could be labeled with both 'cat' and 'dog'.
     */
    KnownTaskType["ImageClassificationMultilabel"] = "ImageClassificationMultilabel";
    /**
     * Image Object Detection. Object detection is used to identify objects in an image and locate each object with a
     * bounding box e.g. locate all dogs and cats in an image and draw a bounding box around each.
     */
    KnownTaskType["ImageObjectDetection"] = "ImageObjectDetection";
    /**
     * Image Instance Segmentation. Instance segmentation is used to identify objects in an image at the pixel level,
     * drawing a polygon around each object in the image.
     */
    KnownTaskType["ImageInstanceSegmentation"] = "ImageInstanceSegmentation";
    /**
     * Text classification (also known as text tagging or text categorization) is the process of sorting texts into categories.
     * Categories are mutually exclusive.
     */
    KnownTaskType["TextClassification"] = "TextClassification";
    /** Multilabel classification task assigns each sample to a group (zero or more) of target labels. */
    KnownTaskType["TextClassificationMultilabel"] = "TextClassificationMultilabel";
    /**
     * Text Named Entity Recognition a.k.a. TextNER.
     * Named Entity Recognition (NER) is the ability to take free-form text and identify the occurrences of entities such as people, locations, organizations, and more.
     */
    KnownTaskType["TextNER"] = "TextNER";
})(exports.KnownTaskType || (exports.KnownTaskType = {}));
/** Known values of {@link JobInputType} that the service accepts. */
exports.KnownJobInputType = void 0;
(function (KnownJobInputType) {
    /** Literal */
    KnownJobInputType["Literal"] = "literal";
    /** UriFile */
    KnownJobInputType["UriFile"] = "uri_file";
    /** UriFolder */
    KnownJobInputType["UriFolder"] = "uri_folder";
    /** Mltable */
    KnownJobInputType["Mltable"] = "mltable";
    /** CustomModel */
    KnownJobInputType["CustomModel"] = "custom_model";
    /** MlflowModel */
    KnownJobInputType["MlflowModel"] = "mlflow_model";
    /** TritonModel */
    KnownJobInputType["TritonModel"] = "triton_model";
})(exports.KnownJobInputType || (exports.KnownJobInputType = {}));
/** Known values of {@link NCrossValidationsMode} that the service accepts. */
exports.KnownNCrossValidationsMode = void 0;
(function (KnownNCrossValidationsMode) {
    /** Determine N-Cross validations value automatically. Supported only for 'Forecasting' AutoML task. */
    KnownNCrossValidationsMode["Auto"] = "Auto";
    /** Use custom N-Cross validations value. */
    KnownNCrossValidationsMode["Custom"] = "Custom";
})(exports.KnownNCrossValidationsMode || (exports.KnownNCrossValidationsMode = {}));
/** Known values of {@link SeasonalityMode} that the service accepts. */
exports.KnownSeasonalityMode = void 0;
(function (KnownSeasonalityMode) {
    /** Seasonality to be determined automatically. */
    KnownSeasonalityMode["Auto"] = "Auto";
    /** Use the custom seasonality value. */
    KnownSeasonalityMode["Custom"] = "Custom";
})(exports.KnownSeasonalityMode || (exports.KnownSeasonalityMode = {}));
/** Known values of {@link TargetLagsMode} that the service accepts. */
exports.KnownTargetLagsMode = void 0;
(function (KnownTargetLagsMode) {
    /** Target lags to be determined automatically. */
    KnownTargetLagsMode["Auto"] = "Auto";
    /** Use the custom target lags. */
    KnownTargetLagsMode["Custom"] = "Custom";
})(exports.KnownTargetLagsMode || (exports.KnownTargetLagsMode = {}));
/** Known values of {@link TargetRollingWindowSizeMode} that the service accepts. */
exports.KnownTargetRollingWindowSizeMode = void 0;
(function (KnownTargetRollingWindowSizeMode) {
    /** Determine rolling windows size automatically. */
    KnownTargetRollingWindowSizeMode["Auto"] = "Auto";
    /** Use the specified rolling window size. */
    KnownTargetRollingWindowSizeMode["Custom"] = "Custom";
})(exports.KnownTargetRollingWindowSizeMode || (exports.KnownTargetRollingWindowSizeMode = {}));
/** Known values of {@link ServiceDataAccessAuthIdentity} that the service accepts. */
exports.KnownServiceDataAccessAuthIdentity = void 0;
(function (KnownServiceDataAccessAuthIdentity) {
    /** Do not use any identity for service data access. */
    KnownServiceDataAccessAuthIdentity["None"] = "None";
    /** Use the system assigned managed identity of the Workspace to authenticate service data access. */
    KnownServiceDataAccessAuthIdentity["WorkspaceSystemAssignedIdentity"] = "WorkspaceSystemAssignedIdentity";
    /** Use the user assigned managed identity of the Workspace to authenticate service data access. */
    KnownServiceDataAccessAuthIdentity["WorkspaceUserAssignedIdentity"] = "WorkspaceUserAssignedIdentity";
})(exports.KnownServiceDataAccessAuthIdentity || (exports.KnownServiceDataAccessAuthIdentity = {}));
/** Known values of {@link EarlyTerminationPolicyType} that the service accepts. */
exports.KnownEarlyTerminationPolicyType = void 0;
(function (KnownEarlyTerminationPolicyType) {
    /** Bandit */
    KnownEarlyTerminationPolicyType["Bandit"] = "Bandit";
    /** MedianStopping */
    KnownEarlyTerminationPolicyType["MedianStopping"] = "MedianStopping";
    /** TruncationSelection */
    KnownEarlyTerminationPolicyType["TruncationSelection"] = "TruncationSelection";
})(exports.KnownEarlyTerminationPolicyType || (exports.KnownEarlyTerminationPolicyType = {}));
/** Known values of {@link SamplingAlgorithmType} that the service accepts. */
exports.KnownSamplingAlgorithmType = void 0;
(function (KnownSamplingAlgorithmType) {
    /** Grid */
    KnownSamplingAlgorithmType["Grid"] = "Grid";
    /** Random */
    KnownSamplingAlgorithmType["Random"] = "Random";
    /** Bayesian */
    KnownSamplingAlgorithmType["Bayesian"] = "Bayesian";
})(exports.KnownSamplingAlgorithmType || (exports.KnownSamplingAlgorithmType = {}));
/** Known values of {@link ClassificationPrimaryMetrics} that the service accepts. */
exports.KnownClassificationPrimaryMetrics = void 0;
(function (KnownClassificationPrimaryMetrics) {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    KnownClassificationPrimaryMetrics["AUCWeighted"] = "AUCWeighted";
    /** Accuracy is the ratio of predictions that exactly match the true class labels. */
    KnownClassificationPrimaryMetrics["Accuracy"] = "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    KnownClassificationPrimaryMetrics["NormMacroRecall"] = "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    KnownClassificationPrimaryMetrics["AveragePrecisionScoreWeighted"] = "AveragePrecisionScoreWeighted";
    /** The arithmetic mean of precision for each class, weighted by number of true instances in each class. */
    KnownClassificationPrimaryMetrics["PrecisionScoreWeighted"] = "PrecisionScoreWeighted";
})(exports.KnownClassificationPrimaryMetrics || (exports.KnownClassificationPrimaryMetrics = {}));
/** Known values of {@link ClassificationModels} that the service accepts. */
exports.KnownClassificationModels = void 0;
(function (KnownClassificationModels) {
    /**
     * Logistic regression is a fundamental classification technique.
     * It belongs to the group of linear classifiers and is somewhat similar to polynomial and linear regression.
     * Logistic regression is fast and relatively uncomplicated, and it's convenient for you to interpret the results.
     * Although it's essentially a method for binary classification, it can also be applied to multiclass problems.
     */
    KnownClassificationModels["LogisticRegression"] = "LogisticRegression";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     */
    KnownClassificationModels["SGD"] = "SGD";
    /**
     * The multinomial Naive Bayes classifier is suitable for classification with discrete features (e.g., word counts for text classification).
     * The multinomial distribution normally requires integer feature counts. However, in practice, fractional counts such as tf-idf may also work.
     */
    KnownClassificationModels["MultinomialNaiveBayes"] = "MultinomialNaiveBayes";
    /** Naive Bayes classifier for multivariate Bernoulli models. */
    KnownClassificationModels["BernoulliNaiveBayes"] = "BernoulliNaiveBayes";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     */
    KnownClassificationModels["SVM"] = "SVM";
    /**
     * A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems.
     * After giving an SVM model sets of labeled training data for each category, they're able to categorize new text.
     * Linear SVM performs best when input data is linear, i.e., data can be easily classified by drawing the straight line between classified values on a plotted graph.
     */
    KnownClassificationModels["LinearSVM"] = "LinearSVM";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownClassificationModels["KNN"] = "KNN";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownClassificationModels["DecisionTree"] = "DecisionTree";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownClassificationModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownClassificationModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownClassificationModels["LightGBM"] = "LightGBM";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownClassificationModels["GradientBoosting"] = "GradientBoosting";
    /** XGBoost: Extreme Gradient Boosting Algorithm. This algorithm is used for structured data where target column values can be divided into distinct class values. */
    KnownClassificationModels["XGBoostClassifier"] = "XGBoostClassifier";
})(exports.KnownClassificationModels || (exports.KnownClassificationModels = {}));
/** Known values of {@link StackMetaLearnerType} that the service accepts. */
exports.KnownStackMetaLearnerType = void 0;
(function (KnownStackMetaLearnerType) {
    /** None */
    KnownStackMetaLearnerType["None"] = "None";
    /** Default meta-learners are LogisticRegression for classification tasks. */
    KnownStackMetaLearnerType["LogisticRegression"] = "LogisticRegression";
    /** Default meta-learners are LogisticRegression for classification task when CV is on. */
    KnownStackMetaLearnerType["LogisticRegressionCV"] = "LogisticRegressionCV";
    /** LightGBMClassifier */
    KnownStackMetaLearnerType["LightGBMClassifier"] = "LightGBMClassifier";
    /** Default meta-learners are LogisticRegression for regression task. */
    KnownStackMetaLearnerType["ElasticNet"] = "ElasticNet";
    /** Default meta-learners are LogisticRegression for regression task when CV is on. */
    KnownStackMetaLearnerType["ElasticNetCV"] = "ElasticNetCV";
    /** LightGBMRegressor */
    KnownStackMetaLearnerType["LightGBMRegressor"] = "LightGBMRegressor";
    /** LinearRegression */
    KnownStackMetaLearnerType["LinearRegression"] = "LinearRegression";
})(exports.KnownStackMetaLearnerType || (exports.KnownStackMetaLearnerType = {}));
/** Known values of {@link BlockedTransformers} that the service accepts. */
exports.KnownBlockedTransformers = void 0;
(function (KnownBlockedTransformers) {
    /** Target encoding for text data. */
    KnownBlockedTransformers["TextTargetEncoder"] = "TextTargetEncoder";
    /** Ohe hot encoding creates a binary feature transformation. */
    KnownBlockedTransformers["OneHotEncoder"] = "OneHotEncoder";
    /** Target encoding for categorical data. */
    KnownBlockedTransformers["CatTargetEncoder"] = "CatTargetEncoder";
    /** Tf-Idf stands for, term-frequency times inverse document-frequency. This is a common term weighting scheme for identifying information from documents. */
    KnownBlockedTransformers["TfIdf"] = "TfIdf";
    /** Weight of Evidence encoding is a technique used to encode categorical variables. It uses the natural log of the P(1)/P(0) to create weights. */
    KnownBlockedTransformers["WoETargetEncoder"] = "WoETargetEncoder";
    /** Label encoder converts labels/categorical variables in a numerical form. */
    KnownBlockedTransformers["LabelEncoder"] = "LabelEncoder";
    /** Word embedding helps represents words or phrases as a vector, or a series of numbers. */
    KnownBlockedTransformers["WordEmbedding"] = "WordEmbedding";
    /** Naive Bayes is a classified that is used for classification of discrete features that are categorically distributed. */
    KnownBlockedTransformers["NaiveBayes"] = "NaiveBayes";
    /** Count Vectorizer converts a collection of text documents to a matrix of token counts. */
    KnownBlockedTransformers["CountVectorizer"] = "CountVectorizer";
    /** Hashing One Hot Encoder can turn categorical variables into a limited number of new features. This is often used for high-cardinality categorical features. */
    KnownBlockedTransformers["HashOneHotEncoder"] = "HashOneHotEncoder";
})(exports.KnownBlockedTransformers || (exports.KnownBlockedTransformers = {}));
/** Known values of {@link FeaturizationMode} that the service accepts. */
exports.KnownFeaturizationMode = void 0;
(function (KnownFeaturizationMode) {
    /** Auto mode, system performs featurization without any custom featurization inputs. */
    KnownFeaturizationMode["Auto"] = "Auto";
    /** Custom featurization. */
    KnownFeaturizationMode["Custom"] = "Custom";
    /** Featurization off. 'Forecasting' task cannot use this value. */
    KnownFeaturizationMode["Off"] = "Off";
})(exports.KnownFeaturizationMode || (exports.KnownFeaturizationMode = {}));
/** Known values of {@link DistributionType} that the service accepts. */
exports.KnownDistributionType = void 0;
(function (KnownDistributionType) {
    /** PyTorch */
    KnownDistributionType["PyTorch"] = "PyTorch";
    /** TensorFlow */
    KnownDistributionType["TensorFlow"] = "TensorFlow";
    /** Mpi */
    KnownDistributionType["Mpi"] = "Mpi";
})(exports.KnownDistributionType || (exports.KnownDistributionType = {}));
/** Known values of {@link JobLimitsType} that the service accepts. */
exports.KnownJobLimitsType = void 0;
(function (KnownJobLimitsType) {
    /** Command */
    KnownJobLimitsType["Command"] = "Command";
    /** Sweep */
    KnownJobLimitsType["Sweep"] = "Sweep";
})(exports.KnownJobLimitsType || (exports.KnownJobLimitsType = {}));
/** Known values of {@link FeatureLags} that the service accepts. */
exports.KnownFeatureLags = void 0;
(function (KnownFeatureLags) {
    /** No feature lags generated. */
    KnownFeatureLags["None"] = "None";
    /** System auto-generates feature lags. */
    KnownFeatureLags["Auto"] = "Auto";
})(exports.KnownFeatureLags || (exports.KnownFeatureLags = {}));
/** Known values of {@link ShortSeriesHandlingConfiguration} that the service accepts. */
exports.KnownShortSeriesHandlingConfiguration = void 0;
(function (KnownShortSeriesHandlingConfiguration) {
    /** Represents no/null value. */
    KnownShortSeriesHandlingConfiguration["None"] = "None";
    /** Short series will be padded if there are no long series, otherwise short series will be dropped. */
    KnownShortSeriesHandlingConfiguration["Auto"] = "Auto";
    /** All the short series will be padded. */
    KnownShortSeriesHandlingConfiguration["Pad"] = "Pad";
    /** All the short series will be dropped. */
    KnownShortSeriesHandlingConfiguration["Drop"] = "Drop";
})(exports.KnownShortSeriesHandlingConfiguration || (exports.KnownShortSeriesHandlingConfiguration = {}));
/** Known values of {@link TargetAggregationFunction} that the service accepts. */
exports.KnownTargetAggregationFunction = void 0;
(function (KnownTargetAggregationFunction) {
    /** Represent no value set. */
    KnownTargetAggregationFunction["None"] = "None";
    /** Sum */
    KnownTargetAggregationFunction["Sum"] = "Sum";
    /** Max */
    KnownTargetAggregationFunction["Max"] = "Max";
    /** Min */
    KnownTargetAggregationFunction["Min"] = "Min";
    /** Mean */
    KnownTargetAggregationFunction["Mean"] = "Mean";
})(exports.KnownTargetAggregationFunction || (exports.KnownTargetAggregationFunction = {}));
/** Known values of {@link UseStl} that the service accepts. */
exports.KnownUseStl = void 0;
(function (KnownUseStl) {
    /** No stl decomposition. */
    KnownUseStl["None"] = "None";
    /** Season */
    KnownUseStl["Season"] = "Season";
    /** SeasonTrend */
    KnownUseStl["SeasonTrend"] = "SeasonTrend";
})(exports.KnownUseStl || (exports.KnownUseStl = {}));
/** Known values of {@link ForecastingPrimaryMetrics} that the service accepts. */
exports.KnownForecastingPrimaryMetrics = void 0;
(function (KnownForecastingPrimaryMetrics) {
    /** The Spearman's rank coefficient of correlation is a non-parametric measure of rank correlation. */
    KnownForecastingPrimaryMetrics["SpearmanCorrelation"] = "SpearmanCorrelation";
    /** The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales. */
    KnownForecastingPrimaryMetrics["NormalizedRootMeanSquaredError"] = "NormalizedRootMeanSquaredError";
    /** The R2 score is one of the performance evaluation measures for forecasting-based machine learning models. */
    KnownForecastingPrimaryMetrics["R2Score"] = "R2Score";
    /** The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales. */
    KnownForecastingPrimaryMetrics["NormalizedMeanAbsoluteError"] = "NormalizedMeanAbsoluteError";
})(exports.KnownForecastingPrimaryMetrics || (exports.KnownForecastingPrimaryMetrics = {}));
/** Known values of {@link ForecastingModels} that the service accepts. */
exports.KnownForecastingModels = void 0;
(function (KnownForecastingModels) {
    /**
     * Auto-Autoregressive Integrated Moving Average (ARIMA) model uses time-series data and statistical analysis to interpret the data and make future predictions.
     * This model aims to explain data by using time series data on its past values and uses linear regression to make predictions.
     */
    KnownForecastingModels["AutoArima"] = "AutoArima";
    /**
     * Prophet is a procedure for forecasting time series data based on an additive model where non-linear trends are fit with yearly, weekly, and daily seasonality, plus holiday effects.
     * It works best with time series that have strong seasonal effects and several seasons of historical data. Prophet is robust to missing data and shifts in the trend, and typically handles outliers well.
     */
    KnownForecastingModels["Prophet"] = "Prophet";
    /** The Naive forecasting model makes predictions by carrying forward the latest target value for each time-series in the training data. */
    KnownForecastingModels["Naive"] = "Naive";
    /** The Seasonal Naive forecasting model makes predictions by carrying forward the latest season of target values for each time-series in the training data. */
    KnownForecastingModels["SeasonalNaive"] = "SeasonalNaive";
    /** The Average forecasting model makes predictions by carrying forward the average of the target values for each time-series in the training data. */
    KnownForecastingModels["Average"] = "Average";
    /** The Seasonal Average forecasting model makes predictions by carrying forward the average value of the latest season of data for each time-series in the training data. */
    KnownForecastingModels["SeasonalAverage"] = "SeasonalAverage";
    /** Exponential smoothing is a time series forecasting method for univariate data that can be extended to support data with a systematic trend or seasonal component. */
    KnownForecastingModels["ExponentialSmoothing"] = "ExponentialSmoothing";
    /**
     * An Autoregressive Integrated Moving Average with Explanatory Variable (ARIMAX) model can be viewed as a multiple regression model with one or more autoregressive (AR) terms and/or one or more moving average (MA) terms.
     * This method is suitable for forecasting when data is stationary/non stationary, and multivariate with any type of data pattern, i.e., level/trend /seasonality/cyclicity.
     */
    KnownForecastingModels["Arimax"] = "Arimax";
    /** TCNForecaster: Temporal Convolutional Networks Forecaster. //TODO: Ask forecasting team for brief intro. */
    KnownForecastingModels["TCNForecaster"] = "TCNForecaster";
    /** Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions. */
    KnownForecastingModels["ElasticNet"] = "ElasticNet";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownForecastingModels["GradientBoosting"] = "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownForecastingModels["DecisionTree"] = "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownForecastingModels["KNN"] = "KNN";
    /** Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer. */
    KnownForecastingModels["LassoLars"] = "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    KnownForecastingModels["SGD"] = "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownForecastingModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownForecastingModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownForecastingModels["LightGBM"] = "LightGBM";
    /** XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners. */
    KnownForecastingModels["XGBoostRegressor"] = "XGBoostRegressor";
})(exports.KnownForecastingModels || (exports.KnownForecastingModels = {}));
/** Known values of {@link LearningRateScheduler} that the service accepts. */
exports.KnownLearningRateScheduler = void 0;
(function (KnownLearningRateScheduler) {
    /** No learning rate scheduler selected. */
    KnownLearningRateScheduler["None"] = "None";
    /** Cosine Annealing With Warmup. */
    KnownLearningRateScheduler["WarmupCosine"] = "WarmupCosine";
    /** Step learning rate scheduler. */
    KnownLearningRateScheduler["Step"] = "Step";
})(exports.KnownLearningRateScheduler || (exports.KnownLearningRateScheduler = {}));
/** Known values of {@link StochasticOptimizer} that the service accepts. */
exports.KnownStochasticOptimizer = void 0;
(function (KnownStochasticOptimizer) {
    /** No optimizer selected. */
    KnownStochasticOptimizer["None"] = "None";
    /** Stochastic Gradient Descent optimizer. */
    KnownStochasticOptimizer["Sgd"] = "Sgd";
    /** Adam is algorithm the optimizes stochastic objective functions based on adaptive estimates of moments */
    KnownStochasticOptimizer["Adam"] = "Adam";
    /** AdamW is a variant of the optimizer Adam that has an improved implementation of weight decay. */
    KnownStochasticOptimizer["Adamw"] = "Adamw";
})(exports.KnownStochasticOptimizer || (exports.KnownStochasticOptimizer = {}));
/** Known values of {@link ClassificationMultilabelPrimaryMetrics} that the service accepts. */
exports.KnownClassificationMultilabelPrimaryMetrics = void 0;
(function (KnownClassificationMultilabelPrimaryMetrics) {
    /**
     * AUC is the Area under the curve.
     * This metric represents arithmetic mean of the score for each class,
     * weighted by the number of true instances in each class.
     */
    KnownClassificationMultilabelPrimaryMetrics["AUCWeighted"] = "AUCWeighted";
    /** Accuracy is the ratio of predictions that exactly match the true class labels. */
    KnownClassificationMultilabelPrimaryMetrics["Accuracy"] = "Accuracy";
    /**
     * Normalized macro recall is recall macro-averaged and normalized, so that random
     * performance has a score of 0, and perfect performance has a score of 1.
     */
    KnownClassificationMultilabelPrimaryMetrics["NormMacroRecall"] = "NormMacroRecall";
    /**
     * The arithmetic mean of the average precision score for each class, weighted by
     * the number of true instances in each class.
     */
    KnownClassificationMultilabelPrimaryMetrics["AveragePrecisionScoreWeighted"] = "AveragePrecisionScoreWeighted";
    /** The arithmetic mean of precision for each class, weighted by number of true instances in each class. */
    KnownClassificationMultilabelPrimaryMetrics["PrecisionScoreWeighted"] = "PrecisionScoreWeighted";
    /** Intersection Over Union. Intersection of predictions divided by union of predictions. */
    KnownClassificationMultilabelPrimaryMetrics["IOU"] = "IOU";
})(exports.KnownClassificationMultilabelPrimaryMetrics || (exports.KnownClassificationMultilabelPrimaryMetrics = {}));
/** Known values of {@link InstanceSegmentationPrimaryMetrics} that the service accepts. */
exports.KnownInstanceSegmentationPrimaryMetrics = void 0;
(function (KnownInstanceSegmentationPrimaryMetrics) {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    KnownInstanceSegmentationPrimaryMetrics["MeanAveragePrecision"] = "MeanAveragePrecision";
})(exports.KnownInstanceSegmentationPrimaryMetrics || (exports.KnownInstanceSegmentationPrimaryMetrics = {}));
/** Known values of {@link ModelSize} that the service accepts. */
exports.KnownModelSize = void 0;
(function (KnownModelSize) {
    /** No value selected. */
    KnownModelSize["None"] = "None";
    /** Small size. */
    KnownModelSize["Small"] = "Small";
    /** Medium size. */
    KnownModelSize["Medium"] = "Medium";
    /** Large size. */
    KnownModelSize["Large"] = "Large";
    /** Extra large size. */
    KnownModelSize["ExtraLarge"] = "ExtraLarge";
})(exports.KnownModelSize || (exports.KnownModelSize = {}));
/** Known values of {@link ValidationMetricType} that the service accepts. */
exports.KnownValidationMetricType = void 0;
(function (KnownValidationMetricType) {
    /** No metric. */
    KnownValidationMetricType["None"] = "None";
    /** Coco metric. */
    KnownValidationMetricType["Coco"] = "Coco";
    /** Voc metric. */
    KnownValidationMetricType["Voc"] = "Voc";
    /** CocoVoc metric. */
    KnownValidationMetricType["CocoVoc"] = "CocoVoc";
})(exports.KnownValidationMetricType || (exports.KnownValidationMetricType = {}));
/** Known values of {@link ObjectDetectionPrimaryMetrics} that the service accepts. */
exports.KnownObjectDetectionPrimaryMetrics = void 0;
(function (KnownObjectDetectionPrimaryMetrics) {
    /**
     * Mean Average Precision (MAP) is the average of AP (Average Precision).
     * AP is calculated for each class and averaged to get the MAP.
     */
    KnownObjectDetectionPrimaryMetrics["MeanAveragePrecision"] = "MeanAveragePrecision";
})(exports.KnownObjectDetectionPrimaryMetrics || (exports.KnownObjectDetectionPrimaryMetrics = {}));
/** Known values of {@link Goal} that the service accepts. */
exports.KnownGoal = void 0;
(function (KnownGoal) {
    /** Minimize */
    KnownGoal["Minimize"] = "Minimize";
    /** Maximize */
    KnownGoal["Maximize"] = "Maximize";
})(exports.KnownGoal || (exports.KnownGoal = {}));
/** Known values of {@link RandomSamplingAlgorithmRule} that the service accepts. */
exports.KnownRandomSamplingAlgorithmRule = void 0;
(function (KnownRandomSamplingAlgorithmRule) {
    /** Random */
    KnownRandomSamplingAlgorithmRule["Random"] = "Random";
    /** Sobol */
    KnownRandomSamplingAlgorithmRule["Sobol"] = "Sobol";
})(exports.KnownRandomSamplingAlgorithmRule || (exports.KnownRandomSamplingAlgorithmRule = {}));
/** Known values of {@link RegressionPrimaryMetrics} that the service accepts. */
exports.KnownRegressionPrimaryMetrics = void 0;
(function (KnownRegressionPrimaryMetrics) {
    /** The Spearman's rank coefficient of correlation is a nonparametric measure of rank correlation. */
    KnownRegressionPrimaryMetrics["SpearmanCorrelation"] = "SpearmanCorrelation";
    /** The Normalized Root Mean Squared Error (NRMSE) the RMSE facilitates the comparison between models with different scales. */
    KnownRegressionPrimaryMetrics["NormalizedRootMeanSquaredError"] = "NormalizedRootMeanSquaredError";
    /** The R2 score is one of the performance evaluation measures for forecasting-based machine learning models. */
    KnownRegressionPrimaryMetrics["R2Score"] = "R2Score";
    /** The Normalized Mean Absolute Error (NMAE) is a validation metric to compare the Mean Absolute Error (MAE) of (time) series with different scales. */
    KnownRegressionPrimaryMetrics["NormalizedMeanAbsoluteError"] = "NormalizedMeanAbsoluteError";
})(exports.KnownRegressionPrimaryMetrics || (exports.KnownRegressionPrimaryMetrics = {}));
/** Known values of {@link RegressionModels} that the service accepts. */
exports.KnownRegressionModels = void 0;
(function (KnownRegressionModels) {
    /** Elastic net is a popular type of regularized linear regression that combines two popular penalties, specifically the L1 and L2 penalty functions. */
    KnownRegressionModels["ElasticNet"] = "ElasticNet";
    /** The technique of transiting week learners into a strong learner is called Boosting. The gradient boosting algorithm process works on this theory of execution. */
    KnownRegressionModels["GradientBoosting"] = "GradientBoosting";
    /**
     * Decision Trees are a non-parametric supervised learning method used for both classification and regression tasks.
     * The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features.
     */
    KnownRegressionModels["DecisionTree"] = "DecisionTree";
    /**
     * K-nearest neighbors (KNN) algorithm uses 'feature similarity' to predict the values of new datapoints
     * which further means that the new data point will be assigned a value based on how closely it matches the points in the training set.
     */
    KnownRegressionModels["KNN"] = "KNN";
    /** Lasso model fit with Least Angle Regression a.k.a. Lars. It is a Linear Model trained with an L1 prior as regularizer. */
    KnownRegressionModels["LassoLars"] = "LassoLars";
    /**
     * SGD: Stochastic gradient descent is an optimization algorithm often used in machine learning applications
     * to find the model parameters that correspond to the best fit between predicted and actual outputs.
     * It's an inexact but powerful technique.
     */
    KnownRegressionModels["SGD"] = "SGD";
    /**
     * Random forest is a supervised learning algorithm.
     * The "forest" it builds, is an ensemble of decision trees, usually trained with the “bagging” method.
     * The general idea of the bagging method is that a combination of learning models increases the overall result.
     */
    KnownRegressionModels["RandomForest"] = "RandomForest";
    /** Extreme Trees is an ensemble machine learning algorithm that combines the predictions from many decision trees. It is related to the widely used random forest algorithm. */
    KnownRegressionModels["ExtremeRandomTrees"] = "ExtremeRandomTrees";
    /** LightGBM is a gradient boosting framework that uses tree based learning algorithms. */
    KnownRegressionModels["LightGBM"] = "LightGBM";
    /** XGBoostRegressor: Extreme Gradient Boosting Regressor is a supervised machine learning model using ensemble of base learners. */
    KnownRegressionModels["XGBoostRegressor"] = "XGBoostRegressor";
})(exports.KnownRegressionModels || (exports.KnownRegressionModels = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AmlOperationListResult = {
    type: {
        name: "Composite",
        className: "AmlOperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlOperation"
                        }
                    }
                }
            }
        }
    }
};
const AmlOperation = {
    type: {
        name: "Composite",
        className: "AmlOperation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "AmlOperationDisplay"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AmlOperationDisplay = {
    type: {
        name: "Composite",
        className: "AmlOperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const EncryptionProperty = {
    type: {
        name: "Composite",
        className: "EncryptionProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityForCmk"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionKeyVaultProperties"
                }
            }
        }
    }
};
const IdentityForCmk = {
    type: {
        name: "Composite",
        className: "IdentityForCmk",
        modelProperties: {
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionKeyVaultProperties = {
    type: {
        name: "Composite",
        className: "EncryptionKeyVaultProperties",
        modelProperties: {
            keyVaultArmId: {
                serializedName: "keyVaultArmId",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyIdentifier: {
                serializedName: "keyIdentifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            identityClientId: {
                serializedName: "identityClientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subnetArmId: {
                serializedName: "subnetArmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "Enum",
                    allowedValues: ["Free", "Basic", "Standard", "Premium"]
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const SharedPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            privateLinkResourceId: {
                serializedName: "properties.privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            requestMessage: {
                serializedName: "properties.requestMessage",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotebookResourceInfo = {
    type: {
        name: "Composite",
        className: "NotebookResourceInfo",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            notebookPreparationError: {
                serializedName: "notebookPreparationError",
                type: {
                    name: "Composite",
                    className: "NotebookPreparationError"
                }
            }
        }
    }
};
const NotebookPreparationError = {
    type: {
        name: "Composite",
        className: "NotebookPreparationError",
        modelProperties: {
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceManagedResourcesSettings = {
    type: {
        name: "Composite",
        className: "ServiceManagedResourcesSettings",
        modelProperties: {
            cosmosDb: {
                serializedName: "cosmosDb",
                type: {
                    name: "Composite",
                    className: "CosmosDbSettings"
                }
            }
        }
    }
};
const CosmosDbSettings = {
    type: {
        name: "Composite",
        className: "CosmosDbSettings",
        modelProperties: {
            collectionsThroughput: {
                serializedName: "collectionsThroughput",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WorkspaceUpdateParameters = {
    type: {
        name: "Composite",
        className: "WorkspaceUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            friendlyName: {
                serializedName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            },
            imageBuildCompute: {
                serializedName: "properties.imageBuildCompute",
                type: {
                    name: "String"
                }
            },
            serviceManagedResourcesSettings: {
                serializedName: "properties.serviceManagedResourcesSettings",
                type: {
                    name: "Composite",
                    className: "ServiceManagedResourcesSettings"
                }
            },
            primaryUserAssignedIdentity: {
                serializedName: "properties.primaryUserAssignedIdentity",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            applicationInsights: {
                serializedName: "properties.applicationInsights",
                type: {
                    name: "String"
                }
            },
            containerRegistry: {
                serializedName: "properties.containerRegistry",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceListResult = {
    type: {
        name: "Composite",
        className: "WorkspaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workspace"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnoseWorkspaceParameters = {
    type: {
        name: "Composite",
        className: "DiagnoseWorkspaceParameters",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DiagnoseRequestProperties"
                }
            }
        }
    }
};
const DiagnoseRequestProperties = {
    type: {
        name: "Composite",
        className: "DiagnoseRequestProperties",
        modelProperties: {
            udr: {
                serializedName: "udr",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            nsg: {
                serializedName: "nsg",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            resourceLock: {
                serializedName: "resourceLock",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            dnsResolution: {
                serializedName: "dnsResolution",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            storageAccount: {
                serializedName: "storageAccount",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            keyVault: {
                serializedName: "keyVault",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            containerRegistry: {
                serializedName: "containerRegistry",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            applicationInsights: {
                serializedName: "applicationInsights",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            others: {
                serializedName: "others",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const DiagnoseResponseResult = {
    type: {
        name: "Composite",
        className: "DiagnoseResponseResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DiagnoseResponseResultValue"
                }
            }
        }
    }
};
const DiagnoseResponseResultValue = {
    type: {
        name: "Composite",
        className: "DiagnoseResponseResultValue",
        modelProperties: {
            userDefinedRouteResults: {
                serializedName: "userDefinedRouteResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            networkSecurityRuleResults: {
                serializedName: "networkSecurityRuleResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            resourceLockResults: {
                serializedName: "resourceLockResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            dnsResolutionResults: {
                serializedName: "dnsResolutionResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            storageAccountResults: {
                serializedName: "storageAccountResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            keyVaultResults: {
                serializedName: "keyVaultResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            containerRegistryResults: {
                serializedName: "containerRegistryResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            applicationInsightsResults: {
                serializedName: "applicationInsightsResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            otherResults: {
                serializedName: "otherResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            }
        }
    }
};
const DiagnoseResult = {
    type: {
        name: "Composite",
        className: "DiagnoseResult",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListWorkspaceKeysResult = {
    type: {
        name: "Composite",
        className: "ListWorkspaceKeysResult",
        modelProperties: {
            userStorageKey: {
                serializedName: "userStorageKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userStorageResourceId: {
                serializedName: "userStorageResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            appInsightsInstrumentationKey: {
                serializedName: "appInsightsInstrumentationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            containerRegistryCredentials: {
                serializedName: "containerRegistryCredentials",
                type: {
                    name: "Composite",
                    className: "RegistryListCredentialsResult"
                }
            },
            notebookAccessKeys: {
                serializedName: "notebookAccessKeys",
                type: {
                    name: "Composite",
                    className: "ListNotebookKeysResult"
                }
            }
        }
    }
};
const RegistryListCredentialsResult = {
    type: {
        name: "Composite",
        className: "RegistryListCredentialsResult",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            passwords: {
                serializedName: "passwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Password"
                        }
                    }
                }
            }
        }
    }
};
const Password = {
    type: {
        name: "Composite",
        className: "Password",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListNotebookKeysResult = {
    type: {
        name: "Composite",
        className: "ListNotebookKeysResult",
        modelProperties: {
            primaryAccessKey: {
                serializedName: "primaryAccessKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondaryAccessKey: {
                serializedName: "secondaryAccessKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListUsagesResult = {
    type: {
        name: "Composite",
        className: "ListUsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amlWorkspaceLocation: {
                serializedName: "amlWorkspaceLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineSizeListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineSizeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineSize"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineSize = {
    type: {
        name: "Composite",
        className: "VirtualMachineSize",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vCPUs: {
                serializedName: "vCPUs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            gpus: {
                serializedName: "gpus",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            osVhdSizeMB: {
                serializedName: "osVhdSizeMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxResourceVolumeMB: {
                serializedName: "maxResourceVolumeMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            memoryGB: {
                serializedName: "memoryGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            lowPriorityCapable: {
                serializedName: "lowPriorityCapable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            premiumIO: {
                serializedName: "premiumIO",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            estimatedVMPrices: {
                serializedName: "estimatedVMPrices",
                type: {
                    name: "Composite",
                    className: "EstimatedVMPrices"
                }
            },
            supportedComputeTypes: {
                serializedName: "supportedComputeTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EstimatedVMPrices = {
    type: {
        name: "Composite",
        className: "EstimatedVMPrices",
        modelProperties: {
            billingCurrency: {
                serializedName: "billingCurrency",
                required: true,
                type: {
                    name: "String"
                }
            },
            unitOfMeasure: {
                serializedName: "unitOfMeasure",
                required: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EstimatedVMPrice"
                        }
                    }
                }
            }
        }
    }
};
const EstimatedVMPrice = {
    type: {
        name: "Composite",
        className: "EstimatedVMPrice",
        modelProperties: {
            retailPrice: {
                serializedName: "retailPrice",
                required: true,
                type: {
                    name: "Number"
                }
            },
            osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "String"
                }
            },
            vmTier: {
                serializedName: "vmTier",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaUpdateParameters = {
    type: {
        name: "Composite",
        className: "QuotaUpdateParameters",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QuotaBaseProperties"
                        }
                    }
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaBaseProperties = {
    type: {
        name: "Composite",
        className: "QuotaBaseProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateWorkspaceQuotasResult = {
    type: {
        name: "Composite",
        className: "UpdateWorkspaceQuotasResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpdateWorkspaceQuotas"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateWorkspaceQuotas = {
    type: {
        name: "Composite",
        className: "UpdateWorkspaceQuotas",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListWorkspaceQuotas = {
    type: {
        name: "Composite",
        className: "ListWorkspaceQuotas",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceQuota"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceQuota = {
    type: {
        name: "Composite",
        className: "ResourceQuota",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amlWorkspaceLocation: {
                serializedName: "amlWorkspaceLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "ResourceName"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceName = {
    type: {
        name: "Composite",
        className: "ResourceName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PaginatedComputeResourcesList = {
    type: {
        name: "Composite",
        className: "PaginatedComputeResourcesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeResourceSchema = {
    type: {
        name: "Composite",
        className: "ComputeResourceSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "Compute"
                }
            }
        }
    }
};
const Compute = {
    type: {
        name: "Composite",
        className: "Compute",
        uberParent: "Compute",
        polymorphicDiscriminator: {
            serializedName: "computeType",
            clientName: "computeType"
        },
        modelProperties: {
            computeType: {
                serializedName: "computeType",
                required: true,
                type: {
                    name: "String"
                }
            },
            computeLocation: {
                serializedName: "computeLocation",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            modifiedOn: {
                serializedName: "modifiedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            provisioningErrors: {
                serializedName: "provisioningErrors",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            isAttachedCompute: {
                serializedName: "isAttachedCompute",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            disableLocalAuth: {
                serializedName: "disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ClusterUpdateParameters = {
    type: {
        name: "Composite",
        className: "ClusterUpdateParameters",
        modelProperties: {
            properties: {
                serializedName: "properties.properties",
                type: {
                    name: "Composite",
                    className: "ScaleSettingsInformation"
                }
            }
        }
    }
};
const ScaleSettingsInformation = {
    type: {
        name: "Composite",
        className: "ScaleSettingsInformation",
        modelProperties: {
            scaleSettings: {
                serializedName: "scaleSettings",
                type: {
                    name: "Composite",
                    className: "ScaleSettings"
                }
            }
        }
    }
};
const ScaleSettings = {
    type: {
        name: "Composite",
        className: "ScaleSettings",
        modelProperties: {
            maxNodeCount: {
                serializedName: "maxNodeCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            minNodeCount: {
                defaultValue: 0,
                serializedName: "minNodeCount",
                type: {
                    name: "Number"
                }
            },
            nodeIdleTimeBeforeScaleDown: {
                serializedName: "nodeIdleTimeBeforeScaleDown",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const AmlComputeNodesInformation = {
    type: {
        name: "Composite",
        className: "AmlComputeNodesInformation",
        modelProperties: {
            nodes: {
                serializedName: "nodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlComputeNodeInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlComputeNodeInformation = {
    type: {
        name: "Composite",
        className: "AmlComputeNodeInformation",
        modelProperties: {
            nodeId: {
                serializedName: "nodeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            nodeState: {
                serializedName: "nodeState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            runId: {
                serializedName: "runId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotebookAccessTokenResult = {
    type: {
        name: "Composite",
        className: "NotebookAccessTokenResult",
        modelProperties: {
            notebookResourceId: {
                serializedName: "notebookResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicDns: {
                serializedName: "publicDns",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tokenType: {
                serializedName: "tokenType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expiresIn: {
                serializedName: "expiresIn",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            refreshToken: {
                serializedName: "refreshToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeSecrets = {
    type: {
        name: "Composite",
        className: "ComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: {
            serializedName: "computeType",
            clientName: "computeType"
        },
        modelProperties: {
            computeType: {
                serializedName: "computeType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ListStorageAccountKeysResult = {
    type: {
        name: "Composite",
        className: "ListStorageAccountKeysResult",
        modelProperties: {
            userStorageKey: {
                serializedName: "userStorageKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionPropertiesV2 = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionPropertiesV2",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: {
            serializedName: "authType",
            clientName: "authType"
        },
        modelProperties: {
            authType: {
                serializedName: "authType",
                required: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            valueFormat: {
                serializedName: "valueFormat",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkspaceConnectionPropertiesV2BasicResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExternalFqdnResponse = {
    type: {
        name: "Composite",
        className: "ExternalFqdnResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpoints"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpoints = {
    type: {
        name: "Composite",
        className: "FqdnEndpoints",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "FqdnEndpointsProperties"
                }
            }
        }
    }
};
const FqdnEndpointsProperties = {
    type: {
        name: "Composite",
        className: "FqdnEndpointsProperties",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpoint = {
    type: {
        name: "Composite",
        className: "FqdnEndpoint",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpointDetail = {
    type: {
        name: "Composite",
        className: "FqdnEndpointDetail",
        modelProperties: {
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchEndpointTrackedResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "BatchEndpointTrackedResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const BatchEndpointDefaults = {
    type: {
        name: "Composite",
        className: "BatchEndpointDefaults",
        modelProperties: {
            deploymentName: {
                serializedName: "deploymentName",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointPropertiesBase = {
    type: {
        name: "Composite",
        className: "EndpointPropertiesBase",
        modelProperties: {
            authMode: {
                serializedName: "authMode",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            keys: {
                serializedName: "keys",
                type: {
                    name: "Composite",
                    className: "EndpointAuthKeys"
                }
            },
            properties: {
                serializedName: "properties",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            scoringUri: {
                serializedName: "scoringUri",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            swaggerUri: {
                serializedName: "swaggerUri",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointAuthKeys = {
    type: {
        name: "Composite",
        className: "EndpointAuthKeys",
        modelProperties: {
            primaryKey: {
                serializedName: "primaryKey",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                serializedName: "secondaryKey",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartialManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "PartialManagedServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const PartialMinimalTrackedResource = {
    type: {
        name: "Composite",
        className: "PartialMinimalTrackedResource",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const BatchDeploymentTrackedResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "BatchDeploymentTrackedResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchDeployment"
                        }
                    }
                }
            }
        }
    }
};
const AssetReferenceBase = {
    type: {
        name: "Composite",
        className: "AssetReferenceBase",
        uberParent: "AssetReferenceBase",
        polymorphicDiscriminator: {
            serializedName: "referenceType",
            clientName: "referenceType"
        },
        modelProperties: {
            referenceType: {
                serializedName: "referenceType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceConfiguration = {
    type: {
        name: "Composite",
        className: "ResourceConfiguration",
        modelProperties: {
            instanceCount: {
                defaultValue: 1,
                serializedName: "instanceCount",
                type: {
                    name: "Number"
                }
            },
            instanceType: {
                serializedName: "instanceType",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const BatchRetrySettings = {
    type: {
        name: "Composite",
        className: "BatchRetrySettings",
        modelProperties: {
            maxRetries: {
                defaultValue: 3,
                serializedName: "maxRetries",
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: "PT30S",
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const EndpointDeploymentPropertiesBase = {
    type: {
        name: "Composite",
        className: "EndpointDeploymentPropertiesBase",
        modelProperties: {
            codeConfiguration: {
                serializedName: "codeConfiguration",
                type: {
                    name: "Composite",
                    className: "CodeConfiguration"
                }
            },
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            environmentId: {
                serializedName: "environmentId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            environmentVariables: {
                serializedName: "environmentVariables",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CodeConfiguration = {
    type: {
        name: "Composite",
        className: "CodeConfiguration",
        modelProperties: {
            codeId: {
                serializedName: "codeId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            scoringScript: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]"),
                    MinLength: 1
                },
                serializedName: "scoringScript",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties = {
    type: {
        name: "Composite",
        className: "PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PartialBatchDeployment"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PartialBatchDeployment = {
    type: {
        name: "Composite",
        className: "PartialBatchDeployment",
        modelProperties: {
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CodeContainerResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "CodeContainerResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CodeContainer"
                        }
                    }
                }
            }
        }
    }
};
const ResourceBase = {
    type: {
        name: "Composite",
        className: "ResourceBase",
        modelProperties: {
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            tags: {
                serializedName: "tags",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CodeVersionResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "CodeVersionResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CodeVersion"
                        }
                    }
                }
            }
        }
    }
};
const ComponentContainerResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "ComponentContainerResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentContainer"
                        }
                    }
                }
            }
        }
    }
};
const ComponentVersionResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "ComponentVersionResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComponentVersion"
                        }
                    }
                }
            }
        }
    }
};
const DataContainerResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "DataContainerResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataContainer"
                        }
                    }
                }
            }
        }
    }
};
const DataVersionBaseResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "DataVersionBaseResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataVersionBase"
                        }
                    }
                }
            }
        }
    }
};
const DatastoreResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "DatastoreResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Datastore"
                        }
                    }
                }
            }
        }
    }
};
const DatastoreCredentials = {
    type: {
        name: "Composite",
        className: "DatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: {
            serializedName: "credentialsType",
            clientName: "credentialsType"
        },
        modelProperties: {
            credentialsType: {
                serializedName: "credentialsType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatastoreSecrets = {
    type: {
        name: "Composite",
        className: "DatastoreSecrets",
        uberParent: "DatastoreSecrets",
        polymorphicDiscriminator: {
            serializedName: "secretsType",
            clientName: "secretsType"
        },
        modelProperties: {
            secretsType: {
                serializedName: "secretsType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EnvironmentContainerResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "EnvironmentContainerResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentContainer"
                        }
                    }
                }
            }
        }
    }
};
const EnvironmentVersionResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "EnvironmentVersionResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentVersion"
                        }
                    }
                }
            }
        }
    }
};
const BuildContext = {
    type: {
        name: "Composite",
        className: "BuildContext",
        modelProperties: {
            contextUri: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "contextUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            dockerfilePath: {
                defaultValue: "Dockerfile",
                serializedName: "dockerfilePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InferenceContainerProperties = {
    type: {
        name: "Composite",
        className: "InferenceContainerProperties",
        modelProperties: {
            livenessRoute: {
                serializedName: "livenessRoute",
                type: {
                    name: "Composite",
                    className: "Route"
                }
            },
            readinessRoute: {
                serializedName: "readinessRoute",
                type: {
                    name: "Composite",
                    className: "Route"
                }
            },
            scoringRoute: {
                serializedName: "scoringRoute",
                type: {
                    name: "Composite",
                    className: "Route"
                }
            }
        }
    }
};
const Route = {
    type: {
        name: "Composite",
        className: "Route",
        modelProperties: {
            path: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "path",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobBaseResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "JobBaseResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "JobBase"
                        }
                    }
                }
            }
        }
    }
};
const IdentityConfiguration = {
    type: {
        name: "Composite",
        className: "IdentityConfiguration",
        uberParent: "IdentityConfiguration",
        polymorphicDiscriminator: {
            serializedName: "identityType",
            clientName: "identityType"
        },
        modelProperties: {
            identityType: {
                serializedName: "identityType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobService = {
    type: {
        name: "Composite",
        className: "JobService",
        modelProperties: {
            endpoint: {
                serializedName: "endpoint",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            jobServiceType: {
                serializedName: "jobServiceType",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            properties: {
                serializedName: "properties",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ModelContainerResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "ModelContainerResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ModelContainer"
                        }
                    }
                }
            }
        }
    }
};
const ModelVersionResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "ModelVersionResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ModelVersion"
                        }
                    }
                }
            }
        }
    }
};
const FlavorData = {
    type: {
        name: "Composite",
        className: "FlavorData",
        modelProperties: {
            data: {
                serializedName: "data",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const OnlineEndpointTrackedResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "OnlineEndpointTrackedResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OnlineEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const OnlineDeploymentTrackedResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "OnlineDeploymentTrackedResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OnlineDeployment"
                        }
                    }
                }
            }
        }
    }
};
const ProbeSettings = {
    type: {
        name: "Composite",
        className: "ProbeSettings",
        modelProperties: {
            failureThreshold: {
                defaultValue: 30,
                serializedName: "failureThreshold",
                type: {
                    name: "Number"
                }
            },
            initialDelay: {
                serializedName: "initialDelay",
                nullable: true,
                type: {
                    name: "TimeSpan"
                }
            },
            period: {
                defaultValue: "PT10S",
                serializedName: "period",
                type: {
                    name: "TimeSpan"
                }
            },
            successThreshold: {
                defaultValue: 1,
                serializedName: "successThreshold",
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: "PT2S",
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const OnlineRequestSettings = {
    type: {
        name: "Composite",
        className: "OnlineRequestSettings",
        modelProperties: {
            maxConcurrentRequestsPerInstance: {
                defaultValue: 1,
                serializedName: "maxConcurrentRequestsPerInstance",
                type: {
                    name: "Number"
                }
            },
            maxQueueWait: {
                defaultValue: "PT0.5S",
                serializedName: "maxQueueWait",
                type: {
                    name: "TimeSpan"
                }
            },
            requestTimeout: {
                defaultValue: "PT5S",
                serializedName: "requestTimeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const OnlineScaleSettings = {
    type: {
        name: "Composite",
        className: "OnlineScaleSettings",
        uberParent: "OnlineScaleSettings",
        polymorphicDiscriminator: {
            serializedName: "scaleType",
            clientName: "scaleType"
        },
        modelProperties: {
            scaleType: {
                serializedName: "scaleType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartialSku = {
    type: {
        name: "Composite",
        className: "PartialSku",
        modelProperties: {
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "Enum",
                    allowedValues: ["Free", "Basic", "Standard", "Premium"]
                }
            }
        }
    }
};
const DeploymentLogsRequest = {
    type: {
        name: "Composite",
        className: "DeploymentLogsRequest",
        modelProperties: {
            containerType: {
                serializedName: "containerType",
                type: {
                    name: "String"
                }
            },
            tail: {
                serializedName: "tail",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DeploymentLogs = {
    type: {
        name: "Composite",
        className: "DeploymentLogs",
        modelProperties: {
            content: {
                serializedName: "content",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "SkuResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuResource"
                        }
                    }
                }
            }
        }
    }
};
const SkuResource = {
    type: {
        name: "Composite",
        className: "SkuResource",
        modelProperties: {
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "SkuCapacity"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "SkuSetting"
                }
            }
        }
    }
};
const SkuCapacity = {
    type: {
        name: "Composite",
        className: "SkuCapacity",
        modelProperties: {
            default: {
                defaultValue: 0,
                serializedName: "default",
                type: {
                    name: "Number"
                }
            },
            maximum: {
                defaultValue: 0,
                serializedName: "maximum",
                type: {
                    name: "Number"
                }
            },
            minimum: {
                defaultValue: 0,
                serializedName: "minimum",
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuSetting = {
    type: {
        name: "Composite",
        className: "SkuSetting",
        modelProperties: {
            name: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "Enum",
                    allowedValues: ["Free", "Basic", "Standard", "Premium"]
                }
            }
        }
    }
};
const RegenerateEndpointKeysRequest = {
    type: {
        name: "Composite",
        className: "RegenerateEndpointKeysRequest",
        modelProperties: {
            keyType: {
                serializedName: "keyType",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyValue: {
                serializedName: "keyValue",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointAuthToken = {
    type: {
        name: "Composite",
        className: "EndpointAuthToken",
        modelProperties: {
            accessToken: {
                serializedName: "accessToken",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            expiryTimeUtc: {
                defaultValue: 0,
                serializedName: "expiryTimeUtc",
                type: {
                    name: "Number"
                }
            },
            refreshAfterTimeUtc: {
                defaultValue: 0,
                serializedName: "refreshAfterTimeUtc",
                type: {
                    name: "Number"
                }
            },
            tokenType: {
                serializedName: "tokenType",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduleResourceArmPaginatedResult = {
    type: {
        name: "Composite",
        className: "ScheduleResourceArmPaginatedResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Schedule"
                        }
                    }
                }
            }
        }
    }
};
const ScheduleActionBase = {
    type: {
        name: "Composite",
        className: "ScheduleActionBase",
        uberParent: "ScheduleActionBase",
        polymorphicDiscriminator: {
            serializedName: "actionType",
            clientName: "actionType"
        },
        modelProperties: {
            actionType: {
                serializedName: "actionType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TriggerBase = {
    type: {
        name: "Composite",
        className: "TriggerBase",
        uberParent: "TriggerBase",
        polymorphicDiscriminator: {
            serializedName: "triggerType",
            clientName: "triggerType"
        },
        modelProperties: {
            endTime: {
                serializedName: "endTime",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            timeZone: {
                defaultValue: "UTC",
                serializedName: "timeZone",
                type: {
                    name: "String"
                }
            },
            triggerType: {
                serializedName: "triggerType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListAmlUserFeatureResult = {
    type: {
        name: "Composite",
        className: "ListAmlUserFeatureResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlUserFeature"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlUserFeature = {
    type: {
        name: "Composite",
        className: "AmlUserFeature",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceId = {
    type: {
        name: "Composite",
        className: "ResourceId",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AKSSchema = {
    type: {
        name: "Composite",
        className: "AKSSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AKSSchemaProperties"
                }
            }
        }
    }
};
const AKSSchemaProperties = {
    type: {
        name: "Composite",
        className: "AKSSchemaProperties",
        modelProperties: {
            clusterFqdn: {
                serializedName: "clusterFqdn",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            systemServices: {
                serializedName: "systemServices",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SystemService"
                        }
                    }
                }
            },
            agentCount: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "agentCount",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            agentVmSize: {
                serializedName: "agentVmSize",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            clusterPurpose: {
                defaultValue: "FastProd",
                serializedName: "clusterPurpose",
                type: {
                    name: "String"
                }
            },
            sslConfiguration: {
                serializedName: "sslConfiguration",
                type: {
                    name: "Composite",
                    className: "SslConfiguration"
                }
            },
            aksNetworkingConfiguration: {
                serializedName: "aksNetworkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AksNetworkingConfiguration"
                }
            },
            loadBalancerType: {
                defaultValue: "PublicIp",
                serializedName: "loadBalancerType",
                type: {
                    name: "String"
                }
            },
            loadBalancerSubnet: {
                serializedName: "loadBalancerSubnet",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemService = {
    type: {
        name: "Composite",
        className: "SystemService",
        modelProperties: {
            systemServiceType: {
                serializedName: "systemServiceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SslConfiguration = {
    type: {
        name: "Composite",
        className: "SslConfiguration",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            cert: {
                serializedName: "cert",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            cname: {
                serializedName: "cname",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            leafDomainLabel: {
                serializedName: "leafDomainLabel",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            overwriteExistingDomain: {
                serializedName: "overwriteExistingDomain",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AksNetworkingConfiguration = {
    type: {
        name: "Composite",
        className: "AksNetworkingConfiguration",
        modelProperties: {
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            serviceCidr: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
                },
                serializedName: "serviceCidr",
                type: {
                    name: "String"
                }
            },
            dnsServiceIP: {
                constraints: {
                    Pattern: new RegExp("^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$")
                },
                serializedName: "dnsServiceIP",
                type: {
                    name: "String"
                }
            },
            dockerBridgeCidr: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
                },
                serializedName: "dockerBridgeCidr",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubernetesSchema = {
    type: {
        name: "Composite",
        className: "KubernetesSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "KubernetesProperties"
                }
            }
        }
    }
};
const KubernetesProperties = {
    type: {
        name: "Composite",
        className: "KubernetesProperties",
        modelProperties: {
            relayConnectionString: {
                serializedName: "relayConnectionString",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            serviceBusConnectionString: {
                serializedName: "serviceBusConnectionString",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            extensionPrincipalId: {
                serializedName: "extensionPrincipalId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            extensionInstanceReleaseTrain: {
                serializedName: "extensionInstanceReleaseTrain",
                type: {
                    name: "String"
                }
            },
            vcName: {
                serializedName: "vcName",
                type: {
                    name: "String"
                }
            },
            namespace: {
                defaultValue: "default",
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            defaultInstanceType: {
                serializedName: "defaultInstanceType",
                type: {
                    name: "String"
                }
            },
            instanceTypes: {
                serializedName: "instanceTypes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "InstanceTypeSchema" }
                    }
                }
            }
        }
    }
};
const InstanceTypeSchema = {
    type: {
        name: "Composite",
        className: "InstanceTypeSchema",
        modelProperties: {
            nodeSelector: {
                serializedName: "nodeSelector",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "InstanceTypeSchemaResources"
                }
            }
        }
    }
};
const InstanceTypeSchemaResources = {
    type: {
        name: "Composite",
        className: "InstanceTypeSchemaResources",
        modelProperties: {
            requests: {
                serializedName: "requests",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AmlComputeProperties = {
    type: {
        name: "Composite",
        className: "AmlComputeProperties",
        modelProperties: {
            osType: {
                defaultValue: "Linux",
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            vmPriority: {
                serializedName: "vmPriority",
                type: {
                    name: "String"
                }
            },
            virtualMachineImage: {
                serializedName: "virtualMachineImage",
                type: {
                    name: "Composite",
                    className: "VirtualMachineImage"
                }
            },
            isolatedNetwork: {
                serializedName: "isolatedNetwork",
                type: {
                    name: "Boolean"
                }
            },
            scaleSettings: {
                serializedName: "scaleSettings",
                type: {
                    name: "Composite",
                    className: "ScaleSettings"
                }
            },
            userAccountCredentials: {
                serializedName: "userAccountCredentials",
                type: {
                    name: "Composite",
                    className: "UserAccountCredentials"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "ResourceId"
                }
            },
            remoteLoginPortPublicAccess: {
                defaultValue: "NotSpecified",
                serializedName: "remoteLoginPortPublicAccess",
                type: {
                    name: "String"
                }
            },
            allocationState: {
                serializedName: "allocationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allocationStateTransitionTime: {
                serializedName: "allocationStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                serializedName: "errors",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            currentNodeCount: {
                serializedName: "currentNodeCount",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            targetNodeCount: {
                serializedName: "targetNodeCount",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            nodeStateCounts: {
                serializedName: "nodeStateCounts",
                type: {
                    name: "Composite",
                    className: "NodeStateCounts"
                }
            },
            enableNodePublicIp: {
                defaultValue: true,
                serializedName: "enableNodePublicIp",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            propertyBag: {
                serializedName: "propertyBag",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const VirtualMachineImage = {
    type: {
        name: "Composite",
        className: "VirtualMachineImage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserAccountCredentials = {
    type: {
        name: "Composite",
        className: "UserAccountCredentials",
        modelProperties: {
            adminUserName: {
                serializedName: "adminUserName",
                required: true,
                type: {
                    name: "String"
                }
            },
            adminUserSshPublicKey: {
                serializedName: "adminUserSshPublicKey",
                type: {
                    name: "String"
                }
            },
            adminUserPassword: {
                serializedName: "adminUserPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeStateCounts = {
    type: {
        name: "Composite",
        className: "NodeStateCounts",
        modelProperties: {
            idleNodeCount: {
                serializedName: "idleNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            runningNodeCount: {
                serializedName: "runningNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            preparingNodeCount: {
                serializedName: "preparingNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unusableNodeCount: {
                serializedName: "unusableNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            leavingNodeCount: {
                serializedName: "leavingNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            preemptedNodeCount: {
                serializedName: "preemptedNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AmlComputeSchema = {
    type: {
        name: "Composite",
        className: "AmlComputeSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AmlComputeProperties"
                }
            }
        }
    }
};
const ComputeInstanceProperties = {
    type: {
        name: "Composite",
        className: "ComputeInstanceProperties",
        modelProperties: {
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "ResourceId"
                }
            },
            applicationSharingPolicy: {
                defaultValue: "Shared",
                serializedName: "applicationSharingPolicy",
                type: {
                    name: "String"
                }
            },
            sshSettings: {
                serializedName: "sshSettings",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceSshSettings"
                }
            },
            connectivityEndpoints: {
                serializedName: "connectivityEndpoints",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceConnectivityEndpoints"
                }
            },
            applications: {
                serializedName: "applications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeInstanceApplication"
                        }
                    }
                }
            },
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceCreatedBy"
                }
            },
            errors: {
                serializedName: "errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            computeInstanceAuthorizationType: {
                defaultValue: "personal",
                serializedName: "computeInstanceAuthorizationType",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            personalComputeInstanceSettings: {
                serializedName: "personalComputeInstanceSettings",
                type: {
                    name: "Composite",
                    className: "PersonalComputeInstanceSettings"
                }
            },
            setupScripts: {
                serializedName: "setupScripts",
                type: {
                    name: "Composite",
                    className: "SetupScripts"
                }
            },
            lastOperation: {
                serializedName: "lastOperation",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceLastOperation"
                }
            },
            schedules: {
                serializedName: "schedules",
                type: {
                    name: "Composite",
                    className: "ComputeSchedules"
                }
            },
            enableNodePublicIp: {
                serializedName: "enableNodePublicIp",
                type: {
                    name: "Boolean"
                }
            },
            containers: {
                serializedName: "containers",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeInstanceContainer"
                        }
                    }
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeInstanceDataDisk"
                        }
                    }
                }
            },
            dataMounts: {
                serializedName: "dataMounts",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeInstanceDataMount"
                        }
                    }
                }
            },
            versions: {
                serializedName: "versions",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceVersion"
                }
            }
        }
    }
};
const ComputeInstanceSshSettings = {
    type: {
        name: "Composite",
        className: "ComputeInstanceSshSettings",
        modelProperties: {
            sshPublicAccess: {
                defaultValue: "Disabled",
                serializedName: "sshPublicAccess",
                type: {
                    name: "String"
                }
            },
            adminUserName: {
                serializedName: "adminUserName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sshPort: {
                serializedName: "sshPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            adminPublicKey: {
                serializedName: "adminPublicKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceConnectivityEndpoints = {
    type: {
        name: "Composite",
        className: "ComputeInstanceConnectivityEndpoints",
        modelProperties: {
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceApplication = {
    type: {
        name: "Composite",
        className: "ComputeInstanceApplication",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            endpointUri: {
                serializedName: "endpointUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceCreatedBy = {
    type: {
        name: "Composite",
        className: "ComputeInstanceCreatedBy",
        modelProperties: {
            userName: {
                serializedName: "userName",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            userOrgId: {
                serializedName: "userOrgId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "userId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PersonalComputeInstanceSettings = {
    type: {
        name: "Composite",
        className: "PersonalComputeInstanceSettings",
        modelProperties: {
            assignedUser: {
                serializedName: "assignedUser",
                type: {
                    name: "Composite",
                    className: "AssignedUser"
                }
            }
        }
    }
};
const AssignedUser = {
    type: {
        name: "Composite",
        className: "AssignedUser",
        modelProperties: {
            objectId: {
                serializedName: "objectId",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SetupScripts = {
    type: {
        name: "Composite",
        className: "SetupScripts",
        modelProperties: {
            scripts: {
                serializedName: "scripts",
                type: {
                    name: "Composite",
                    className: "ScriptsToExecute"
                }
            }
        }
    }
};
const ScriptsToExecute = {
    type: {
        name: "Composite",
        className: "ScriptsToExecute",
        modelProperties: {
            startupScript: {
                serializedName: "startupScript",
                type: {
                    name: "Composite",
                    className: "ScriptReference"
                }
            },
            creationScript: {
                serializedName: "creationScript",
                type: {
                    name: "Composite",
                    className: "ScriptReference"
                }
            }
        }
    }
};
const ScriptReference = {
    type: {
        name: "Composite",
        className: "ScriptReference",
        modelProperties: {
            scriptSource: {
                serializedName: "scriptSource",
                type: {
                    name: "String"
                }
            },
            scriptData: {
                serializedName: "scriptData",
                type: {
                    name: "String"
                }
            },
            scriptArguments: {
                serializedName: "scriptArguments",
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "timeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceLastOperation = {
    type: {
        name: "Composite",
        className: "ComputeInstanceLastOperation",
        modelProperties: {
            operationName: {
                serializedName: "operationName",
                type: {
                    name: "String"
                }
            },
            operationTime: {
                serializedName: "operationTime",
                type: {
                    name: "DateTime"
                }
            },
            operationStatus: {
                serializedName: "operationStatus",
                type: {
                    name: "String"
                }
            },
            operationTrigger: {
                serializedName: "operationTrigger",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeSchedules = {
    type: {
        name: "Composite",
        className: "ComputeSchedules",
        modelProperties: {
            computeStartStop: {
                serializedName: "computeStartStop",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeStartStopSchedule"
                        }
                    }
                }
            }
        }
    }
};
const ComputeStartStopSchedule = {
    type: {
        name: "Composite",
        className: "ComputeStartStopSchedule",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            provisioningStatus: {
                serializedName: "provisioningStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            triggerType: {
                serializedName: "triggerType",
                type: {
                    name: "String"
                }
            },
            recurrence: {
                serializedName: "recurrence",
                type: {
                    name: "Composite",
                    className: "RecurrenceTrigger"
                }
            },
            cron: {
                serializedName: "cron",
                type: {
                    name: "Composite",
                    className: "CronTrigger"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "ScheduleBase"
                }
            }
        }
    }
};
const RecurrenceSchedule = {
    type: {
        name: "Composite",
        className: "RecurrenceSchedule",
        modelProperties: {
            hours: {
                serializedName: "hours",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            minutes: {
                serializedName: "minutes",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            monthDays: {
                serializedName: "monthDays",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            weekDays: {
                serializedName: "weekDays",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ScheduleBase = {
    type: {
        name: "Composite",
        className: "ScheduleBase",
        modelProperties: {
            id: {
                serializedName: "id",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            provisioningStatus: {
                serializedName: "provisioningStatus",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceContainer = {
    type: {
        name: "Composite",
        className: "ComputeInstanceContainer",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            autosave: {
                serializedName: "autosave",
                type: {
                    name: "String"
                }
            },
            gpu: {
                serializedName: "gpu",
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                type: {
                    name: "String"
                }
            },
            environment: {
                serializedName: "environment",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceEnvironmentInfo"
                }
            },
            services: {
                serializedName: "services",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "any" } }
                        }
                    }
                }
            }
        }
    }
};
const ComputeInstanceEnvironmentInfo = {
    type: {
        name: "Composite",
        className: "ComputeInstanceEnvironmentInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceDataDisk = {
    type: {
        name: "Composite",
        className: "ComputeInstanceDataDisk",
        modelProperties: {
            caching: {
                serializedName: "caching",
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            lun: {
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                defaultValue: "Standard_LRS",
                serializedName: "storageAccountType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceDataMount = {
    type: {
        name: "Composite",
        className: "ComputeInstanceDataMount",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            sourceType: {
                serializedName: "sourceType",
                type: {
                    name: "String"
                }
            },
            mountName: {
                serializedName: "mountName",
                type: {
                    name: "String"
                }
            },
            mountAction: {
                serializedName: "mountAction",
                type: {
                    name: "String"
                }
            },
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            mountPath: {
                serializedName: "mountPath",
                type: {
                    name: "String"
                }
            },
            mountState: {
                serializedName: "mountState",
                type: {
                    name: "String"
                }
            },
            mountedOn: {
                serializedName: "mountedOn",
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceVersion = {
    type: {
        name: "Composite",
        className: "ComputeInstanceVersion",
        modelProperties: {
            runtime: {
                serializedName: "runtime",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceSchema = {
    type: {
        name: "Composite",
        className: "ComputeInstanceSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceProperties"
                }
            }
        }
    }
};
const VirtualMachineSchema = {
    type: {
        name: "Composite",
        className: "VirtualMachineSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSchemaProperties"
                }
            }
        }
    }
};
const VirtualMachineSchemaProperties = {
    type: {
        name: "Composite",
        className: "VirtualMachineSchemaProperties",
        modelProperties: {
            virtualMachineSize: {
                serializedName: "virtualMachineSize",
                type: {
                    name: "String"
                }
            },
            sshPort: {
                serializedName: "sshPort",
                type: {
                    name: "Number"
                }
            },
            notebookServerPort: {
                serializedName: "notebookServerPort",
                type: {
                    name: "Number"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            },
            isNotebookInstanceCompute: {
                serializedName: "isNotebookInstanceCompute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineSshCredentials = {
    type: {
        name: "Composite",
        className: "VirtualMachineSshCredentials",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            publicKeyData: {
                serializedName: "publicKeyData",
                type: {
                    name: "String"
                }
            },
            privateKeyData: {
                serializedName: "privateKeyData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HDInsightProperties = {
    type: {
        name: "Composite",
        className: "HDInsightProperties",
        modelProperties: {
            sshPort: {
                serializedName: "sshPort",
                type: {
                    name: "Number"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            }
        }
    }
};
const HDInsightSchema = {
    type: {
        name: "Composite",
        className: "HDInsightSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "HDInsightProperties"
                }
            }
        }
    }
};
const DatabricksProperties = {
    type: {
        name: "Composite",
        className: "DatabricksProperties",
        modelProperties: {
            databricksAccessToken: {
                serializedName: "databricksAccessToken",
                type: {
                    name: "String"
                }
            },
            workspaceUrl: {
                serializedName: "workspaceUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabricksSchema = {
    type: {
        name: "Composite",
        className: "DatabricksSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DatabricksProperties"
                }
            }
        }
    }
};
const DataLakeAnalyticsSchema = {
    type: {
        name: "Composite",
        className: "DataLakeAnalyticsSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataLakeAnalyticsSchemaProperties"
                }
            }
        }
    }
};
const DataLakeAnalyticsSchemaProperties = {
    type: {
        name: "Composite",
        className: "DataLakeAnalyticsSchemaProperties",
        modelProperties: {
            dataLakeStoreAccountName: {
                serializedName: "dataLakeStoreAccountName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SynapseSparkProperties = {
    type: {
        name: "Composite",
        className: "SynapseSparkProperties",
        modelProperties: {
            autoScaleProperties: {
                serializedName: "autoScaleProperties",
                type: {
                    name: "Composite",
                    className: "AutoScaleProperties"
                }
            },
            autoPauseProperties: {
                serializedName: "autoPauseProperties",
                type: {
                    name: "Composite",
                    className: "AutoPauseProperties"
                }
            },
            sparkVersion: {
                serializedName: "sparkVersion",
                type: {
                    name: "String"
                }
            },
            nodeCount: {
                serializedName: "nodeCount",
                type: {
                    name: "Number"
                }
            },
            nodeSize: {
                serializedName: "nodeSize",
                type: {
                    name: "String"
                }
            },
            nodeSizeFamily: {
                serializedName: "nodeSizeFamily",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            resourceGroup: {
                serializedName: "resourceGroup",
                type: {
                    name: "String"
                }
            },
            workspaceName: {
                serializedName: "workspaceName",
                type: {
                    name: "String"
                }
            },
            poolName: {
                serializedName: "poolName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoScaleProperties = {
    type: {
        name: "Composite",
        className: "AutoScaleProperties",
        modelProperties: {
            minNodeCount: {
                serializedName: "minNodeCount",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            maxNodeCount: {
                serializedName: "maxNodeCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoPauseProperties = {
    type: {
        name: "Composite",
        className: "AutoPauseProperties",
        modelProperties: {
            delayInMinutes: {
                serializedName: "delayInMinutes",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AksComputeSecretsProperties = {
    type: {
        name: "Composite",
        className: "AksComputeSecretsProperties",
        modelProperties: {
            userKubeConfig: {
                serializedName: "userKubeConfig",
                type: {
                    name: "String"
                }
            },
            adminKubeConfig: {
                serializedName: "adminKubeConfig",
                type: {
                    name: "String"
                }
            },
            imagePullSecretName: {
                serializedName: "imagePullSecretName",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineSecretsSchema = {
    type: {
        name: "Composite",
        className: "VirtualMachineSecretsSchema",
        modelProperties: {
            administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            }
        }
    }
};
const DatabricksComputeSecretsProperties = {
    type: {
        name: "Composite",
        className: "DatabricksComputeSecretsProperties",
        modelProperties: {
            databricksAccessToken: {
                serializedName: "databricksAccessToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionUsernamePassword = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionUsernamePassword",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionPersonalAccessToken = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionPersonalAccessToken",
        modelProperties: {
            pat: {
                serializedName: "pat",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionSharedAccessSignature = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionSharedAccessSignature",
        modelProperties: {
            sas: {
                serializedName: "sas",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnectionManagedIdentity = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionManagedIdentity",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssetJobInput = {
    type: {
        name: "Composite",
        className: "AssetJobInput",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            uri: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssetJobOutput = {
    type: {
        name: "Composite",
        className: "AssetJobOutput",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForecastHorizon = {
    type: {
        name: "Composite",
        className: "ForecastHorizon",
        uberParent: "ForecastHorizon",
        polymorphicDiscriminator: {
            serializedName: "mode",
            clientName: "mode"
        },
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobOutput = {
    type: {
        name: "Composite",
        className: "JobOutput",
        uberParent: "JobOutput",
        polymorphicDiscriminator: {
            serializedName: "jobOutputType",
            clientName: "jobOutputType"
        },
        modelProperties: {
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            jobOutputType: {
                serializedName: "jobOutputType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoMLVertical = {
    type: {
        name: "Composite",
        className: "AutoMLVertical",
        uberParent: "AutoMLVertical",
        polymorphicDiscriminator: {
            serializedName: "taskType",
            clientName: "taskType"
        },
        modelProperties: {
            logVerbosity: {
                serializedName: "logVerbosity",
                type: {
                    name: "String"
                }
            },
            targetColumnName: {
                serializedName: "targetColumnName",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            taskType: {
                serializedName: "taskType",
                required: true,
                type: {
                    name: "String"
                }
            },
            trainingData: {
                serializedName: "trainingData",
                type: {
                    name: "Composite",
                    className: "MLTableJobInput"
                }
            }
        }
    }
};
const JobInput = {
    type: {
        name: "Composite",
        className: "JobInput",
        uberParent: "JobInput",
        polymorphicDiscriminator: {
            serializedName: "jobInputType",
            clientName: "jobInputType"
        },
        modelProperties: {
            description: {
                serializedName: "description",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            jobInputType: {
                serializedName: "jobInputType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NCrossValidations = {
    type: {
        name: "Composite",
        className: "NCrossValidations",
        uberParent: "NCrossValidations",
        polymorphicDiscriminator: {
            serializedName: "mode",
            clientName: "mode"
        },
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Seasonality = {
    type: {
        name: "Composite",
        className: "Seasonality",
        uberParent: "Seasonality",
        polymorphicDiscriminator: {
            serializedName: "mode",
            clientName: "mode"
        },
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TargetLags = {
    type: {
        name: "Composite",
        className: "TargetLags",
        uberParent: "TargetLags",
        polymorphicDiscriminator: {
            serializedName: "mode",
            clientName: "mode"
        },
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TargetRollingWindowSize = {
    type: {
        name: "Composite",
        className: "TargetRollingWindowSize",
        uberParent: "TargetRollingWindowSize",
        polymorphicDiscriminator: {
            serializedName: "mode",
            clientName: "mode"
        },
        modelProperties: {
            mode: {
                serializedName: "mode",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EarlyTerminationPolicy = {
    type: {
        name: "Composite",
        className: "EarlyTerminationPolicy",
        uberParent: "EarlyTerminationPolicy",
        polymorphicDiscriminator: {
            serializedName: "policyType",
            clientName: "policyType"
        },
        modelProperties: {
            delayEvaluation: {
                defaultValue: 0,
                serializedName: "delayEvaluation",
                type: {
                    name: "Number"
                }
            },
            evaluationInterval: {
                defaultValue: 0,
                serializedName: "evaluationInterval",
                type: {
                    name: "Number"
                }
            },
            policyType: {
                serializedName: "policyType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SamplingAlgorithm = {
    type: {
        name: "Composite",
        className: "SamplingAlgorithm",
        uberParent: "SamplingAlgorithm",
        polymorphicDiscriminator: {
            serializedName: "samplingAlgorithmType",
            clientName: "samplingAlgorithmType"
        },
        modelProperties: {
            samplingAlgorithmType: {
                serializedName: "samplingAlgorithmType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrainingSettings = {
    type: {
        name: "Composite",
        className: "TrainingSettings",
        modelProperties: {
            enableDnnTraining: {
                defaultValue: false,
                serializedName: "enableDnnTraining",
                type: {
                    name: "Boolean"
                }
            },
            enableModelExplainability: {
                defaultValue: true,
                serializedName: "enableModelExplainability",
                type: {
                    name: "Boolean"
                }
            },
            enableOnnxCompatibleModels: {
                defaultValue: false,
                serializedName: "enableOnnxCompatibleModels",
                type: {
                    name: "Boolean"
                }
            },
            enableStackEnsemble: {
                defaultValue: true,
                serializedName: "enableStackEnsemble",
                type: {
                    name: "Boolean"
                }
            },
            enableVoteEnsemble: {
                defaultValue: true,
                serializedName: "enableVoteEnsemble",
                type: {
                    name: "Boolean"
                }
            },
            ensembleModelDownloadTimeout: {
                defaultValue: "PT5M",
                serializedName: "ensembleModelDownloadTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            stackEnsembleSettings: {
                serializedName: "stackEnsembleSettings",
                type: {
                    name: "Composite",
                    className: "StackEnsembleSettings"
                }
            }
        }
    }
};
const StackEnsembleSettings = {
    type: {
        name: "Composite",
        className: "StackEnsembleSettings",
        modelProperties: {
            stackMetaLearnerKWargs: {
                serializedName: "stackMetaLearnerKWargs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            stackMetaLearnerTrainPercentage: {
                defaultValue: 0.2,
                serializedName: "stackMetaLearnerTrainPercentage",
                type: {
                    name: "Number"
                }
            },
            stackMetaLearnerType: {
                serializedName: "stackMetaLearnerType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableVertical = {
    type: {
        name: "Composite",
        className: "TableVertical",
        modelProperties: {
            cvSplitColumnNames: {
                serializedName: "cvSplitColumnNames",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            featurizationSettings: {
                serializedName: "featurizationSettings",
                type: {
                    name: "Composite",
                    className: "TableVerticalFeaturizationSettings"
                }
            },
            limitSettings: {
                serializedName: "limitSettings",
                type: {
                    name: "Composite",
                    className: "TableVerticalLimitSettings"
                }
            },
            nCrossValidations: {
                serializedName: "nCrossValidations",
                type: {
                    name: "Composite",
                    className: "NCrossValidations"
                }
            },
            testData: {
                serializedName: "testData",
                type: {
                    name: "Composite",
                    className: "MLTableJobInput"
                }
            },
            testDataSize: {
                serializedName: "testDataSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            validationData: {
                serializedName: "validationData",
                type: {
                    name: "Composite",
                    className: "MLTableJobInput"
                }
            },
            validationDataSize: {
                serializedName: "validationDataSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            weightColumnName: {
                serializedName: "weightColumnName",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ColumnTransformer = {
    type: {
        name: "Composite",
        className: "ColumnTransformer",
        modelProperties: {
            fields: {
                serializedName: "fields",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            parameters: {
                serializedName: "parameters",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const FeaturizationSettings = {
    type: {
        name: "Composite",
        className: "FeaturizationSettings",
        modelProperties: {
            datasetLanguage: {
                serializedName: "datasetLanguage",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TableVerticalLimitSettings = {
    type: {
        name: "Composite",
        className: "TableVerticalLimitSettings",
        modelProperties: {
            enableEarlyTermination: {
                defaultValue: true,
                serializedName: "enableEarlyTermination",
                type: {
                    name: "Boolean"
                }
            },
            exitScore: {
                serializedName: "exitScore",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            maxConcurrentTrials: {
                defaultValue: 1,
                serializedName: "maxConcurrentTrials",
                type: {
                    name: "Number"
                }
            },
            maxCoresPerTrial: {
                defaultValue: -1,
                serializedName: "maxCoresPerTrial",
                type: {
                    name: "Number"
                }
            },
            maxTrials: {
                defaultValue: 1000,
                serializedName: "maxTrials",
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: "PT6H",
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            trialTimeout: {
                defaultValue: "PT30M",
                serializedName: "trialTimeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const DistributionConfiguration = {
    type: {
        name: "Composite",
        className: "DistributionConfiguration",
        uberParent: "DistributionConfiguration",
        polymorphicDiscriminator: {
            serializedName: "distributionType",
            clientName: "distributionType"
        },
        modelProperties: {
            distributionType: {
                serializedName: "distributionType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobLimits = {
    type: {
        name: "Composite",
        className: "JobLimits",
        uberParent: "JobLimits",
        polymorphicDiscriminator: {
            serializedName: "jobLimitsType",
            clientName: "jobLimitsType"
        },
        modelProperties: {
            jobLimitsType: {
                serializedName: "jobLimitsType",
                required: true,
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "timeout",
                nullable: true,
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const ContainerResourceRequirements = {
    type: {
        name: "Composite",
        className: "ContainerResourceRequirements",
        modelProperties: {
            containerResourceLimits: {
                serializedName: "containerResourceLimits",
                type: {
                    name: "Composite",
                    className: "ContainerResourceSettings"
                }
            },
            containerResourceRequests: {
                serializedName: "containerResourceRequests",
                type: {
                    name: "Composite",
                    className: "ContainerResourceSettings"
                }
            }
        }
    }
};
const ContainerResourceSettings = {
    type: {
        name: "Composite",
        className: "ContainerResourceSettings",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            gpu: {
                serializedName: "gpu",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            memory: {
                serializedName: "memory",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ForecastingSettings = {
    type: {
        name: "Composite",
        className: "ForecastingSettings",
        modelProperties: {
            countryOrRegionForHolidays: {
                serializedName: "countryOrRegionForHolidays",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            cvStepSize: {
                serializedName: "cvStepSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            featureLags: {
                serializedName: "featureLags",
                type: {
                    name: "String"
                }
            },
            forecastHorizon: {
                serializedName: "forecastHorizon",
                type: {
                    name: "Composite",
                    className: "ForecastHorizon"
                }
            },
            frequency: {
                serializedName: "frequency",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            seasonality: {
                serializedName: "seasonality",
                type: {
                    name: "Composite",
                    className: "Seasonality"
                }
            },
            shortSeriesHandlingConfig: {
                serializedName: "shortSeriesHandlingConfig",
                type: {
                    name: "String"
                }
            },
            targetAggregateFunction: {
                serializedName: "targetAggregateFunction",
                type: {
                    name: "String"
                }
            },
            targetLags: {
                serializedName: "targetLags",
                type: {
                    name: "Composite",
                    className: "TargetLags"
                }
            },
            targetRollingWindowSize: {
                serializedName: "targetRollingWindowSize",
                type: {
                    name: "Composite",
                    className: "TargetRollingWindowSize"
                }
            },
            timeColumnName: {
                serializedName: "timeColumnName",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            timeSeriesIdColumnNames: {
                serializedName: "timeSeriesIdColumnNames",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            useStl: {
                serializedName: "useStl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageModelSettings = {
    type: {
        name: "Composite",
        className: "ImageModelSettings",
        modelProperties: {
            advancedSettings: {
                serializedName: "advancedSettings",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            amsGradient: {
                serializedName: "amsGradient",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            augmentations: {
                serializedName: "augmentations",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            beta1: {
                serializedName: "beta1",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            beta2: {
                serializedName: "beta2",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            checkpointFrequency: {
                serializedName: "checkpointFrequency",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            checkpointModel: {
                serializedName: "checkpointModel",
                type: {
                    name: "Composite",
                    className: "MLFlowModelJobInput"
                }
            },
            checkpointRunId: {
                serializedName: "checkpointRunId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            distributed: {
                serializedName: "distributed",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            earlyStopping: {
                serializedName: "earlyStopping",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            earlyStoppingDelay: {
                serializedName: "earlyStoppingDelay",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            earlyStoppingPatience: {
                serializedName: "earlyStoppingPatience",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            enableOnnxNormalization: {
                serializedName: "enableOnnxNormalization",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            evaluationFrequency: {
                serializedName: "evaluationFrequency",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            gradientAccumulationStep: {
                serializedName: "gradientAccumulationStep",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            layersToFreeze: {
                serializedName: "layersToFreeze",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            learningRate: {
                serializedName: "learningRate",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            learningRateScheduler: {
                serializedName: "learningRateScheduler",
                type: {
                    name: "String"
                }
            },
            modelName: {
                serializedName: "modelName",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            momentum: {
                serializedName: "momentum",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            nesterov: {
                serializedName: "nesterov",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            numberOfEpochs: {
                serializedName: "numberOfEpochs",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            numberOfWorkers: {
                serializedName: "numberOfWorkers",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            optimizer: {
                serializedName: "optimizer",
                type: {
                    name: "String"
                }
            },
            randomSeed: {
                serializedName: "randomSeed",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            stepLRGamma: {
                serializedName: "stepLRGamma",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            stepLRStepSize: {
                serializedName: "stepLRStepSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            trainingBatchSize: {
                serializedName: "trainingBatchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            validationBatchSize: {
                serializedName: "validationBatchSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            warmupCosineLRCycles: {
                serializedName: "warmupCosineLRCycles",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            warmupCosineLRWarmupEpochs: {
                serializedName: "warmupCosineLRWarmupEpochs",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            weightDecay: {
                serializedName: "weightDecay",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ImageModelDistributionSettings = {
    type: {
        name: "Composite",
        className: "ImageModelDistributionSettings",
        modelProperties: {
            amsGradient: {
                serializedName: "amsGradient",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            augmentations: {
                serializedName: "augmentations",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            beta1: {
                serializedName: "beta1",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            beta2: {
                serializedName: "beta2",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            distributed: {
                serializedName: "distributed",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            earlyStopping: {
                serializedName: "earlyStopping",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            earlyStoppingDelay: {
                serializedName: "earlyStoppingDelay",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            earlyStoppingPatience: {
                serializedName: "earlyStoppingPatience",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            enableOnnxNormalization: {
                serializedName: "enableOnnxNormalization",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            evaluationFrequency: {
                serializedName: "evaluationFrequency",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            gradientAccumulationStep: {
                serializedName: "gradientAccumulationStep",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            layersToFreeze: {
                serializedName: "layersToFreeze",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            learningRate: {
                serializedName: "learningRate",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            learningRateScheduler: {
                serializedName: "learningRateScheduler",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            modelName: {
                serializedName: "modelName",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            momentum: {
                serializedName: "momentum",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            nesterov: {
                serializedName: "nesterov",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            numberOfEpochs: {
                serializedName: "numberOfEpochs",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            numberOfWorkers: {
                serializedName: "numberOfWorkers",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            optimizer: {
                serializedName: "optimizer",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            randomSeed: {
                serializedName: "randomSeed",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            stepLRGamma: {
                serializedName: "stepLRGamma",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            stepLRStepSize: {
                serializedName: "stepLRStepSize",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            trainingBatchSize: {
                serializedName: "trainingBatchSize",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            validationBatchSize: {
                serializedName: "validationBatchSize",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            warmupCosineLRCycles: {
                serializedName: "warmupCosineLRCycles",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            warmupCosineLRWarmupEpochs: {
                serializedName: "warmupCosineLRWarmupEpochs",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            weightDecay: {
                serializedName: "weightDecay",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageVertical = {
    type: {
        name: "Composite",
        className: "ImageVertical",
        modelProperties: {
            limitSettings: {
                serializedName: "limitSettings",
                type: {
                    name: "Composite",
                    className: "ImageLimitSettings"
                }
            },
            sweepSettings: {
                serializedName: "sweepSettings",
                type: {
                    name: "Composite",
                    className: "ImageSweepSettings"
                }
            },
            validationData: {
                serializedName: "validationData",
                type: {
                    name: "Composite",
                    className: "MLTableJobInput"
                }
            },
            validationDataSize: {
                serializedName: "validationDataSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ImageLimitSettings = {
    type: {
        name: "Composite",
        className: "ImageLimitSettings",
        modelProperties: {
            maxConcurrentTrials: {
                defaultValue: 1,
                serializedName: "maxConcurrentTrials",
                type: {
                    name: "Number"
                }
            },
            maxTrials: {
                defaultValue: 1,
                serializedName: "maxTrials",
                type: {
                    name: "Number"
                }
            },
            timeout: {
                defaultValue: "P7D",
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const ImageSweepSettings = {
    type: {
        name: "Composite",
        className: "ImageSweepSettings",
        modelProperties: {
            earlyTermination: {
                serializedName: "earlyTermination",
                type: {
                    name: "Composite",
                    className: "EarlyTerminationPolicy"
                }
            },
            samplingAlgorithm: {
                serializedName: "samplingAlgorithm",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NlpVertical = {
    type: {
        name: "Composite",
        className: "NlpVertical",
        modelProperties: {
            featurizationSettings: {
                serializedName: "featurizationSettings",
                type: {
                    name: "Composite",
                    className: "NlpVerticalFeaturizationSettings"
                }
            },
            limitSettings: {
                serializedName: "limitSettings",
                type: {
                    name: "Composite",
                    className: "NlpVerticalLimitSettings"
                }
            },
            validationData: {
                serializedName: "validationData",
                type: {
                    name: "Composite",
                    className: "MLTableJobInput"
                }
            }
        }
    }
};
const NlpVerticalLimitSettings = {
    type: {
        name: "Composite",
        className: "NlpVerticalLimitSettings",
        modelProperties: {
            maxConcurrentTrials: {
                defaultValue: 1,
                serializedName: "maxConcurrentTrials",
                type: {
                    name: "Number"
                }
            },
            maxTrials: {
                defaultValue: 1,
                serializedName: "maxTrials",
                type: {
                    name: "Number"
                }
            },
            timeout: {
                serializedName: "timeout",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const Objective = {
    type: {
        name: "Composite",
        className: "Objective",
        modelProperties: {
            goal: {
                serializedName: "goal",
                required: true,
                type: {
                    name: "String"
                }
            },
            primaryMetric: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "primaryMetric",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrialComponent = {
    type: {
        name: "Composite",
        className: "TrialComponent",
        modelProperties: {
            codeId: {
                serializedName: "codeId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            command: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]"),
                    MinLength: 1
                },
                serializedName: "command",
                required: true,
                type: {
                    name: "String"
                }
            },
            distribution: {
                serializedName: "distribution",
                type: {
                    name: "Composite",
                    className: "DistributionConfiguration"
                }
            },
            environmentId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "environmentId",
                required: true,
                type: {
                    name: "String"
                }
            },
            environmentVariables: {
                serializedName: "environmentVariables",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "JobResourceConfiguration"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Workspace = {
    type: {
        name: "Composite",
        className: "Workspace",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, workspaceId: {
                serializedName: "properties.workspaceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "properties.keyVault",
                type: {
                    name: "String"
                }
            }, applicationInsights: {
                serializedName: "properties.applicationInsights",
                type: {
                    name: "String"
                }
            }, containerRegistry: {
                serializedName: "properties.containerRegistry",
                nullable: true,
                type: {
                    name: "String"
                }
            }, storageAccount: {
                serializedName: "properties.storageAccount",
                type: {
                    name: "String"
                }
            }, discoveryUrl: {
                serializedName: "properties.discoveryUrl",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperty"
                }
            }, hbiWorkspace: {
                defaultValue: false,
                serializedName: "properties.hbiWorkspace",
                type: {
                    name: "Boolean"
                }
            }, serviceProvisionedResourceGroup: {
                serializedName: "properties.serviceProvisionedResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkCount: {
                serializedName: "properties.privateLinkCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, imageBuildCompute: {
                serializedName: "properties.imageBuildCompute",
                type: {
                    name: "String"
                }
            }, allowPublicAccessWhenBehindVnet: {
                defaultValue: false,
                serializedName: "properties.allowPublicAccessWhenBehindVnet",
                type: {
                    name: "Boolean"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, sharedPrivateLinkResources: {
                serializedName: "properties.sharedPrivateLinkResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedPrivateLinkResource"
                        }
                    }
                }
            }, notebookInfo: {
                serializedName: "properties.notebookInfo",
                type: {
                    name: "Composite",
                    className: "NotebookResourceInfo"
                }
            }, serviceManagedResourcesSettings: {
                serializedName: "properties.serviceManagedResourcesSettings",
                type: {
                    name: "Composite",
                    className: "ServiceManagedResourcesSettings"
                }
            }, primaryUserAssignedIdentity: {
                serializedName: "properties.primaryUserAssignedIdentity",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageHnsEnabled: {
                serializedName: "properties.storageHnsEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, mlFlowTrackingUri: {
                serializedName: "properties.mlFlowTrackingUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, v1LegacyMode: {
                defaultValue: false,
                serializedName: "properties.v1LegacyMode",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ComputeResource = {
    type: {
        name: "Composite",
        className: "ComputeResource",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), ComputeResourceSchema.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const WorkspaceConnectionPropertiesV2BasicResource = {
    type: {
        name: "Composite",
        className: "WorkspaceConnectionPropertiesV2BasicResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "WorkspaceConnectionPropertiesV2"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CodeContainer = {
    type: {
        name: "Composite",
        className: "CodeContainer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CodeContainerProperties"
                }
            } })
    }
};
const CodeVersion = {
    type: {
        name: "Composite",
        className: "CodeVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "CodeVersionProperties"
                }
            } })
    }
};
const ComponentContainer = {
    type: {
        name: "Composite",
        className: "ComponentContainer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ComponentContainerProperties"
                }
            } })
    }
};
const ComponentVersion = {
    type: {
        name: "Composite",
        className: "ComponentVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ComponentVersionProperties"
                }
            } })
    }
};
const DataContainer = {
    type: {
        name: "Composite",
        className: "DataContainer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataContainerProperties"
                }
            } })
    }
};
const DataVersionBase = {
    type: {
        name: "Composite",
        className: "DataVersionBase",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataVersionBaseProperties"
                }
            } })
    }
};
const Datastore = {
    type: {
        name: "Composite",
        className: "Datastore",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DatastoreProperties"
                }
            } })
    }
};
const EnvironmentContainer = {
    type: {
        name: "Composite",
        className: "EnvironmentContainer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "EnvironmentContainerProperties"
                }
            } })
    }
};
const EnvironmentVersion = {
    type: {
        name: "Composite",
        className: "EnvironmentVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "EnvironmentVersionProperties"
                }
            } })
    }
};
const JobBase = {
    type: {
        name: "Composite",
        className: "JobBase",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "JobBaseProperties"
                }
            } })
    }
};
const ModelContainer = {
    type: {
        name: "Composite",
        className: "ModelContainer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ModelContainerProperties"
                }
            } })
    }
};
const ModelVersion = {
    type: {
        name: "Composite",
        className: "ModelVersion",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ModelVersionProperties"
                }
            } })
    }
};
const Schedule = {
    type: {
        name: "Composite",
        className: "Schedule",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ScheduleProperties"
                }
            } })
    }
};
const Aks = {
    serializedName: "AKS",
    type: {
        name: "Composite",
        className: "Aks",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), AKSSchema.type.modelProperties)
    }
};
const Kubernetes = {
    serializedName: "Kubernetes",
    type: {
        name: "Composite",
        className: "Kubernetes",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), KubernetesSchema.type.modelProperties)
    }
};
const AmlCompute = {
    serializedName: "AmlCompute",
    type: {
        name: "Composite",
        className: "AmlCompute",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), AmlComputeSchema.type.modelProperties)
    }
};
const ComputeInstance = {
    serializedName: "ComputeInstance",
    type: {
        name: "Composite",
        className: "ComputeInstance",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), ComputeInstanceSchema.type.modelProperties)
    }
};
const VirtualMachine = {
    serializedName: "VirtualMachine",
    type: {
        name: "Composite",
        className: "VirtualMachine",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), VirtualMachineSchema.type.modelProperties)
    }
};
const HDInsight = {
    serializedName: "HDInsight",
    type: {
        name: "Composite",
        className: "HDInsight",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), HDInsightSchema.type.modelProperties)
    }
};
const DataFactory = {
    serializedName: "DataFactory",
    type: {
        name: "Composite",
        className: "DataFactory",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, Compute.type.modelProperties)
    }
};
const Databricks = {
    serializedName: "Databricks",
    type: {
        name: "Composite",
        className: "Databricks",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), DatabricksSchema.type.modelProperties)
    }
};
const DataLakeAnalytics = {
    serializedName: "DataLakeAnalytics",
    type: {
        name: "Composite",
        className: "DataLakeAnalytics",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), DataLakeAnalyticsSchema.type.modelProperties)
    }
};
const SynapseSpark = {
    serializedName: "SynapseSpark",
    type: {
        name: "Composite",
        className: "SynapseSpark",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SynapseSparkProperties"
                }
            } })
    }
};
const AksComputeSecrets = {
    serializedName: "AKS",
    type: {
        name: "Composite",
        className: "AksComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), AksComputeSecretsProperties.type.modelProperties)
    }
};
const VirtualMachineSecrets = {
    serializedName: "VirtualMachine",
    type: {
        name: "Composite",
        className: "VirtualMachineSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), VirtualMachineSecretsSchema.type.modelProperties)
    }
};
const DatabricksComputeSecrets = {
    serializedName: "Databricks",
    type: {
        name: "Composite",
        className: "DatabricksComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), DatabricksComputeSecretsProperties.type.modelProperties)
    }
};
const PATAuthTypeWorkspaceConnectionProperties = {
    serializedName: "PAT",
    type: {
        name: "Composite",
        className: "PATAuthTypeWorkspaceConnectionProperties",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: WorkspaceConnectionPropertiesV2.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkspaceConnectionPropertiesV2.type.modelProperties), { credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "WorkspaceConnectionPersonalAccessToken"
                }
            } })
    }
};
const SASAuthTypeWorkspaceConnectionProperties = {
    serializedName: "SAS",
    type: {
        name: "Composite",
        className: "SASAuthTypeWorkspaceConnectionProperties",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: WorkspaceConnectionPropertiesV2.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkspaceConnectionPropertiesV2.type.modelProperties), { credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "WorkspaceConnectionSharedAccessSignature"
                }
            } })
    }
};
const UsernamePasswordAuthTypeWorkspaceConnectionProperties = {
    serializedName: "UsernamePassword",
    type: {
        name: "Composite",
        className: "UsernamePasswordAuthTypeWorkspaceConnectionProperties",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: WorkspaceConnectionPropertiesV2.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkspaceConnectionPropertiesV2.type.modelProperties), { credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "WorkspaceConnectionUsernamePassword"
                }
            } })
    }
};
const NoneAuthTypeWorkspaceConnectionProperties = {
    serializedName: "None",
    type: {
        name: "Composite",
        className: "NoneAuthTypeWorkspaceConnectionProperties",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: WorkspaceConnectionPropertiesV2.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, WorkspaceConnectionPropertiesV2.type.modelProperties)
    }
};
const ManagedIdentityAuthTypeWorkspaceConnectionProperties = {
    serializedName: "ManagedIdentity",
    type: {
        name: "Composite",
        className: "ManagedIdentityAuthTypeWorkspaceConnectionProperties",
        uberParent: "WorkspaceConnectionPropertiesV2",
        polymorphicDiscriminator: WorkspaceConnectionPropertiesV2.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkspaceConnectionPropertiesV2.type.modelProperties), { credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "WorkspaceConnectionManagedIdentity"
                }
            } })
    }
};
const BatchEndpointProperties = {
    type: {
        name: "Composite",
        className: "BatchEndpointProperties",
        modelProperties: Object.assign(Object.assign({}, EndpointPropertiesBase.type.modelProperties), { defaults: {
                serializedName: "defaults",
                type: {
                    name: "Composite",
                    className: "BatchEndpointDefaults"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OnlineEndpointProperties = {
    type: {
        name: "Composite",
        className: "OnlineEndpointProperties",
        modelProperties: Object.assign(Object.assign({}, EndpointPropertiesBase.type.modelProperties), { compute: {
                serializedName: "compute",
                nullable: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, traffic: {
                serializedName: "traffic",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            } })
    }
};
const PartialMinimalTrackedResourceWithIdentity = {
    type: {
        name: "Composite",
        className: "PartialMinimalTrackedResourceWithIdentity",
        modelProperties: Object.assign(Object.assign({}, PartialMinimalTrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "PartialManagedServiceIdentity"
                }
            } })
    }
};
const PartialMinimalTrackedResourceWithSku = {
    type: {
        name: "Composite",
        className: "PartialMinimalTrackedResourceWithSku",
        modelProperties: Object.assign(Object.assign({}, PartialMinimalTrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PartialSku"
                }
            } })
    }
};
const DataPathAssetReference = {
    serializedName: "DataPath",
    type: {
        name: "Composite",
        className: "DataPathAssetReference",
        uberParent: "AssetReferenceBase",
        polymorphicDiscriminator: AssetReferenceBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetReferenceBase.type.modelProperties), { datastoreId: {
                serializedName: "datastoreId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "path",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IdAssetReference = {
    serializedName: "Id",
    type: {
        name: "Composite",
        className: "IdAssetReference",
        uberParent: "AssetReferenceBase",
        polymorphicDiscriminator: AssetReferenceBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetReferenceBase.type.modelProperties), { assetId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "assetId",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OutputPathAssetReference = {
    serializedName: "OutputPath",
    type: {
        name: "Composite",
        className: "OutputPathAssetReference",
        uberParent: "AssetReferenceBase",
        polymorphicDiscriminator: AssetReferenceBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetReferenceBase.type.modelProperties), { jobId: {
                serializedName: "jobId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "path",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DeploymentResourceConfiguration = {
    type: {
        name: "Composite",
        className: "DeploymentResourceConfiguration",
        modelProperties: Object.assign({}, ResourceConfiguration.type.modelProperties)
    }
};
const JobResourceConfiguration = {
    type: {
        name: "Composite",
        className: "JobResourceConfiguration",
        modelProperties: Object.assign(Object.assign({}, ResourceConfiguration.type.modelProperties), { dockerArgs: {
                serializedName: "dockerArgs",
                nullable: true,
                type: {
                    name: "String"
                }
            }, shmSize: {
                defaultValue: "2g",
                constraints: {
                    Pattern: new RegExp("\\d+[bBkKmMgG]")
                },
                serializedName: "shmSize",
                type: {
                    name: "String"
                }
            } })
    }
};
const BatchDeploymentProperties = {
    type: {
        name: "Composite",
        className: "BatchDeploymentProperties",
        modelProperties: Object.assign(Object.assign({}, EndpointDeploymentPropertiesBase.type.modelProperties), { compute: {
                serializedName: "compute",
                nullable: true,
                type: {
                    name: "String"
                }
            }, errorThreshold: {
                defaultValue: -1,
                serializedName: "errorThreshold",
                type: {
                    name: "Number"
                }
            }, loggingLevel: {
                serializedName: "loggingLevel",
                type: {
                    name: "String"
                }
            }, maxConcurrencyPerInstance: {
                defaultValue: 1,
                serializedName: "maxConcurrencyPerInstance",
                type: {
                    name: "Number"
                }
            }, miniBatchSize: {
                defaultValue: 10,
                serializedName: "miniBatchSize",
                type: {
                    name: "Number"
                }
            }, model: {
                serializedName: "model",
                type: {
                    name: "Composite",
                    className: "AssetReferenceBase"
                }
            }, outputAction: {
                serializedName: "outputAction",
                type: {
                    name: "String"
                }
            }, outputFileName: {
                defaultValue: "predictions.csv",
                serializedName: "outputFileName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "DeploymentResourceConfiguration"
                }
            }, retrySettings: {
                serializedName: "retrySettings",
                type: {
                    name: "Composite",
                    className: "BatchRetrySettings"
                }
            } })
    }
};
const OnlineDeploymentProperties = {
    serializedName: "OnlineDeploymentProperties",
    type: {
        name: "Composite",
        className: "OnlineDeploymentProperties",
        uberParent: "EndpointDeploymentPropertiesBase",
        polymorphicDiscriminator: {
            serializedName: "endpointComputeType",
            clientName: "endpointComputeType"
        },
        modelProperties: Object.assign(Object.assign({}, EndpointDeploymentPropertiesBase.type.modelProperties), { appInsightsEnabled: {
                defaultValue: false,
                serializedName: "appInsightsEnabled",
                type: {
                    name: "Boolean"
                }
            }, egressPublicNetworkAccess: {
                serializedName: "egressPublicNetworkAccess",
                type: {
                    name: "String"
                }
            }, endpointComputeType: {
                serializedName: "endpointComputeType",
                required: true,
                type: {
                    name: "String"
                }
            }, instanceType: {
                serializedName: "instanceType",
                nullable: true,
                type: {
                    name: "String"
                }
            }, livenessProbe: {
                serializedName: "livenessProbe",
                type: {
                    name: "Composite",
                    className: "ProbeSettings"
                }
            }, model: {
                serializedName: "model",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelMountPath: {
                serializedName: "modelMountPath",
                nullable: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, readinessProbe: {
                serializedName: "readinessProbe",
                type: {
                    name: "Composite",
                    className: "ProbeSettings"
                }
            }, requestSettings: {
                serializedName: "requestSettings",
                type: {
                    name: "Composite",
                    className: "OnlineRequestSettings"
                }
            }, scaleSettings: {
                serializedName: "scaleSettings",
                type: {
                    name: "Composite",
                    className: "OnlineScaleSettings"
                }
            } })
    }
};
const AssetContainer = {
    type: {
        name: "Composite",
        className: "AssetContainer",
        modelProperties: Object.assign(Object.assign({}, ResourceBase.type.modelProperties), { isArchived: {
                defaultValue: false,
                serializedName: "isArchived",
                type: {
                    name: "Boolean"
                }
            }, latestVersion: {
                serializedName: "latestVersion",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }, nextVersion: {
                serializedName: "nextVersion",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AssetBase = {
    type: {
        name: "Composite",
        className: "AssetBase",
        modelProperties: Object.assign(Object.assign({}, ResourceBase.type.modelProperties), { isAnonymous: {
                defaultValue: false,
                serializedName: "isAnonymous",
                type: {
                    name: "Boolean"
                }
            }, isArchived: {
                defaultValue: false,
                serializedName: "isArchived",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const DatastoreProperties = {
    serializedName: "DatastoreProperties",
    type: {
        name: "Composite",
        className: "DatastoreProperties",
        uberParent: "ResourceBase",
        polymorphicDiscriminator: {
            serializedName: "datastoreType",
            clientName: "datastoreType"
        },
        modelProperties: Object.assign(Object.assign({}, ResourceBase.type.modelProperties), { credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "DatastoreCredentials"
                }
            }, datastoreType: {
                serializedName: "datastoreType",
                required: true,
                type: {
                    name: "String"
                }
            }, isDefault: {
                serializedName: "isDefault",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const JobBaseProperties = {
    serializedName: "JobBaseProperties",
    type: {
        name: "Composite",
        className: "JobBaseProperties",
        uberParent: "ResourceBase",
        polymorphicDiscriminator: {
            serializedName: "jobType",
            clientName: "jobType"
        },
        modelProperties: Object.assign(Object.assign({}, ResourceBase.type.modelProperties), { componentId: {
                serializedName: "componentId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, computeId: {
                serializedName: "computeId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "displayName",
                nullable: true,
                type: {
                    name: "String"
                }
            }, experimentName: {
                defaultValue: "Default",
                serializedName: "experimentName",
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityConfiguration"
                }
            }, isArchived: {
                defaultValue: false,
                serializedName: "isArchived",
                type: {
                    name: "Boolean"
                }
            }, jobType: {
                serializedName: "jobType",
                required: true,
                type: {
                    name: "String"
                }
            }, services: {
                serializedName: "services",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobService" } }
                }
            }, status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ScheduleProperties = {
    type: {
        name: "Composite",
        className: "ScheduleProperties",
        modelProperties: Object.assign(Object.assign({}, ResourceBase.type.modelProperties), { action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "ScheduleActionBase"
                }
            }, displayName: {
                serializedName: "displayName",
                nullable: true,
                type: {
                    name: "String"
                }
            }, isEnabled: {
                defaultValue: true,
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, trigger: {
                serializedName: "trigger",
                type: {
                    name: "Composite",
                    className: "TriggerBase"
                }
            } })
    }
};
const AccountKeyDatastoreCredentials = {
    serializedName: "AccountKey",
    type: {
        name: "Composite",
        className: "AccountKeyDatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: DatastoreCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreCredentials.type.modelProperties), { secrets: {
                serializedName: "secrets",
                type: {
                    name: "Composite",
                    className: "AccountKeyDatastoreSecrets"
                }
            } })
    }
};
const CertificateDatastoreCredentials = {
    serializedName: "Certificate",
    type: {
        name: "Composite",
        className: "CertificateDatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: DatastoreCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreCredentials.type.modelProperties), { authorityUrl: {
                serializedName: "authorityUrl",
                nullable: true,
                type: {
                    name: "String"
                }
            }, clientId: {
                serializedName: "clientId",
                required: true,
                type: {
                    name: "Uuid"
                }
            }, resourceUrl: {
                serializedName: "resourceUrl",
                nullable: true,
                type: {
                    name: "String"
                }
            }, secrets: {
                serializedName: "secrets",
                type: {
                    name: "Composite",
                    className: "CertificateDatastoreSecrets"
                }
            }, tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            }, thumbprint: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "thumbprint",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NoneDatastoreCredentials = {
    serializedName: "None",
    type: {
        name: "Composite",
        className: "NoneDatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: DatastoreCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DatastoreCredentials.type.modelProperties)
    }
};
const SasDatastoreCredentials = {
    serializedName: "Sas",
    type: {
        name: "Composite",
        className: "SasDatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: DatastoreCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreCredentials.type.modelProperties), { secrets: {
                serializedName: "secrets",
                type: {
                    name: "Composite",
                    className: "SasDatastoreSecrets"
                }
            } })
    }
};
const ServicePrincipalDatastoreCredentials = {
    serializedName: "ServicePrincipal",
    type: {
        name: "Composite",
        className: "ServicePrincipalDatastoreCredentials",
        uberParent: "DatastoreCredentials",
        polymorphicDiscriminator: DatastoreCredentials.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreCredentials.type.modelProperties), { authorityUrl: {
                serializedName: "authorityUrl",
                nullable: true,
                type: {
                    name: "String"
                }
            }, clientId: {
                serializedName: "clientId",
                required: true,
                type: {
                    name: "Uuid"
                }
            }, resourceUrl: {
                serializedName: "resourceUrl",
                nullable: true,
                type: {
                    name: "String"
                }
            }, secrets: {
                serializedName: "secrets",
                type: {
                    name: "Composite",
                    className: "ServicePrincipalDatastoreSecrets"
                }
            }, tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const AccountKeyDatastoreSecrets = {
    serializedName: "AccountKey",
    type: {
        name: "Composite",
        className: "AccountKeyDatastoreSecrets",
        uberParent: "DatastoreSecrets",
        polymorphicDiscriminator: DatastoreSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreSecrets.type.modelProperties), { key: {
                serializedName: "key",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CertificateDatastoreSecrets = {
    serializedName: "Certificate",
    type: {
        name: "Composite",
        className: "CertificateDatastoreSecrets",
        uberParent: "DatastoreSecrets",
        polymorphicDiscriminator: DatastoreSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreSecrets.type.modelProperties), { certificate: {
                serializedName: "certificate",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SasDatastoreSecrets = {
    serializedName: "Sas",
    type: {
        name: "Composite",
        className: "SasDatastoreSecrets",
        uberParent: "DatastoreSecrets",
        polymorphicDiscriminator: DatastoreSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreSecrets.type.modelProperties), { sasToken: {
                serializedName: "sasToken",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServicePrincipalDatastoreSecrets = {
    serializedName: "ServicePrincipal",
    type: {
        name: "Composite",
        className: "ServicePrincipalDatastoreSecrets",
        uberParent: "DatastoreSecrets",
        polymorphicDiscriminator: DatastoreSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreSecrets.type.modelProperties), { clientSecret: {
                serializedName: "clientSecret",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AmlToken = {
    serializedName: "AMLToken",
    type: {
        name: "Composite",
        className: "AmlToken",
        uberParent: "IdentityConfiguration",
        polymorphicDiscriminator: IdentityConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, IdentityConfiguration.type.modelProperties)
    }
};
const ManagedIdentity = {
    serializedName: "Managed",
    type: {
        name: "Composite",
        className: "ManagedIdentity",
        uberParent: "IdentityConfiguration",
        polymorphicDiscriminator: IdentityConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, IdentityConfiguration.type.modelProperties), { clientId: {
                serializedName: "clientId",
                nullable: true,
                type: {
                    name: "Uuid"
                }
            }, objectId: {
                serializedName: "objectId",
                nullable: true,
                type: {
                    name: "Uuid"
                }
            }, resourceId: {
                serializedName: "resourceId",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const UserIdentity = {
    serializedName: "UserIdentity",
    type: {
        name: "Composite",
        className: "UserIdentity",
        uberParent: "IdentityConfiguration",
        polymorphicDiscriminator: IdentityConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, IdentityConfiguration.type.modelProperties)
    }
};
const DefaultScaleSettings = {
    serializedName: "Default",
    type: {
        name: "Composite",
        className: "DefaultScaleSettings",
        uberParent: "OnlineScaleSettings",
        polymorphicDiscriminator: OnlineScaleSettings.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, OnlineScaleSettings.type.modelProperties)
    }
};
const TargetUtilizationScaleSettings = {
    serializedName: "TargetUtilization",
    type: {
        name: "Composite",
        className: "TargetUtilizationScaleSettings",
        uberParent: "OnlineScaleSettings",
        polymorphicDiscriminator: OnlineScaleSettings.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OnlineScaleSettings.type.modelProperties), { maxInstances: {
                defaultValue: 1,
                serializedName: "maxInstances",
                type: {
                    name: "Number"
                }
            }, minInstances: {
                defaultValue: 1,
                serializedName: "minInstances",
                type: {
                    name: "Number"
                }
            }, pollingInterval: {
                defaultValue: "PT1S",
                serializedName: "pollingInterval",
                type: {
                    name: "TimeSpan"
                }
            }, targetUtilizationPercentage: {
                defaultValue: 70,
                serializedName: "targetUtilizationPercentage",
                type: {
                    name: "Number"
                }
            } })
    }
};
const EndpointScheduleAction = {
    serializedName: "InvokeBatchEndpoint",
    type: {
        name: "Composite",
        className: "EndpointScheduleAction",
        uberParent: "ScheduleActionBase",
        polymorphicDiscriminator: ScheduleActionBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScheduleActionBase.type.modelProperties), { endpointInvocationDefinition: {
                serializedName: "endpointInvocationDefinition",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const JobScheduleAction = {
    serializedName: "CreateJob",
    type: {
        name: "Composite",
        className: "JobScheduleAction",
        uberParent: "ScheduleActionBase",
        polymorphicDiscriminator: ScheduleActionBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScheduleActionBase.type.modelProperties), { jobDefinition: {
                serializedName: "jobDefinition",
                type: {
                    name: "Composite",
                    className: "JobBaseProperties"
                }
            } })
    }
};
const RecurrenceTrigger = {
    serializedName: "Recurrence",
    type: {
        name: "Composite",
        className: "RecurrenceTrigger",
        uberParent: "TriggerBase",
        polymorphicDiscriminator: TriggerBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TriggerBase.type.modelProperties), { frequency: {
                serializedName: "frequency",
                required: true,
                type: {
                    name: "String"
                }
            }, interval: {
                serializedName: "interval",
                required: true,
                type: {
                    name: "Number"
                }
            }, schedule: {
                serializedName: "schedule",
                type: {
                    name: "Composite",
                    className: "RecurrenceSchedule"
                }
            } })
    }
};
const CronTrigger = {
    serializedName: "Cron",
    type: {
        name: "Composite",
        className: "CronTrigger",
        uberParent: "TriggerBase",
        polymorphicDiscriminator: TriggerBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TriggerBase.type.modelProperties), { expression: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "expression",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const MLTableJobInput = {
    serializedName: "mltable",
    type: {
        name: "Composite",
        className: "MLTableJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const CustomModelJobInput = {
    serializedName: "custom_model",
    type: {
        name: "Composite",
        className: "CustomModelJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const MLFlowModelJobInput = {
    serializedName: "mlflow_model",
    type: {
        name: "Composite",
        className: "MLFlowModelJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const TritonModelJobInput = {
    serializedName: "triton_model",
    type: {
        name: "Composite",
        className: "TritonModelJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const UriFileJobInput = {
    serializedName: "uri_file",
    type: {
        name: "Composite",
        className: "UriFileJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const UriFolderJobInput = {
    serializedName: "uri_folder",
    type: {
        name: "Composite",
        className: "UriFolderJobInput",
        uberParent: "AssetJobInput",
        polymorphicDiscriminator: AssetJobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobInput.type.modelProperties), JobInput.type.modelProperties)
    }
};
const CustomModelJobOutput = {
    serializedName: "custom_model",
    type: {
        name: "Composite",
        className: "CustomModelJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const MLFlowModelJobOutput = {
    serializedName: "mlflow_model",
    type: {
        name: "Composite",
        className: "MLFlowModelJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const MLTableJobOutput = {
    serializedName: "mltable",
    type: {
        name: "Composite",
        className: "MLTableJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const TritonModelJobOutput = {
    serializedName: "triton_model",
    type: {
        name: "Composite",
        className: "TritonModelJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const UriFileJobOutput = {
    serializedName: "uri_file",
    type: {
        name: "Composite",
        className: "UriFileJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const UriFolderJobOutput = {
    serializedName: "uri_folder",
    type: {
        name: "Composite",
        className: "UriFolderJobOutput",
        uberParent: "AssetJobOutput",
        polymorphicDiscriminator: AssetJobOutput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AssetJobOutput.type.modelProperties), JobOutput.type.modelProperties)
    }
};
const AutoForecastHorizon = {
    serializedName: "Auto",
    type: {
        name: "Composite",
        className: "AutoForecastHorizon",
        uberParent: "ForecastHorizon",
        polymorphicDiscriminator: ForecastHorizon.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, ForecastHorizon.type.modelProperties)
    }
};
const CustomForecastHorizon = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "CustomForecastHorizon",
        uberParent: "ForecastHorizon",
        polymorphicDiscriminator: ForecastHorizon.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ForecastHorizon.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const Classification = {
    serializedName: "Classification",
    type: {
        name: "Composite",
        className: "Classification",
        uberParent: "TableVertical",
        polymorphicDiscriminator: TableVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, TableVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { positiveLabel: {
                serializedName: "positiveLabel",
                nullable: true,
                type: {
                    name: "String"
                }
            }, primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            }, trainingSettings: {
                serializedName: "trainingSettings",
                type: {
                    name: "Composite",
                    className: "ClassificationTrainingSettings"
                }
            } })
    }
};
const Forecasting = {
    serializedName: "Forecasting",
    type: {
        name: "Composite",
        className: "Forecasting",
        uberParent: "TableVertical",
        polymorphicDiscriminator: TableVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, TableVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { forecastingSettings: {
                serializedName: "forecastingSettings",
                type: {
                    name: "Composite",
                    className: "ForecastingSettings"
                }
            }, primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            }, trainingSettings: {
                serializedName: "trainingSettings",
                type: {
                    name: "Composite",
                    className: "ForecastingTrainingSettings"
                }
            } })
    }
};
const ImageClassificationBase = {
    type: {
        name: "Composite",
        className: "ImageClassificationBase",
        modelProperties: Object.assign(Object.assign({}, ImageVertical.type.modelProperties), { modelSettings: {
                serializedName: "modelSettings",
                type: {
                    name: "Composite",
                    className: "ImageModelSettingsClassification"
                }
            }, searchSpace: {
                serializedName: "searchSpace",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageModelDistributionSettingsClassification"
                        }
                    }
                }
            } })
    }
};
const ImageClassification = {
    serializedName: "ImageClassification",
    type: {
        name: "Composite",
        className: "ImageClassification",
        uberParent: "ImageClassificationBase",
        modelProperties: Object.assign(Object.assign(Object.assign({}, ImageClassificationBase.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            } })
    }
};
ImageClassificationBase.type.polymorphicDiscriminator =
    ImageClassificationBase.type.polymorphicDiscriminator;
const ImageClassificationMultilabel = {
    serializedName: "ImageClassificationMultilabel",
    type: {
        name: "Composite",
        className: "ImageClassificationMultilabel",
        uberParent: "ImageClassificationBase",
        polymorphicDiscriminator: ImageClassificationBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, ImageClassificationBase.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageObjectDetectionBase = {
    type: {
        name: "Composite",
        className: "ImageObjectDetectionBase",
        modelProperties: Object.assign(Object.assign({}, ImageVertical.type.modelProperties), { modelSettings: {
                serializedName: "modelSettings",
                type: {
                    name: "Composite",
                    className: "ImageModelSettingsObjectDetection"
                }
            }, searchSpace: {
                serializedName: "searchSpace",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageModelDistributionSettingsObjectDetection"
                        }
                    }
                }
            } })
    }
};
const ImageInstanceSegmentation = {
    serializedName: "ImageInstanceSegmentation",
    type: {
        name: "Composite",
        className: "ImageInstanceSegmentation",
        uberParent: "ImageObjectDetectionBase",
        polymorphicDiscriminator: ImageObjectDetectionBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, ImageObjectDetectionBase.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageObjectDetection = {
    serializedName: "ImageObjectDetection",
    type: {
        name: "Composite",
        className: "ImageObjectDetection",
        uberParent: "ImageObjectDetectionBase",
        modelProperties: Object.assign(Object.assign(Object.assign({}, ImageObjectDetectionBase.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            } })
    }
};
ImageObjectDetectionBase.type.polymorphicDiscriminator =
    ImageObjectDetectionBase.type.polymorphicDiscriminator;
const Regression = {
    serializedName: "Regression",
    type: {
        name: "Composite",
        className: "Regression",
        uberParent: "TableVertical",
        polymorphicDiscriminator: TableVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, TableVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            }, trainingSettings: {
                serializedName: "trainingSettings",
                type: {
                    name: "Composite",
                    className: "RegressionTrainingSettings"
                }
            } })
    }
};
const TextClassification = {
    serializedName: "TextClassification",
    type: {
        name: "Composite",
        className: "TextClassification",
        uberParent: "NlpVertical",
        polymorphicDiscriminator: NlpVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, NlpVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                type: {
                    name: "String"
                }
            } })
    }
};
const TextClassificationMultilabel = {
    serializedName: "TextClassificationMultilabel",
    type: {
        name: "Composite",
        className: "TextClassificationMultilabel",
        uberParent: "NlpVertical",
        polymorphicDiscriminator: NlpVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, NlpVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const TextNer = {
    serializedName: "TextNER",
    type: {
        name: "Composite",
        className: "TextNer",
        uberParent: "NlpVertical",
        polymorphicDiscriminator: NlpVertical.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign(Object.assign({}, NlpVertical.type.modelProperties), AutoMLVertical.type.modelProperties), { primaryMetric: {
                serializedName: "primaryMetric",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LiteralJobInput = {
    serializedName: "literal",
    type: {
        name: "Composite",
        className: "LiteralJobInput",
        uberParent: "JobInput",
        polymorphicDiscriminator: JobInput.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobInput.type.modelProperties), { value: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AutoNCrossValidations = {
    serializedName: "Auto",
    type: {
        name: "Composite",
        className: "AutoNCrossValidations",
        uberParent: "NCrossValidations",
        polymorphicDiscriminator: NCrossValidations.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, NCrossValidations.type.modelProperties)
    }
};
const CustomNCrossValidations = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "CustomNCrossValidations",
        uberParent: "NCrossValidations",
        polymorphicDiscriminator: NCrossValidations.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, NCrossValidations.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const AutoSeasonality = {
    serializedName: "Auto",
    type: {
        name: "Composite",
        className: "AutoSeasonality",
        uberParent: "Seasonality",
        polymorphicDiscriminator: Seasonality.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, Seasonality.type.modelProperties)
    }
};
const CustomSeasonality = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "CustomSeasonality",
        uberParent: "Seasonality",
        polymorphicDiscriminator: Seasonality.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Seasonality.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const AutoTargetLags = {
    serializedName: "Auto",
    type: {
        name: "Composite",
        className: "AutoTargetLags",
        uberParent: "TargetLags",
        polymorphicDiscriminator: TargetLags.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TargetLags.type.modelProperties)
    }
};
const CustomTargetLags = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "CustomTargetLags",
        uberParent: "TargetLags",
        polymorphicDiscriminator: TargetLags.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TargetLags.type.modelProperties), { values: {
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            } })
    }
};
const AutoTargetRollingWindowSize = {
    serializedName: "Auto",
    type: {
        name: "Composite",
        className: "AutoTargetRollingWindowSize",
        uberParent: "TargetRollingWindowSize",
        polymorphicDiscriminator: TargetRollingWindowSize.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, TargetRollingWindowSize.type.modelProperties)
    }
};
const CustomTargetRollingWindowSize = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "CustomTargetRollingWindowSize",
        uberParent: "TargetRollingWindowSize",
        polymorphicDiscriminator: TargetRollingWindowSize.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TargetRollingWindowSize.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const BanditPolicy = {
    serializedName: "Bandit",
    type: {
        name: "Composite",
        className: "BanditPolicy",
        uberParent: "EarlyTerminationPolicy",
        polymorphicDiscriminator: EarlyTerminationPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EarlyTerminationPolicy.type.modelProperties), { slackAmount: {
                defaultValue: 0,
                serializedName: "slackAmount",
                type: {
                    name: "Number"
                }
            }, slackFactor: {
                defaultValue: 0,
                serializedName: "slackFactor",
                type: {
                    name: "Number"
                }
            } })
    }
};
const MedianStoppingPolicy = {
    serializedName: "MedianStopping",
    type: {
        name: "Composite",
        className: "MedianStoppingPolicy",
        uberParent: "EarlyTerminationPolicy",
        polymorphicDiscriminator: EarlyTerminationPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, EarlyTerminationPolicy.type.modelProperties)
    }
};
const TruncationSelectionPolicy = {
    serializedName: "TruncationSelection",
    type: {
        name: "Composite",
        className: "TruncationSelectionPolicy",
        uberParent: "EarlyTerminationPolicy",
        polymorphicDiscriminator: EarlyTerminationPolicy.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EarlyTerminationPolicy.type.modelProperties), { truncationPercentage: {
                defaultValue: 0,
                serializedName: "truncationPercentage",
                type: {
                    name: "Number"
                }
            } })
    }
};
const BayesianSamplingAlgorithm = {
    serializedName: "Bayesian",
    type: {
        name: "Composite",
        className: "BayesianSamplingAlgorithm",
        uberParent: "SamplingAlgorithm",
        polymorphicDiscriminator: SamplingAlgorithm.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SamplingAlgorithm.type.modelProperties)
    }
};
const GridSamplingAlgorithm = {
    serializedName: "Grid",
    type: {
        name: "Composite",
        className: "GridSamplingAlgorithm",
        uberParent: "SamplingAlgorithm",
        polymorphicDiscriminator: SamplingAlgorithm.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, SamplingAlgorithm.type.modelProperties)
    }
};
const RandomSamplingAlgorithm = {
    serializedName: "Random",
    type: {
        name: "Composite",
        className: "RandomSamplingAlgorithm",
        uberParent: "SamplingAlgorithm",
        polymorphicDiscriminator: SamplingAlgorithm.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SamplingAlgorithm.type.modelProperties), { rule: {
                serializedName: "rule",
                type: {
                    name: "String"
                }
            }, seed: {
                serializedName: "seed",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ClassificationTrainingSettings = {
    type: {
        name: "Composite",
        className: "ClassificationTrainingSettings",
        modelProperties: Object.assign(Object.assign({}, TrainingSettings.type.modelProperties), { allowedTrainingAlgorithms: {
                serializedName: "allowedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, blockedTrainingAlgorithms: {
                serializedName: "blockedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ForecastingTrainingSettings = {
    type: {
        name: "Composite",
        className: "ForecastingTrainingSettings",
        modelProperties: Object.assign(Object.assign({}, TrainingSettings.type.modelProperties), { allowedTrainingAlgorithms: {
                serializedName: "allowedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, blockedTrainingAlgorithms: {
                serializedName: "blockedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const RegressionTrainingSettings = {
    type: {
        name: "Composite",
        className: "RegressionTrainingSettings",
        modelProperties: Object.assign(Object.assign({}, TrainingSettings.type.modelProperties), { allowedTrainingAlgorithms: {
                serializedName: "allowedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, blockedTrainingAlgorithms: {
                serializedName: "blockedTrainingAlgorithms",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const TableVerticalFeaturizationSettings = {
    type: {
        name: "Composite",
        className: "TableVerticalFeaturizationSettings",
        modelProperties: Object.assign(Object.assign({}, FeaturizationSettings.type.modelProperties), { blockedTransformers: {
                serializedName: "blockedTransformers",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, columnNameAndTypes: {
                serializedName: "columnNameAndTypes",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, enableDnnFeaturization: {
                defaultValue: false,
                serializedName: "enableDnnFeaturization",
                type: {
                    name: "Boolean"
                }
            }, mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            }, transformerParams: {
                serializedName: "transformerParams",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Sequence",
                            element: {
                                type: { name: "Composite", className: "ColumnTransformer" }
                            }
                        }
                    }
                }
            } })
    }
};
const NlpVerticalFeaturizationSettings = {
    type: {
        name: "Composite",
        className: "NlpVerticalFeaturizationSettings",
        modelProperties: Object.assign({}, FeaturizationSettings.type.modelProperties)
    }
};
const Mpi = {
    serializedName: "Mpi",
    type: {
        name: "Composite",
        className: "Mpi",
        uberParent: "DistributionConfiguration",
        polymorphicDiscriminator: DistributionConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DistributionConfiguration.type.modelProperties), { processCountPerInstance: {
                serializedName: "processCountPerInstance",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const PyTorch = {
    serializedName: "PyTorch",
    type: {
        name: "Composite",
        className: "PyTorch",
        uberParent: "DistributionConfiguration",
        polymorphicDiscriminator: DistributionConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DistributionConfiguration.type.modelProperties), { processCountPerInstance: {
                serializedName: "processCountPerInstance",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const TensorFlow = {
    serializedName: "TensorFlow",
    type: {
        name: "Composite",
        className: "TensorFlow",
        uberParent: "DistributionConfiguration",
        polymorphicDiscriminator: DistributionConfiguration.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DistributionConfiguration.type.modelProperties), { parameterServerCount: {
                defaultValue: 0,
                serializedName: "parameterServerCount",
                type: {
                    name: "Number"
                }
            }, workerCount: {
                serializedName: "workerCount",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const CommandJobLimits = {
    serializedName: "Command",
    type: {
        name: "Composite",
        className: "CommandJobLimits",
        uberParent: "JobLimits",
        polymorphicDiscriminator: JobLimits.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, JobLimits.type.modelProperties)
    }
};
const SweepJobLimits = {
    serializedName: "Sweep",
    type: {
        name: "Composite",
        className: "SweepJobLimits",
        uberParent: "JobLimits",
        polymorphicDiscriminator: JobLimits.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobLimits.type.modelProperties), { maxConcurrentTrials: {
                serializedName: "maxConcurrentTrials",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, maxTotalTrials: {
                serializedName: "maxTotalTrials",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, trialTimeout: {
                serializedName: "trialTimeout",
                nullable: true,
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const ImageModelSettingsClassification = {
    type: {
        name: "Composite",
        className: "ImageModelSettingsClassification",
        modelProperties: Object.assign(Object.assign({}, ImageModelSettings.type.modelProperties), { trainingCropSize: {
                serializedName: "trainingCropSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, validationCropSize: {
                serializedName: "validationCropSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, validationResizeSize: {
                serializedName: "validationResizeSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, weightedLoss: {
                serializedName: "weightedLoss",
                nullable: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const ImageModelSettingsObjectDetection = {
    type: {
        name: "Composite",
        className: "ImageModelSettingsObjectDetection",
        modelProperties: Object.assign(Object.assign({}, ImageModelSettings.type.modelProperties), { boxDetectionsPerImage: {
                serializedName: "boxDetectionsPerImage",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, boxScoreThreshold: {
                serializedName: "boxScoreThreshold",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, imageSize: {
                serializedName: "imageSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, maxSize: {
                serializedName: "maxSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, minSize: {
                serializedName: "minSize",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, modelSize: {
                serializedName: "modelSize",
                type: {
                    name: "String"
                }
            }, multiScale: {
                serializedName: "multiScale",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, nmsIouThreshold: {
                serializedName: "nmsIouThreshold",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, tileGridSize: {
                serializedName: "tileGridSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, tileOverlapRatio: {
                serializedName: "tileOverlapRatio",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, tilePredictionsNmsThreshold: {
                serializedName: "tilePredictionsNmsThreshold",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, validationIouThreshold: {
                serializedName: "validationIouThreshold",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, validationMetricType: {
                serializedName: "validationMetricType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageModelDistributionSettingsClassification = {
    type: {
        name: "Composite",
        className: "ImageModelDistributionSettingsClassification",
        modelProperties: Object.assign(Object.assign({}, ImageModelDistributionSettings.type.modelProperties), { trainingCropSize: {
                serializedName: "trainingCropSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, validationCropSize: {
                serializedName: "validationCropSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, validationResizeSize: {
                serializedName: "validationResizeSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, weightedLoss: {
                serializedName: "weightedLoss",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ImageModelDistributionSettingsObjectDetection = {
    type: {
        name: "Composite",
        className: "ImageModelDistributionSettingsObjectDetection",
        modelProperties: Object.assign(Object.assign({}, ImageModelDistributionSettings.type.modelProperties), { boxDetectionsPerImage: {
                serializedName: "boxDetectionsPerImage",
                nullable: true,
                type: {
                    name: "String"
                }
            }, boxScoreThreshold: {
                serializedName: "boxScoreThreshold",
                nullable: true,
                type: {
                    name: "String"
                }
            }, imageSize: {
                serializedName: "imageSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, maxSize: {
                serializedName: "maxSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, minSize: {
                serializedName: "minSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelSize: {
                serializedName: "modelSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, multiScale: {
                serializedName: "multiScale",
                nullable: true,
                type: {
                    name: "String"
                }
            }, nmsIouThreshold: {
                serializedName: "nmsIouThreshold",
                nullable: true,
                type: {
                    name: "String"
                }
            }, tileGridSize: {
                serializedName: "tileGridSize",
                nullable: true,
                type: {
                    name: "String"
                }
            }, tileOverlapRatio: {
                serializedName: "tileOverlapRatio",
                nullable: true,
                type: {
                    name: "String"
                }
            }, tilePredictionsNmsThreshold: {
                serializedName: "tilePredictionsNmsThreshold",
                nullable: true,
                type: {
                    name: "String"
                }
            }, validationIouThreshold: {
                serializedName: "validationIouThreshold",
                nullable: true,
                type: {
                    name: "String"
                }
            }, validationMetricType: {
                serializedName: "validationMetricType",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BatchEndpoint = {
    type: {
        name: "Composite",
        className: "BatchEndpoint",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BatchEndpointProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            } })
    }
};
const BatchDeployment = {
    type: {
        name: "Composite",
        className: "BatchDeployment",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "BatchDeploymentProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            } })
    }
};
const OnlineEndpoint = {
    type: {
        name: "Composite",
        className: "OnlineEndpoint",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OnlineEndpointProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            } })
    }
};
const OnlineDeployment = {
    type: {
        name: "Composite",
        className: "OnlineDeployment",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OnlineDeploymentProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            } })
    }
};
const KubernetesOnlineDeployment = {
    serializedName: "Kubernetes",
    type: {
        name: "Composite",
        className: "KubernetesOnlineDeployment",
        uberParent: "OnlineDeploymentProperties",
        polymorphicDiscriminator: OnlineDeploymentProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, OnlineDeploymentProperties.type.modelProperties), { containerResourceRequirements: {
                serializedName: "containerResourceRequirements",
                type: {
                    name: "Composite",
                    className: "ContainerResourceRequirements"
                }
            } })
    }
};
const ManagedOnlineDeployment = {
    serializedName: "Managed",
    type: {
        name: "Composite",
        className: "ManagedOnlineDeployment",
        uberParent: "OnlineDeploymentProperties",
        polymorphicDiscriminator: OnlineDeploymentProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, OnlineDeploymentProperties.type.modelProperties)
    }
};
const CodeContainerProperties = {
    type: {
        name: "Composite",
        className: "CodeContainerProperties",
        modelProperties: Object.assign({}, AssetContainer.type.modelProperties)
    }
};
const ComponentContainerProperties = {
    type: {
        name: "Composite",
        className: "ComponentContainerProperties",
        modelProperties: Object.assign({}, AssetContainer.type.modelProperties)
    }
};
const DataContainerProperties = {
    type: {
        name: "Composite",
        className: "DataContainerProperties",
        modelProperties: Object.assign(Object.assign({}, AssetContainer.type.modelProperties), { dataType: {
                serializedName: "dataType",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EnvironmentContainerProperties = {
    type: {
        name: "Composite",
        className: "EnvironmentContainerProperties",
        modelProperties: Object.assign({}, AssetContainer.type.modelProperties)
    }
};
const ModelContainerProperties = {
    type: {
        name: "Composite",
        className: "ModelContainerProperties",
        modelProperties: Object.assign({}, AssetContainer.type.modelProperties)
    }
};
const CodeVersionProperties = {
    type: {
        name: "Composite",
        className: "CodeVersionProperties",
        modelProperties: Object.assign(Object.assign({}, AssetBase.type.modelProperties), { codeUri: {
                serializedName: "codeUri",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ComponentVersionProperties = {
    type: {
        name: "Composite",
        className: "ComponentVersionProperties",
        modelProperties: Object.assign(Object.assign({}, AssetBase.type.modelProperties), { componentSpec: {
                serializedName: "componentSpec",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const DataVersionBaseProperties = {
    serializedName: "DataVersionBaseProperties",
    type: {
        name: "Composite",
        className: "DataVersionBaseProperties",
        uberParent: "AssetBase",
        polymorphicDiscriminator: {
            serializedName: "dataType",
            clientName: "dataType"
        },
        modelProperties: Object.assign(Object.assign({}, AssetBase.type.modelProperties), { dataType: {
                serializedName: "dataType",
                required: true,
                type: {
                    name: "String"
                }
            }, dataUri: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "dataUri",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EnvironmentVersionProperties = {
    type: {
        name: "Composite",
        className: "EnvironmentVersionProperties",
        modelProperties: Object.assign(Object.assign({}, AssetBase.type.modelProperties), { autoRebuild: {
                serializedName: "autoRebuild",
                type: {
                    name: "String"
                }
            }, build: {
                serializedName: "build",
                type: {
                    name: "Composite",
                    className: "BuildContext"
                }
            }, condaFile: {
                serializedName: "condaFile",
                type: {
                    name: "String"
                }
            }, environmentType: {
                serializedName: "environmentType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, image: {
                serializedName: "image",
                type: {
                    name: "String"
                }
            }, inferenceConfig: {
                serializedName: "inferenceConfig",
                type: {
                    name: "Composite",
                    className: "InferenceContainerProperties"
                }
            }, osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ModelVersionProperties = {
    type: {
        name: "Composite",
        className: "ModelVersionProperties",
        modelProperties: Object.assign(Object.assign({}, AssetBase.type.modelProperties), { flavors: {
                serializedName: "flavors",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "FlavorData" } }
                }
            }, jobName: {
                serializedName: "jobName",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelType: {
                serializedName: "modelType",
                nullable: true,
                type: {
                    name: "String"
                }
            }, modelUri: {
                serializedName: "modelUri",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureBlobDatastore = {
    serializedName: "AzureBlob",
    type: {
        name: "Composite",
        className: "AzureBlobDatastore",
        uberParent: "DatastoreProperties",
        polymorphicDiscriminator: DatastoreProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreProperties.type.modelProperties), { accountName: {
                serializedName: "accountName",
                nullable: true,
                type: {
                    name: "String"
                }
            }, containerName: {
                serializedName: "containerName",
                nullable: true,
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "endpoint",
                nullable: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "protocol",
                nullable: true,
                type: {
                    name: "String"
                }
            }, serviceDataAccessAuthIdentity: {
                serializedName: "serviceDataAccessAuthIdentity",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureDataLakeGen1Datastore = {
    serializedName: "AzureDataLakeGen1",
    type: {
        name: "Composite",
        className: "AzureDataLakeGen1Datastore",
        uberParent: "DatastoreProperties",
        polymorphicDiscriminator: DatastoreProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreProperties.type.modelProperties), { serviceDataAccessAuthIdentity: {
                serializedName: "serviceDataAccessAuthIdentity",
                type: {
                    name: "String"
                }
            }, storeName: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "storeName",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureDataLakeGen2Datastore = {
    serializedName: "AzureDataLakeGen2",
    type: {
        name: "Composite",
        className: "AzureDataLakeGen2Datastore",
        uberParent: "DatastoreProperties",
        polymorphicDiscriminator: DatastoreProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreProperties.type.modelProperties), { accountName: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "accountName",
                required: true,
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "endpoint",
                nullable: true,
                type: {
                    name: "String"
                }
            }, filesystem: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "filesystem",
                required: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "protocol",
                nullable: true,
                type: {
                    name: "String"
                }
            }, serviceDataAccessAuthIdentity: {
                serializedName: "serviceDataAccessAuthIdentity",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFileDatastore = {
    serializedName: "AzureFile",
    type: {
        name: "Composite",
        className: "AzureFileDatastore",
        uberParent: "DatastoreProperties",
        polymorphicDiscriminator: DatastoreProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DatastoreProperties.type.modelProperties), { accountName: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "accountName",
                required: true,
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "endpoint",
                nullable: true,
                type: {
                    name: "String"
                }
            }, fileShareName: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "fileShareName",
                required: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "protocol",
                nullable: true,
                type: {
                    name: "String"
                }
            }, serviceDataAccessAuthIdentity: {
                serializedName: "serviceDataAccessAuthIdentity",
                type: {
                    name: "String"
                }
            } })
    }
};
const AutoMLJob = {
    serializedName: "AutoML",
    type: {
        name: "Composite",
        className: "AutoMLJob",
        uberParent: "JobBaseProperties",
        polymorphicDiscriminator: JobBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobBaseProperties.type.modelProperties), { environmentId: {
                serializedName: "environmentId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, environmentVariables: {
                serializedName: "environmentVariables",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, outputs: {
                serializedName: "outputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobOutput" } }
                }
            }, resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "JobResourceConfiguration"
                }
            }, taskDetails: {
                serializedName: "taskDetails",
                type: {
                    name: "Composite",
                    className: "AutoMLVertical"
                }
            } })
    }
};
const CommandJob = {
    serializedName: "Command",
    type: {
        name: "Composite",
        className: "CommandJob",
        uberParent: "JobBaseProperties",
        polymorphicDiscriminator: JobBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobBaseProperties.type.modelProperties), { codeId: {
                serializedName: "codeId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, command: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]"),
                    MinLength: 1
                },
                serializedName: "command",
                required: true,
                type: {
                    name: "String"
                }
            }, distribution: {
                serializedName: "distribution",
                type: {
                    name: "Composite",
                    className: "DistributionConfiguration"
                }
            }, environmentId: {
                constraints: {
                    Pattern: new RegExp("[a-zA-Z0-9_]")
                },
                serializedName: "environmentId",
                required: true,
                type: {
                    name: "String"
                }
            }, environmentVariables: {
                serializedName: "environmentVariables",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, inputs: {
                serializedName: "inputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobInput" } }
                }
            }, limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "CommandJobLimits"
                }
            }, outputs: {
                serializedName: "outputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobOutput" } }
                }
            }, parameters: {
                serializedName: "parameters",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "JobResourceConfiguration"
                }
            } })
    }
};
const PipelineJob = {
    serializedName: "Pipeline",
    type: {
        name: "Composite",
        className: "PipelineJob",
        uberParent: "JobBaseProperties",
        polymorphicDiscriminator: JobBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobBaseProperties.type.modelProperties), { inputs: {
                serializedName: "inputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobInput" } }
                }
            }, jobs: {
                serializedName: "jobs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }, outputs: {
                serializedName: "outputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobOutput" } }
                }
            }, settings: {
                serializedName: "settings",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, sourceJobId: {
                serializedName: "sourceJobId",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SweepJob = {
    serializedName: "Sweep",
    type: {
        name: "Composite",
        className: "SweepJob",
        uberParent: "JobBaseProperties",
        polymorphicDiscriminator: JobBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, JobBaseProperties.type.modelProperties), { earlyTermination: {
                serializedName: "earlyTermination",
                type: {
                    name: "Composite",
                    className: "EarlyTerminationPolicy"
                }
            }, inputs: {
                serializedName: "inputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobInput" } }
                }
            }, limits: {
                serializedName: "limits",
                type: {
                    name: "Composite",
                    className: "SweepJobLimits"
                }
            }, objective: {
                serializedName: "objective",
                type: {
                    name: "Composite",
                    className: "Objective"
                }
            }, outputs: {
                serializedName: "outputs",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "JobOutput" } }
                }
            }, samplingAlgorithm: {
                serializedName: "samplingAlgorithm",
                type: {
                    name: "Composite",
                    className: "SamplingAlgorithm"
                }
            }, searchSpace: {
                serializedName: "searchSpace",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, trial: {
                serializedName: "trial",
                type: {
                    name: "Composite",
                    className: "TrialComponent"
                }
            } })
    }
};
const MLTableData = {
    serializedName: "mltable",
    type: {
        name: "Composite",
        className: "MLTableData",
        uberParent: "DataVersionBaseProperties",
        polymorphicDiscriminator: DataVersionBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, DataVersionBaseProperties.type.modelProperties), { referencedUris: {
                serializedName: "referencedUris",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const UriFileDataVersion = {
    serializedName: "uri_file",
    type: {
        name: "Composite",
        className: "UriFileDataVersion",
        uberParent: "DataVersionBaseProperties",
        polymorphicDiscriminator: DataVersionBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DataVersionBaseProperties.type.modelProperties)
    }
};
const UriFolderDataVersion = {
    serializedName: "uri_folder",
    type: {
        name: "Composite",
        className: "UriFolderDataVersion",
        uberParent: "DataVersionBaseProperties",
        polymorphicDiscriminator: DataVersionBaseProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, DataVersionBaseProperties.type.modelProperties)
    }
};
const WorkspacesDiagnoseHeaders = {
    type: {
        name: "Composite",
        className: "WorkspacesDiagnoseHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ComputeCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "ComputeCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ComputeDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchEndpointsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "BatchEndpointsDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchEndpointsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "BatchEndpointsUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchEndpointsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "BatchEndpointsCreateOrUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchDeploymentsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "BatchDeploymentsDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchDeploymentsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "BatchDeploymentsUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchDeploymentsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "BatchDeploymentsCreateOrUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JobsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "JobsDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const JobsCancelHeaders = {
    type: {
        name: "Composite",
        className: "JobsCancelHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineEndpointsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "OnlineEndpointsDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineEndpointsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "OnlineEndpointsUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineEndpointsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "OnlineEndpointsCreateOrUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OnlineEndpointsRegenerateKeysHeaders = {
    type: {
        name: "Composite",
        className: "OnlineEndpointsRegenerateKeysHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineDeploymentsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "OnlineDeploymentsDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineDeploymentsUpdateHeaders = {
    type: {
        name: "Composite",
        className: "OnlineDeploymentsUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OnlineDeploymentsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "OnlineDeploymentsCreateOrUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SchedulesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "SchedulesDeleteHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SchedulesCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "SchedulesCreateOrUpdateHeaders",
        modelProperties: {
            xMsAsyncOperationTimeout: {
                serializedName: "x-ms-async-operation-timeout",
                type: {
                    name: "TimeSpan"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    Compute: Compute,
    ComputeSecrets: ComputeSecrets,
    WorkspaceConnectionPropertiesV2: WorkspaceConnectionPropertiesV2,
    AssetReferenceBase: AssetReferenceBase,
    DatastoreCredentials: DatastoreCredentials,
    DatastoreSecrets: DatastoreSecrets,
    IdentityConfiguration: IdentityConfiguration,
    OnlineScaleSettings: OnlineScaleSettings,
    ScheduleActionBase: ScheduleActionBase,
    TriggerBase: TriggerBase,
    ForecastHorizon: ForecastHorizon,
    JobOutput: JobOutput,
    AutoMLVertical: AutoMLVertical,
    JobInput: JobInput,
    NCrossValidations: NCrossValidations,
    Seasonality: Seasonality,
    TargetLags: TargetLags,
    TargetRollingWindowSize: TargetRollingWindowSize,
    EarlyTerminationPolicy: EarlyTerminationPolicy,
    SamplingAlgorithm: SamplingAlgorithm,
    DistributionConfiguration: DistributionConfiguration,
    JobLimits: JobLimits,
    "Compute.AKS": Aks,
    "Compute.Kubernetes": Kubernetes,
    "Compute.AmlCompute": AmlCompute,
    "Compute.ComputeInstance": ComputeInstance,
    "Compute.VirtualMachine": VirtualMachine,
    "Compute.HDInsight": HDInsight,
    "Compute.DataFactory": DataFactory,
    "Compute.Databricks": Databricks,
    "Compute.DataLakeAnalytics": DataLakeAnalytics,
    "Compute.SynapseSpark": SynapseSpark,
    "ComputeSecrets.AKS": AksComputeSecrets,
    "ComputeSecrets.VirtualMachine": VirtualMachineSecrets,
    "ComputeSecrets.Databricks": DatabricksComputeSecrets,
    "WorkspaceConnectionPropertiesV2.PAT": PATAuthTypeWorkspaceConnectionProperties,
    "WorkspaceConnectionPropertiesV2.SAS": SASAuthTypeWorkspaceConnectionProperties,
    "WorkspaceConnectionPropertiesV2.UsernamePassword": UsernamePasswordAuthTypeWorkspaceConnectionProperties,
    "WorkspaceConnectionPropertiesV2.None": NoneAuthTypeWorkspaceConnectionProperties,
    "WorkspaceConnectionPropertiesV2.ManagedIdentity": ManagedIdentityAuthTypeWorkspaceConnectionProperties,
    "AssetReferenceBase.DataPath": DataPathAssetReference,
    "AssetReferenceBase.Id": IdAssetReference,
    "AssetReferenceBase.OutputPath": OutputPathAssetReference,
    "EndpointDeploymentPropertiesBase.OnlineDeploymentProperties": OnlineDeploymentProperties,
    "ResourceBase.DatastoreProperties": DatastoreProperties,
    "ResourceBase.JobBaseProperties": JobBaseProperties,
    "DatastoreCredentials.AccountKey": AccountKeyDatastoreCredentials,
    "DatastoreCredentials.Certificate": CertificateDatastoreCredentials,
    "DatastoreCredentials.None": NoneDatastoreCredentials,
    "DatastoreCredentials.Sas": SasDatastoreCredentials,
    "DatastoreCredentials.ServicePrincipal": ServicePrincipalDatastoreCredentials,
    "DatastoreSecrets.AccountKey": AccountKeyDatastoreSecrets,
    "DatastoreSecrets.Certificate": CertificateDatastoreSecrets,
    "DatastoreSecrets.Sas": SasDatastoreSecrets,
    "DatastoreSecrets.ServicePrincipal": ServicePrincipalDatastoreSecrets,
    "IdentityConfiguration.AMLToken": AmlToken,
    "IdentityConfiguration.Managed": ManagedIdentity,
    "IdentityConfiguration.UserIdentity": UserIdentity,
    "OnlineScaleSettings.Default": DefaultScaleSettings,
    "OnlineScaleSettings.TargetUtilization": TargetUtilizationScaleSettings,
    "ScheduleActionBase.InvokeBatchEndpoint": EndpointScheduleAction,
    "ScheduleActionBase.CreateJob": JobScheduleAction,
    "TriggerBase.Recurrence": RecurrenceTrigger,
    "TriggerBase.Cron": CronTrigger,
    "AssetJobInput.mltable": MLTableJobInput,
    "AssetJobInput.custom_model": CustomModelJobInput,
    "AssetJobInput.mlflow_model": MLFlowModelJobInput,
    "AssetJobInput.triton_model": TritonModelJobInput,
    "AssetJobInput.uri_file": UriFileJobInput,
    "AssetJobInput.uri_folder": UriFolderJobInput,
    "AssetJobOutput.custom_model": CustomModelJobOutput,
    "AssetJobOutput.mlflow_model": MLFlowModelJobOutput,
    "AssetJobOutput.mltable": MLTableJobOutput,
    "AssetJobOutput.triton_model": TritonModelJobOutput,
    "AssetJobOutput.uri_file": UriFileJobOutput,
    "AssetJobOutput.uri_folder": UriFolderJobOutput,
    "ForecastHorizon.Auto": AutoForecastHorizon,
    "ForecastHorizon.Custom": CustomForecastHorizon,
    "TableVertical.Classification": Classification,
    "TableVertical.Forecasting": Forecasting,
    "ImageClassificationBase.ImageClassification": ImageClassification,
    "ImageClassificationBase.ImageClassificationMultilabel": ImageClassificationMultilabel,
    "ImageObjectDetectionBase.ImageInstanceSegmentation": ImageInstanceSegmentation,
    "ImageObjectDetectionBase.ImageObjectDetection": ImageObjectDetection,
    "TableVertical.Regression": Regression,
    "NlpVertical.TextClassification": TextClassification,
    "NlpVertical.TextClassificationMultilabel": TextClassificationMultilabel,
    "NlpVertical.TextNER": TextNer,
    "JobInput.literal": LiteralJobInput,
    "NCrossValidations.Auto": AutoNCrossValidations,
    "NCrossValidations.Custom": CustomNCrossValidations,
    "Seasonality.Auto": AutoSeasonality,
    "Seasonality.Custom": CustomSeasonality,
    "TargetLags.Auto": AutoTargetLags,
    "TargetLags.Custom": CustomTargetLags,
    "TargetRollingWindowSize.Auto": AutoTargetRollingWindowSize,
    "TargetRollingWindowSize.Custom": CustomTargetRollingWindowSize,
    "EarlyTerminationPolicy.Bandit": BanditPolicy,
    "EarlyTerminationPolicy.MedianStopping": MedianStoppingPolicy,
    "EarlyTerminationPolicy.TruncationSelection": TruncationSelectionPolicy,
    "SamplingAlgorithm.Bayesian": BayesianSamplingAlgorithm,
    "SamplingAlgorithm.Grid": GridSamplingAlgorithm,
    "SamplingAlgorithm.Random": RandomSamplingAlgorithm,
    "DistributionConfiguration.Mpi": Mpi,
    "DistributionConfiguration.PyTorch": PyTorch,
    "DistributionConfiguration.TensorFlow": TensorFlow,
    "JobLimits.Command": CommandJobLimits,
    "JobLimits.Sweep": SweepJobLimits,
    "OnlineDeploymentProperties.Kubernetes": KubernetesOnlineDeployment,
    "OnlineDeploymentProperties.Managed": ManagedOnlineDeployment,
    "AssetBase.DataVersionBaseProperties": DataVersionBaseProperties,
    "DatastoreProperties.AzureBlob": AzureBlobDatastore,
    "DatastoreProperties.AzureDataLakeGen1": AzureDataLakeGen1Datastore,
    "DatastoreProperties.AzureDataLakeGen2": AzureDataLakeGen2Datastore,
    "DatastoreProperties.AzureFile": AzureFileDatastore,
    "JobBaseProperties.AutoML": AutoMLJob,
    "JobBaseProperties.Command": CommandJob,
    "JobBaseProperties.Pipeline": PipelineJob,
    "JobBaseProperties.Sweep": SweepJob,
    "DataVersionBaseProperties.mltable": MLTableData,
    "DataVersionBaseProperties.uri_file": UriFileDataVersion,
    "DataVersionBaseProperties.uri_folder": UriFolderDataVersion
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AmlOperationListResult: AmlOperationListResult,
    AmlOperation: AmlOperation,
    AmlOperationDisplay: AmlOperationDisplay,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    EncryptionProperty: EncryptionProperty,
    IdentityForCmk: IdentityForCmk,
    EncryptionKeyVaultProperties: EncryptionKeyVaultProperties,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    ManagedServiceIdentity: ManagedServiceIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    Sku: Sku,
    Resource: Resource,
    SystemData: SystemData,
    SharedPrivateLinkResource: SharedPrivateLinkResource,
    NotebookResourceInfo: NotebookResourceInfo,
    NotebookPreparationError: NotebookPreparationError,
    ServiceManagedResourcesSettings: ServiceManagedResourcesSettings,
    CosmosDbSettings: CosmosDbSettings,
    WorkspaceUpdateParameters: WorkspaceUpdateParameters,
    WorkspaceListResult: WorkspaceListResult,
    DiagnoseWorkspaceParameters: DiagnoseWorkspaceParameters,
    DiagnoseRequestProperties: DiagnoseRequestProperties,
    DiagnoseResponseResult: DiagnoseResponseResult,
    DiagnoseResponseResultValue: DiagnoseResponseResultValue,
    DiagnoseResult: DiagnoseResult,
    ListWorkspaceKeysResult: ListWorkspaceKeysResult,
    RegistryListCredentialsResult: RegistryListCredentialsResult,
    Password: Password,
    ListNotebookKeysResult: ListNotebookKeysResult,
    ListUsagesResult: ListUsagesResult,
    Usage: Usage,
    UsageName: UsageName,
    VirtualMachineSizeListResult: VirtualMachineSizeListResult,
    VirtualMachineSize: VirtualMachineSize,
    EstimatedVMPrices: EstimatedVMPrices,
    EstimatedVMPrice: EstimatedVMPrice,
    QuotaUpdateParameters: QuotaUpdateParameters,
    QuotaBaseProperties: QuotaBaseProperties,
    UpdateWorkspaceQuotasResult: UpdateWorkspaceQuotasResult,
    UpdateWorkspaceQuotas: UpdateWorkspaceQuotas,
    ListWorkspaceQuotas: ListWorkspaceQuotas,
    ResourceQuota: ResourceQuota,
    ResourceName: ResourceName,
    PaginatedComputeResourcesList: PaginatedComputeResourcesList,
    ComputeResourceSchema: ComputeResourceSchema,
    Compute: Compute,
    ClusterUpdateParameters: ClusterUpdateParameters,
    ScaleSettingsInformation: ScaleSettingsInformation,
    ScaleSettings: ScaleSettings,
    AmlComputeNodesInformation: AmlComputeNodesInformation,
    AmlComputeNodeInformation: AmlComputeNodeInformation,
    NotebookAccessTokenResult: NotebookAccessTokenResult,
    ComputeSecrets: ComputeSecrets,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ListStorageAccountKeysResult: ListStorageAccountKeysResult,
    WorkspaceConnectionPropertiesV2: WorkspaceConnectionPropertiesV2,
    WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult: WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult,
    ExternalFqdnResponse: ExternalFqdnResponse,
    FqdnEndpoints: FqdnEndpoints,
    FqdnEndpointsProperties: FqdnEndpointsProperties,
    FqdnEndpoint: FqdnEndpoint,
    FqdnEndpointDetail: FqdnEndpointDetail,
    BatchEndpointTrackedResourceArmPaginatedResult: BatchEndpointTrackedResourceArmPaginatedResult,
    BatchEndpointDefaults: BatchEndpointDefaults,
    EndpointPropertiesBase: EndpointPropertiesBase,
    EndpointAuthKeys: EndpointAuthKeys,
    PartialManagedServiceIdentity: PartialManagedServiceIdentity,
    PartialMinimalTrackedResource: PartialMinimalTrackedResource,
    BatchDeploymentTrackedResourceArmPaginatedResult: BatchDeploymentTrackedResourceArmPaginatedResult,
    AssetReferenceBase: AssetReferenceBase,
    ResourceConfiguration: ResourceConfiguration,
    BatchRetrySettings: BatchRetrySettings,
    EndpointDeploymentPropertiesBase: EndpointDeploymentPropertiesBase,
    CodeConfiguration: CodeConfiguration,
    PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties: PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties,
    PartialBatchDeployment: PartialBatchDeployment,
    CodeContainerResourceArmPaginatedResult: CodeContainerResourceArmPaginatedResult,
    ResourceBase: ResourceBase,
    CodeVersionResourceArmPaginatedResult: CodeVersionResourceArmPaginatedResult,
    ComponentContainerResourceArmPaginatedResult: ComponentContainerResourceArmPaginatedResult,
    ComponentVersionResourceArmPaginatedResult: ComponentVersionResourceArmPaginatedResult,
    DataContainerResourceArmPaginatedResult: DataContainerResourceArmPaginatedResult,
    DataVersionBaseResourceArmPaginatedResult: DataVersionBaseResourceArmPaginatedResult,
    DatastoreResourceArmPaginatedResult: DatastoreResourceArmPaginatedResult,
    DatastoreCredentials: DatastoreCredentials,
    DatastoreSecrets: DatastoreSecrets,
    EnvironmentContainerResourceArmPaginatedResult: EnvironmentContainerResourceArmPaginatedResult,
    EnvironmentVersionResourceArmPaginatedResult: EnvironmentVersionResourceArmPaginatedResult,
    BuildContext: BuildContext,
    InferenceContainerProperties: InferenceContainerProperties,
    Route: Route,
    JobBaseResourceArmPaginatedResult: JobBaseResourceArmPaginatedResult,
    IdentityConfiguration: IdentityConfiguration,
    JobService: JobService,
    ModelContainerResourceArmPaginatedResult: ModelContainerResourceArmPaginatedResult,
    ModelVersionResourceArmPaginatedResult: ModelVersionResourceArmPaginatedResult,
    FlavorData: FlavorData,
    OnlineEndpointTrackedResourceArmPaginatedResult: OnlineEndpointTrackedResourceArmPaginatedResult,
    OnlineDeploymentTrackedResourceArmPaginatedResult: OnlineDeploymentTrackedResourceArmPaginatedResult,
    ProbeSettings: ProbeSettings,
    OnlineRequestSettings: OnlineRequestSettings,
    OnlineScaleSettings: OnlineScaleSettings,
    PartialSku: PartialSku,
    DeploymentLogsRequest: DeploymentLogsRequest,
    DeploymentLogs: DeploymentLogs,
    SkuResourceArmPaginatedResult: SkuResourceArmPaginatedResult,
    SkuResource: SkuResource,
    SkuCapacity: SkuCapacity,
    SkuSetting: SkuSetting,
    RegenerateEndpointKeysRequest: RegenerateEndpointKeysRequest,
    EndpointAuthToken: EndpointAuthToken,
    ScheduleResourceArmPaginatedResult: ScheduleResourceArmPaginatedResult,
    ScheduleActionBase: ScheduleActionBase,
    TriggerBase: TriggerBase,
    ListAmlUserFeatureResult: ListAmlUserFeatureResult,
    AmlUserFeature: AmlUserFeature,
    ResourceId: ResourceId,
    AKSSchema: AKSSchema,
    AKSSchemaProperties: AKSSchemaProperties,
    SystemService: SystemService,
    SslConfiguration: SslConfiguration,
    AksNetworkingConfiguration: AksNetworkingConfiguration,
    KubernetesSchema: KubernetesSchema,
    KubernetesProperties: KubernetesProperties,
    InstanceTypeSchema: InstanceTypeSchema,
    InstanceTypeSchemaResources: InstanceTypeSchemaResources,
    AmlComputeProperties: AmlComputeProperties,
    VirtualMachineImage: VirtualMachineImage,
    UserAccountCredentials: UserAccountCredentials,
    NodeStateCounts: NodeStateCounts,
    AmlComputeSchema: AmlComputeSchema,
    ComputeInstanceProperties: ComputeInstanceProperties,
    ComputeInstanceSshSettings: ComputeInstanceSshSettings,
    ComputeInstanceConnectivityEndpoints: ComputeInstanceConnectivityEndpoints,
    ComputeInstanceApplication: ComputeInstanceApplication,
    ComputeInstanceCreatedBy: ComputeInstanceCreatedBy,
    PersonalComputeInstanceSettings: PersonalComputeInstanceSettings,
    AssignedUser: AssignedUser,
    SetupScripts: SetupScripts,
    ScriptsToExecute: ScriptsToExecute,
    ScriptReference: ScriptReference,
    ComputeInstanceLastOperation: ComputeInstanceLastOperation,
    ComputeSchedules: ComputeSchedules,
    ComputeStartStopSchedule: ComputeStartStopSchedule,
    RecurrenceSchedule: RecurrenceSchedule,
    ScheduleBase: ScheduleBase,
    ComputeInstanceContainer: ComputeInstanceContainer,
    ComputeInstanceEnvironmentInfo: ComputeInstanceEnvironmentInfo,
    ComputeInstanceDataDisk: ComputeInstanceDataDisk,
    ComputeInstanceDataMount: ComputeInstanceDataMount,
    ComputeInstanceVersion: ComputeInstanceVersion,
    ComputeInstanceSchema: ComputeInstanceSchema,
    VirtualMachineSchema: VirtualMachineSchema,
    VirtualMachineSchemaProperties: VirtualMachineSchemaProperties,
    VirtualMachineSshCredentials: VirtualMachineSshCredentials,
    HDInsightProperties: HDInsightProperties,
    HDInsightSchema: HDInsightSchema,
    DatabricksProperties: DatabricksProperties,
    DatabricksSchema: DatabricksSchema,
    DataLakeAnalyticsSchema: DataLakeAnalyticsSchema,
    DataLakeAnalyticsSchemaProperties: DataLakeAnalyticsSchemaProperties,
    SynapseSparkProperties: SynapseSparkProperties,
    AutoScaleProperties: AutoScaleProperties,
    AutoPauseProperties: AutoPauseProperties,
    AksComputeSecretsProperties: AksComputeSecretsProperties,
    VirtualMachineSecretsSchema: VirtualMachineSecretsSchema,
    DatabricksComputeSecretsProperties: DatabricksComputeSecretsProperties,
    WorkspaceConnectionUsernamePassword: WorkspaceConnectionUsernamePassword,
    WorkspaceConnectionPersonalAccessToken: WorkspaceConnectionPersonalAccessToken,
    WorkspaceConnectionSharedAccessSignature: WorkspaceConnectionSharedAccessSignature,
    WorkspaceConnectionManagedIdentity: WorkspaceConnectionManagedIdentity,
    AssetJobInput: AssetJobInput,
    AssetJobOutput: AssetJobOutput,
    ForecastHorizon: ForecastHorizon,
    JobOutput: JobOutput,
    AutoMLVertical: AutoMLVertical,
    JobInput: JobInput,
    NCrossValidations: NCrossValidations,
    Seasonality: Seasonality,
    TargetLags: TargetLags,
    TargetRollingWindowSize: TargetRollingWindowSize,
    EarlyTerminationPolicy: EarlyTerminationPolicy,
    SamplingAlgorithm: SamplingAlgorithm,
    TrainingSettings: TrainingSettings,
    StackEnsembleSettings: StackEnsembleSettings,
    TableVertical: TableVertical,
    ColumnTransformer: ColumnTransformer,
    FeaturizationSettings: FeaturizationSettings,
    TableVerticalLimitSettings: TableVerticalLimitSettings,
    DistributionConfiguration: DistributionConfiguration,
    JobLimits: JobLimits,
    ContainerResourceRequirements: ContainerResourceRequirements,
    ContainerResourceSettings: ContainerResourceSettings,
    ForecastingSettings: ForecastingSettings,
    ImageModelSettings: ImageModelSettings,
    ImageModelDistributionSettings: ImageModelDistributionSettings,
    ImageVertical: ImageVertical,
    ImageLimitSettings: ImageLimitSettings,
    ImageSweepSettings: ImageSweepSettings,
    NlpVertical: NlpVertical,
    NlpVerticalLimitSettings: NlpVerticalLimitSettings,
    Objective: Objective,
    TrialComponent: TrialComponent,
    PrivateEndpointConnection: PrivateEndpointConnection,
    Workspace: Workspace,
    ComputeResource: ComputeResource,
    PrivateLinkResource: PrivateLinkResource,
    WorkspaceConnectionPropertiesV2BasicResource: WorkspaceConnectionPropertiesV2BasicResource,
    TrackedResource: TrackedResource,
    CodeContainer: CodeContainer,
    CodeVersion: CodeVersion,
    ComponentContainer: ComponentContainer,
    ComponentVersion: ComponentVersion,
    DataContainer: DataContainer,
    DataVersionBase: DataVersionBase,
    Datastore: Datastore,
    EnvironmentContainer: EnvironmentContainer,
    EnvironmentVersion: EnvironmentVersion,
    JobBase: JobBase,
    ModelContainer: ModelContainer,
    ModelVersion: ModelVersion,
    Schedule: Schedule,
    Aks: Aks,
    Kubernetes: Kubernetes,
    AmlCompute: AmlCompute,
    ComputeInstance: ComputeInstance,
    VirtualMachine: VirtualMachine,
    HDInsight: HDInsight,
    DataFactory: DataFactory,
    Databricks: Databricks,
    DataLakeAnalytics: DataLakeAnalytics,
    SynapseSpark: SynapseSpark,
    AksComputeSecrets: AksComputeSecrets,
    VirtualMachineSecrets: VirtualMachineSecrets,
    DatabricksComputeSecrets: DatabricksComputeSecrets,
    PATAuthTypeWorkspaceConnectionProperties: PATAuthTypeWorkspaceConnectionProperties,
    SASAuthTypeWorkspaceConnectionProperties: SASAuthTypeWorkspaceConnectionProperties,
    UsernamePasswordAuthTypeWorkspaceConnectionProperties: UsernamePasswordAuthTypeWorkspaceConnectionProperties,
    NoneAuthTypeWorkspaceConnectionProperties: NoneAuthTypeWorkspaceConnectionProperties,
    ManagedIdentityAuthTypeWorkspaceConnectionProperties: ManagedIdentityAuthTypeWorkspaceConnectionProperties,
    BatchEndpointProperties: BatchEndpointProperties,
    OnlineEndpointProperties: OnlineEndpointProperties,
    PartialMinimalTrackedResourceWithIdentity: PartialMinimalTrackedResourceWithIdentity,
    PartialMinimalTrackedResourceWithSku: PartialMinimalTrackedResourceWithSku,
    DataPathAssetReference: DataPathAssetReference,
    IdAssetReference: IdAssetReference,
    OutputPathAssetReference: OutputPathAssetReference,
    DeploymentResourceConfiguration: DeploymentResourceConfiguration,
    JobResourceConfiguration: JobResourceConfiguration,
    BatchDeploymentProperties: BatchDeploymentProperties,
    OnlineDeploymentProperties: OnlineDeploymentProperties,
    AssetContainer: AssetContainer,
    AssetBase: AssetBase,
    DatastoreProperties: DatastoreProperties,
    JobBaseProperties: JobBaseProperties,
    ScheduleProperties: ScheduleProperties,
    AccountKeyDatastoreCredentials: AccountKeyDatastoreCredentials,
    CertificateDatastoreCredentials: CertificateDatastoreCredentials,
    NoneDatastoreCredentials: NoneDatastoreCredentials,
    SasDatastoreCredentials: SasDatastoreCredentials,
    ServicePrincipalDatastoreCredentials: ServicePrincipalDatastoreCredentials,
    AccountKeyDatastoreSecrets: AccountKeyDatastoreSecrets,
    CertificateDatastoreSecrets: CertificateDatastoreSecrets,
    SasDatastoreSecrets: SasDatastoreSecrets,
    ServicePrincipalDatastoreSecrets: ServicePrincipalDatastoreSecrets,
    AmlToken: AmlToken,
    ManagedIdentity: ManagedIdentity,
    UserIdentity: UserIdentity,
    DefaultScaleSettings: DefaultScaleSettings,
    TargetUtilizationScaleSettings: TargetUtilizationScaleSettings,
    EndpointScheduleAction: EndpointScheduleAction,
    JobScheduleAction: JobScheduleAction,
    RecurrenceTrigger: RecurrenceTrigger,
    CronTrigger: CronTrigger,
    MLTableJobInput: MLTableJobInput,
    CustomModelJobInput: CustomModelJobInput,
    MLFlowModelJobInput: MLFlowModelJobInput,
    TritonModelJobInput: TritonModelJobInput,
    UriFileJobInput: UriFileJobInput,
    UriFolderJobInput: UriFolderJobInput,
    CustomModelJobOutput: CustomModelJobOutput,
    MLFlowModelJobOutput: MLFlowModelJobOutput,
    MLTableJobOutput: MLTableJobOutput,
    TritonModelJobOutput: TritonModelJobOutput,
    UriFileJobOutput: UriFileJobOutput,
    UriFolderJobOutput: UriFolderJobOutput,
    AutoForecastHorizon: AutoForecastHorizon,
    CustomForecastHorizon: CustomForecastHorizon,
    Classification: Classification,
    Forecasting: Forecasting,
    ImageClassificationBase: ImageClassificationBase,
    ImageClassification: ImageClassification,
    ImageClassificationMultilabel: ImageClassificationMultilabel,
    ImageObjectDetectionBase: ImageObjectDetectionBase,
    ImageInstanceSegmentation: ImageInstanceSegmentation,
    ImageObjectDetection: ImageObjectDetection,
    Regression: Regression,
    TextClassification: TextClassification,
    TextClassificationMultilabel: TextClassificationMultilabel,
    TextNer: TextNer,
    LiteralJobInput: LiteralJobInput,
    AutoNCrossValidations: AutoNCrossValidations,
    CustomNCrossValidations: CustomNCrossValidations,
    AutoSeasonality: AutoSeasonality,
    CustomSeasonality: CustomSeasonality,
    AutoTargetLags: AutoTargetLags,
    CustomTargetLags: CustomTargetLags,
    AutoTargetRollingWindowSize: AutoTargetRollingWindowSize,
    CustomTargetRollingWindowSize: CustomTargetRollingWindowSize,
    BanditPolicy: BanditPolicy,
    MedianStoppingPolicy: MedianStoppingPolicy,
    TruncationSelectionPolicy: TruncationSelectionPolicy,
    BayesianSamplingAlgorithm: BayesianSamplingAlgorithm,
    GridSamplingAlgorithm: GridSamplingAlgorithm,
    RandomSamplingAlgorithm: RandomSamplingAlgorithm,
    ClassificationTrainingSettings: ClassificationTrainingSettings,
    ForecastingTrainingSettings: ForecastingTrainingSettings,
    RegressionTrainingSettings: RegressionTrainingSettings,
    TableVerticalFeaturizationSettings: TableVerticalFeaturizationSettings,
    NlpVerticalFeaturizationSettings: NlpVerticalFeaturizationSettings,
    Mpi: Mpi,
    PyTorch: PyTorch,
    TensorFlow: TensorFlow,
    CommandJobLimits: CommandJobLimits,
    SweepJobLimits: SweepJobLimits,
    ImageModelSettingsClassification: ImageModelSettingsClassification,
    ImageModelSettingsObjectDetection: ImageModelSettingsObjectDetection,
    ImageModelDistributionSettingsClassification: ImageModelDistributionSettingsClassification,
    ImageModelDistributionSettingsObjectDetection: ImageModelDistributionSettingsObjectDetection,
    BatchEndpoint: BatchEndpoint,
    BatchDeployment: BatchDeployment,
    OnlineEndpoint: OnlineEndpoint,
    OnlineDeployment: OnlineDeployment,
    KubernetesOnlineDeployment: KubernetesOnlineDeployment,
    ManagedOnlineDeployment: ManagedOnlineDeployment,
    CodeContainerProperties: CodeContainerProperties,
    ComponentContainerProperties: ComponentContainerProperties,
    DataContainerProperties: DataContainerProperties,
    EnvironmentContainerProperties: EnvironmentContainerProperties,
    ModelContainerProperties: ModelContainerProperties,
    CodeVersionProperties: CodeVersionProperties,
    ComponentVersionProperties: ComponentVersionProperties,
    DataVersionBaseProperties: DataVersionBaseProperties,
    EnvironmentVersionProperties: EnvironmentVersionProperties,
    ModelVersionProperties: ModelVersionProperties,
    AzureBlobDatastore: AzureBlobDatastore,
    AzureDataLakeGen1Datastore: AzureDataLakeGen1Datastore,
    AzureDataLakeGen2Datastore: AzureDataLakeGen2Datastore,
    AzureFileDatastore: AzureFileDatastore,
    AutoMLJob: AutoMLJob,
    CommandJob: CommandJob,
    PipelineJob: PipelineJob,
    SweepJob: SweepJob,
    MLTableData: MLTableData,
    UriFileDataVersion: UriFileDataVersion,
    UriFolderDataVersion: UriFolderDataVersion,
    WorkspacesDiagnoseHeaders: WorkspacesDiagnoseHeaders,
    ComputeCreateOrUpdateHeaders: ComputeCreateOrUpdateHeaders,
    ComputeDeleteHeaders: ComputeDeleteHeaders,
    BatchEndpointsDeleteHeaders: BatchEndpointsDeleteHeaders,
    BatchEndpointsUpdateHeaders: BatchEndpointsUpdateHeaders,
    BatchEndpointsCreateOrUpdateHeaders: BatchEndpointsCreateOrUpdateHeaders,
    BatchDeploymentsDeleteHeaders: BatchDeploymentsDeleteHeaders,
    BatchDeploymentsUpdateHeaders: BatchDeploymentsUpdateHeaders,
    BatchDeploymentsCreateOrUpdateHeaders: BatchDeploymentsCreateOrUpdateHeaders,
    JobsDeleteHeaders: JobsDeleteHeaders,
    JobsCancelHeaders: JobsCancelHeaders,
    OnlineEndpointsDeleteHeaders: OnlineEndpointsDeleteHeaders,
    OnlineEndpointsUpdateHeaders: OnlineEndpointsUpdateHeaders,
    OnlineEndpointsCreateOrUpdateHeaders: OnlineEndpointsCreateOrUpdateHeaders,
    OnlineEndpointsRegenerateKeysHeaders: OnlineEndpointsRegenerateKeysHeaders,
    OnlineDeploymentsDeleteHeaders: OnlineDeploymentsDeleteHeaders,
    OnlineDeploymentsUpdateHeaders: OnlineDeploymentsUpdateHeaders,
    OnlineDeploymentsCreateOrUpdateHeaders: OnlineDeploymentsCreateOrUpdateHeaders,
    SchedulesDeleteHeaders: SchedulesDeleteHeaders,
    SchedulesCreateOrUpdateHeaders: SchedulesCreateOrUpdateHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceName = {
    parameterPath: "workspaceName",
    mapper: {
        serializedName: "workspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Workspace
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: WorkspaceUpdateParameters
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: ["options", "parameters"],
    mapper: DiagnoseWorkspaceParameters
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: QuotaUpdateParameters
};
const computeName = {
    parameterPath: "computeName",
    mapper: {
        serializedName: "computeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ComputeResource
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ClusterUpdateParameters
};
const underlyingResourceAction = {
    parameterPath: "underlyingResourceAction",
    mapper: {
        serializedName: "underlyingResourceAction",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: PrivateEndpointConnection
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: WorkspaceConnectionPropertiesV2BasicResource
};
const connectionName = {
    parameterPath: "connectionName",
    mapper: {
        serializedName: "connectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const target = {
    parameterPath: ["options", "target"],
    mapper: {
        serializedName: "target",
        type: {
            name: "String"
        }
    }
};
const category = {
    parameterPath: ["options", "category"],
    mapper: {
        serializedName: "category",
        type: {
            name: "String"
        }
    }
};
const count = {
    parameterPath: ["options", "count"],
    mapper: {
        serializedName: "count",
        type: {
            name: "Number"
        }
    }
};
const endpointName = {
    parameterPath: "endpointName",
    mapper: {
        serializedName: "endpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: PartialMinimalTrackedResourceWithIdentity
};
const endpointName1 = {
    parameterPath: "endpointName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,254}$")
        },
        serializedName: "endpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body1 = {
    parameterPath: "body",
    mapper: BatchEndpoint
};
const orderBy = {
    parameterPath: ["options", "orderBy"],
    mapper: {
        serializedName: "$orderBy",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const deploymentName = {
    parameterPath: "deploymentName",
    mapper: {
        serializedName: "deploymentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body2 = {
    parameterPath: "body",
    mapper: PartialBatchDeploymentPartialMinimalTrackedResourceWithProperties
};
const deploymentName1 = {
    parameterPath: "deploymentName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,254}$")
        },
        serializedName: "deploymentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body3 = {
    parameterPath: "body",
    mapper: BatchDeployment
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body4 = {
    parameterPath: "body",
    mapper: CodeContainer
};
const name1 = {
    parameterPath: "name",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,254}$")
        },
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const version = {
    parameterPath: "version",
    mapper: {
        serializedName: "version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body5 = {
    parameterPath: "body",
    mapper: CodeVersion
};
const listViewType = {
    parameterPath: ["options", "listViewType"],
    mapper: {
        serializedName: "listViewType",
        type: {
            name: "String"
        }
    }
};
const body6 = {
    parameterPath: "body",
    mapper: ComponentContainer
};
const body7 = {
    parameterPath: "body",
    mapper: ComponentVersion
};
const body8 = {
    parameterPath: "body",
    mapper: DataContainer
};
const tags = {
    parameterPath: ["options", "tags"],
    mapper: {
        serializedName: "$tags",
        type: {
            name: "String"
        }
    }
};
const body9 = {
    parameterPath: "body",
    mapper: DataVersionBase
};
const count1 = {
    parameterPath: ["options", "count"],
    mapper: {
        defaultValue: 30,
        serializedName: "count",
        type: {
            name: "Number"
        }
    }
};
const isDefault = {
    parameterPath: ["options", "isDefault"],
    mapper: {
        serializedName: "isDefault",
        type: {
            name: "Boolean"
        }
    }
};
const names = {
    parameterPath: ["options", "names"],
    mapper: {
        serializedName: "names",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: "CSV"
};
const searchText = {
    parameterPath: ["options", "searchText"],
    mapper: {
        serializedName: "searchText",
        type: {
            name: "String"
        }
    }
};
const orderBy1 = {
    parameterPath: ["options", "orderBy"],
    mapper: {
        serializedName: "orderBy",
        type: {
            name: "String"
        }
    }
};
const orderByAsc = {
    parameterPath: ["options", "orderByAsc"],
    mapper: {
        defaultValue: false,
        serializedName: "orderByAsc",
        type: {
            name: "Boolean"
        }
    }
};
const body10 = {
    parameterPath: "body",
    mapper: Datastore
};
const skipValidation = {
    parameterPath: ["options", "skipValidation"],
    mapper: {
        defaultValue: false,
        serializedName: "skipValidation",
        type: {
            name: "Boolean"
        }
    }
};
const body11 = {
    parameterPath: "body",
    mapper: EnvironmentContainer
};
const body12 = {
    parameterPath: "body",
    mapper: EnvironmentVersion
};
const jobType = {
    parameterPath: ["options", "jobType"],
    mapper: {
        serializedName: "jobType",
        type: {
            name: "String"
        }
    }
};
const tag = {
    parameterPath: ["options", "tag"],
    mapper: {
        serializedName: "tag",
        type: {
            name: "String"
        }
    }
};
const id = {
    parameterPath: "id",
    mapper: {
        serializedName: "id",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body13 = {
    parameterPath: "body",
    mapper: JobBase
};
const id1 = {
    parameterPath: "id",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,254}$")
        },
        serializedName: "id",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body14 = {
    parameterPath: "body",
    mapper: ModelContainer
};
const version1 = {
    parameterPath: ["options", "version"],
    mapper: {
        serializedName: "version",
        type: {
            name: "String"
        }
    }
};
const description = {
    parameterPath: ["options", "description"],
    mapper: {
        serializedName: "description",
        type: {
            name: "String"
        }
    }
};
const offset = {
    parameterPath: ["options", "offset"],
    mapper: {
        serializedName: "offset",
        type: {
            name: "Number"
        }
    }
};
const tags1 = {
    parameterPath: ["options", "tags"],
    mapper: {
        serializedName: "tags",
        type: {
            name: "String"
        }
    }
};
const properties1 = {
    parameterPath: ["options", "properties"],
    mapper: {
        serializedName: "properties",
        type: {
            name: "String"
        }
    }
};
const feed = {
    parameterPath: ["options", "feed"],
    mapper: {
        serializedName: "feed",
        type: {
            name: "String"
        }
    }
};
const body15 = {
    parameterPath: "body",
    mapper: ModelVersion
};
const name2 = {
    parameterPath: ["options", "name"],
    mapper: {
        serializedName: "name",
        type: {
            name: "String"
        }
    }
};
const computeType = {
    parameterPath: ["options", "computeType"],
    mapper: {
        serializedName: "computeType",
        type: {
            name: "String"
        }
    }
};
const orderBy2 = {
    parameterPath: ["options", "orderBy"],
    mapper: {
        serializedName: "orderBy",
        type: {
            name: "String"
        }
    }
};
const body16 = {
    parameterPath: "body",
    mapper: OnlineEndpoint
};
const body17 = {
    parameterPath: "body",
    mapper: RegenerateEndpointKeysRequest
};
const body18 = {
    parameterPath: "body",
    mapper: PartialMinimalTrackedResourceWithSku
};
const body19 = {
    parameterPath: "body",
    mapper: OnlineDeployment
};
const body20 = {
    parameterPath: "body",
    mapper: DeploymentLogsRequest
};
const listViewType1 = {
    parameterPath: ["options", "listViewType"],
    mapper: {
        serializedName: "listViewType",
        type: {
            name: "String"
        }
    }
};
const body21 = {
    parameterPath: "body",
    mapper: Schedule
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Azure Machine Learning Workspaces REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Azure Machine Learning Workspaces REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$p);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$p = {
    path: "/providers/Microsoft.MachineLearningServices/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlOperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Workspaces operations. */
class WorkspacesImpl {
    /**
     * Initialize a new instance of the class Workspaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the available machine learning workspaces under the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the available machine learning workspaces under the specified subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the properties of the specified machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$k);
    }
    /**
     * Creates or updates a workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for creating or updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, parameters, options }, createOrUpdateOperationSpec$j);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for creating or updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, deleteOperationSpec$k);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a machine learning workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, parameters, options }, updateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a machine learning workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the available machine learning workspaces under the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Diagnose workspace setup issue.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDiagnose(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, diagnoseOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Diagnose workspace setup issue.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDiagnoseAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDiagnose(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listKeysOperationSpec$3);
    }
    /**
     * Resync all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginResyncKeys(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, resyncKeysOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resync all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginResyncKeysAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResyncKeys(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the available machine learning workspaces under the specified subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * return notebook access token and refresh token
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listNotebookAccessToken(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listNotebookAccessTokenOperationSpec);
    }
    /**
     * Prepare a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginPrepareNotebook(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, prepareNotebookOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Prepare a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginPrepareNotebookAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPrepareNotebook(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List storage account keys of a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listStorageAccountKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listStorageAccountKeysOperationSpec);
    }
    /**
     * List keys of a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listNotebookKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listNotebookKeysOperationSpec);
    }
    /**
     * Called by Client (Portal, CLI, etc) to get a list of all external outbound dependencies (FQDNs)
     * programmatically.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const diagnoseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/diagnose",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnoseResponseResult
        },
        201: {
            bodyMapper: DiagnoseResponseResult
        },
        202: {
            bodyMapper: DiagnoseResponseResult
        },
        204: {
            bodyMapper: DiagnoseResponseResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const listKeysOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListWorkspaceKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const resyncKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/resyncKeys",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$p
};
const listNotebookAccessTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listNotebookAccessToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NotebookAccessTokenResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const prepareNotebookOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/prepareNotebook",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NotebookResourceInfo
        },
        201: {
            bodyMapper: NotebookResourceInfo
        },
        202: {
            bodyMapper: NotebookResourceInfo
        },
        204: {
            bodyMapper: NotebookResourceInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listStorageAccountKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listStorageAccountKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListStorageAccountKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listNotebookKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listNotebookKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListNotebookKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalFqdnResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the current usage information as well as limits for AML resources for given subscription and
     * location.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the current usage information as well as limits for AML resources for given subscription and
     * location.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$o);
    }
    /**
     * ListNext
     * @param location The location for which resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$l);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineSizes operations. */
class VirtualMachineSizesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineSizes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns supported VM Sizes in a location
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$n);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/vmSizes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineSizeListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Quotas operations. */
class QuotasImpl {
    /**
     * Initialize a new instance of the class Quotas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the currently assigned Workspace Quotas based on VMFamily.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Update quota for each VM family in workspace.
     * @param location The location for update quota is queried.
     * @param parameters Quota update parameters.
     * @param options The options parameters.
     */
    update(location, parameters, options) {
        return this.client.sendOperationRequest({ location, parameters, options }, updateOperationSpec$5);
    }
    /**
     * Gets the currently assigned Workspace Quotas based on VMFamily.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$m);
    }
    /**
     * ListNext
     * @param location The location for which resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/updateQuotas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UpdateWorkspaceQuotasResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/quotas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListWorkspaceQuotas
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$m
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListWorkspaceQuotas
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ComputeOperations operations. */
class ComputeOperationsImpl {
    /**
     * Initialize a new instance of the class ComputeOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets computes in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the details (e.g IP address, port etc) of all the compute nodes in the compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    listNodes(resourceGroupName, workspaceName, computeName, options) {
        const iter = this.listNodesPagingAll(resourceGroupName, workspaceName, computeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listNodesPagingPage(resourceGroupName, workspaceName, computeName, options, settings);
            }
        };
    }
    listNodesPagingPage(resourceGroupName, workspaceName, computeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listNodesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listNodes(resourceGroupName, workspaceName, computeName, options));
                let page = result.nodes || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNodesNext(resourceGroupName, workspaceName, computeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.nodes || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listNodesPagingAll(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listNodesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listNodesPagingPage(resourceGroupName, workspaceName, computeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets computes in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$l);
    }
    /**
     * Gets compute definition by its name. Any secrets (storage keys, service credentials, etc) are not
     * returned - use 'keys' nested resource to get them.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, getOperationSpec$j);
    }
    /**
     * Creates or updates compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation. If your intent is to create a new compute, do a GET first to verify that
     * it does not exist yet.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Payload with Machine Learning compute definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, parameters, options }, createOrUpdateOperationSpec$i);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation. If your intent is to create a new compute, do a GET first to verify that
     * it does not exist yet.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Payload with Machine Learning compute definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, computeName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates properties of a compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Additional parameters for cluster update.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, parameters, options }, updateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates properties of a compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Additional parameters for cluster update.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, computeName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes specified Machine Learning compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param underlyingResourceAction Delete the underlying compute if 'Delete', or detach the underlying
     *                                 compute from workspace if 'Detach'.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                computeName,
                underlyingResourceAction,
                options
            }, deleteOperationSpec$j);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes specified Machine Learning compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param underlyingResourceAction Delete the underlying compute if 'Delete', or detach the underlying
     *                                 compute from workspace if 'Detach'.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the details (e.g IP address, port etc) of all the compute nodes in the compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    _listNodes(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, listNodesOperationSpec);
    }
    /**
     * Gets secrets related to Machine Learning compute (storage keys, service credentials, etc).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, listKeysOperationSpec$2);
    }
    /**
     * Posts a start action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a start action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Posts a stop action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a stop action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Posts a restart action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a restart action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$j);
    }
    /**
     * ListNodesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param nextLink The nextLink from the previous successful call to the ListNodes method.
     * @param options The options parameters.
     */
    _listNodesNext(resourceGroupName, workspaceName, computeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, nextLink, options }, listNodesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PaginatedComputeResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        201: {
            bodyMapper: ComputeResource
        },
        202: {
            bodyMapper: ComputeResource
        },
        204: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        201: {
            bodyMapper: ComputeResource
        },
        202: {
            bodyMapper: ComputeResource
        },
        204: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, underlyingResourceAction],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNodesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/listNodes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AmlComputeNodesInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listKeysOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ComputeSecrets
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PaginatedComputeResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNodesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlComputeNodesInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the private endpoint connections associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the private endpoint connections associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$k);
    }
    /**
     * Gets the specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$i);
    }
    /**
     * Update the state of specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param properties The private endpoint connection properties.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            properties,
            options
        }, createOrUpdateOperationSpec$h);
    }
    /**
     * Deletes the specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, deleteOperationSpec$i);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources that need to be created for a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$j);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceConnections operations. */
class WorkspaceConnectionsImpl {
    /**
     * Initialize a new instance of the class WorkspaceConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param parameters The object for creating or updating a new workspace connection
     * @param options The options parameters.
     */
    create(resourceGroupName, workspaceName, connectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, parameters, options }, createOperationSpec);
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, options }, getOperationSpec$h);
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, options }, deleteOperationSpec$h);
    }
    /**
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$i);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkspaceConnectionPropertiesV2BasicResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceConnectionPropertiesV2BasicResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        target,
        category
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceConnectionPropertiesV2BasicResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        target,
        category
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BatchEndpoints operations. */
class BatchEndpointsImpl {
    /**
     * Initialize a new instance of the class BatchEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists Batch inference endpoint in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists Batch inference endpoint in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$h);
    }
    /**
     * Delete Batch Inference Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference Endpoint name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, options }, deleteOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete Batch Inference Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference Endpoint name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a batch inference endpoint by name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Name for the Batch Endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, getOperationSpec$g);
    }
    /**
     * Update a batch inference endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Name for the Batch inference endpoint.
     * @param body Mutable batch inference endpoint definition object.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, body, options }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a batch inference endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Name for the Batch inference endpoint.
     * @param body Mutable batch inference endpoint definition object.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, endpointName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates a batch inference endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Name for the Batch inference endpoint.
     * @param body Batch inference endpoint definition object.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, body, options }, createOrUpdateOperationSpec$g);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a batch inference endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Name for the Batch inference endpoint.
     * @param body Batch inference endpoint definition object.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists batch Inference Endpoint keys.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference Endpoint name.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, listKeysOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchEndpointTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip, count],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BatchEndpoint
        },
        201: {
            bodyMapper: BatchEndpoint
        },
        202: {
            bodyMapper: BatchEndpoint
        },
        204: {
            bodyMapper: BatchEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BatchEndpoint
        },
        201: {
            bodyMapper: BatchEndpoint
        },
        202: {
            bodyMapper: BatchEndpoint
        },
        204: {
            bodyMapper: BatchEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const listKeysOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/listkeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EndpointAuthKeys
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchEndpointTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip, count],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BatchDeployments operations. */
class BatchDeploymentsImpl {
    /**
     * Initialize a new instance of the class BatchDeployments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists Batch inference deployments in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, endpointName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, endpointName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists Batch inference deployments in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, listOperationSpec$g);
    }
    /**
     * Delete Batch Inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param deploymentName Inference deployment identifier.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                options
            }, deleteOperationSpec$f);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete Batch Inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param deploymentName Inference deployment identifier.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, endpointName, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a batch inference deployment by id.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param deploymentName The identifier for the Batch deployments.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            endpointName,
            deploymentName,
            options
        }, getOperationSpec$f);
    }
    /**
     * Update a batch inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name
     * @param deploymentName The identifier for the Batch inference deployment.
     * @param body Batch inference deployment definition object.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                body,
                options
            }, updateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a batch inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name
     * @param deploymentName The identifier for the Batch inference deployment.
     * @param body Batch inference deployment definition object.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates/updates a batch inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name
     * @param deploymentName The identifier for the Batch inference deployment.
     * @param body Batch inference deployment definition object.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                body,
                options
            }, createOrUpdateOperationSpec$f);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates/updates a batch inference deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name
     * @param deploymentName The identifier for the Batch inference deployment.
     * @param body Batch inference deployment definition object.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Endpoint name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchDeploymentTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BatchDeployment
        },
        201: {
            bodyMapper: BatchDeployment
        },
        202: {
            bodyMapper: BatchDeployment
        },
        204: {
            bodyMapper: BatchDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1,
        deploymentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/batchEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BatchDeployment
        },
        201: {
            bodyMapper: BatchDeployment
        },
        202: {
            bodyMapper: BatchDeployment
        },
        204: {
            bodyMapper: BatchDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1,
        deploymentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchDeploymentTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CodeContainers operations. */
class CodeContainersImpl {
    /**
     * Initialize a new instance of the class CodeContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$f);
    }
    /**
     * Delete container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$e);
    }
    /**
     * Get container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$e);
    }
    /**
     * Create or update container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param body Container entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CodeContainer
        },
        201: {
            bodyMapper: CodeContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CodeVersions operations. */
class CodeVersionsImpl {
    /**
     * Initialize a new instance of the class CodeVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listOperationSpec$e);
    }
    /**
     * Delete version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, deleteOperationSpec$d);
    }
    /**
     * Get version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, getOperationSpec$d);
    }
    /**
     * Create or update version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param body Version entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, version, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, body, options }, createOrUpdateOperationSpec$d);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/codes/{name}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CodeVersion
        },
        201: {
            bodyMapper: CodeVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CodeVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ComponentContainers operations. */
class ComponentContainersImpl {
    /**
     * Initialize a new instance of the class ComponentContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List component containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List component containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$d);
    }
    /**
     * Delete container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$c);
    }
    /**
     * Get container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$c);
    }
    /**
     * Create or update container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param body Container entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ComponentContainer
        },
        201: {
            bodyMapper: ComponentContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ComponentVersions operations. */
class ComponentVersionsImpl {
    /**
     * Initialize a new instance of the class ComponentVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List component versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Component name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List component versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Component name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listOperationSpec$c);
    }
    /**
     * Delete version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, deleteOperationSpec$b);
    }
    /**
     * Get version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, getOperationSpec$b);
    }
    /**
     * Create or update version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param body Version entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, version, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, body, options }, createOrUpdateOperationSpec$b);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Component name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/components/{name}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ComponentVersion
        },
        201: {
            bodyMapper: ComponentVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComponentVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataContainers operations. */
class DataContainersImpl {
    /**
     * Initialize a new instance of the class DataContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List data containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List data containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$b);
    }
    /**
     * Delete container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$a);
    }
    /**
     * Get container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$a);
    }
    /**
     * Create or update container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param body Container entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataContainer
        },
        201: {
            bodyMapper: DataContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataVersions operations. */
class DataVersionsImpl {
    /**
     * Initialize a new instance of the class DataVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List data versions in the data container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Data container's name
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List data versions in the data container
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Data container's name
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listOperationSpec$a);
    }
    /**
     * Delete version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, deleteOperationSpec$9);
    }
    /**
     * Get version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, getOperationSpec$9);
    }
    /**
     * Create or update version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name.
     * @param version Version identifier.
     * @param body Version entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, version, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, body, options }, createOrUpdateOperationSpec$9);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Data container's name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataVersionBaseResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType,
        tags
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataVersionBase
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/data/{name}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataVersionBase
        },
        201: {
            bodyMapper: DataVersionBase
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataVersionBaseResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType,
        tags
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Datastores operations. */
class DatastoresImpl {
    /**
     * Initialize a new instance of the class Datastores class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List datastores.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List datastores.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$9);
    }
    /**
     * Delete datastore.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Datastore name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$8);
    }
    /**
     * Get datastore.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Datastore name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$8);
    }
    /**
     * Create or update datastore.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Datastore name.
     * @param body Datastore entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$8);
    }
    /**
     * Get datastore secrets.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Datastore name.
     * @param options The options parameters.
     */
    listSecrets(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listSecretsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/datastores",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatastoreResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count1,
        isDefault,
        names,
        searchText,
        orderBy1,
        orderByAsc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/datastores/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/datastores/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Datastore
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/datastores/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Datastore
        },
        201: {
            bodyMapper: Datastore
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body10,
    queryParameters: [apiVersion, skipValidation],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listSecretsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/datastores/{name}/listSecrets",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DatastoreSecrets
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatastoreResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count1,
        isDefault,
        names,
        searchText,
        orderBy1,
        orderByAsc
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EnvironmentContainers operations. */
class EnvironmentContainersImpl {
    /**
     * Initialize a new instance of the class EnvironmentContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List environment containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List environment containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$8);
    }
    /**
     * Delete container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$7);
    }
    /**
     * Get container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$7);
    }
    /**
     * Create or update container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param body Container entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EnvironmentContainer
        },
        201: {
            bodyMapper: EnvironmentContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EnvironmentVersions operations. */
class EnvironmentVersionsImpl {
    /**
     * Initialize a new instance of the class EnvironmentVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listOperationSpec$7);
    }
    /**
     * Delete version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, deleteOperationSpec$6);
    }
    /**
     * Get version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, getOperationSpec$6);
    }
    /**
     * Creates or updates an EnvironmentVersion.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Name of EnvironmentVersion. This is case-sensitive.
     * @param version Version of EnvironmentVersion.
     * @param body Definition of EnvironmentVersion.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, version, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, body, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/environments/{name}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EnvironmentVersion
        },
        201: {
            bodyMapper: EnvironmentVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EnvironmentVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Jobs operations. */
class JobsImpl {
    /**
     * Initialize a new instance of the class Jobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists Jobs in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists Jobs in the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$6);
    }
    /**
     * Deletes a Job (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, id, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, id, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a Job (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, id, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, id, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a Job by name/id.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, id, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, id, options }, getOperationSpec$5);
    }
    /**
     * Creates and executes a Job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param body Job definition object.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, id, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, id, body, options }, createOrUpdateOperationSpec$5);
    }
    /**
     * Cancels a Job (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param options The options parameters.
     */
    beginCancel(resourceGroupName, workspaceName, id, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, id, options }, cancelOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Cancels a Job (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param id The name and identifier for the Job. This is case-sensitive.
     * @param options The options parameters.
     */
    beginCancelAndWait(resourceGroupName, workspaceName, id, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCancel(resourceGroupName, workspaceName, id, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/jobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobBaseResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType,
        jobType,
        tag
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/jobs/{id}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/jobs/{id}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobBase
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/jobs/{id}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: JobBase
        },
        201: {
            bodyMapper: JobBase
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        id1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/jobs/{id}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        id
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: JobBaseResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType,
        jobType,
        tag
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ModelContainers operations. */
class ModelContainersImpl {
    /**
     * Initialize a new instance of the class ModelContainers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List model containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List model containers.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$5);
    }
    /**
     * Delete container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, deleteOperationSpec$4);
    }
    /**
     * Get container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec$4);
    }
    /**
     * Create or update container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param body Container entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ModelContainer
        },
        201: {
            bodyMapper: ModelContainer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelContainerResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count,
        listViewType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ModelVersions operations. */
class ModelVersionsImpl {
    /**
     * Initialize a new instance of the class ModelVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List model versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Model name. This is case-sensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, name, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, name, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List model versions.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Model name. This is case-sensitive.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, listOperationSpec$4);
    }
    /**
     * Delete version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, deleteOperationSpec$3);
    }
    /**
     * Get version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, options }, getOperationSpec$3);
    }
    /**
     * Create or update version.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Container name. This is case-sensitive.
     * @param version Version identifier. This is case-sensitive.
     * @param body Version entity to create or update.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, name, version, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, version, body, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Model name. This is case-sensitive.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType,
        version1,
        description,
        offset,
        tags1,
        properties1,
        feed
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/models/{name}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ModelVersion
        },
        201: {
            bodyMapper: ModelVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelVersionResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top,
        listViewType,
        version1,
        description,
        offset,
        tags1,
        properties1,
        feed
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OnlineEndpoints operations. */
class OnlineEndpointsImpl {
    /**
     * Initialize a new instance of the class OnlineEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List Online Endpoints.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List Online Endpoints.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$3);
    }
    /**
     * Delete Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, endpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get Online Endpoint.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, getOperationSpec$2);
    }
    /**
     * Update Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, body, options }, updateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, endpointName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, body, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update Online Endpoint (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List EndpointAuthKeys for an Endpoint using Key-based authentication.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, listKeysOperationSpec);
    }
    /**
     * Regenerate EndpointAuthKeys for an Endpoint using Key-based authentication (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body RegenerateKeys request .
     * @param options The options parameters.
     */
    beginRegenerateKeys(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, endpointName, body, options }, regenerateKeysOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Regenerate EndpointAuthKeys for an Endpoint using Key-based authentication (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param body RegenerateKeys request .
     * @param options The options parameters.
     */
    beginRegenerateKeysAndWait(resourceGroupName, workspaceName, endpointName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRegenerateKeys(resourceGroupName, workspaceName, endpointName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieve a valid AAD token for an Endpoint using AMLToken-based authentication.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param options The options parameters.
     */
    getToken(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, getTokenOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineEndpointTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count,
        tags1,
        properties1,
        name2,
        computeType,
        orderBy2
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: OnlineEndpoint
        },
        201: {
            bodyMapper: OnlineEndpoint
        },
        202: {
            bodyMapper: OnlineEndpoint
        },
        204: {
            bodyMapper: OnlineEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OnlineEndpoint
        },
        201: {
            bodyMapper: OnlineEndpoint
        },
        202: {
            bodyMapper: OnlineEndpoint
        },
        204: {
            bodyMapper: OnlineEndpoint
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EndpointAuthKeys
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const regenerateKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/regenerateKeys",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/token",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EndpointAuthToken
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineEndpointTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        count,
        tags1,
        properties1,
        name2,
        computeType,
        orderBy2
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing OnlineDeployments operations. */
class OnlineDeploymentsImpl {
    /**
     * Initialize a new instance of the class OnlineDeployments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List Inference Endpoint Deployments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, endpointName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, endpointName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, endpointName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, endpointName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, endpointName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, endpointName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, endpointName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, endpointName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List Inference Endpoint Deployment Skus.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param options The options parameters.
     */
    listSkus(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        const iter = this.listSkusPagingAll(resourceGroupName, workspaceName, endpointName, deploymentName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSkusPagingPage(resourceGroupName, workspaceName, endpointName, deploymentName, options, settings);
            }
        };
    }
    listSkusPagingPage(resourceGroupName, workspaceName, endpointName, deploymentName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSkus(resourceGroupName, workspaceName, endpointName, deploymentName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSkusNext(resourceGroupName, workspaceName, endpointName, deploymentName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSkusPagingAll(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSkusPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listSkusPagingPage(resourceGroupName, workspaceName, endpointName, deploymentName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List Inference Endpoint Deployments.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, endpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, options }, listOperationSpec$2);
    }
    /**
     * Delete Inference Endpoint Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                options
            }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete Inference Endpoint Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, endpointName, deploymentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get Inference Deployment Deployment.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            endpointName,
            deploymentName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Update Online Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                body,
                options
            }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update Online Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Online Endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param body Online Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update Inference Endpoint Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param body Inference Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                endpointName,
                deploymentName,
                body,
                options
            }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update Inference Endpoint Deployment (asynchronous).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param body Inference Endpoint entity to apply during operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, endpointName, deploymentName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Polls an Endpoint operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName The name and identifier for the endpoint.
     * @param body The request containing parameters for retrieving logs.
     * @param options The options parameters.
     */
    getLogs(resourceGroupName, workspaceName, endpointName, deploymentName, body, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            endpointName,
            deploymentName,
            body,
            options
        }, getLogsOperationSpec);
    }
    /**
     * List Inference Endpoint Deployment Skus.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param options The options parameters.
     */
    _listSkus(resourceGroupName, workspaceName, endpointName, deploymentName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            endpointName,
            deploymentName,
            options
        }, listSkusOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, endpointName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, endpointName, nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListSkusNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param endpointName Inference endpoint name.
     * @param deploymentName Inference Endpoint Deployment name.
     * @param nextLink The nextLink from the previous successful call to the ListSkus method.
     * @param options The options parameters.
     */
    _listSkusNext(resourceGroupName, workspaceName, endpointName, deploymentName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            endpointName,
            deploymentName,
            nextLink,
            options
        }, listSkusNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineDeploymentTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: OnlineDeployment
        },
        201: {
            bodyMapper: OnlineDeployment
        },
        202: {
            bodyMapper: OnlineDeployment
        },
        204: {
            bodyMapper: OnlineDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1,
        deploymentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: OnlineDeployment
        },
        201: {
            bodyMapper: OnlineDeployment
        },
        202: {
            bodyMapper: OnlineDeployment
        },
        204: {
            bodyMapper: OnlineDeployment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName1,
        deploymentName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}/getLogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DeploymentLogs
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/onlineEndpoints/{endpointName}/deployments/{deploymentName}/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip, count],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OnlineDeploymentTrackedResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        orderBy,
        top
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        endpointName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip, count],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        endpointName,
        deploymentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Schedules operations. */
class SchedulesImpl {
    /**
     * Initialize a new instance of the class Schedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List schedules in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List schedules in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$1);
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Schedule name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, name, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Schedule name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Schedule name.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, name, options }, getOperationSpec);
    }
    /**
     * Create or update schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Schedule name.
     * @param body Schedule definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, name, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, name, body, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param name Schedule name.
     * @param body Schedule definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, name, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, name, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/schedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/schedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/schedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        202: {
            bodyMapper: Schedule
        },
        204: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        name1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleResourceArmPaginatedResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        skip,
        listViewType1
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceFeatures operations. */
class WorkspaceFeaturesImpl {
    /**
     * Initialize a new instance of the class WorkspaceFeatures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all enabled features for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all enabled features for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/features",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListAmlUserFeatureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListAmlUserFeatureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class AzureMachineLearningWorkspaces extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AzureMachineLearningWorkspaces class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-machinelearning/2.1.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2022-10-01";
        this.operations = new OperationsImpl(this);
        this.workspaces = new WorkspacesImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualMachineSizes = new VirtualMachineSizesImpl(this);
        this.quotas = new QuotasImpl(this);
        this.computeOperations = new ComputeOperationsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.workspaceConnections = new WorkspaceConnectionsImpl(this);
        this.batchEndpoints = new BatchEndpointsImpl(this);
        this.batchDeployments = new BatchDeploymentsImpl(this);
        this.codeContainers = new CodeContainersImpl(this);
        this.codeVersions = new CodeVersionsImpl(this);
        this.componentContainers = new ComponentContainersImpl(this);
        this.componentVersions = new ComponentVersionsImpl(this);
        this.dataContainers = new DataContainersImpl(this);
        this.dataVersions = new DataVersionsImpl(this);
        this.datastores = new DatastoresImpl(this);
        this.environmentContainers = new EnvironmentContainersImpl(this);
        this.environmentVersions = new EnvironmentVersionsImpl(this);
        this.jobs = new JobsImpl(this);
        this.modelContainers = new ModelContainersImpl(this);
        this.modelVersions = new ModelVersionsImpl(this);
        this.onlineEndpoints = new OnlineEndpointsImpl(this);
        this.onlineDeployments = new OnlineDeploymentsImpl(this);
        this.schedules = new SchedulesImpl(this);
        this.workspaceFeatures = new WorkspaceFeaturesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.AzureMachineLearningWorkspaces = AzureMachineLearningWorkspaces;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
