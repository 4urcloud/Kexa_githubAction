'use strict';

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link PrivateLinkServiceConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateLinkServiceConnectionProvisioningState = void 0;
(function (KnownPrivateLinkServiceConnectionProvisioningState) {
    /** The private link service connection is in the process of being created along with other resources for it to be fully functional. */
    KnownPrivateLinkServiceConnectionProvisioningState["Updating"] = "Updating";
    /** The private link service connection is in the process of being deleted. */
    KnownPrivateLinkServiceConnectionProvisioningState["Deleting"] = "Deleting";
    /** The private link service connection has failed to be provisioned or deleted. */
    KnownPrivateLinkServiceConnectionProvisioningState["Failed"] = "Failed";
    /** The private link service connection has finished provisioning and is ready for approval. */
    KnownPrivateLinkServiceConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Provisioning request for the private link service connection resource has been accepted but the process of creation has not commenced yet. */
    KnownPrivateLinkServiceConnectionProvisioningState["Incomplete"] = "Incomplete";
    /** Provisioning request for the private link service connection resource has been canceled */
    KnownPrivateLinkServiceConnectionProvisioningState["Canceled"] = "Canceled";
})(exports.KnownPrivateLinkServiceConnectionProvisioningState || (exports.KnownPrivateLinkServiceConnectionProvisioningState = {}));
/** Known values of {@link SearchSemanticSearch} that the service accepts. */
exports.KnownSearchSemanticSearch = void 0;
(function (KnownSearchSemanticSearch) {
    /** Indicates that semantic search is disabled for the search service. */
    KnownSearchSemanticSearch["Disabled"] = "disabled";
    /** Enables semantic search on a search service and indicates that it is to be used within the limits of the free tier. This would cap the volume of semantic search requests and is offered at no extra charge. This is the default for newly provisioned search services. */
    KnownSearchSemanticSearch["Free"] = "free";
    /** Enables semantic search on a search service as a billable feature, with higher throughput and volume of semantic search queries. */
    KnownSearchSemanticSearch["Standard"] = "standard";
})(exports.KnownSearchSemanticSearch || (exports.KnownSearchSemanticSearch = {}));
/** Known values of {@link UnavailableNameReason} that the service accepts. */
exports.KnownUnavailableNameReason = void 0;
(function (KnownUnavailableNameReason) {
    /** The search service name does not match naming requirements. */
    KnownUnavailableNameReason["Invalid"] = "Invalid";
    /** The search service name is already assigned to a different search service. */
    KnownUnavailableNameReason["AlreadyExists"] = "AlreadyExists";
})(exports.KnownUnavailableNameReason || (exports.KnownUnavailableNameReason = {}));
/** Known values of {@link SharedPrivateLinkResourceAsyncOperationResult} that the service accepts. */
exports.KnownSharedPrivateLinkResourceAsyncOperationResult = void 0;
(function (KnownSharedPrivateLinkResourceAsyncOperationResult) {
    /** Running */
    KnownSharedPrivateLinkResourceAsyncOperationResult["Running"] = "Running";
    /** Succeeded */
    KnownSharedPrivateLinkResourceAsyncOperationResult["Succeeded"] = "Succeeded";
    /** Failed */
    KnownSharedPrivateLinkResourceAsyncOperationResult["Failed"] = "Failed";
})(exports.KnownSharedPrivateLinkResourceAsyncOperationResult || (exports.KnownSharedPrivateLinkResourceAsyncOperationResult = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const AdminKeyResult = {
    type: {
        name: "Composite",
        className: "AdminKeyResult",
        modelProperties: {
            primaryKey: {
                serializedName: "primaryKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                serializedName: "secondaryKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryKey = {
    type: {
        name: "Composite",
        className: "QueryKey",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListQueryKeysResult = {
    type: {
        name: "Composite",
        className: "ListQueryKeysResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QueryKey"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkRuleSet = {
    type: {
        name: "Composite",
        className: "NetworkRuleSet",
        modelProperties: {
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpRule"
                        }
                    }
                }
            }
        }
    }
};
const IpRule = {
    type: {
        name: "Composite",
        className: "IpRule",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionWithCmk = {
    type: {
        name: "Composite",
        className: "EncryptionWithCmk",
        modelProperties: {
            enforcement: {
                serializedName: "enforcement",
                type: {
                    name: "Enum",
                    allowedValues: ["Disabled", "Enabled", "Unspecified"]
                }
            },
            encryptionComplianceStatus: {
                serializedName: "encryptionComplianceStatus",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Compliant", "NonCompliant"]
                }
            }
        }
    }
};
const DataPlaneAuthOptions = {
    type: {
        name: "Composite",
        className: "DataPlaneAuthOptions",
        modelProperties: {
            apiKeyOnly: {
                serializedName: "apiKeyOnly",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            aadOrApiKey: {
                serializedName: "aadOrApiKey",
                type: {
                    name: "Composite",
                    className: "DataPlaneAadOrApiKeyAuthOption"
                }
            }
        }
    }
};
const DataPlaneAadOrApiKeyAuthOption = {
    type: {
        name: "Composite",
        className: "DataPlaneAadOrApiKeyAuthOption",
        modelProperties: {
            aadAuthFailureMode: {
                serializedName: "aadAuthFailureMode",
                type: {
                    name: "Enum",
                    allowedValues: ["http403", "http401WithBearerChallenge"]
                }
            }
        }
    }
};
const PrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionPropertiesPrivateEndpoint"
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionPropertiesPrivateLinkServiceConnectionState"
                }
            },
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionPropertiesPrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionPropertiesPrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionPropertiesPrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionPropertiesPrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Pending", "Approved", "Rejected", "Disconnected"]
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                defaultValue: "None",
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedPrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResourceProperties",
        modelProperties: {
            privateLinkResourceId: {
                serializedName: "privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            },
            requestMessage: {
                serializedName: "requestMessage",
                type: {
                    name: "String"
                }
            },
            resourceRegion: {
                serializedName: "resourceRegion",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Enum",
                    allowedValues: ["Pending", "Approved", "Rejected", "Disconnected"]
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Updating",
                        "Deleting",
                        "Failed",
                        "Succeeded",
                        "Incomplete"
                    ]
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "free",
                        "basic",
                        "standard",
                        "standard2",
                        "standard3",
                        "storage_optimized_l1",
                        "storage_optimized_l2"
                    ]
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["None", "SystemAssigned"]
                }
            }
        }
    }
};
const SearchServiceListResult = {
    type: {
        name: "Composite",
        className: "SearchServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SearchService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourcesResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            shareablePrivateLinkResourceTypes: {
                serializedName: "shareablePrivateLinkResourceTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ShareablePrivateLinkResourceType"
                        }
                    }
                }
            }
        }
    }
};
const ShareablePrivateLinkResourceType = {
    type: {
        name: "Composite",
        className: "ShareablePrivateLinkResourceType",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ShareablePrivateLinkResourceProperties"
                }
            }
        }
    }
};
const ShareablePrivateLinkResourceProperties = {
    type: {
        name: "Composite",
        className: "ShareablePrivateLinkResourceProperties",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedPrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedPrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityInput",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            typeParam: {
                defaultValue: "searchServices",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityOutput = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityOutput",
        modelProperties: {
            isNameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaUsagesListResult = {
    type: {
        name: "Composite",
        className: "QuotaUsagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QuotaUsageResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaUsageResult = {
    type: {
        name: "Composite",
        className: "QuotaUsageResult",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "QuotaUsageResultName"
                }
            }
        }
    }
};
const QuotaUsageResultName = {
    type: {
        name: "Composite",
        className: "QuotaUsageResultName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AsyncOperationResult = {
    type: {
        name: "Composite",
        className: "AsyncOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionProperties"
                }
            } })
    }
};
const SharedPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SharedPrivateLinkResourceProperties"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SearchServiceUpdate = {
    type: {
        name: "Composite",
        className: "SearchServiceUpdate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, replicaCount: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 12,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.replicaCount",
                type: {
                    name: "Number"
                }
            }, partitionCount: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 12,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.partitionCount",
                type: {
                    name: "Number"
                }
            }, hostingMode: {
                defaultValue: "default",
                serializedName: "properties.hostingMode",
                type: {
                    name: "Enum",
                    allowedValues: ["default", "highDensity"]
                }
            }, publicNetworkAccess: {
                defaultValue: "enabled",
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["enabled", "disabled"]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "provisioning",
                        "deleting",
                        "degraded",
                        "disabled",
                        "error"
                    ]
                }
            }, statusDetails: {
                serializedName: "properties.statusDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["succeeded", "provisioning", "failed"]
                }
            }, networkRuleSet: {
                serializedName: "properties.networkRuleSet",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            }, encryptionWithCmk: {
                serializedName: "properties.encryptionWithCmk",
                type: {
                    name: "Composite",
                    className: "EncryptionWithCmk"
                }
            }, disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, authOptions: {
                serializedName: "properties.authOptions",
                type: {
                    name: "Composite",
                    className: "DataPlaneAuthOptions"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, semanticSearch: {
                serializedName: "properties.semanticSearch",
                nullable: true,
                type: {
                    name: "String"
                }
            }, sharedPrivateLinkResources: {
                serializedName: "properties.sharedPrivateLinkResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedPrivateLinkResource"
                        }
                    }
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateLinkResourceProperties"
                }
            } })
    }
};
const SearchService = {
    type: {
        name: "Composite",
        className: "SearchService",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, replicaCount: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 12,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.replicaCount",
                type: {
                    name: "Number"
                }
            }, partitionCount: {
                defaultValue: 1,
                constraints: {
                    InclusiveMaximum: 12,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.partitionCount",
                type: {
                    name: "Number"
                }
            }, hostingMode: {
                defaultValue: "default",
                serializedName: "properties.hostingMode",
                type: {
                    name: "Enum",
                    allowedValues: ["default", "highDensity"]
                }
            }, publicNetworkAccess: {
                defaultValue: "enabled",
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["enabled", "disabled"]
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "provisioning",
                        "deleting",
                        "degraded",
                        "disabled",
                        "error"
                    ]
                }
            }, statusDetails: {
                serializedName: "properties.statusDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["succeeded", "provisioning", "failed"]
                }
            }, networkRuleSet: {
                serializedName: "properties.networkRuleSet",
                type: {
                    name: "Composite",
                    className: "NetworkRuleSet"
                }
            }, encryptionWithCmk: {
                serializedName: "properties.encryptionWithCmk",
                type: {
                    name: "Composite",
                    className: "EncryptionWithCmk"
                }
            }, disableLocalAuth: {
                serializedName: "properties.disableLocalAuth",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }, authOptions: {
                serializedName: "properties.authOptions",
                type: {
                    name: "Composite",
                    className: "DataPlaneAuthOptions"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, semanticSearch: {
                serializedName: "properties.semanticSearch",
                nullable: true,
                type: {
                    name: "String"
                }
            }, sharedPrivateLinkResources: {
                serializedName: "properties.sharedPrivateLinkResources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedPrivateLinkResource"
                        }
                    }
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AdminKeyResult: AdminKeyResult,
    AsyncOperationResult: AsyncOperationResult,
    CheckNameAvailabilityInput: CheckNameAvailabilityInput,
    CheckNameAvailabilityOutput: CheckNameAvailabilityOutput,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    DataPlaneAadOrApiKeyAuthOption: DataPlaneAadOrApiKeyAuthOption,
    DataPlaneAuthOptions: DataPlaneAuthOptions,
    EncryptionWithCmk: EncryptionWithCmk,
    Identity: Identity,
    IpRule: IpRule,
    ListQueryKeysResult: ListQueryKeysResult,
    NetworkRuleSet: NetworkRuleSet,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationListResult: OperationListResult,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateEndpointConnectionProperties: PrivateEndpointConnectionProperties,
    PrivateEndpointConnectionPropertiesPrivateEndpoint: PrivateEndpointConnectionPropertiesPrivateEndpoint,
    PrivateEndpointConnectionPropertiesPrivateLinkServiceConnectionState: PrivateEndpointConnectionPropertiesPrivateLinkServiceConnectionState,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkResourceProperties: PrivateLinkResourceProperties,
    PrivateLinkResourcesResult: PrivateLinkResourcesResult,
    QueryKey: QueryKey,
    QuotaUsageResult: QuotaUsageResult,
    QuotaUsageResultName: QuotaUsageResultName,
    QuotaUsagesListResult: QuotaUsagesListResult,
    Resource: Resource,
    SearchService: SearchService,
    SearchServiceListResult: SearchServiceListResult,
    SearchServiceUpdate: SearchServiceUpdate,
    ShareablePrivateLinkResourceProperties: ShareablePrivateLinkResourceProperties,
    ShareablePrivateLinkResourceType: ShareablePrivateLinkResourceType,
    SharedPrivateLinkResource: SharedPrivateLinkResource,
    SharedPrivateLinkResourceListResult: SharedPrivateLinkResourceListResult,
    SharedPrivateLinkResourceProperties: SharedPrivateLinkResourceProperties,
    Sku: Sku,
    TrackedResource: TrackedResource
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const searchServiceName = {
    parameterPath: "searchServiceName",
    mapper: {
        serializedName: "searchServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clientRequestId = {
    parameterPath: [
        "options",
        "searchManagementRequestOptions",
        "clientRequestId"
    ],
    mapper: {
        serializedName: "x-ms-client-request-id",
        type: {
            name: "Uuid"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const keyKind = {
    parameterPath: "keyKind",
    mapper: {
        serializedName: "keyKind",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["primary", "secondary"]
        }
    }
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const key = {
    parameterPath: "key",
    mapper: {
        serializedName: "key",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const service = {
    parameterPath: "service",
    mapper: SearchService
};
const service1 = {
    parameterPath: "service",
    mapper: SearchServiceUpdate
};
const privateEndpointConnection = {
    parameterPath: "privateEndpointConnection",
    mapper: PrivateEndpointConnection
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sharedPrivateLinkResource = {
    parameterPath: "sharedPrivateLinkResource",
    mapper: SharedPrivateLinkResource
};
const sharedPrivateLinkResourceName = {
    parameterPath: "sharedPrivateLinkResourceName",
    mapper: {
        serializedName: "sharedPrivateLinkResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const skuName = {
    parameterPath: "skuName",
    mapper: {
        serializedName: "skuName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available REST API operations of the Microsoft.Search provider.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available REST API operations of the Microsoft.Search provider.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.Search/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing AdminKeys operations. */
class AdminKeysImpl {
    /**
     * Initialize a new instance of the class AdminKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the primary and secondary admin API keys for the specified Azure Cognitive Search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    get(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, getOperationSpec$3);
    }
    /**
     * Regenerates either the primary or secondary admin API key. You can only regenerate one key at a
     * time.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param keyKind Specifies which key to regenerate. Valid values include 'primary' and 'secondary'.
     * @param options The options parameters.
     */
    regenerate(resourceGroupName, searchServiceName, keyKind, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, keyKind, options }, regenerateOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/listAdminKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AdminKeyResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$7
};
const regenerateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/regenerateAdminKey/{keyKind}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AdminKeyResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        keyKind
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing QueryKeys operations. */
class QueryKeysImpl {
    /**
     * Initialize a new instance of the class QueryKeys class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of query API keys for the given Azure Cognitive Search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    listBySearchService(resourceGroupName, searchServiceName, options) {
        const iter = this.listBySearchServicePagingAll(resourceGroupName, searchServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySearchServicePagingPage(resourceGroupName, searchServiceName, options, settings);
            }
        };
    }
    listBySearchServicePagingPage(resourceGroupName, searchServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySearchServicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySearchService(resourceGroupName, searchServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySearchServiceNext(resourceGroupName, searchServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySearchServicePagingAll(resourceGroupName, searchServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySearchServicePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySearchServicePagingPage(resourceGroupName, searchServiceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Generates a new query key for the specified search service. You can create up to 50 query keys per
     * service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param name The name of the new query API key.
     * @param options The options parameters.
     */
    create(resourceGroupName, searchServiceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, name, options }, createOperationSpec);
    }
    /**
     * Returns the list of query API keys for the given Azure Cognitive Search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    _listBySearchService(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, listBySearchServiceOperationSpec);
    }
    /**
     * Deletes the specified query key. Unlike admin keys, query keys are not regenerated. The process for
     * regenerating a query key is to delete and then recreate it.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param key The query key to be deleted. Query keys are identified by value, not by name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, searchServiceName, key, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, key, options }, deleteOperationSpec$3);
    }
    /**
     * ListBySearchServiceNext
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param nextLink The nextLink from the previous successful call to the ListBySearchService method.
     * @param options The options parameters.
     */
    _listBySearchServiceNext(resourceGroupName, searchServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, nextLink, options }, listBySearchServiceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/createQueryKey/{name}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        name
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$6
};
const listBySearchServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/listQueryKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListQueryKeysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/deleteQueryKey/{key}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        key
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$6
};
const listBySearchServiceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListQueryKeysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Services operations. */
class ServicesImpl {
    /**
     * Initialize a new instance of the class Services class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all Search services in the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all Search services in the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a search service in the given resource group. If the search service already
     * exists, all properties will be updated with the given values.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service to create or update. Search
     *                          service names must only contain lowercase letters, digits or dashes, cannot use dash as the first
     *                          two or last one characters, cannot contain consecutive dashes, and must be between 2 and 60
     *                          characters in length. Search service names must be globally unique since they are part of the
     *                          service URI (https://<name>.search.windows.net). You cannot change the service name after the
     *                          service is created.
     * @param service The definition of the search service to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, searchServiceName, service, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, searchServiceName, service, options },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a search service in the given resource group. If the search service already
     * exists, all properties will be updated with the given values.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service to create or update. Search
     *                          service names must only contain lowercase letters, digits or dashes, cannot use dash as the first
     *                          two or last one characters, cannot contain consecutive dashes, and must be between 2 and 60
     *                          characters in length. Search service names must be globally unique since they are part of the
     *                          service URI (https://<name>.search.windows.net). You cannot change the service name after the
     *                          service is created.
     * @param service The definition of the search service to create or update.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, searchServiceName, service, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, searchServiceName, service, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an existing search service in the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service to update.
     * @param service The definition of the search service to update.
     * @param options The options parameters.
     */
    update(resourceGroupName, searchServiceName, service, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, service, options }, updateOperationSpec$1);
    }
    /**
     * Gets the search service with the given name in the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    get(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, getOperationSpec$2);
    }
    /**
     * Deletes a search service in the given resource group, along with its associated resources.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, deleteOperationSpec$2);
    }
    /**
     * Gets a list of all Search services in the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets a list of all Search services in the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Checks whether or not the given search service name is available for use. Search service names must
     * be globally unique since they are part of the service URI (https://<name>.search.windows.net).
     * @param name The search service name to validate. Search service names must only contain lowercase
     *             letters, digits or dashes, cannot use dash as the first two or last one characters, cannot contain
     *             consecutive dashes, and must be between 2 and 60 characters in length.
     * @param options The options parameters.
     */
    checkNameAvailability(name, options) {
        return this.client.sendOperationRequest({ name, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SearchService
        },
        201: {
            bodyMapper: SearchService
        },
        202: {
            bodyMapper: SearchService
        },
        204: {
            bodyMapper: SearchService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: service,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        clientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SearchService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: service1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [
        accept,
        clientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$5
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchService
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Search/searchServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Search/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityOutput
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: {
        parameterPath: { name: ["name"], typeParam: ["typeParam"] },
        mapper: Object.assign(Object.assign({}, CheckNameAvailabilityInput), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [
        accept,
        clientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$5
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SearchServiceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all supported private link resource types for the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    listSupported(resourceGroupName, searchServiceName, options) {
        const iter = this.listSupportedPagingAll(resourceGroupName, searchServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSupportedPagingPage(resourceGroupName, searchServiceName, options, settings);
            }
        };
    }
    listSupportedPagingPage(resourceGroupName, searchServiceName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listSupported(resourceGroupName, searchServiceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listSupportedPagingAll(resourceGroupName, searchServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSupportedPagingPage(resourceGroupName, searchServiceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all supported private link resource types for the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    _listSupported(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, listSupportedOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listSupportedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all private endpoint connections in the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, searchServiceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, searchServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByServicePagingPage(resourceGroupName, searchServiceName, options, settings);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, searchServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByService(resourceGroupName, searchServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, searchServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, searchServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, searchServiceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Updates a Private Endpoint connection to the search service in the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param privateEndpointConnectionName The name of the private endpoint connection to the Azure
     *                                      Cognitive Search service with the specified resource group.
     * @param privateEndpointConnection The definition of the private endpoint connection to update.
     * @param options The options parameters.
     */
    update(resourceGroupName, searchServiceName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            searchServiceName,
            privateEndpointConnectionName,
            privateEndpointConnection,
            options
        }, updateOperationSpec);
    }
    /**
     * Gets the details of the private endpoint connection to the search service in the given resource
     * group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param privateEndpointConnectionName The name of the private endpoint connection to the Azure
     *                                      Cognitive Search service with the specified resource group.
     * @param options The options parameters.
     */
    get(resourceGroupName, searchServiceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            searchServiceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Disconnects the private endpoint connection and deletes it from the search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param privateEndpointConnectionName The name of the private endpoint connection to the Azure
     *                                      Cognitive Search service with the specified resource group.
     * @param options The options parameters.
     */
    delete(resourceGroupName, searchServiceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            searchServiceName,
            privateEndpointConnectionName,
            options
        }, deleteOperationSpec$1);
    }
    /**
     * Gets a list of all private endpoint connections in the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, listByServiceOperationSpec$1);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, searchServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, nextLink, options }, listByServiceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: privateEndpointConnection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [
        accept,
        clientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$3
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$3
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        404: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$3
};
const listByServiceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$3
};
const listByServiceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SharedPrivateLinkResources operations. */
class SharedPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class SharedPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all shared private link resources managed by the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    listByService(resourceGroupName, searchServiceName, options) {
        const iter = this.listByServicePagingAll(resourceGroupName, searchServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByServicePagingPage(resourceGroupName, searchServiceName, options, settings);
            }
        };
    }
    listByServicePagingPage(resourceGroupName, searchServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByService(resourceGroupName, searchServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByServiceNext(resourceGroupName, searchServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByServicePagingAll(resourceGroupName, searchServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByServicePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByServicePagingPage(resourceGroupName, searchServiceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Initiates the creation or update of a shared private link resource managed by the search service in
     * the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param sharedPrivateLinkResourceName The name of the shared private link resource managed by the
     *                                      Azure Cognitive Search service within the specified resource group.
     * @param sharedPrivateLinkResource The definition of the shared private link resource to create or
     *                                  update.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, sharedPrivateLinkResource, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    searchServiceName,
                    sharedPrivateLinkResourceName,
                    sharedPrivateLinkResource,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Initiates the creation or update of a shared private link resource managed by the search service in
     * the given resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param sharedPrivateLinkResourceName The name of the shared private link resource managed by the
     *                                      Azure Cognitive Search service within the specified resource group.
     * @param sharedPrivateLinkResource The definition of the shared private link resource to create or
     *                                  update.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, sharedPrivateLinkResource, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, sharedPrivateLinkResource, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the details of the shared private link resource managed by the search service in the given
     * resource group.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param sharedPrivateLinkResourceName The name of the shared private link resource managed by the
     *                                      Azure Cognitive Search service within the specified resource group.
     * @param options The options parameters.
     */
    get(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            searchServiceName,
            sharedPrivateLinkResourceName,
            options
        }, getOperationSpec);
    }
    /**
     * Initiates the deletion of the shared private link resource from the search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param sharedPrivateLinkResourceName The name of the shared private link resource managed by the
     *                                      Azure Cognitive Search service within the specified resource group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    searchServiceName,
                    sharedPrivateLinkResourceName,
                    options
                },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Initiates the deletion of the shared private link resource from the search service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param sharedPrivateLinkResourceName The name of the shared private link resource managed by the
     *                                      Azure Cognitive Search service within the specified resource group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, searchServiceName, sharedPrivateLinkResourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a list of all shared private link resources managed by the given service.
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param options The options parameters.
     */
    _listByService(resourceGroupName, searchServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, options }, listByServiceOperationSpec);
    }
    /**
     * ListByServiceNext
     * @param resourceGroupName The name of the resource group within the current subscription. You can
     *                          obtain this value from the Azure Resource Manager API or the portal.
     * @param searchServiceName The name of the Azure Cognitive Search service associated with the
     *                          specified resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByService method.
     * @param options The options parameters.
     */
    _listByServiceNext(resourceGroupName, searchServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, searchServiceName, nextLink, options }, listByServiceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/sharedPrivateLinkResources/{sharedPrivateLinkResourceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SharedPrivateLinkResource
        },
        201: {
            bodyMapper: SharedPrivateLinkResource
        },
        202: {
            bodyMapper: SharedPrivateLinkResource
        },
        204: {
            bodyMapper: SharedPrivateLinkResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: sharedPrivateLinkResource,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        sharedPrivateLinkResourceName
    ],
    headerParameters: [
        accept,
        clientRequestId,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/sharedPrivateLinkResources/{sharedPrivateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedPrivateLinkResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        sharedPrivateLinkResourceName
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/sharedPrivateLinkResources/{sharedPrivateLinkResourceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        sharedPrivateLinkResourceName
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$2
};
const listByServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}/sharedPrivateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$2
};
const listByServiceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SharedPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        searchServiceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of all Search quota usages in the given subscription.
     * @param location The unique location name for a Microsoft Azure geographic region.
     * @param options The options parameters.
     */
    listBySubscription(location, options) {
        const iter = this.listBySubscriptionPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(location, options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of all Search quota usages in the given subscription.
     * @param location The unique location name for a Microsoft Azure geographic region.
     * @param options The options parameters.
     */
    _listBySubscription(location, options) {
        return this.client.sendOperationRequest({ location, options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param location The unique location name for a Microsoft Azure geographic region.
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Search/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QuotaUsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QuotaUsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept, clientRequestId],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class SearchManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the SearchManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The unique identifier for a Microsoft Azure subscription. You can obtain this
     *                       value from the Azure Resource Manager API or the portal.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-search/3.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-11-01";
        this.operations = new OperationsImpl(this);
        this.adminKeys = new AdminKeysImpl(this);
        this.queryKeys = new QueryKeysImpl(this);
        this.services = new ServicesImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.sharedPrivateLinkResources = new SharedPrivateLinkResourcesImpl(this);
        this.usages = new UsagesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Gets the quota usage for a search sku in the given subscription.
     * @param location The unique location name for a Microsoft Azure geographic region.
     * @param skuName The unique search service sku name supported by Azure Cognitive Search.
     * @param options The options parameters.
     */
    usageBySubscriptionSku(location, skuName, options) {
        return this.sendOperationRequest({ location, skuName, options }, usageBySubscriptionSkuOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const usageBySubscriptionSkuOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Search/locations/{location}/usages/{skuName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: QuotaUsageResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        skuName
    ],
    headerParameters: [accept, clientRequestId],
    serializer
};

exports.SearchManagementClient = SearchManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
