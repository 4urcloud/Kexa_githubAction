'use strict';

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link MetricAggregationType} that the service accepts. */
exports.KnownMetricAggregationType = void 0;
(function (KnownMetricAggregationType) {
    /** Average */
    KnownMetricAggregationType["Average"] = "Average";
})(exports.KnownMetricAggregationType || (exports.KnownMetricAggregationType = {}));
/** Known values of {@link CheckNameResourceTypes} that the service accepts. */
exports.KnownCheckNameResourceTypes = void 0;
(function (KnownCheckNameResourceTypes) {
    /** MicrosoftNetAppNetAppAccounts */
    KnownCheckNameResourceTypes["MicrosoftNetAppNetAppAccounts"] = "Microsoft.NetApp/netAppAccounts";
    /** MicrosoftNetAppNetAppAccountsCapacityPools */
    KnownCheckNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPools"] = "Microsoft.NetApp/netAppAccounts/capacityPools";
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes */
    KnownCheckNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes"] = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes";
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots */
    KnownCheckNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots"] = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots";
})(exports.KnownCheckNameResourceTypes || (exports.KnownCheckNameResourceTypes = {}));
/** Known values of {@link InAvailabilityReasonType} that the service accepts. */
exports.KnownInAvailabilityReasonType = void 0;
(function (KnownInAvailabilityReasonType) {
    /** Invalid */
    KnownInAvailabilityReasonType["Invalid"] = "Invalid";
    /** AlreadyExists */
    KnownInAvailabilityReasonType["AlreadyExists"] = "AlreadyExists";
})(exports.KnownInAvailabilityReasonType || (exports.KnownInAvailabilityReasonType = {}));
/** Known values of {@link CheckQuotaNameResourceTypes} that the service accepts. */
exports.KnownCheckQuotaNameResourceTypes = void 0;
(function (KnownCheckQuotaNameResourceTypes) {
    /** MicrosoftNetAppNetAppAccounts */
    KnownCheckQuotaNameResourceTypes["MicrosoftNetAppNetAppAccounts"] = "Microsoft.NetApp/netAppAccounts";
    /** MicrosoftNetAppNetAppAccountsCapacityPools */
    KnownCheckQuotaNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPools"] = "Microsoft.NetApp/netAppAccounts/capacityPools";
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes */
    KnownCheckQuotaNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPoolsVolumes"] = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes";
    /** MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots */
    KnownCheckQuotaNameResourceTypes["MicrosoftNetAppNetAppAccountsCapacityPoolsVolumesSnapshots"] = "Microsoft.NetApp/netAppAccounts/capacityPools/volumes/snapshots";
})(exports.KnownCheckQuotaNameResourceTypes || (exports.KnownCheckQuotaNameResourceTypes = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link RegionStorageToNetworkProximity} that the service accepts. */
exports.KnownRegionStorageToNetworkProximity = void 0;
(function (KnownRegionStorageToNetworkProximity) {
    /** Basic network connectivity. */
    KnownRegionStorageToNetworkProximity["Default"] = "Default";
    /** Standard T1 network connectivity. */
    KnownRegionStorageToNetworkProximity["T1"] = "T1";
    /** Standard T2 network connectivity. */
    KnownRegionStorageToNetworkProximity["T2"] = "T2";
    /** Standard AcrossT2 network connectivity. */
    KnownRegionStorageToNetworkProximity["AcrossT2"] = "AcrossT2";
    /** Standard T1 and T2 network connectivity. */
    KnownRegionStorageToNetworkProximity["T1AndT2"] = "T1AndT2";
    /** Standard T1 and AcrossT2 network connectivity. */
    KnownRegionStorageToNetworkProximity["T1AndAcrossT2"] = "T1AndAcrossT2";
    /** Standard T2 and AcrossT2 network connectivity. */
    KnownRegionStorageToNetworkProximity["T2AndAcrossT2"] = "T2AndAcrossT2";
    /** Standard T1, T2 and AcrossT2 network connectivity. */
    KnownRegionStorageToNetworkProximity["T1AndT2AndAcrossT2"] = "T1AndT2AndAcrossT2";
})(exports.KnownRegionStorageToNetworkProximity || (exports.KnownRegionStorageToNetworkProximity = {}));
/** Known values of {@link NetworkFeatures} that the service accepts. */
exports.KnownNetworkFeatures = void 0;
(function (KnownNetworkFeatures) {
    /** Basic network features. */
    KnownNetworkFeatures["Basic"] = "Basic";
    /** Standard network features. */
    KnownNetworkFeatures["Standard"] = "Standard";
    /** Updating from Basic to Standard network features. */
    KnownNetworkFeatures["BasicStandard"] = "Basic_Standard";
    /** Updating from Standard to Basic network features. */
    KnownNetworkFeatures["StandardBasic"] = "Standard_Basic";
})(exports.KnownNetworkFeatures || (exports.KnownNetworkFeatures = {}));
/** Known values of {@link NetworkSiblingSetProvisioningState} that the service accepts. */
exports.KnownNetworkSiblingSetProvisioningState = void 0;
(function (KnownNetworkSiblingSetProvisioningState) {
    /** Succeeded */
    KnownNetworkSiblingSetProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownNetworkSiblingSetProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownNetworkSiblingSetProvisioningState["Canceled"] = "Canceled";
    /** Updating */
    KnownNetworkSiblingSetProvisioningState["Updating"] = "Updating";
})(exports.KnownNetworkSiblingSetProvisioningState || (exports.KnownNetworkSiblingSetProvisioningState = {}));
/** Known values of {@link ActiveDirectoryStatus} that the service accepts. */
exports.KnownActiveDirectoryStatus = void 0;
(function (KnownActiveDirectoryStatus) {
    /** Active Directory created but not in use */
    KnownActiveDirectoryStatus["Created"] = "Created";
    /** Active Directory in use by SMB Volume */
    KnownActiveDirectoryStatus["InUse"] = "InUse";
    /** Active Directory Deleted */
    KnownActiveDirectoryStatus["Deleted"] = "Deleted";
    /** Error with the Active Directory */
    KnownActiveDirectoryStatus["Error"] = "Error";
    /** Active Directory Updating */
    KnownActiveDirectoryStatus["Updating"] = "Updating";
})(exports.KnownActiveDirectoryStatus || (exports.KnownActiveDirectoryStatus = {}));
/** Known values of {@link KeySource} that the service accepts. */
exports.KnownKeySource = void 0;
(function (KnownKeySource) {
    /** Microsoft-managed key encryption */
    KnownKeySource["MicrosoftNetApp"] = "Microsoft.NetApp";
    /** Customer-managed key encryption */
    KnownKeySource["MicrosoftKeyVault"] = "Microsoft.KeyVault";
})(exports.KnownKeySource || (exports.KnownKeySource = {}));
/** Known values of {@link KeyVaultStatus} that the service accepts. */
exports.KnownKeyVaultStatus = void 0;
(function (KnownKeyVaultStatus) {
    /** KeyVault connection created but not in use */
    KnownKeyVaultStatus["Created"] = "Created";
    /** KeyVault connection in use by SMB Volume */
    KnownKeyVaultStatus["InUse"] = "InUse";
    /** KeyVault connection Deleted */
    KnownKeyVaultStatus["Deleted"] = "Deleted";
    /** Error with the KeyVault connection */
    KnownKeyVaultStatus["Error"] = "Error";
    /** KeyVault connection Updating */
    KnownKeyVaultStatus["Updating"] = "Updating";
})(exports.KnownKeyVaultStatus || (exports.KnownKeyVaultStatus = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));
/** Known values of {@link ServiceLevel} that the service accepts. */
exports.KnownServiceLevel = void 0;
(function (KnownServiceLevel) {
    /** Standard service level */
    KnownServiceLevel["Standard"] = "Standard";
    /** Premium service level */
    KnownServiceLevel["Premium"] = "Premium";
    /** Ultra service level */
    KnownServiceLevel["Ultra"] = "Ultra";
    /** Zone redundant storage service level */
    KnownServiceLevel["StandardZRS"] = "StandardZRS";
})(exports.KnownServiceLevel || (exports.KnownServiceLevel = {}));
/** Known values of {@link QosType} that the service accepts. */
exports.KnownQosType = void 0;
(function (KnownQosType) {
    /** qos type Auto */
    KnownQosType["Auto"] = "Auto";
    /** qos type Manual */
    KnownQosType["Manual"] = "Manual";
})(exports.KnownQosType || (exports.KnownQosType = {}));
/** Known values of {@link EncryptionType} that the service accepts. */
exports.KnownEncryptionType = void 0;
(function (KnownEncryptionType) {
    /** EncryptionType Single, volumes will use single encryption at rest */
    KnownEncryptionType["Single"] = "Single";
    /** EncryptionType Double, volumes will use double encryption at rest */
    KnownEncryptionType["Double"] = "Double";
})(exports.KnownEncryptionType || (exports.KnownEncryptionType = {}));
/** Known values of {@link ChownMode} that the service accepts. */
exports.KnownChownMode = void 0;
(function (KnownChownMode) {
    /** Restricted */
    KnownChownMode["Restricted"] = "Restricted";
    /** Unrestricted */
    KnownChownMode["Unrestricted"] = "Unrestricted";
})(exports.KnownChownMode || (exports.KnownChownMode = {}));
/** Known values of {@link VolumeStorageToNetworkProximity} that the service accepts. */
exports.KnownVolumeStorageToNetworkProximity = void 0;
(function (KnownVolumeStorageToNetworkProximity) {
    /** Basic storage to network connectivity. */
    KnownVolumeStorageToNetworkProximity["Default"] = "Default";
    /** Standard T1 storage to network connectivity. */
    KnownVolumeStorageToNetworkProximity["T1"] = "T1";
    /** Standard T2 storage to network connectivity. */
    KnownVolumeStorageToNetworkProximity["T2"] = "T2";
    /** Standard AcrossT2 storage to network connectivity. */
    KnownVolumeStorageToNetworkProximity["AcrossT2"] = "AcrossT2";
})(exports.KnownVolumeStorageToNetworkProximity || (exports.KnownVolumeStorageToNetworkProximity = {}));
/** Known values of {@link EndpointType} that the service accepts. */
exports.KnownEndpointType = void 0;
(function (KnownEndpointType) {
    /** Src */
    KnownEndpointType["Src"] = "src";
    /** Dst */
    KnownEndpointType["Dst"] = "dst";
})(exports.KnownEndpointType || (exports.KnownEndpointType = {}));
/** Known values of {@link ReplicationSchedule} that the service accepts. */
exports.KnownReplicationSchedule = void 0;
(function (KnownReplicationSchedule) {
    /** 10Minutely */
    KnownReplicationSchedule["10Minutely"] = "_10minutely";
    /** Hourly */
    KnownReplicationSchedule["Hourly"] = "hourly";
    /** Daily */
    KnownReplicationSchedule["Daily"] = "daily";
})(exports.KnownReplicationSchedule || (exports.KnownReplicationSchedule = {}));
/** Known values of {@link SecurityStyle} that the service accepts. */
exports.KnownSecurityStyle = void 0;
(function (KnownSecurityStyle) {
    /** Ntfs */
    KnownSecurityStyle["Ntfs"] = "ntfs";
    /** Unix */
    KnownSecurityStyle["Unix"] = "unix";
})(exports.KnownSecurityStyle || (exports.KnownSecurityStyle = {}));
/** Known values of {@link SmbAccessBasedEnumeration} that the service accepts. */
exports.KnownSmbAccessBasedEnumeration = void 0;
(function (KnownSmbAccessBasedEnumeration) {
    /** smbAccessBasedEnumeration share setting is disabled */
    KnownSmbAccessBasedEnumeration["Disabled"] = "Disabled";
    /** smbAccessBasedEnumeration share setting is enabled */
    KnownSmbAccessBasedEnumeration["Enabled"] = "Enabled";
})(exports.KnownSmbAccessBasedEnumeration || (exports.KnownSmbAccessBasedEnumeration = {}));
/** Known values of {@link SmbNonBrowsable} that the service accepts. */
exports.KnownSmbNonBrowsable = void 0;
(function (KnownSmbNonBrowsable) {
    /** smbNonBrowsable share setting is disabled */
    KnownSmbNonBrowsable["Disabled"] = "Disabled";
    /** smbNonBrowsable share setting is enabled */
    KnownSmbNonBrowsable["Enabled"] = "Enabled";
})(exports.KnownSmbNonBrowsable || (exports.KnownSmbNonBrowsable = {}));
/** Known values of {@link EncryptionKeySource} that the service accepts. */
exports.KnownEncryptionKeySource = void 0;
(function (KnownEncryptionKeySource) {
    /** Microsoft-managed key encryption */
    KnownEncryptionKeySource["MicrosoftNetApp"] = "Microsoft.NetApp";
    /** Customer-managed key encryption */
    KnownEncryptionKeySource["MicrosoftKeyVault"] = "Microsoft.KeyVault";
})(exports.KnownEncryptionKeySource || (exports.KnownEncryptionKeySource = {}));
/** Known values of {@link CoolAccessRetrievalPolicy} that the service accepts. */
exports.KnownCoolAccessRetrievalPolicy = void 0;
(function (KnownCoolAccessRetrievalPolicy) {
    /** Default */
    KnownCoolAccessRetrievalPolicy["Default"] = "Default";
    /** OnRead */
    KnownCoolAccessRetrievalPolicy["OnRead"] = "OnRead";
    /** Never */
    KnownCoolAccessRetrievalPolicy["Never"] = "Never";
})(exports.KnownCoolAccessRetrievalPolicy || (exports.KnownCoolAccessRetrievalPolicy = {}));
/** Known values of {@link FileAccessLogs} that the service accepts. */
exports.KnownFileAccessLogs = void 0;
(function (KnownFileAccessLogs) {
    /** fileAccessLogs are enabled */
    KnownFileAccessLogs["Enabled"] = "Enabled";
    /** fileAccessLogs are not enabled */
    KnownFileAccessLogs["Disabled"] = "Disabled";
})(exports.KnownFileAccessLogs || (exports.KnownFileAccessLogs = {}));
/** Known values of {@link AvsDataStore} that the service accepts. */
exports.KnownAvsDataStore = void 0;
(function (KnownAvsDataStore) {
    /** avsDataStore is enabled */
    KnownAvsDataStore["Enabled"] = "Enabled";
    /** avsDataStore is disabled */
    KnownAvsDataStore["Disabled"] = "Disabled";
})(exports.KnownAvsDataStore || (exports.KnownAvsDataStore = {}));
/** Known values of {@link EnableSubvolumes} that the service accepts. */
exports.KnownEnableSubvolumes = void 0;
(function (KnownEnableSubvolumes) {
    /** subvolumes are enabled */
    KnownEnableSubvolumes["Enabled"] = "Enabled";
    /** subvolumes are not enabled */
    KnownEnableSubvolumes["Disabled"] = "Disabled";
})(exports.KnownEnableSubvolumes || (exports.KnownEnableSubvolumes = {}));
/** Known values of {@link RelationshipStatus} that the service accepts. */
exports.KnownRelationshipStatus = void 0;
(function (KnownRelationshipStatus) {
    /** Idle */
    KnownRelationshipStatus["Idle"] = "Idle";
    /** Transferring */
    KnownRelationshipStatus["Transferring"] = "Transferring";
})(exports.KnownRelationshipStatus || (exports.KnownRelationshipStatus = {}));
/** Known values of {@link MirrorState} that the service accepts. */
exports.KnownMirrorState = void 0;
(function (KnownMirrorState) {
    /** Uninitialized */
    KnownMirrorState["Uninitialized"] = "Uninitialized";
    /** Mirrored */
    KnownMirrorState["Mirrored"] = "Mirrored";
    /** Broken */
    KnownMirrorState["Broken"] = "Broken";
})(exports.KnownMirrorState || (exports.KnownMirrorState = {}));
/** Known values of {@link Type} that the service accepts. */
exports.KnownType = void 0;
(function (KnownType) {
    /** Default user quota */
    KnownType["DefaultUserQuota"] = "DefaultUserQuota";
    /** Default group quota */
    KnownType["DefaultGroupQuota"] = "DefaultGroupQuota";
    /** Individual user quota */
    KnownType["IndividualUserQuota"] = "IndividualUserQuota";
    /** Individual group quota */
    KnownType["IndividualGroupQuota"] = "IndividualGroupQuota";
})(exports.KnownType || (exports.KnownType = {}));
/** Known values of {@link ApplicationType} that the service accepts. */
exports.KnownApplicationType = void 0;
(function (KnownApplicationType) {
    /** SAPHana */
    KnownApplicationType["SAPHana"] = "SAP-HANA";
    /** Oracle */
    KnownApplicationType["Oracle"] = "ORACLE";
})(exports.KnownApplicationType || (exports.KnownApplicationType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            internalMetricName: {
                serializedName: "internalMetricName",
                type: {
                    name: "String"
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            },
            isInternal: {
                serializedName: "isInternal",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "ResourceNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            typeParam: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceGroup: {
                serializedName: "resourceGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckAvailabilityResponse",
        modelProperties: {
            isAvailable: {
                serializedName: "isAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FilePathAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "FilePathAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "QuotaAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            typeParam: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceGroup: {
                serializedName: "resourceGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubscriptionQuotaItemList = {
    type: {
        name: "Composite",
        className: "SubscriptionQuotaItemList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubscriptionQuotaItem"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const RegionInfo = {
    type: {
        name: "Composite",
        className: "RegionInfo",
        modelProperties: {
            storageToNetworkProximity: {
                serializedName: "storageToNetworkProximity",
                type: {
                    name: "String"
                }
            },
            availabilityZoneMappings: {
                serializedName: "availabilityZoneMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegionInfoAvailabilityZoneMappingsItem"
                        }
                    }
                }
            }
        }
    }
};
const RegionInfoAvailabilityZoneMappingsItem = {
    type: {
        name: "Composite",
        className: "RegionInfoAvailabilityZoneMappingsItem",
        modelProperties: {
            availabilityZone: {
                serializedName: "availabilityZone",
                type: {
                    name: "String"
                }
            },
            isAvailable: {
                serializedName: "isAvailable",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const QueryNetworkSiblingSetRequest = {
    type: {
        name: "Composite",
        className: "QueryNetworkSiblingSetRequest",
        modelProperties: {
            networkSiblingSetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "networkSiblingSetId",
                required: true,
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkSiblingSet = {
    type: {
        name: "Composite",
        className: "NetworkSiblingSet",
        modelProperties: {
            networkSiblingSetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "networkSiblingSetId",
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            networkSiblingSetStateId: {
                serializedName: "networkSiblingSetStateId",
                type: {
                    name: "String"
                }
            },
            networkFeatures: {
                defaultValue: "Basic",
                serializedName: "networkFeatures",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nicInfoList: {
                serializedName: "nicInfoList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NicInfo"
                        }
                    }
                }
            }
        }
    }
};
const NicInfo = {
    type: {
        name: "Composite",
        className: "NicInfo",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            volumeResourceIds: {
                serializedName: "volumeResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const UpdateNetworkSiblingSetRequest = {
    type: {
        name: "Composite",
        className: "UpdateNetworkSiblingSetRequest",
        modelProperties: {
            networkSiblingSetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "networkSiblingSetId",
                required: true,
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                required: true,
                type: {
                    name: "String"
                }
            },
            networkSiblingSetStateId: {
                serializedName: "networkSiblingSetStateId",
                required: true,
                type: {
                    name: "String"
                }
            },
            networkFeatures: {
                defaultValue: "Basic",
                serializedName: "networkFeatures",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetAppAccountList = {
    type: {
        name: "Composite",
        className: "NetAppAccountList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetAppAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveDirectory = {
    type: {
        name: "Composite",
        className: "ActiveDirectory",
        modelProperties: {
            activeDirectoryId: {
                serializedName: "activeDirectoryId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                constraints: {
                    MaxLength: 64
                },
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            domain: {
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            dns: {
                constraints: {
                    Pattern: new RegExp("^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((, ?)(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$")
                },
                serializedName: "dns",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            statusDetails: {
                serializedName: "statusDetails",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            smbServerName: {
                serializedName: "smbServerName",
                type: {
                    name: "String"
                }
            },
            organizationalUnit: {
                defaultValue: "CN=Computers",
                serializedName: "organizationalUnit",
                type: {
                    name: "String"
                }
            },
            site: {
                serializedName: "site",
                type: {
                    name: "String"
                }
            },
            backupOperators: {
                serializedName: "backupOperators",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 255,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            administrators: {
                serializedName: "administrators",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 255,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            kdcIP: {
                constraints: {
                    Pattern: new RegExp("^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((, ?)(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$")
                },
                serializedName: "kdcIP",
                type: {
                    name: "String"
                }
            },
            adName: {
                constraints: {
                    MaxLength: 64,
                    MinLength: 1
                },
                serializedName: "adName",
                type: {
                    name: "String"
                }
            },
            serverRootCACertificate: {
                constraints: {
                    MaxLength: 10240,
                    MinLength: 1
                },
                serializedName: "serverRootCACertificate",
                type: {
                    name: "String"
                }
            },
            aesEncryption: {
                serializedName: "aesEncryption",
                type: {
                    name: "Boolean"
                }
            },
            ldapSigning: {
                serializedName: "ldapSigning",
                type: {
                    name: "Boolean"
                }
            },
            securityOperators: {
                serializedName: "securityOperators",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 255,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ldapOverTLS: {
                serializedName: "ldapOverTLS",
                type: {
                    name: "Boolean"
                }
            },
            allowLocalNfsUsersWithLdap: {
                serializedName: "allowLocalNfsUsersWithLdap",
                type: {
                    name: "Boolean"
                }
            },
            encryptDCConnections: {
                serializedName: "encryptDCConnections",
                type: {
                    name: "Boolean"
                }
            },
            ldapSearchScope: {
                serializedName: "ldapSearchScope",
                type: {
                    name: "Composite",
                    className: "LdapSearchScopeOpt"
                }
            },
            preferredServersForLdapClient: {
                constraints: {
                    Pattern: new RegExp("^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)((, ?)(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))?)?$"),
                    MaxLength: 32
                },
                serializedName: "preferredServersForLdapClient",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LdapSearchScopeOpt = {
    type: {
        name: "Composite",
        className: "LdapSearchScopeOpt",
        modelProperties: {
            userDN: {
                constraints: {
                    MaxLength: 255
                },
                serializedName: "userDN",
                type: {
                    name: "String"
                }
            },
            groupDN: {
                constraints: {
                    MaxLength: 255
                },
                serializedName: "groupDN",
                type: {
                    name: "String"
                }
            },
            groupMembershipFilter: {
                constraints: {
                    MaxLength: 255
                },
                serializedName: "groupMembershipFilter",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccountEncryption = {
    type: {
        name: "Composite",
        className: "AccountEncryption",
        modelProperties: {
            keySource: {
                defaultValue: "Microsoft.NetApp",
                serializedName: "keySource",
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "EncryptionIdentity"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyVaultId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "keyVaultId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyVaultUri: {
                serializedName: "keyVaultUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVaultResourceId: {
                serializedName: "keyVaultResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionIdentity = {
    type: {
        name: "Composite",
        className: "EncryptionIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const NetAppAccountPatch = {
    type: {
        name: "Composite",
        className: "NetAppAccountPatch",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            activeDirectories: {
                serializedName: "properties.activeDirectories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActiveDirectory"
                        }
                    }
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "AccountEncryption"
                }
            },
            disableShowmount: {
                serializedName: "properties.disableShowmount",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapacityPoolList = {
    type: {
        name: "Composite",
        className: "CapacityPoolList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CapacityPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapacityPoolPatch = {
    type: {
        name: "Composite",
        className: "CapacityPoolPatch",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            size: {
                defaultValue: 4398046511104,
                serializedName: "properties.size",
                type: {
                    name: "Number"
                }
            },
            qosType: {
                serializedName: "properties.qosType",
                type: {
                    name: "String"
                }
            },
            coolAccess: {
                serializedName: "properties.coolAccess",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VolumeList = {
    type: {
        name: "Composite",
        className: "VolumeList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Volume"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumePropertiesExportPolicy = {
    type: {
        name: "Composite",
        className: "VolumePropertiesExportPolicy",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExportPolicyRule"
                        }
                    }
                }
            }
        }
    }
};
const ExportPolicyRule = {
    type: {
        name: "Composite",
        className: "ExportPolicyRule",
        modelProperties: {
            ruleIndex: {
                serializedName: "ruleIndex",
                type: {
                    name: "Number"
                }
            },
            unixReadOnly: {
                serializedName: "unixReadOnly",
                type: {
                    name: "Boolean"
                }
            },
            unixReadWrite: {
                serializedName: "unixReadWrite",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5ReadOnly: {
                defaultValue: false,
                serializedName: "kerberos5ReadOnly",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5ReadWrite: {
                defaultValue: false,
                serializedName: "kerberos5ReadWrite",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5IReadOnly: {
                defaultValue: false,
                serializedName: "kerberos5iReadOnly",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5IReadWrite: {
                defaultValue: false,
                serializedName: "kerberos5iReadWrite",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5PReadOnly: {
                defaultValue: false,
                serializedName: "kerberos5pReadOnly",
                type: {
                    name: "Boolean"
                }
            },
            kerberos5PReadWrite: {
                defaultValue: false,
                serializedName: "kerberos5pReadWrite",
                type: {
                    name: "Boolean"
                }
            },
            cifs: {
                serializedName: "cifs",
                type: {
                    name: "Boolean"
                }
            },
            nfsv3: {
                serializedName: "nfsv3",
                type: {
                    name: "Boolean"
                }
            },
            nfsv41: {
                serializedName: "nfsv41",
                type: {
                    name: "Boolean"
                }
            },
            allowedClients: {
                serializedName: "allowedClients",
                type: {
                    name: "String"
                }
            },
            hasRootAccess: {
                defaultValue: true,
                serializedName: "hasRootAccess",
                type: {
                    name: "Boolean"
                }
            },
            chownMode: {
                defaultValue: "Restricted",
                serializedName: "chownMode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MountTargetProperties = {
    type: {
        name: "Composite",
        className: "MountTargetProperties",
        modelProperties: {
            mountTargetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "mountTargetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fileSystemId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "fileSystemId",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            smbServerFqdn: {
                serializedName: "smbServerFqdn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumePropertiesDataProtection = {
    type: {
        name: "Composite",
        className: "VolumePropertiesDataProtection",
        modelProperties: {
            replication: {
                serializedName: "replication",
                type: {
                    name: "Composite",
                    className: "ReplicationObject"
                }
            },
            snapshot: {
                serializedName: "snapshot",
                type: {
                    name: "Composite",
                    className: "VolumeSnapshotProperties"
                }
            },
            volumeRelocation: {
                serializedName: "volumeRelocation",
                type: {
                    name: "Composite",
                    className: "VolumeRelocationProperties"
                }
            }
        }
    }
};
const ReplicationObject = {
    type: {
        name: "Composite",
        className: "ReplicationObject",
        modelProperties: {
            replicationId: {
                serializedName: "replicationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endpointType: {
                serializedName: "endpointType",
                type: {
                    name: "String"
                }
            },
            replicationSchedule: {
                serializedName: "replicationSchedule",
                type: {
                    name: "String"
                }
            },
            remoteVolumeResourceId: {
                serializedName: "remoteVolumeResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            remoteVolumeRegion: {
                serializedName: "remoteVolumeRegion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumeSnapshotProperties = {
    type: {
        name: "Composite",
        className: "VolumeSnapshotProperties",
        modelProperties: {
            snapshotPolicyId: {
                serializedName: "snapshotPolicyId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumeRelocationProperties = {
    type: {
        name: "Composite",
        className: "VolumeRelocationProperties",
        modelProperties: {
            relocationRequested: {
                serializedName: "relocationRequested",
                type: {
                    name: "Boolean"
                }
            },
            readyToBeFinalized: {
                serializedName: "readyToBeFinalized",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PlacementKeyValuePairs = {
    type: {
        name: "Composite",
        className: "PlacementKeyValuePairs",
        modelProperties: {
            key: {
                serializedName: "key",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumePatch = {
    type: {
        name: "Composite",
        className: "VolumePatch",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            serviceLevel: {
                defaultValue: "Premium",
                serializedName: "properties.serviceLevel",
                type: {
                    name: "String"
                }
            },
            usageThreshold: {
                defaultValue: 107374182400,
                constraints: {
                    InclusiveMaximum: 2638827906662400,
                    InclusiveMinimum: 107374182400
                },
                serializedName: "properties.usageThreshold",
                type: {
                    name: "Number"
                }
            },
            exportPolicy: {
                serializedName: "properties.exportPolicy",
                type: {
                    name: "Composite",
                    className: "VolumePatchPropertiesExportPolicy"
                }
            },
            throughputMibps: {
                serializedName: "properties.throughputMibps",
                type: {
                    name: "Number"
                }
            },
            dataProtection: {
                serializedName: "properties.dataProtection",
                type: {
                    name: "Composite",
                    className: "VolumePatchPropertiesDataProtection"
                }
            },
            isDefaultQuotaEnabled: {
                defaultValue: false,
                serializedName: "properties.isDefaultQuotaEnabled",
                type: {
                    name: "Boolean"
                }
            },
            defaultUserQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultUserQuotaInKiBs",
                type: {
                    name: "Number"
                }
            },
            defaultGroupQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultGroupQuotaInKiBs",
                type: {
                    name: "Number"
                }
            },
            unixPermissions: {
                constraints: {
                    MaxLength: 4,
                    MinLength: 4
                },
                serializedName: "properties.unixPermissions",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            coolAccess: {
                serializedName: "properties.coolAccess",
                type: {
                    name: "Boolean"
                }
            },
            coolnessPeriod: {
                constraints: {
                    InclusiveMaximum: 63,
                    InclusiveMinimum: 7
                },
                serializedName: "properties.coolnessPeriod",
                type: {
                    name: "Number"
                }
            },
            coolAccessRetrievalPolicy: {
                serializedName: "properties.coolAccessRetrievalPolicy",
                type: {
                    name: "String"
                }
            },
            snapshotDirectoryVisible: {
                serializedName: "properties.snapshotDirectoryVisible",
                type: {
                    name: "Boolean"
                }
            },
            smbAccessBasedEnumeration: {
                serializedName: "properties.smbAccessBasedEnumeration",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            smbNonBrowsable: {
                serializedName: "properties.smbNonBrowsable",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumePatchPropertiesExportPolicy = {
    type: {
        name: "Composite",
        className: "VolumePatchPropertiesExportPolicy",
        modelProperties: {
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExportPolicyRule"
                        }
                    }
                }
            }
        }
    }
};
const VolumePatchPropertiesDataProtection = {
    type: {
        name: "Composite",
        className: "VolumePatchPropertiesDataProtection",
        modelProperties: {
            snapshot: {
                serializedName: "snapshot",
                type: {
                    name: "Composite",
                    className: "VolumeSnapshotProperties"
                }
            }
        }
    }
};
const VolumeRevert = {
    type: {
        name: "Composite",
        className: "VolumeRevert",
        modelProperties: {
            snapshotId: {
                serializedName: "snapshotId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BreakFileLocksRequest = {
    type: {
        name: "Composite",
        className: "BreakFileLocksRequest",
        modelProperties: {
            clientIp: {
                constraints: {
                    Pattern: new RegExp("^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$")
                },
                serializedName: "clientIp",
                type: {
                    name: "String"
                }
            },
            confirmRunningDisruptiveOperation: {
                defaultValue: false,
                serializedName: "confirmRunningDisruptiveOperation",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const GetGroupIdListForLdapUserRequest = {
    type: {
        name: "Composite",
        className: "GetGroupIdListForLdapUserRequest",
        modelProperties: {
            username: {
                constraints: {
                    MaxLength: 255,
                    MinLength: 1
                },
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetGroupIdListForLdapUserResponse = {
    type: {
        name: "Composite",
        className: "GetGroupIdListForLdapUserResponse",
        modelProperties: {
            groupIdsForLdapUser: {
                serializedName: "groupIdsForLdapUser",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BreakReplicationRequest = {
    type: {
        name: "Composite",
        className: "BreakReplicationRequest",
        modelProperties: {
            forceBreakReplication: {
                serializedName: "forceBreakReplication",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ReestablishReplicationRequest = {
    type: {
        name: "Composite",
        className: "ReestablishReplicationRequest",
        modelProperties: {
            sourceVolumeId: {
                serializedName: "sourceVolumeId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReplicationStatus = {
    type: {
        name: "Composite",
        className: "ReplicationStatus",
        modelProperties: {
            healthy: {
                serializedName: "healthy",
                type: {
                    name: "Boolean"
                }
            },
            relationshipStatus: {
                serializedName: "relationshipStatus",
                type: {
                    name: "String"
                }
            },
            mirrorState: {
                serializedName: "mirrorState",
                type: {
                    name: "String"
                }
            },
            totalProgress: {
                serializedName: "totalProgress",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListReplications = {
    type: {
        name: "Composite",
        className: "ListReplications",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Replication"
                        }
                    }
                }
            }
        }
    }
};
const Replication = {
    type: {
        name: "Composite",
        className: "Replication",
        modelProperties: {
            endpointType: {
                serializedName: "endpointType",
                type: {
                    name: "String"
                }
            },
            replicationSchedule: {
                serializedName: "replicationSchedule",
                type: {
                    name: "String"
                }
            },
            remoteVolumeResourceId: {
                serializedName: "remoteVolumeResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            remoteVolumeRegion: {
                serializedName: "remoteVolumeRegion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizeRequest = {
    type: {
        name: "Composite",
        className: "AuthorizeRequest",
        modelProperties: {
            remoteVolumeResourceId: {
                serializedName: "remoteVolumeResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PoolChangeRequest = {
    type: {
        name: "Composite",
        className: "PoolChangeRequest",
        modelProperties: {
            newPoolResourceId: {
                serializedName: "newPoolResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RelocateVolumeRequest = {
    type: {
        name: "Composite",
        className: "RelocateVolumeRequest",
        modelProperties: {
            creationToken: {
                serializedName: "creationToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotsList = {
    type: {
        name: "Composite",
        className: "SnapshotsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Snapshot"
                        }
                    }
                }
            }
        }
    }
};
const SnapshotRestoreFiles = {
    type: {
        name: "Composite",
        className: "SnapshotRestoreFiles",
        modelProperties: {
            filePaths: {
                constraints: {
                    MinItems: 1,
                    MaxItems: 10
                },
                serializedName: "filePaths",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 1024,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPath: {
                serializedName: "destinationPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotPoliciesList = {
    type: {
        name: "Composite",
        className: "SnapshotPoliciesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SnapshotPolicy"
                        }
                    }
                }
            }
        }
    }
};
const HourlySchedule = {
    type: {
        name: "Composite",
        className: "HourlySchedule",
        modelProperties: {
            snapshotsToKeep: {
                serializedName: "snapshotsToKeep",
                type: {
                    name: "Number"
                }
            },
            minute: {
                serializedName: "minute",
                type: {
                    name: "Number"
                }
            },
            usedBytes: {
                serializedName: "usedBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DailySchedule = {
    type: {
        name: "Composite",
        className: "DailySchedule",
        modelProperties: {
            snapshotsToKeep: {
                serializedName: "snapshotsToKeep",
                type: {
                    name: "Number"
                }
            },
            hour: {
                serializedName: "hour",
                type: {
                    name: "Number"
                }
            },
            minute: {
                serializedName: "minute",
                type: {
                    name: "Number"
                }
            },
            usedBytes: {
                serializedName: "usedBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WeeklySchedule = {
    type: {
        name: "Composite",
        className: "WeeklySchedule",
        modelProperties: {
            snapshotsToKeep: {
                serializedName: "snapshotsToKeep",
                type: {
                    name: "Number"
                }
            },
            day: {
                serializedName: "day",
                type: {
                    name: "String"
                }
            },
            hour: {
                serializedName: "hour",
                type: {
                    name: "Number"
                }
            },
            minute: {
                serializedName: "minute",
                type: {
                    name: "Number"
                }
            },
            usedBytes: {
                serializedName: "usedBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const MonthlySchedule = {
    type: {
        name: "Composite",
        className: "MonthlySchedule",
        modelProperties: {
            snapshotsToKeep: {
                serializedName: "snapshotsToKeep",
                type: {
                    name: "Number"
                }
            },
            daysOfMonth: {
                serializedName: "daysOfMonth",
                type: {
                    name: "String"
                }
            },
            hour: {
                serializedName: "hour",
                type: {
                    name: "Number"
                }
            },
            minute: {
                serializedName: "minute",
                type: {
                    name: "Number"
                }
            },
            usedBytes: {
                serializedName: "usedBytes",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SnapshotPolicyPatch = {
    type: {
        name: "Composite",
        className: "SnapshotPolicyPatch",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            hourlySchedule: {
                serializedName: "properties.hourlySchedule",
                type: {
                    name: "Composite",
                    className: "HourlySchedule"
                }
            },
            dailySchedule: {
                serializedName: "properties.dailySchedule",
                type: {
                    name: "Composite",
                    className: "DailySchedule"
                }
            },
            weeklySchedule: {
                serializedName: "properties.weeklySchedule",
                type: {
                    name: "Composite",
                    className: "WeeklySchedule"
                }
            },
            monthlySchedule: {
                serializedName: "properties.monthlySchedule",
                type: {
                    name: "Composite",
                    className: "MonthlySchedule"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotPolicyVolumeList = {
    type: {
        name: "Composite",
        className: "SnapshotPolicyVolumeList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Volume"
                        }
                    }
                }
            }
        }
    }
};
const RestoreStatus = {
    type: {
        name: "Composite",
        className: "RestoreStatus",
        modelProperties: {
            healthy: {
                serializedName: "healthy",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            relationshipStatus: {
                serializedName: "relationshipStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            mirrorState: {
                serializedName: "mirrorState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unhealthyReason: {
                serializedName: "unhealthyReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            totalTransferBytes: {
                serializedName: "totalTransferBytes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BackupPoliciesList = {
    type: {
        name: "Composite",
        className: "BackupPoliciesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackupPolicy"
                        }
                    }
                }
            }
        }
    }
};
const VolumeBackups = {
    type: {
        name: "Composite",
        className: "VolumeBackups",
        modelProperties: {
            volumeName: {
                serializedName: "volumeName",
                type: {
                    name: "String"
                }
            },
            backupsCount: {
                serializedName: "backupsCount",
                type: {
                    name: "Number"
                }
            },
            policyEnabled: {
                serializedName: "policyEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const BackupPolicyPatch = {
    type: {
        name: "Composite",
        className: "BackupPolicyPatch",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            backupPolicyId: {
                serializedName: "properties.backupPolicyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dailyBackupsToKeep: {
                serializedName: "properties.dailyBackupsToKeep",
                type: {
                    name: "Number"
                }
            },
            weeklyBackupsToKeep: {
                serializedName: "properties.weeklyBackupsToKeep",
                type: {
                    name: "Number"
                }
            },
            monthlyBackupsToKeep: {
                serializedName: "properties.monthlyBackupsToKeep",
                type: {
                    name: "Number"
                }
            },
            volumesAssigned: {
                serializedName: "properties.volumesAssigned",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            },
            volumeBackups: {
                serializedName: "properties.volumeBackups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeBackups"
                        }
                    }
                }
            }
        }
    }
};
const VolumeQuotaRulesList = {
    type: {
        name: "Composite",
        className: "VolumeQuotaRulesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeQuotaRule"
                        }
                    }
                }
            }
        }
    }
};
const VolumeQuotaRulePatch = {
    type: {
        name: "Composite",
        className: "VolumeQuotaRulePatch",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Accepted",
                        "Creating",
                        "Patching",
                        "Deleting",
                        "Moving",
                        "Failed",
                        "Succeeded"
                    ]
                }
            },
            quotaSizeInKiBs: {
                serializedName: "properties.quotaSizeInKiBs",
                type: {
                    name: "Number"
                }
            },
            quotaType: {
                serializedName: "properties.quotaType",
                type: {
                    name: "String"
                }
            },
            quotaTarget: {
                serializedName: "properties.quotaTarget",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumeGroupList = {
    type: {
        name: "Composite",
        className: "VolumeGroupList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeGroup"
                        }
                    }
                }
            }
        }
    }
};
const VolumeGroup = {
    type: {
        name: "Composite",
        className: "VolumeGroup",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupMetaData: {
                serializedName: "properties.groupMetaData",
                type: {
                    name: "Composite",
                    className: "VolumeGroupMetaData"
                }
            }
        }
    }
};
const VolumeGroupMetaData = {
    type: {
        name: "Composite",
        className: "VolumeGroupMetaData",
        modelProperties: {
            groupDescription: {
                serializedName: "groupDescription",
                type: {
                    name: "String"
                }
            },
            applicationType: {
                serializedName: "applicationType",
                type: {
                    name: "String"
                }
            },
            applicationIdentifier: {
                serializedName: "applicationIdentifier",
                type: {
                    name: "String"
                }
            },
            globalPlacementRules: {
                serializedName: "globalPlacementRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PlacementKeyValuePairs"
                        }
                    }
                }
            },
            deploymentSpecId: {
                serializedName: "deploymentSpecId",
                type: {
                    name: "String"
                }
            },
            volumesCount: {
                serializedName: "volumesCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VolumeGroupDetails = {
    type: {
        name: "Composite",
        className: "VolumeGroupDetails",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupMetaData: {
                serializedName: "properties.groupMetaData",
                type: {
                    name: "Composite",
                    className: "VolumeGroupMetaData"
                }
            },
            volumes: {
                serializedName: "properties.volumes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeGroupVolumeProperties"
                        }
                    }
                }
            }
        }
    }
};
const VolumeGroupVolumeProperties = {
    type: {
        name: "Composite",
        className: "VolumeGroupVolumeProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 255,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fileSystemId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.fileSystemId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            creationToken: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9\\-]{0,79}$"),
                    MaxLength: 80,
                    MinLength: 1
                },
                serializedName: "properties.creationToken",
                required: true,
                type: {
                    name: "String"
                }
            },
            serviceLevel: {
                defaultValue: "Premium",
                serializedName: "properties.serviceLevel",
                type: {
                    name: "String"
                }
            },
            usageThreshold: {
                defaultValue: 107374182400,
                constraints: {
                    InclusiveMaximum: 2638827906662400,
                    InclusiveMinimum: 107374182400
                },
                serializedName: "properties.usageThreshold",
                required: true,
                type: {
                    name: "Number"
                }
            },
            exportPolicy: {
                serializedName: "properties.exportPolicy",
                type: {
                    name: "Composite",
                    className: "VolumePropertiesExportPolicy"
                }
            },
            protocolTypes: {
                serializedName: "properties.protocolTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            snapshotId: {
                serializedName: "properties.snapshotId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            deleteBaseSnapshot: {
                serializedName: "properties.deleteBaseSnapshot",
                type: {
                    name: "Boolean"
                }
            },
            backupId: {
                serializedName: "properties.backupId",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            baremetalTenantId: {
                serializedName: "properties.baremetalTenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "properties.subnetId",
                required: true,
                type: {
                    name: "String"
                }
            },
            networkFeatures: {
                defaultValue: "Basic",
                serializedName: "properties.networkFeatures",
                type: {
                    name: "String"
                }
            },
            networkSiblingSetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.networkSiblingSetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            storageToNetworkProximity: {
                serializedName: "properties.storageToNetworkProximity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            mountTargets: {
                serializedName: "properties.mountTargets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountTargetProperties"
                        }
                    }
                }
            },
            volumeType: {
                serializedName: "properties.volumeType",
                type: {
                    name: "String"
                }
            },
            dataProtection: {
                serializedName: "properties.dataProtection",
                type: {
                    name: "Composite",
                    className: "VolumePropertiesDataProtection"
                }
            },
            isRestoring: {
                serializedName: "properties.isRestoring",
                type: {
                    name: "Boolean"
                }
            },
            snapshotDirectoryVisible: {
                defaultValue: true,
                serializedName: "properties.snapshotDirectoryVisible",
                type: {
                    name: "Boolean"
                }
            },
            kerberosEnabled: {
                defaultValue: false,
                serializedName: "properties.kerberosEnabled",
                type: {
                    name: "Boolean"
                }
            },
            securityStyle: {
                defaultValue: "unix",
                serializedName: "properties.securityStyle",
                type: {
                    name: "String"
                }
            },
            smbEncryption: {
                defaultValue: false,
                serializedName: "properties.smbEncryption",
                type: {
                    name: "Boolean"
                }
            },
            smbAccessBasedEnumeration: {
                serializedName: "properties.smbAccessBasedEnumeration",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            smbNonBrowsable: {
                serializedName: "properties.smbNonBrowsable",
                type: {
                    name: "String"
                }
            },
            smbContinuouslyAvailable: {
                defaultValue: false,
                serializedName: "properties.smbContinuouslyAvailable",
                type: {
                    name: "Boolean"
                }
            },
            throughputMibps: {
                serializedName: "properties.throughputMibps",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            actualThroughputMibps: {
                serializedName: "properties.actualThroughputMibps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            encryptionKeySource: {
                defaultValue: "Microsoft.NetApp",
                serializedName: "properties.encryptionKeySource",
                type: {
                    name: "String"
                }
            },
            keyVaultPrivateEndpointResourceId: {
                serializedName: "properties.keyVaultPrivateEndpointResourceId",
                type: {
                    name: "String"
                }
            },
            ldapEnabled: {
                defaultValue: false,
                serializedName: "properties.ldapEnabled",
                type: {
                    name: "Boolean"
                }
            },
            coolAccess: {
                defaultValue: false,
                serializedName: "properties.coolAccess",
                type: {
                    name: "Boolean"
                }
            },
            coolnessPeriod: {
                constraints: {
                    InclusiveMaximum: 63,
                    InclusiveMinimum: 7
                },
                serializedName: "properties.coolnessPeriod",
                type: {
                    name: "Number"
                }
            },
            coolAccessRetrievalPolicy: {
                serializedName: "properties.coolAccessRetrievalPolicy",
                type: {
                    name: "String"
                }
            },
            unixPermissions: {
                constraints: {
                    MaxLength: 4,
                    MinLength: 4
                },
                serializedName: "properties.unixPermissions",
                nullable: true,
                type: {
                    name: "String"
                }
            },
            cloneProgress: {
                serializedName: "properties.cloneProgress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            fileAccessLogs: {
                defaultValue: "Disabled",
                serializedName: "properties.fileAccessLogs",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            avsDataStore: {
                defaultValue: "Disabled",
                serializedName: "properties.avsDataStore",
                type: {
                    name: "String"
                }
            },
            dataStoreResourceId: {
                serializedName: "properties.dataStoreResourceId",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isDefaultQuotaEnabled: {
                defaultValue: false,
                serializedName: "properties.isDefaultQuotaEnabled",
                type: {
                    name: "Boolean"
                }
            },
            defaultUserQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultUserQuotaInKiBs",
                type: {
                    name: "Number"
                }
            },
            defaultGroupQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultGroupQuotaInKiBs",
                type: {
                    name: "Number"
                }
            },
            maximumNumberOfFiles: {
                serializedName: "properties.maximumNumberOfFiles",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            volumeGroupName: {
                serializedName: "properties.volumeGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capacityPoolResourceId: {
                serializedName: "properties.capacityPoolResourceId",
                type: {
                    name: "String"
                }
            },
            proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "String"
                }
            },
            t2Network: {
                serializedName: "properties.t2Network",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            volumeSpecName: {
                serializedName: "properties.volumeSpecName",
                type: {
                    name: "String"
                }
            },
            encrypted: {
                serializedName: "properties.encrypted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            placementRules: {
                serializedName: "properties.placementRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PlacementKeyValuePairs"
                        }
                    }
                }
            },
            enableSubvolumes: {
                defaultValue: "Disabled",
                serializedName: "properties.enableSubvolumes",
                type: {
                    name: "String"
                }
            },
            provisionedAvailabilityZone: {
                serializedName: "properties.provisionedAvailabilityZone",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            isLargeVolume: {
                defaultValue: false,
                serializedName: "properties.isLargeVolume",
                type: {
                    name: "Boolean"
                }
            },
            originatingResourceId: {
                serializedName: "properties.originatingResourceId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubvolumesList = {
    type: {
        name: "Composite",
        className: "SubvolumesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubvolumeInfo"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubvolumePatchRequest = {
    type: {
        name: "Composite",
        className: "SubvolumePatchRequest",
        modelProperties: {
            size: {
                serializedName: "properties.size",
                nullable: true,
                type: {
                    name: "Number"
                }
            },
            path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubvolumeModel = {
    type: {
        name: "Composite",
        className: "SubvolumeModel",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            },
            parentPath: {
                serializedName: "properties.parentPath",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "properties.size",
                type: {
                    name: "Number"
                }
            },
            bytesUsed: {
                serializedName: "properties.bytesUsed",
                type: {
                    name: "Number"
                }
            },
            permissions: {
                serializedName: "properties.permissions",
                type: {
                    name: "String"
                }
            },
            creationTimeStamp: {
                serializedName: "properties.creationTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            accessedTimeStamp: {
                serializedName: "properties.accessedTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            modifiedTimeStamp: {
                serializedName: "properties.modifiedTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            changedTimeStamp: {
                serializedName: "properties.changedTimeStamp",
                type: {
                    name: "DateTime"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceIdentity = {
    type: {
        name: "Composite",
        className: "ResourceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MountTarget = {
    type: {
        name: "Composite",
        className: "MountTarget",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            mountTargetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.mountTargetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fileSystemId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.fileSystemId",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "properties.ipAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            smbServerFqdn: {
                serializedName: "properties.smbServerFqdn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SnapshotPolicyDetails = {
    type: {
        name: "Composite",
        className: "SnapshotPolicyDetails",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            hourlySchedule: {
                serializedName: "properties.hourlySchedule",
                type: {
                    name: "Composite",
                    className: "HourlySchedule"
                }
            },
            dailySchedule: {
                serializedName: "properties.dailySchedule",
                type: {
                    name: "Composite",
                    className: "DailySchedule"
                }
            },
            weeklySchedule: {
                serializedName: "properties.weeklySchedule",
                type: {
                    name: "Composite",
                    className: "WeeklySchedule"
                }
            },
            monthlySchedule: {
                serializedName: "properties.monthlySchedule",
                type: {
                    name: "Composite",
                    className: "MonthlySchedule"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SubscriptionQuotaItem = {
    type: {
        name: "Composite",
        className: "SubscriptionQuotaItem",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { current: {
                serializedName: "properties.current",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, default: {
                serializedName: "properties.default",
                readOnly: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const Snapshot = {
    type: {
        name: "Composite",
        className: "Snapshot",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, snapshotId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.snapshotId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SubvolumeInfo = {
    type: {
        name: "Composite",
        className: "SubvolumeInfo",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, size: {
                serializedName: "properties.size",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, parentPath: {
                serializedName: "properties.parentPath",
                nullable: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetAppAccount = {
    type: {
        name: "Composite",
        className: "NetAppAccount",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, activeDirectories: {
                serializedName: "properties.activeDirectories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActiveDirectory"
                        }
                    }
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "AccountEncryption"
                }
            }, disableShowmount: {
                serializedName: "properties.disableShowmount",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const CapacityPool = {
    type: {
        name: "Composite",
        className: "CapacityPool",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, poolId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.poolId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, size: {
                defaultValue: 4398046511104,
                serializedName: "properties.size",
                required: true,
                type: {
                    name: "Number"
                }
            }, serviceLevel: {
                defaultValue: "Premium",
                serializedName: "properties.serviceLevel",
                required: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, totalThroughputMibps: {
                serializedName: "properties.totalThroughputMibps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, utilizedThroughputMibps: {
                serializedName: "properties.utilizedThroughputMibps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, qosType: {
                serializedName: "properties.qosType",
                type: {
                    name: "String"
                }
            }, coolAccess: {
                defaultValue: false,
                serializedName: "properties.coolAccess",
                type: {
                    name: "Boolean"
                }
            }, encryptionType: {
                defaultValue: "Single",
                serializedName: "properties.encryptionType",
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Volume = {
    type: {
        name: "Composite",
        className: "Volume",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            MaxLength: 255,
                            MinLength: 1
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }, fileSystemId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.fileSystemId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, creationToken: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9\\-]{0,79}$"),
                    MaxLength: 80,
                    MinLength: 1
                },
                serializedName: "properties.creationToken",
                required: true,
                type: {
                    name: "String"
                }
            }, serviceLevel: {
                defaultValue: "Premium",
                serializedName: "properties.serviceLevel",
                type: {
                    name: "String"
                }
            }, usageThreshold: {
                defaultValue: 107374182400,
                constraints: {
                    InclusiveMaximum: 2638827906662400,
                    InclusiveMinimum: 107374182400
                },
                serializedName: "properties.usageThreshold",
                required: true,
                type: {
                    name: "Number"
                }
            }, exportPolicy: {
                serializedName: "properties.exportPolicy",
                type: {
                    name: "Composite",
                    className: "VolumePropertiesExportPolicy"
                }
            }, protocolTypes: {
                serializedName: "properties.protocolTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, snapshotId: {
                serializedName: "properties.snapshotId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, deleteBaseSnapshot: {
                serializedName: "properties.deleteBaseSnapshot",
                type: {
                    name: "Boolean"
                }
            }, backupId: {
                serializedName: "properties.backupId",
                nullable: true,
                type: {
                    name: "String"
                }
            }, baremetalTenantId: {
                serializedName: "properties.baremetalTenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnetId: {
                serializedName: "properties.subnetId",
                required: true,
                type: {
                    name: "String"
                }
            }, networkFeatures: {
                defaultValue: "Basic",
                serializedName: "properties.networkFeatures",
                type: {
                    name: "String"
                }
            }, networkSiblingSetId: {
                constraints: {
                    Pattern: new RegExp("^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$"),
                    MaxLength: 36,
                    MinLength: 36
                },
                serializedName: "properties.networkSiblingSetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageToNetworkProximity: {
                serializedName: "properties.storageToNetworkProximity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, mountTargets: {
                serializedName: "properties.mountTargets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountTargetProperties"
                        }
                    }
                }
            }, volumeType: {
                serializedName: "properties.volumeType",
                type: {
                    name: "String"
                }
            }, dataProtection: {
                serializedName: "properties.dataProtection",
                type: {
                    name: "Composite",
                    className: "VolumePropertiesDataProtection"
                }
            }, isRestoring: {
                serializedName: "properties.isRestoring",
                type: {
                    name: "Boolean"
                }
            }, snapshotDirectoryVisible: {
                defaultValue: true,
                serializedName: "properties.snapshotDirectoryVisible",
                type: {
                    name: "Boolean"
                }
            }, kerberosEnabled: {
                defaultValue: false,
                serializedName: "properties.kerberosEnabled",
                type: {
                    name: "Boolean"
                }
            }, securityStyle: {
                defaultValue: "unix",
                serializedName: "properties.securityStyle",
                type: {
                    name: "String"
                }
            }, smbEncryption: {
                defaultValue: false,
                serializedName: "properties.smbEncryption",
                type: {
                    name: "Boolean"
                }
            }, smbAccessBasedEnumeration: {
                serializedName: "properties.smbAccessBasedEnumeration",
                nullable: true,
                type: {
                    name: "String"
                }
            }, smbNonBrowsable: {
                serializedName: "properties.smbNonBrowsable",
                type: {
                    name: "String"
                }
            }, smbContinuouslyAvailable: {
                defaultValue: false,
                serializedName: "properties.smbContinuouslyAvailable",
                type: {
                    name: "Boolean"
                }
            }, throughputMibps: {
                serializedName: "properties.throughputMibps",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, actualThroughputMibps: {
                serializedName: "properties.actualThroughputMibps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, encryptionKeySource: {
                defaultValue: "Microsoft.NetApp",
                serializedName: "properties.encryptionKeySource",
                type: {
                    name: "String"
                }
            }, keyVaultPrivateEndpointResourceId: {
                serializedName: "properties.keyVaultPrivateEndpointResourceId",
                type: {
                    name: "String"
                }
            }, ldapEnabled: {
                defaultValue: false,
                serializedName: "properties.ldapEnabled",
                type: {
                    name: "Boolean"
                }
            }, coolAccess: {
                defaultValue: false,
                serializedName: "properties.coolAccess",
                type: {
                    name: "Boolean"
                }
            }, coolnessPeriod: {
                constraints: {
                    InclusiveMaximum: 63,
                    InclusiveMinimum: 7
                },
                serializedName: "properties.coolnessPeriod",
                type: {
                    name: "Number"
                }
            }, coolAccessRetrievalPolicy: {
                serializedName: "properties.coolAccessRetrievalPolicy",
                type: {
                    name: "String"
                }
            }, unixPermissions: {
                constraints: {
                    MaxLength: 4,
                    MinLength: 4
                },
                serializedName: "properties.unixPermissions",
                nullable: true,
                type: {
                    name: "String"
                }
            }, cloneProgress: {
                serializedName: "properties.cloneProgress",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            }, fileAccessLogs: {
                defaultValue: "Disabled",
                serializedName: "properties.fileAccessLogs",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, avsDataStore: {
                defaultValue: "Disabled",
                serializedName: "properties.avsDataStore",
                type: {
                    name: "String"
                }
            }, dataStoreResourceId: {
                serializedName: "properties.dataStoreResourceId",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isDefaultQuotaEnabled: {
                defaultValue: false,
                serializedName: "properties.isDefaultQuotaEnabled",
                type: {
                    name: "Boolean"
                }
            }, defaultUserQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultUserQuotaInKiBs",
                type: {
                    name: "Number"
                }
            }, defaultGroupQuotaInKiBs: {
                defaultValue: 0,
                serializedName: "properties.defaultGroupQuotaInKiBs",
                type: {
                    name: "Number"
                }
            }, maximumNumberOfFiles: {
                serializedName: "properties.maximumNumberOfFiles",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, volumeGroupName: {
                serializedName: "properties.volumeGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, capacityPoolResourceId: {
                serializedName: "properties.capacityPoolResourceId",
                type: {
                    name: "String"
                }
            }, proximityPlacementGroup: {
                serializedName: "properties.proximityPlacementGroup",
                type: {
                    name: "String"
                }
            }, t2Network: {
                serializedName: "properties.t2Network",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, volumeSpecName: {
                serializedName: "properties.volumeSpecName",
                type: {
                    name: "String"
                }
            }, encrypted: {
                serializedName: "properties.encrypted",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, placementRules: {
                serializedName: "properties.placementRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PlacementKeyValuePairs"
                        }
                    }
                }
            }, enableSubvolumes: {
                defaultValue: "Disabled",
                serializedName: "properties.enableSubvolumes",
                type: {
                    name: "String"
                }
            }, provisionedAvailabilityZone: {
                serializedName: "properties.provisionedAvailabilityZone",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            }, isLargeVolume: {
                defaultValue: false,
                serializedName: "properties.isLargeVolume",
                type: {
                    name: "Boolean"
                }
            }, originatingResourceId: {
                serializedName: "properties.originatingResourceId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SnapshotPolicy = {
    type: {
        name: "Composite",
        className: "SnapshotPolicy",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hourlySchedule: {
                serializedName: "properties.hourlySchedule",
                type: {
                    name: "Composite",
                    className: "HourlySchedule"
                }
            }, dailySchedule: {
                serializedName: "properties.dailySchedule",
                type: {
                    name: "Composite",
                    className: "DailySchedule"
                }
            }, weeklySchedule: {
                serializedName: "properties.weeklySchedule",
                type: {
                    name: "Composite",
                    className: "WeeklySchedule"
                }
            }, monthlySchedule: {
                serializedName: "properties.monthlySchedule",
                type: {
                    name: "Composite",
                    className: "MonthlySchedule"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BackupPolicy = {
    type: {
        name: "Composite",
        className: "BackupPolicy",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, backupPolicyId: {
                serializedName: "properties.backupPolicyId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dailyBackupsToKeep: {
                serializedName: "properties.dailyBackupsToKeep",
                type: {
                    name: "Number"
                }
            }, weeklyBackupsToKeep: {
                serializedName: "properties.weeklyBackupsToKeep",
                type: {
                    name: "Number"
                }
            }, monthlyBackupsToKeep: {
                serializedName: "properties.monthlyBackupsToKeep",
                type: {
                    name: "Number"
                }
            }, volumesAssigned: {
                serializedName: "properties.volumesAssigned",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, volumeBackups: {
                serializedName: "properties.volumeBackups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VolumeBackups"
                        }
                    }
                }
            } })
    }
};
const VolumeQuotaRule = {
    type: {
        name: "Composite",
        className: "VolumeQuotaRule",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Accepted",
                        "Creating",
                        "Patching",
                        "Deleting",
                        "Moving",
                        "Failed",
                        "Succeeded"
                    ]
                }
            }, quotaSizeInKiBs: {
                serializedName: "properties.quotaSizeInKiBs",
                type: {
                    name: "Number"
                }
            }, quotaType: {
                serializedName: "properties.quotaType",
                type: {
                    name: "String"
                }
            }, quotaTarget: {
                serializedName: "properties.quotaTarget",
                type: {
                    name: "String"
                }
            } })
    }
};
const NetAppResourceUpdateNetworkSiblingSetHeaders = {
    type: {
        name: "Composite",
        className: "NetAppResourceUpdateNetworkSiblingSetHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumesPopulateAvailabilityZoneHeaders = {
    type: {
        name: "Composite",
        className: "VolumesPopulateAvailabilityZoneHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumesBreakFileLocksHeaders = {
    type: {
        name: "Composite",
        className: "VolumesBreakFileLocksHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VolumesListGetGroupIdListForLdapUserHeaders = {
    type: {
        name: "Composite",
        className: "VolumesListGetGroupIdListForLdapUserHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AccountEncryption: AccountEncryption,
    ActiveDirectory: ActiveDirectory,
    AuthorizeRequest: AuthorizeRequest,
    BackupPoliciesList: BackupPoliciesList,
    BackupPolicy: BackupPolicy,
    BackupPolicyPatch: BackupPolicyPatch,
    BreakFileLocksRequest: BreakFileLocksRequest,
    BreakReplicationRequest: BreakReplicationRequest,
    CapacityPool: CapacityPool,
    CapacityPoolList: CapacityPoolList,
    CapacityPoolPatch: CapacityPoolPatch,
    CheckAvailabilityResponse: CheckAvailabilityResponse,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    DailySchedule: DailySchedule,
    Dimension: Dimension,
    EncryptionIdentity: EncryptionIdentity,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ErrorDetail: ErrorDetail,
    ErrorResponse: ErrorResponse,
    ExportPolicyRule: ExportPolicyRule,
    FilePathAvailabilityRequest: FilePathAvailabilityRequest,
    GetGroupIdListForLdapUserRequest: GetGroupIdListForLdapUserRequest,
    GetGroupIdListForLdapUserResponse: GetGroupIdListForLdapUserResponse,
    HourlySchedule: HourlySchedule,
    KeyVaultProperties: KeyVaultProperties,
    LdapSearchScopeOpt: LdapSearchScopeOpt,
    ListReplications: ListReplications,
    LogSpecification: LogSpecification,
    ManagedServiceIdentity: ManagedServiceIdentity,
    MetricSpecification: MetricSpecification,
    MonthlySchedule: MonthlySchedule,
    MountTarget: MountTarget,
    MountTargetProperties: MountTargetProperties,
    NetAppAccount: NetAppAccount,
    NetAppAccountList: NetAppAccountList,
    NetAppAccountPatch: NetAppAccountPatch,
    NetAppResourceUpdateNetworkSiblingSetHeaders: NetAppResourceUpdateNetworkSiblingSetHeaders,
    NetworkSiblingSet: NetworkSiblingSet,
    NicInfo: NicInfo,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationListResult: OperationListResult,
    PlacementKeyValuePairs: PlacementKeyValuePairs,
    PoolChangeRequest: PoolChangeRequest,
    ProxyResource: ProxyResource,
    QueryNetworkSiblingSetRequest: QueryNetworkSiblingSetRequest,
    QuotaAvailabilityRequest: QuotaAvailabilityRequest,
    ReestablishReplicationRequest: ReestablishReplicationRequest,
    RegionInfo: RegionInfo,
    RegionInfoAvailabilityZoneMappingsItem: RegionInfoAvailabilityZoneMappingsItem,
    RelocateVolumeRequest: RelocateVolumeRequest,
    Replication: Replication,
    ReplicationObject: ReplicationObject,
    ReplicationStatus: ReplicationStatus,
    Resource: Resource,
    ResourceIdentity: ResourceIdentity,
    ResourceNameAvailabilityRequest: ResourceNameAvailabilityRequest,
    RestoreStatus: RestoreStatus,
    ServiceSpecification: ServiceSpecification,
    Snapshot: Snapshot,
    SnapshotPoliciesList: SnapshotPoliciesList,
    SnapshotPolicy: SnapshotPolicy,
    SnapshotPolicyDetails: SnapshotPolicyDetails,
    SnapshotPolicyPatch: SnapshotPolicyPatch,
    SnapshotPolicyVolumeList: SnapshotPolicyVolumeList,
    SnapshotRestoreFiles: SnapshotRestoreFiles,
    SnapshotsList: SnapshotsList,
    SubscriptionQuotaItem: SubscriptionQuotaItem,
    SubscriptionQuotaItemList: SubscriptionQuotaItemList,
    SubvolumeInfo: SubvolumeInfo,
    SubvolumeModel: SubvolumeModel,
    SubvolumePatchRequest: SubvolumePatchRequest,
    SubvolumesList: SubvolumesList,
    SystemData: SystemData,
    TrackedResource: TrackedResource,
    UpdateNetworkSiblingSetRequest: UpdateNetworkSiblingSetRequest,
    UserAssignedIdentity: UserAssignedIdentity,
    Volume: Volume,
    VolumeBackups: VolumeBackups,
    VolumeGroup: VolumeGroup,
    VolumeGroupDetails: VolumeGroupDetails,
    VolumeGroupList: VolumeGroupList,
    VolumeGroupMetaData: VolumeGroupMetaData,
    VolumeGroupVolumeProperties: VolumeGroupVolumeProperties,
    VolumeList: VolumeList,
    VolumePatch: VolumePatch,
    VolumePatchPropertiesDataProtection: VolumePatchPropertiesDataProtection,
    VolumePatchPropertiesExportPolicy: VolumePatchPropertiesExportPolicy,
    VolumePropertiesDataProtection: VolumePropertiesDataProtection,
    VolumePropertiesExportPolicy: VolumePropertiesExportPolicy,
    VolumeQuotaRule: VolumeQuotaRule,
    VolumeQuotaRulePatch: VolumeQuotaRulePatch,
    VolumeQuotaRulesList: VolumeQuotaRulesList,
    VolumeRelocationProperties: VolumeRelocationProperties,
    VolumeRevert: VolumeRevert,
    VolumeSnapshotProperties: VolumeSnapshotProperties,
    VolumesBreakFileLocksHeaders: VolumesBreakFileLocksHeaders,
    VolumesListGetGroupIdListForLdapUserHeaders: VolumesListGetGroupIdListForLdapUserHeaders,
    VolumesPopulateAvailabilityZoneHeaders: VolumesPopulateAvailabilityZoneHeaders,
    WeeklySchedule: WeeklySchedule
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const quotaLimitName = {
    parameterPath: "quotaLimitName",
    mapper: {
        serializedName: "quotaLimitName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accountName = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,127}$")
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body5 = {
    parameterPath: "body",
    mapper: NetAppAccount
};
const body6 = {
    parameterPath: "body",
    mapper: NetAppAccountPatch
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const poolName = {
    parameterPath: "poolName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,63}$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "poolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body7 = {
    parameterPath: "body",
    mapper: CapacityPool
};
const body8 = {
    parameterPath: "body",
    mapper: CapacityPoolPatch
};
const volumeName = {
    parameterPath: "volumeName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9\\-_]{0,63}$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "volumeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body9 = {
    parameterPath: "body",
    mapper: Volume
};
const body10 = {
    parameterPath: "body",
    mapper: VolumePatch
};
const forceDelete = {
    parameterPath: ["options", "forceDelete"],
    mapper: {
        serializedName: "forceDelete",
        type: {
            name: "Boolean"
        }
    }
};
const body11 = {
    parameterPath: "body",
    mapper: VolumeRevert
};
const body12 = {
    parameterPath: ["options", "body"],
    mapper: BreakFileLocksRequest
};
const body13 = {
    parameterPath: "body",
    mapper: GetGroupIdListForLdapUserRequest
};
const body14 = {
    parameterPath: ["options", "body"],
    mapper: BreakReplicationRequest
};
const body15 = {
    parameterPath: "body",
    mapper: ReestablishReplicationRequest
};
const body16 = {
    parameterPath: "body",
    mapper: AuthorizeRequest
};
const body17 = {
    parameterPath: "body",
    mapper: PoolChangeRequest
};
const body18 = {
    parameterPath: ["options", "body"],
    mapper: RelocateVolumeRequest
};
const snapshotName = {
    parameterPath: "snapshotName",
    mapper: {
        serializedName: "snapshotName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body19 = {
    parameterPath: "body",
    mapper: Snapshot
};
const body20 = {
    parameterPath: "body",
    mapper: {
        serializedName: "body",
        required: true,
        type: {
            name: "Dictionary",
            value: { type: { name: "any" } }
        }
    }
};
const body21 = {
    parameterPath: "body",
    mapper: SnapshotRestoreFiles
};
const snapshotPolicyName = {
    parameterPath: "snapshotPolicyName",
    mapper: {
        serializedName: "snapshotPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body22 = {
    parameterPath: "body",
    mapper: SnapshotPolicy
};
const body23 = {
    parameterPath: "body",
    mapper: SnapshotPolicyPatch
};
const backupPolicyName = {
    parameterPath: "backupPolicyName",
    mapper: {
        serializedName: "backupPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body24 = {
    parameterPath: "body",
    mapper: BackupPolicy
};
const body25 = {
    parameterPath: "body",
    mapper: BackupPolicyPatch
};
const volumeQuotaRuleName = {
    parameterPath: "volumeQuotaRuleName",
    mapper: {
        serializedName: "volumeQuotaRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body26 = {
    parameterPath: "body",
    mapper: VolumeQuotaRule
};
const body27 = {
    parameterPath: "body",
    mapper: VolumeQuotaRulePatch
};
const volumeGroupName = {
    parameterPath: "volumeGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9\\-_]{0,63}$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "volumeGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body28 = {
    parameterPath: "body",
    mapper: VolumeGroupDetails
};
const subvolumeName = {
    parameterPath: "subvolumeName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9\\-_]{0,63}$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "subvolumeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body29 = {
    parameterPath: "body",
    mapper: SubvolumeInfo
};
const body30 = {
    parameterPath: "body",
    mapper: SubvolumePatchRequest
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Microsoft.NetApp Rest API operations
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Microsoft.NetApp Rest API operations
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$7);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/providers/Microsoft.NetApp/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NetAppResource operations. */
class NetAppResourceImpl {
    /**
     * Initialize a new instance of the class NetAppResource class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Check if a resource name is available.
     * @param location The name of Azure region.
     * @param name Resource name to verify.
     * @param typeParam Resource type used for verification.
     * @param resourceGroup Resource group name.
     * @param options The options parameters.
     */
    checkNameAvailability(location, name, typeParam, resourceGroup, options) {
        return this.client.sendOperationRequest({ location, name, typeParam, resourceGroup, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Check if a file path is available.
     * @param location The name of Azure region.
     * @param name File path to verify.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes
     * @param options The options parameters.
     */
    checkFilePathAvailability(location, name, subnetId, options) {
        return this.client.sendOperationRequest({ location, name, subnetId, options }, checkFilePathAvailabilityOperationSpec);
    }
    /**
     * Check if a quota is available.
     * @param location The name of Azure region.
     * @param name Name of the resource to verify.
     * @param typeParam Resource type used for verification.
     * @param resourceGroup Resource group name.
     * @param options The options parameters.
     */
    checkQuotaAvailability(location, name, typeParam, resourceGroup, options) {
        return this.client.sendOperationRequest({ location, name, typeParam, resourceGroup, options }, checkQuotaAvailabilityOperationSpec);
    }
    /**
     * Provides storage to network proximity and logical zone mapping information.
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    queryRegionInfo(location, options) {
        return this.client.sendOperationRequest({ location, options }, queryRegionInfoOperationSpec);
    }
    /**
     * Get details of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param options The options parameters.
     */
    queryNetworkSiblingSet(location, networkSiblingSetId, subnetId, options) {
        return this.client.sendOperationRequest({ location, networkSiblingSetId, subnetId, options }, queryNetworkSiblingSetOperationSpec);
    }
    /**
     * Update the network features of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param networkSiblingSetStateId Network sibling set state Id identifying the current state of the
     *                                 sibling set.
     * @param networkFeatures Network features available to the volume, some such
     * @param options The options parameters.
     */
    beginUpdateNetworkSiblingSet(location, networkSiblingSetId, subnetId, networkSiblingSetStateId, networkFeatures, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    location,
                    networkSiblingSetId,
                    subnetId,
                    networkSiblingSetStateId,
                    networkFeatures,
                    options
                },
                spec: updateNetworkSiblingSetOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the network features of the specified network sibling set.
     * @param location The name of Azure region.
     * @param networkSiblingSetId Network Sibling Set ID for a group of volumes sharing networking
     *                            resources in a subnet.
     * @param subnetId The Azure Resource URI for a delegated subnet. Must have the delegation
     *                 Microsoft.NetApp/volumes. Example
     *                 /subscriptions/subscriptionId/resourceGroups/resourceGroup/providers/Microsoft.Network/virtualNetworks/testVnet/subnets/{mySubnet}
     * @param networkSiblingSetStateId Network sibling set state Id identifying the current state of the
     *                                 sibling set.
     * @param networkFeatures Network features available to the volume, some such
     * @param options The options parameters.
     */
    beginUpdateNetworkSiblingSetAndWait(location, networkSiblingSetId, subnetId, networkSiblingSetStateId, networkFeatures, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateNetworkSiblingSet(location, networkSiblingSetId, subnetId, networkSiblingSetStateId, networkFeatures, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckAvailabilityResponse
        },
        default: {}
    },
    requestBody: {
        parameterPath: {
            name: ["name"],
            typeParam: ["typeParam"],
            resourceGroup: ["resourceGroup"]
        },
        mapper: Object.assign(Object.assign({}, ResourceNameAvailabilityRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const checkFilePathAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/checkFilePathAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckAvailabilityResponse
        },
        default: {}
    },
    requestBody: {
        parameterPath: { name: ["name"], subnetId: ["subnetId"] },
        mapper: Object.assign(Object.assign({}, FilePathAvailabilityRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const checkQuotaAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/checkQuotaAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckAvailabilityResponse
        },
        default: {}
    },
    requestBody: {
        parameterPath: {
            name: ["name"],
            typeParam: ["typeParam"],
            resourceGroup: ["resourceGroup"]
        },
        mapper: Object.assign(Object.assign({}, QuotaAvailabilityRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const queryRegionInfoOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/regionInfo",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RegionInfo
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const queryNetworkSiblingSetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/queryNetworkSiblingSet",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkSiblingSet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: {
        parameterPath: {
            networkSiblingSetId: ["networkSiblingSetId"],
            subnetId: ["subnetId"]
        },
        mapper: Object.assign(Object.assign({}, QueryNetworkSiblingSetRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const updateNetworkSiblingSetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/updateNetworkSiblingSet",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkSiblingSet
        },
        201: {
            bodyMapper: NetworkSiblingSet
        },
        202: {
            bodyMapper: NetworkSiblingSet
        },
        204: {
            bodyMapper: NetworkSiblingSet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: {
        parameterPath: {
            networkSiblingSetId: ["networkSiblingSetId"],
            subnetId: ["subnetId"],
            networkSiblingSetStateId: ["networkSiblingSetStateId"],
            networkFeatures: ["networkFeatures"]
        },
        mapper: Object.assign(Object.assign({}, UpdateNetworkSiblingSetRequest), { required: true })
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetAppResourceQuotaLimits operations. */
class NetAppResourceQuotaLimitsImpl {
    /**
     * Initialize a new instance of the class NetAppResourceQuotaLimits class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the default and current limits for quotas
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(location, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the default and current limits for quotas
     * @param location The name of Azure region.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$6);
    }
    /**
     * Get the default and current subscription quota limit
     * @param location The name of Azure region.
     * @param quotaLimitName The name of the Quota Limit
     * @param options The options parameters.
     */
    get(location, quotaLimitName, options) {
        return this.client.sendOperationRequest({ location, quotaLimitName, options }, getOperationSpec$9);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/quotaLimits",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionQuotaItemList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/locations/{location}/quotaLimits/{quotaLimitName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubscriptionQuotaItem
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        quotaLimitName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Accounts operations. */
class AccountsImpl {
    /**
     * Initialize a new instance of the class Accounts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List and describe all NetApp accounts in the subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List and describe all NetApp accounts in the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List and describe all NetApp accounts in the subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * List and describe all NetApp accounts in the resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$5);
    }
    /**
     * Get the NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getOperationSpec$8);
    }
    /**
     * Create or update the specified NetApp account within the resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, body, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update the specified NetApp account within the resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: deleteOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, body, options },
                spec: updateOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch the specified NetApp account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param body NetApp Account object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Renew identity credentials that are used to authenticate to key vault, for customer-managed key
     * encryption. If encryption.identity.principalId does not match identity.principalId, running this
     * operation will fix it.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginRenewCredentials(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: renewCredentialsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Renew identity credentials that are used to authenticate to key vault, for customer-managed key
     * encryption. If encryption.identity.principalId does not match identity.principalId, running this
     * operation will fix it.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    beginRenewCredentialsAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRenewCredentials(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.NetApp/netAppAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetAppAccountList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetAppAccountList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetAppAccount
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetAppAccount
        },
        201: {
            bodyMapper: NetAppAccount
        },
        202: {
            bodyMapper: NetAppAccount
        },
        204: {
            bodyMapper: NetAppAccount
        },
        default: {}
    },
    requestBody: body5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    serializer: serializer$9
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetAppAccount
        },
        201: {
            bodyMapper: NetAppAccount
        },
        202: {
            bodyMapper: NetAppAccount
        },
        204: {
            bodyMapper: NetAppAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const renewCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/renewCredentials",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetAppAccountList
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetAppAccountList
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Pools operations. */
class PoolsImpl {
    /**
     * Initialize a new instance of the class Pools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all capacity pools in the NetApp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all capacity pools in the NetApp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$4);
    }
    /**
     * Get details of the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, options }, getOperationSpec$7);
    }
    /**
     * Create or Update a capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, poolName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, body, options },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or Update a capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, poolName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, poolName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, poolName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, body, options },
                spec: updateOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param body Capacity pool object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, poolName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, poolName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, options },
                spec: deleteOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityPoolList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityPool
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CapacityPool
        },
        201: {
            bodyMapper: CapacityPool
        },
        202: {
            bodyMapper: CapacityPool
        },
        204: {
            bodyMapper: CapacityPool
        },
        default: {}
    },
    requestBody: body7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CapacityPool
        },
        201: {
            bodyMapper: CapacityPool
        },
        202: {
            bodyMapper: CapacityPool
        },
        204: {
            bodyMapper: CapacityPool
        },
        default: {}
    },
    requestBody: body8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName
    ],
    serializer: serializer$8
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapacityPoolList
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Volumes operations. */
class VolumesImpl {
    /**
     * Initialize a new instance of the class Volumes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all volumes within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, poolName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, poolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, poolName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, poolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, poolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, poolName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, poolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, poolName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all replications for a specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listReplications(resourceGroupName, accountName, poolName, volumeName, options) {
        const iter = this.listReplicationsPagingAll(resourceGroupName, accountName, poolName, volumeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listReplicationsPagingPage(resourceGroupName, accountName, poolName, volumeName, options, settings);
            }
        };
    }
    listReplicationsPagingPage(resourceGroupName, accountName, poolName, volumeName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listReplicationsPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listReplications(resourceGroupName, accountName, poolName, volumeName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listReplicationsPagingAll(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listReplicationsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listReplicationsPagingPage(resourceGroupName, accountName, poolName, volumeName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List all volumes within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, poolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, options }, listOperationSpec$3);
    }
    /**
     * Get the details of the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, getOperationSpec$6);
    }
    /**
     * Create or update the specified volume within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update the specified volume within the capacity pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: updateOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Volume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: deleteOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation will populate availability zone information for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginPopulateAvailabilityZone(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: populateAvailabilityZoneOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation will populate availability zone information for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginPopulateAvailabilityZoneAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPopulateAvailabilityZone(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Revert a volume to the snapshot specified in the body
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Object for snapshot to revert supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRevert(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: revertOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Revert a volume to the snapshot specified in the body
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Object for snapshot to revert supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRevertAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevert(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reset cifs password from volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResetCifsPassword(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: resetCifsPasswordOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reset cifs password from volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResetCifsPasswordAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetCifsPassword(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Break all the file locks on a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakFileLocks(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: breakFileLocksOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Break all the file locks on a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakFileLocksAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBreakFileLocks(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns the list of group Ids for a specific LDAP User
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Returns group Id list for a specific LDAP user
     * @param options The options parameters.
     */
    beginListGetGroupIdListForLdapUser(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: listGetGroupIdListForLdapUserOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns the list of group Ids for a specific LDAP User
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Returns group Id list for a specific LDAP user
     * @param options The options parameters.
     */
    beginListGetGroupIdListForLdapUserAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListGetGroupIdListForLdapUser(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Break the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakReplication(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: breakReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Break the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginBreakReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBreakReplication(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Re-establish a previously deleted replication between 2 volumes that have a common ad-hoc or
     * policy-based snapshots
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body body for the id of the source volume.
     * @param options The options parameters.
     */
    beginReestablishReplication(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: reestablishReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Re-establish a previously deleted replication between 2 volumes that have a common ad-hoc or
     * policy-based snapshots
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body body for the id of the source volume.
     * @param options The options parameters.
     */
    beginReestablishReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReestablishReplication(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the status of the replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    replicationStatus(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, replicationStatusOperationSpec);
    }
    /**
     * List all replications for a specified volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    _listReplications(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, listReplicationsOperationSpec);
    }
    /**
     * Resync the connection on the destination volume. If the operation is ran on the source volume it
     * will reverse-resync the connection and sync from destination to source.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResyncReplication(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: resyncReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resync the connection on the destination volume. If the operation is ran on the source volume it
     * will reverse-resync the connection and sync from destination to source.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginResyncReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResyncReplication(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the replication connection on the destination volume, and send release to the source
     * replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteReplication(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: deleteReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the replication connection on the destination volume, and send release to the source
     * replication
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginDeleteReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteReplication(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Authorize the replication connection on the source volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Authorize request object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginAuthorizeReplication(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: authorizeReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Authorize the replication connection on the source volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Authorize request object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginAuthorizeReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAuthorizeReplication(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Re-Initializes the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginReInitializeReplication(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: reInitializeReplicationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Re-Initializes the replication connection on the destination volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginReInitializeReplicationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReInitializeReplication(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Moves volume to another pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Move volume to the pool supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginPoolChange(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    body,
                    options
                },
                spec: poolChangeOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Moves volume to another pool
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param body Move volume to the pool supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginPoolChangeAndWait(resourceGroupName, accountName, poolName, volumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPoolChange(resourceGroupName, accountName, poolName, volumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Relocates volume to a new stamp
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRelocate(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: relocateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Relocates volume to a new stamp
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRelocateAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRelocate(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Finalizes the relocation of the volume and cleans up the old volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginFinalizeRelocation(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: finalizeRelocationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Finalizes the relocation of the volume and cleans up the old volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginFinalizeRelocationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginFinalizeRelocation(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reverts the volume relocation process, cleans up the new volume and starts using the former-existing
     * volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRevertRelocation(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, volumeName, options },
                spec: revertRelocationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reverts the volume relocation process, cleans up the new volume and starts using the former-existing
     * volume.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    beginRevertRelocationAndWait(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRevertRelocation(resourceGroupName, accountName, poolName, volumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, poolName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Volume
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Volume
        },
        201: {
            bodyMapper: Volume
        },
        202: {
            bodyMapper: Volume
        },
        204: {
            bodyMapper: Volume
        },
        default: {}
    },
    requestBody: body9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Volume
        },
        201: {
            bodyMapper: Volume
        },
        202: {
            bodyMapper: Volume
        },
        204: {
            bodyMapper: Volume
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: body10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion, forceDelete],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const populateAvailabilityZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/populateAvailabilityZone",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Volume
        },
        201: {
            bodyMapper: Volume
        },
        202: {
            bodyMapper: Volume
        },
        204: {
            bodyMapper: Volume
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const revertOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/revert",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const resetCifsPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/resetCifsPassword",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const breakFileLocksOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/breakFileLocks",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listGetGroupIdListForLdapUserOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/getGroupIdListForLdapUser",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GetGroupIdListForLdapUserResponse
        },
        201: {
            bodyMapper: GetGroupIdListForLdapUserResponse
        },
        202: {
            bodyMapper: GetGroupIdListForLdapUserResponse
        },
        204: {
            bodyMapper: GetGroupIdListForLdapUserResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const breakReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/breakReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const reestablishReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/reestablishReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const replicationStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/replicationStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ReplicationStatus
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listReplicationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/listReplications",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListReplications
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const resyncReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/resyncReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const deleteReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/deleteReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const authorizeReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/authorizeReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const reInitializeReplicationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/reinitializeReplication",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const poolChangeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/poolChange",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const relocateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/relocate",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$7
};
const finalizeRelocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/finalizeRelocation",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const revertRelocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/revertRelocation",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    serializer: serializer$7
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeList
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink,
        poolName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Snapshots operations. */
class SnapshotsImpl {
    /**
     * Initialize a new instance of the class Snapshots class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all snapshots associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, poolName, volumeName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, poolName, volumeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, poolName, volumeName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, poolName, volumeName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, poolName, volumeName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, poolName, volumeName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all snapshots associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, listOperationSpec$2);
    }
    /**
     * Get details of the specified snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, volumeName, snapshotName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            poolName,
            volumeName,
            snapshotName,
            options
        }, getOperationSpec$5);
    }
    /**
     * Create the specified snapshot within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    snapshotName,
                    body,
                    options
                },
                spec: createOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create the specified snapshot within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch a snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    snapshotName,
                    body,
                    options
                },
                spec: updateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Snapshot object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, volumeName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    snapshotName,
                    options
                },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete snapshot
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, volumeName, snapshotName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, volumeName, snapshotName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restore the specified files from the specified snapshot to the active filesystem
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Restore payload supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRestoreFiles(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    snapshotName,
                    body,
                    options
                },
                spec: restoreFilesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restore the specified files from the specified snapshot to the active filesystem
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param snapshotName The name of the snapshot
     * @param body Restore payload supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginRestoreFilesAndWait(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreFiles(resourceGroupName, accountName, poolName, volumeName, snapshotName, body, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotsList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots/{snapshotName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Snapshot
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        snapshotName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots/{snapshotName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Snapshot
        },
        201: {
            bodyMapper: Snapshot
        },
        202: {
            bodyMapper: Snapshot
        },
        204: {
            bodyMapper: Snapshot
        },
        default: {}
    },
    requestBody: body19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        snapshotName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots/{snapshotName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Snapshot
        },
        201: {
            bodyMapper: Snapshot
        },
        202: {
            bodyMapper: Snapshot
        },
        204: {
            bodyMapper: Snapshot
        },
        default: {}
    },
    requestBody: body20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        snapshotName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots/{snapshotName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        snapshotName
    ],
    serializer: serializer$6
};
const restoreFilesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/snapshots/{snapshotName}/restoreFiles",
    httpMethod: "POST",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    requestBody: body21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        snapshotName
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SnapshotPolicies operations. */
class SnapshotPoliciesImpl {
    /**
     * Initialize a new instance of the class SnapshotPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$1);
    }
    /**
     * Get a snapshot Policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, snapshotPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, snapshotPolicyName, options }, getOperationSpec$4);
    }
    /**
     * Create a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, snapshotPolicyName, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, snapshotPolicyName, body, options }, createOperationSpec$4);
    }
    /**
     * Patch a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, snapshotPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    snapshotPolicyName,
                    body,
                    options
                },
                spec: updateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param body Snapshot policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, snapshotPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, snapshotPolicyName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, snapshotPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, snapshotPolicyName, options },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, snapshotPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, snapshotPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get volumes associated with snapshot policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param snapshotPolicyName The name of the snapshot policy
     * @param options The options parameters.
     */
    listVolumes(resourceGroupName, accountName, snapshotPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, snapshotPolicyName, options }, listVolumesOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotPoliciesList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies/{snapshotPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        snapshotPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies/{snapshotPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SnapshotPolicy
        },
        201: {
            bodyMapper: SnapshotPolicy
        },
        default: {}
    },
    requestBody: body22,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        snapshotPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies/{snapshotPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SnapshotPolicy
        },
        201: {
            bodyMapper: SnapshotPolicy
        },
        202: {
            bodyMapper: SnapshotPolicy
        },
        204: {
            bodyMapper: SnapshotPolicy
        },
        default: {}
    },
    requestBody: body23,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        snapshotPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies/{snapshotPolicyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        snapshotPolicyName
    ],
    serializer: serializer$5
};
const listVolumesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/snapshotPolicies/{snapshotPolicyName}/volumes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SnapshotPolicyVolumeList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        snapshotPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Backups operations. */
class BackupsImpl {
    /**
     * Initialize a new instance of the class Backups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the status of the restore for a volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    getVolumeRestoreStatus(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, getVolumeRestoreStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getVolumeRestoreStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/restoreStatus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RestoreStatus
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BackupPolicies operations. */
class BackupPoliciesImpl {
    /**
     * Initialize a new instance of the class BackupPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List backup policies for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List backup policies for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec);
    }
    /**
     * Get a particular backup Policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, backupPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, backupPolicyName, options }, getOperationSpec$3);
    }
    /**
     * Create a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, backupPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, backupPolicyName, body, options },
                spec: createOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, backupPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, backupPolicyName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, backupPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, backupPolicyName, body, options },
                spec: updateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a backup policy for Netapp Account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param body Backup policy object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, backupPolicyName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, backupPolicyName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete backup policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, backupPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, backupPolicyName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete backup policy
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param backupPolicyName Backup policy Name which uniquely identify backup policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, backupPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, backupPolicyName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/backupPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupPoliciesList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/backupPolicies/{backupPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackupPolicy
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        backupPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/backupPolicies/{backupPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackupPolicy
        },
        201: {
            bodyMapper: BackupPolicy
        },
        202: {
            bodyMapper: BackupPolicy
        },
        204: {
            bodyMapper: BackupPolicy
        },
        default: {}
    },
    requestBody: body24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        backupPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/backupPolicies/{backupPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BackupPolicy
        },
        201: {
            bodyMapper: BackupPolicy
        },
        202: {
            bodyMapper: BackupPolicy
        },
        204: {
            bodyMapper: BackupPolicy
        },
        default: {}
    },
    requestBody: body25,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        backupPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/backupPolicies/{backupPolicyName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        backupPolicyName
    ],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VolumeQuotaRules operations. */
class VolumeQuotaRulesImpl {
    /**
     * Initialize a new instance of the class VolumeQuotaRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all quota rules associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listByVolume(resourceGroupName, accountName, poolName, volumeName, options) {
        const iter = this.listByVolumePagingAll(resourceGroupName, accountName, poolName, volumeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options, settings);
            }
        };
    }
    listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVolumePagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByVolume(resourceGroupName, accountName, poolName, volumeName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByVolumePagingAll(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVolumePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all quota rules associated with the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    _listByVolume(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, listByVolumeOperationSpec$1);
    }
    /**
     * Get details of the specified quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            poolName,
            volumeName,
            volumeQuotaRuleName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Create the specified quota rule within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    volumeQuotaRuleName,
                    body,
                    options
                },
                spec: createOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create the specified quota rule within the given volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch a quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    volumeQuotaRuleName,
                    body,
                    options
                },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param body Quota rule object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    volumeQuotaRuleName,
                    options
                },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete quota rule
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param volumeQuotaRuleName The name of volume quota rule
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, volumeName, volumeQuotaRuleName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByVolumeOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/volumeQuotaRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeQuotaRulesList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/volumeQuotaRules/{volumeQuotaRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeQuotaRule
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        volumeQuotaRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/volumeQuotaRules/{volumeQuotaRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VolumeQuotaRule
        },
        201: {
            bodyMapper: VolumeQuotaRule
        },
        202: {
            bodyMapper: VolumeQuotaRule
        },
        204: {
            bodyMapper: VolumeQuotaRule
        },
        default: {}
    },
    requestBody: body26,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        volumeQuotaRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/volumeQuotaRules/{volumeQuotaRuleName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VolumeQuotaRule
        },
        201: {
            bodyMapper: VolumeQuotaRule
        },
        202: {
            bodyMapper: VolumeQuotaRule
        },
        204: {
            bodyMapper: VolumeQuotaRule
        },
        default: {}
    },
    requestBody: body27,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        volumeQuotaRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/volumeQuotaRules/{volumeQuotaRuleName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        volumeQuotaRuleName
    ],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VolumeGroups operations. */
class VolumeGroupsImpl {
    /**
     * Initialize a new instance of the class VolumeGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all volume groups for given account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    listByNetAppAccount(resourceGroupName, accountName, options) {
        const iter = this.listByNetAppAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByNetAppAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByNetAppAccountPagingPage(resourceGroupName, accountName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByNetAppAccountPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listByNetAppAccount(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listByNetAppAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByNetAppAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByNetAppAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all volume groups for given account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param options The options parameters.
     */
    _listByNetAppAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByNetAppAccountOperationSpec);
    }
    /**
     * Get details of the specified volume group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, volumeGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, volumeGroupName, options }, getOperationSpec$1);
    }
    /**
     * Create a volume group along with specified volumes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param body Volume Group object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, volumeGroupName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, volumeGroupName, body, options },
                spec: createOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a volume group along with specified volumes
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param body Volume Group object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, volumeGroupName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, volumeGroupName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the specified volume group only if there are no volumes under volume group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, volumeGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, volumeGroupName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete the specified volume group only if there are no volumes under volume group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param volumeGroupName The name of the volumeGroup
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, volumeGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, volumeGroupName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByNetAppAccountOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/volumeGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeGroupList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/volumeGroups/{volumeGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VolumeGroupDetails
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        volumeGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/volumeGroups/{volumeGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VolumeGroupDetails
        },
        201: {
            bodyMapper: VolumeGroupDetails
        },
        202: {
            bodyMapper: VolumeGroupDetails
        },
        204: {
            bodyMapper: VolumeGroupDetails
        },
        default: {}
    },
    requestBody: body28,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        volumeGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/volumeGroups/{volumeGroupName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        volumeGroupName
    ],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Subvolumes operations. */
class SubvolumesImpl {
    /**
     * Initialize a new instance of the class Subvolumes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of the subvolumes in the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    listByVolume(resourceGroupName, accountName, poolName, volumeName, options) {
        const iter = this.listByVolumePagingAll(resourceGroupName, accountName, poolName, volumeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options, settings);
            }
        };
    }
    listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVolumePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVolume(resourceGroupName, accountName, poolName, volumeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVolumeNext(resourceGroupName, accountName, poolName, volumeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVolumePagingAll(resourceGroupName, accountName, poolName, volumeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVolumePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByVolumePagingPage(resourceGroupName, accountName, poolName, volumeName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of the subvolumes in the volume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param options The options parameters.
     */
    _listByVolume(resourceGroupName, accountName, poolName, volumeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, volumeName, options }, listByVolumeOperationSpec);
    }
    /**
     * Returns the path associated with the subvolumeName provided
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            poolName,
            volumeName,
            subvolumeName,
            options
        }, getOperationSpec);
    }
    /**
     * Creates a subvolume in the path or clones the subvolume mentioned in the parentPath
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    subvolumeName,
                    body,
                    options
                },
                spec: createOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a subvolume in the path or clones the subvolume mentioned in the parentPath
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch a subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    subvolumeName,
                    body,
                    options
                },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch a subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param body Subvolume object supplied in the body of the operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, poolName, volumeName, subvolumeName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    subvolumeName,
                    options
                },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get details of the specified subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginGetMetadata(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    poolName,
                    volumeName,
                    subvolumeName,
                    options
                },
                spec: getMetadataOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get details of the specified subvolume
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param subvolumeName The name of the subvolume.
     * @param options The options parameters.
     */
    beginGetMetadataAndWait(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetMetadata(resourceGroupName, accountName, poolName, volumeName, subvolumeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByVolumeNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The name of the NetApp account
     * @param poolName The name of the capacity pool
     * @param volumeName The name of the volume
     * @param nextLink The nextLink from the previous successful call to the ListByVolume method.
     * @param options The options parameters.
     */
    _listByVolumeNext(resourceGroupName, accountName, poolName, volumeName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            poolName,
            volumeName,
            nextLink,
            options
        }, listByVolumeNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByVolumeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubvolumesList
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes/{subvolumeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubvolumeInfo
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        subvolumeName
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes/{subvolumeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SubvolumeInfo
        },
        201: {
            bodyMapper: SubvolumeInfo
        },
        202: {
            bodyMapper: SubvolumeInfo
        },
        204: {
            bodyMapper: SubvolumeInfo
        },
        default: {}
    },
    requestBody: body29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        subvolumeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes/{subvolumeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SubvolumeInfo
        },
        201: {
            bodyMapper: SubvolumeInfo
        },
        202: {
            bodyMapper: SubvolumeInfo
        },
        204: {
            bodyMapper: SubvolumeInfo
        },
        default: {}
    },
    requestBody: body30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        subvolumeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes/{subvolumeName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {}, default: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        subvolumeName
    ],
    serializer
};
const getMetadataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.NetApp/netAppAccounts/{accountName}/capacityPools/{poolName}/volumes/{volumeName}/subvolumes/{subvolumeName}/getMetadata",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SubvolumeModel
        },
        201: {
            bodyMapper: SubvolumeModel
        },
        202: {
            bodyMapper: SubvolumeModel
        },
        204: {
            bodyMapper: SubvolumeModel
        },
        default: {}
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        poolName,
        volumeName,
        subvolumeName
    ],
    headerParameters: [accept],
    serializer
};
const listByVolumeNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubvolumesList
        },
        default: {}
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink,
        poolName,
        volumeName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class NetAppManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the NetAppManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-netapp/19.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-05-01";
        this.operations = new OperationsImpl(this);
        this.netAppResource = new NetAppResourceImpl(this);
        this.netAppResourceQuotaLimits = new NetAppResourceQuotaLimitsImpl(this);
        this.accounts = new AccountsImpl(this);
        this.pools = new PoolsImpl(this);
        this.volumes = new VolumesImpl(this);
        this.snapshots = new SnapshotsImpl(this);
        this.snapshotPolicies = new SnapshotPoliciesImpl(this);
        this.backups = new BackupsImpl(this);
        this.backupPolicies = new BackupPoliciesImpl(this);
        this.volumeQuotaRules = new VolumeQuotaRulesImpl(this);
        this.volumeGroups = new VolumeGroupsImpl(this);
        this.subvolumes = new SubvolumesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.NetAppManagementClient = NetAppManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
