'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ContainerType} that the service accepts. */
exports.KnownContainerType = void 0;
(function (KnownContainerType) {
    /** A Docker compatible container technology will be used to launch the containers. */
    KnownContainerType["DockerCompatible"] = "DockerCompatible";
    /** A CRI based technology will be used to launch the containers. */
    KnownContainerType["CriCompatible"] = "CriCompatible";
})(exports.KnownContainerType || (exports.KnownContainerType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const BatchAccountCreateParameters = {
    type: {
        name: "Composite",
        className: "BatchAccountCreateParameters",
        modelProperties: {
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "BatchAccountIdentity"
                }
            },
            autoStorage: {
                serializedName: "properties.autoStorage",
                type: {
                    name: "Composite",
                    className: "AutoStorageBaseProperties"
                }
            },
            poolAllocationMode: {
                serializedName: "properties.poolAllocationMode",
                type: {
                    name: "Enum",
                    allowedValues: ["BatchService", "UserSubscription"]
                }
            },
            keyVaultReference: {
                serializedName: "properties.keyVaultReference",
                type: {
                    name: "Composite",
                    className: "KeyVaultReference"
                }
            },
            publicNetworkAccess: {
                defaultValue: "Enabled",
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            },
            networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperties"
                }
            },
            allowedAuthenticationModes: {
                serializedName: "properties.allowedAuthenticationModes",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["SharedKey", "AAD", "TaskAuthenticationToken"]
                        }
                    }
                }
            }
        }
    }
};
const AutoStorageBaseProperties = {
    type: {
        name: "Composite",
        className: "AutoStorageBaseProperties",
        modelProperties: {
            storageAccountId: {
                serializedName: "storageAccountId",
                required: true,
                type: {
                    name: "String"
                }
            },
            authenticationMode: {
                defaultValue: "StorageKeys",
                serializedName: "authenticationMode",
                type: {
                    name: "Enum",
                    allowedValues: ["StorageKeys", "BatchAccountManagedIdentity"]
                }
            },
            nodeIdentityReference: {
                serializedName: "nodeIdentityReference",
                type: {
                    name: "Composite",
                    className: "ComputeNodeIdentityReference"
                }
            }
        }
    }
};
const ComputeNodeIdentityReference = {
    type: {
        name: "Composite",
        className: "ComputeNodeIdentityReference",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultReference = {
    type: {
        name: "Composite",
        className: "KeyVaultReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkProfile = {
    type: {
        name: "Composite",
        className: "NetworkProfile",
        modelProperties: {
            accountAccess: {
                serializedName: "accountAccess",
                type: {
                    name: "Composite",
                    className: "EndpointAccessProfile"
                }
            },
            nodeManagementAccess: {
                serializedName: "nodeManagementAccess",
                type: {
                    name: "Composite",
                    className: "EndpointAccessProfile"
                }
            }
        }
    }
};
const EndpointAccessProfile = {
    type: {
        name: "Composite",
        className: "EndpointAccessProfile",
        modelProperties: {
            defaultAction: {
                serializedName: "defaultAction",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Allow", "Deny"]
                }
            },
            ipRules: {
                serializedName: "ipRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPRule"
                        }
                    }
                }
            }
        }
    }
};
const IPRule = {
    type: {
        name: "Composite",
        className: "IPRule",
        modelProperties: {
            action: {
                defaultValue: "Allow",
                isConstant: true,
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncryptionProperties = {
    type: {
        name: "Composite",
        className: "EncryptionProperties",
        modelProperties: {
            keySource: {
                serializedName: "keySource",
                type: {
                    name: "Enum",
                    allowedValues: ["Microsoft.Batch", "Microsoft.KeyVault"]
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyIdentifier: {
                serializedName: "keyIdentifier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchAccountIdentity = {
    type: {
        name: "Composite",
        className: "BatchAccountIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["SystemAssigned", "UserAssigned", "None"]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentities" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentities = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentities",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Approved", "Pending", "Rejected", "Disconnected"]
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineFamilyCoreQuota = {
    type: {
        name: "Composite",
        className: "VirtualMachineFamilyCoreQuota",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            coreQuota: {
                serializedName: "coreQuota",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const BatchAccountUpdateParameters = {
    type: {
        name: "Composite",
        className: "BatchAccountUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "BatchAccountIdentity"
                }
            },
            autoStorage: {
                serializedName: "properties.autoStorage",
                type: {
                    name: "Composite",
                    className: "AutoStorageBaseProperties"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperties"
                }
            },
            allowedAuthenticationModes: {
                serializedName: "properties.allowedAuthenticationModes",
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["SharedKey", "AAD", "TaskAuthenticationToken"]
                        }
                    }
                }
            },
            publicNetworkAccess: {
                defaultValue: "Enabled",
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            },
            networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            }
        }
    }
};
const BatchAccountListResult = {
    type: {
        name: "Composite",
        className: "BatchAccountListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BatchAccount"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchAccountRegenerateKeyParameters = {
    type: {
        name: "Composite",
        className: "BatchAccountRegenerateKeyParameters",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Primary", "Secondary"]
                }
            }
        }
    }
};
const BatchAccountKeys = {
    type: {
        name: "Composite",
        className: "BatchAccountKeys",
        modelProperties: {
            accountName: {
                serializedName: "accountName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primary: {
                serializedName: "primary",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondary: {
                serializedName: "secondary",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActivateApplicationPackageParameters = {
    type: {
        name: "Composite",
        className: "ActivateApplicationPackageParameters",
        modelProperties: {
            format: {
                serializedName: "format",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListApplicationsResult = {
    type: {
        name: "Composite",
        className: "ListApplicationsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Application"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListApplicationPackagesResult = {
    type: {
        name: "Composite",
        className: "ListApplicationPackagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationPackage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchLocationQuota = {
    type: {
        name: "Composite",
        className: "BatchLocationQuota",
        modelProperties: {
            accountQuota: {
                serializedName: "accountQuota",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SupportedSkusResult = {
    type: {
        name: "Composite",
        className: "SupportedSkusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SupportedSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SupportedSku = {
    type: {
        name: "Composite",
        className: "SupportedSku",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            familyName: {
                serializedName: "familyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuCapability"
                        }
                    }
                }
            }
        }
    }
};
const SkuCapability = {
    type: {
        name: "Composite",
        className: "SkuCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityParameters = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.Batch/batchAccounts",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Invalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListCertificatesResult = {
    type: {
        name: "Composite",
        className: "ListCertificatesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Certificate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeleteCertificateError = {
    type: {
        name: "Composite",
        className: "DeleteCertificateError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DeleteCertificateError"
                        }
                    }
                }
            }
        }
    }
};
const CertificateBaseProperties = {
    type: {
        name: "Composite",
        className: "CertificateBaseProperties",
        modelProperties: {
            thumbprintAlgorithm: {
                serializedName: "thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            },
            format: {
                serializedName: "format",
                type: {
                    name: "Enum",
                    allowedValues: ["Pfx", "Cer"]
                }
            }
        }
    }
};
const DetectorListResult = {
    type: {
        name: "Composite",
        className: "DetectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DetectorResponse"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListPrivateLinkResourcesResult = {
    type: {
        name: "Composite",
        className: "ListPrivateLinkResourcesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListPrivateEndpointConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListPrivateEndpointConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListPoolsResult = {
    type: {
        name: "Composite",
        className: "ListPoolsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Pool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeploymentConfiguration = {
    type: {
        name: "Composite",
        className: "DeploymentConfiguration",
        modelProperties: {
            cloudServiceConfiguration: {
                serializedName: "cloudServiceConfiguration",
                type: {
                    name: "Composite",
                    className: "CloudServiceConfiguration"
                }
            },
            virtualMachineConfiguration: {
                serializedName: "virtualMachineConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualMachineConfiguration"
                }
            }
        }
    }
};
const CloudServiceConfiguration = {
    type: {
        name: "Composite",
        className: "CloudServiceConfiguration",
        modelProperties: {
            osFamily: {
                serializedName: "osFamily",
                required: true,
                type: {
                    name: "String"
                }
            },
            osVersion: {
                serializedName: "osVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualMachineConfiguration",
        modelProperties: {
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            nodeAgentSkuId: {
                serializedName: "nodeAgentSkuId",
                required: true,
                type: {
                    name: "String"
                }
            },
            windowsConfiguration: {
                serializedName: "windowsConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsConfiguration"
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDisk"
                        }
                    }
                }
            },
            licenseType: {
                serializedName: "licenseType",
                type: {
                    name: "String"
                }
            },
            containerConfiguration: {
                serializedName: "containerConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerConfiguration"
                }
            },
            diskEncryptionConfiguration: {
                serializedName: "diskEncryptionConfiguration",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionConfiguration"
                }
            },
            nodePlacementConfiguration: {
                serializedName: "nodePlacementConfiguration",
                type: {
                    name: "Composite",
                    className: "NodePlacementConfiguration"
                }
            },
            extensions: {
                serializedName: "extensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VMExtension"
                        }
                    }
                }
            },
            osDisk: {
                serializedName: "osDisk",
                type: {
                    name: "Composite",
                    className: "OSDisk"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            serviceArtifactReference: {
                serializedName: "serviceArtifactReference",
                type: {
                    name: "Composite",
                    className: "ServiceArtifactReference"
                }
            }
        }
    }
};
const ImageReference = {
    type: {
        name: "Composite",
        className: "ImageReference",
        modelProperties: {
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            version: {
                defaultValue: "latest",
                serializedName: "version",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WindowsConfiguration = {
    type: {
        name: "Composite",
        className: "WindowsConfiguration",
        modelProperties: {
            enableAutomaticUpdates: {
                serializedName: "enableAutomaticUpdates",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DataDisk = {
    type: {
        name: "Composite",
        className: "DataDisk",
        modelProperties: {
            lun: {
                serializedName: "lun",
                required: true,
                type: {
                    name: "Number"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                required: true,
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "Enum",
                    allowedValues: ["Standard_LRS", "Premium_LRS", "StandardSSD_LRS"]
                }
            }
        }
    }
};
const ContainerConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerConfiguration",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            containerImageNames: {
                serializedName: "containerImageNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            containerRegistries: {
                serializedName: "containerRegistries",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerRegistry"
                        }
                    }
                }
            }
        }
    }
};
const ContainerRegistry = {
    type: {
        name: "Composite",
        className: "ContainerRegistry",
        modelProperties: {
            userName: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            registryServer: {
                serializedName: "registryServer",
                type: {
                    name: "String"
                }
            },
            identityReference: {
                serializedName: "identityReference",
                type: {
                    name: "Composite",
                    className: "ComputeNodeIdentityReference"
                }
            }
        }
    }
};
const DiskEncryptionConfiguration = {
    type: {
        name: "Composite",
        className: "DiskEncryptionConfiguration",
        modelProperties: {
            targets: {
                serializedName: "targets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["OsDisk", "TemporaryDisk"]
                        }
                    }
                }
            }
        }
    }
};
const NodePlacementConfiguration = {
    type: {
        name: "Composite",
        className: "NodePlacementConfiguration",
        modelProperties: {
            policy: {
                serializedName: "policy",
                type: {
                    name: "Enum",
                    allowedValues: ["Regional", "Zonal"]
                }
            }
        }
    }
};
const VMExtension = {
    type: {
        name: "Composite",
        className: "VMExtension",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            typeHandlerVersion: {
                serializedName: "typeHandlerVersion",
                type: {
                    name: "String"
                }
            },
            autoUpgradeMinorVersion: {
                serializedName: "autoUpgradeMinorVersion",
                type: {
                    name: "Boolean"
                }
            },
            enableAutomaticUpgrade: {
                serializedName: "enableAutomaticUpgrade",
                type: {
                    name: "Boolean"
                }
            },
            settings: {
                serializedName: "settings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            protectedSettings: {
                serializedName: "protectedSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            provisionAfterExtensions: {
                serializedName: "provisionAfterExtensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OSDisk = {
    type: {
        name: "Composite",
        className: "OSDisk",
        modelProperties: {
            ephemeralOSDiskSettings: {
                serializedName: "ephemeralOSDiskSettings",
                type: {
                    name: "Composite",
                    className: "DiffDiskSettings"
                }
            },
            caching: {
                serializedName: "caching",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "ReadOnly", "ReadWrite"]
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDisk"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            writeAcceleratorEnabled: {
                serializedName: "writeAcceleratorEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DiffDiskSettings = {
    type: {
        name: "Composite",
        className: "DiffDiskSettings",
        modelProperties: {
            placement: {
                defaultValue: "CacheDisk",
                isConstant: true,
                serializedName: "placement",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedDisk = {
    type: {
        name: "Composite",
        className: "ManagedDisk",
        modelProperties: {
            storageAccountType: {
                serializedName: "storageAccountType",
                type: {
                    name: "Enum",
                    allowedValues: ["Standard_LRS", "Premium_LRS", "StandardSSD_LRS"]
                }
            }
        }
    }
};
const SecurityProfile = {
    type: {
        name: "Composite",
        className: "SecurityProfile",
        modelProperties: {
            securityType: {
                defaultValue: "trustedLaunch",
                isConstant: true,
                serializedName: "securityType",
                type: {
                    name: "String"
                }
            },
            encryptionAtHost: {
                serializedName: "encryptionAtHost",
                type: {
                    name: "Boolean"
                }
            },
            uefiSettings: {
                serializedName: "uefiSettings",
                type: {
                    name: "Composite",
                    className: "UefiSettings"
                }
            }
        }
    }
};
const UefiSettings = {
    type: {
        name: "Composite",
        className: "UefiSettings",
        modelProperties: {
            secureBootEnabled: {
                serializedName: "secureBootEnabled",
                type: {
                    name: "Boolean"
                }
            },
            vTpmEnabled: {
                serializedName: "vTpmEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ServiceArtifactReference = {
    type: {
        name: "Composite",
        className: "ServiceArtifactReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScaleSettings = {
    type: {
        name: "Composite",
        className: "ScaleSettings",
        modelProperties: {
            fixedScale: {
                serializedName: "fixedScale",
                type: {
                    name: "Composite",
                    className: "FixedScaleSettings"
                }
            },
            autoScale: {
                serializedName: "autoScale",
                type: {
                    name: "Composite",
                    className: "AutoScaleSettings"
                }
            }
        }
    }
};
const FixedScaleSettings = {
    type: {
        name: "Composite",
        className: "FixedScaleSettings",
        modelProperties: {
            resizeTimeout: {
                defaultValue: "PT15M",
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            nodeDeallocationOption: {
                serializedName: "nodeDeallocationOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Requeue",
                        "Terminate",
                        "TaskCompletion",
                        "RetainedData"
                    ]
                }
            }
        }
    }
};
const AutoScaleSettings = {
    type: {
        name: "Composite",
        className: "AutoScaleSettings",
        modelProperties: {
            formula: {
                serializedName: "formula",
                required: true,
                type: {
                    name: "String"
                }
            },
            evaluationInterval: {
                serializedName: "evaluationInterval",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const AutoScaleRun = {
    type: {
        name: "Composite",
        className: "AutoScaleRun",
        modelProperties: {
            evaluationTime: {
                serializedName: "evaluationTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "AutoScaleRunError"
                }
            }
        }
    }
};
const AutoScaleRunError = {
    type: {
        name: "Composite",
        className: "AutoScaleRunError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutoScaleRunError"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkConfiguration",
        modelProperties: {
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            dynamicVnetAssignmentScope: {
                defaultValue: "none",
                serializedName: "dynamicVnetAssignmentScope",
                type: {
                    name: "Enum",
                    allowedValues: ["none", "job"]
                }
            },
            endpointConfiguration: {
                serializedName: "endpointConfiguration",
                type: {
                    name: "Composite",
                    className: "PoolEndpointConfiguration"
                }
            },
            publicIPAddressConfiguration: {
                serializedName: "publicIPAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressConfiguration"
                }
            },
            enableAcceleratedNetworking: {
                serializedName: "enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const PoolEndpointConfiguration = {
    type: {
        name: "Composite",
        className: "PoolEndpointConfiguration",
        modelProperties: {
            inboundNatPools: {
                serializedName: "inboundNatPools",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatPool"
                        }
                    }
                }
            }
        }
    }
};
const InboundNatPool = {
    type: {
        name: "Composite",
        className: "InboundNatPool",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["TCP", "UDP"]
                }
            },
            backendPort: {
                serializedName: "backendPort",
                required: true,
                type: {
                    name: "Number"
                }
            },
            frontendPortRangeStart: {
                serializedName: "frontendPortRangeStart",
                required: true,
                type: {
                    name: "Number"
                }
            },
            frontendPortRangeEnd: {
                serializedName: "frontendPortRangeEnd",
                required: true,
                type: {
                    name: "Number"
                }
            },
            networkSecurityGroupRules: {
                serializedName: "networkSecurityGroupRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityGroupRule"
                        }
                    }
                }
            }
        }
    }
};
const NetworkSecurityGroupRule = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupRule",
        modelProperties: {
            priority: {
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number"
                }
            },
            access: {
                serializedName: "access",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Allow", "Deny"]
                }
            },
            sourceAddressPrefix: {
                serializedName: "sourceAddressPrefix",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourcePortRanges: {
                serializedName: "sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PublicIPAddressConfiguration = {
    type: {
        name: "Composite",
        className: "PublicIPAddressConfiguration",
        modelProperties: {
            provision: {
                serializedName: "provision",
                type: {
                    name: "Enum",
                    allowedValues: ["BatchManaged", "UserManaged", "NoPublicIPAddresses"]
                }
            },
            ipAddressIds: {
                serializedName: "ipAddressIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const TaskSchedulingPolicy = {
    type: {
        name: "Composite",
        className: "TaskSchedulingPolicy",
        modelProperties: {
            nodeFillType: {
                defaultValue: "Spread",
                serializedName: "nodeFillType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Spread", "Pack"]
                }
            }
        }
    }
};
const UserAccount = {
    type: {
        name: "Composite",
        className: "UserAccount",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                required: true,
                type: {
                    name: "String"
                }
            },
            elevationLevel: {
                serializedName: "elevationLevel",
                type: {
                    name: "Enum",
                    allowedValues: ["NonAdmin", "Admin"]
                }
            },
            linuxUserConfiguration: {
                serializedName: "linuxUserConfiguration",
                type: {
                    name: "Composite",
                    className: "LinuxUserConfiguration"
                }
            },
            windowsUserConfiguration: {
                serializedName: "windowsUserConfiguration",
                type: {
                    name: "Composite",
                    className: "WindowsUserConfiguration"
                }
            }
        }
    }
};
const LinuxUserConfiguration = {
    type: {
        name: "Composite",
        className: "LinuxUserConfiguration",
        modelProperties: {
            uid: {
                serializedName: "uid",
                type: {
                    name: "Number"
                }
            },
            gid: {
                serializedName: "gid",
                type: {
                    name: "Number"
                }
            },
            sshPrivateKey: {
                serializedName: "sshPrivateKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WindowsUserConfiguration = {
    type: {
        name: "Composite",
        className: "WindowsUserConfiguration",
        modelProperties: {
            loginMode: {
                serializedName: "loginMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Batch", "Interactive"]
                }
            }
        }
    }
};
const MetadataItem = {
    type: {
        name: "Composite",
        className: "MetadataItem",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StartTask = {
    type: {
        name: "Composite",
        className: "StartTask",
        modelProperties: {
            commandLine: {
                serializedName: "commandLine",
                type: {
                    name: "String"
                }
            },
            resourceFiles: {
                serializedName: "resourceFiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceFile"
                        }
                    }
                }
            },
            environmentSettings: {
                serializedName: "environmentSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EnvironmentSetting"
                        }
                    }
                }
            },
            userIdentity: {
                serializedName: "userIdentity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            },
            maxTaskRetryCount: {
                defaultValue: 0,
                serializedName: "maxTaskRetryCount",
                type: {
                    name: "Number"
                }
            },
            waitForSuccess: {
                serializedName: "waitForSuccess",
                type: {
                    name: "Boolean"
                }
            },
            containerSettings: {
                serializedName: "containerSettings",
                type: {
                    name: "Composite",
                    className: "TaskContainerSettings"
                }
            }
        }
    }
};
const ResourceFile = {
    type: {
        name: "Composite",
        className: "ResourceFile",
        modelProperties: {
            autoStorageContainerName: {
                serializedName: "autoStorageContainerName",
                type: {
                    name: "String"
                }
            },
            storageContainerUrl: {
                serializedName: "storageContainerUrl",
                type: {
                    name: "String"
                }
            },
            httpUrl: {
                serializedName: "httpUrl",
                type: {
                    name: "String"
                }
            },
            blobPrefix: {
                serializedName: "blobPrefix",
                type: {
                    name: "String"
                }
            },
            filePath: {
                serializedName: "filePath",
                type: {
                    name: "String"
                }
            },
            fileMode: {
                serializedName: "fileMode",
                type: {
                    name: "String"
                }
            },
            identityReference: {
                serializedName: "identityReference",
                type: {
                    name: "Composite",
                    className: "ComputeNodeIdentityReference"
                }
            }
        }
    }
};
const EnvironmentSetting = {
    type: {
        name: "Composite",
        className: "EnvironmentSetting",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserIdentity = {
    type: {
        name: "Composite",
        className: "UserIdentity",
        modelProperties: {
            userName: {
                serializedName: "userName",
                type: {
                    name: "String"
                }
            },
            autoUser: {
                serializedName: "autoUser",
                type: {
                    name: "Composite",
                    className: "AutoUserSpecification"
                }
            }
        }
    }
};
const AutoUserSpecification = {
    type: {
        name: "Composite",
        className: "AutoUserSpecification",
        modelProperties: {
            scope: {
                serializedName: "scope",
                type: {
                    name: "Enum",
                    allowedValues: ["Task", "Pool"]
                }
            },
            elevationLevel: {
                serializedName: "elevationLevel",
                type: {
                    name: "Enum",
                    allowedValues: ["NonAdmin", "Admin"]
                }
            }
        }
    }
};
const TaskContainerSettings = {
    type: {
        name: "Composite",
        className: "TaskContainerSettings",
        modelProperties: {
            containerRunOptions: {
                serializedName: "containerRunOptions",
                type: {
                    name: "String"
                }
            },
            imageName: {
                serializedName: "imageName",
                required: true,
                type: {
                    name: "String"
                }
            },
            registry: {
                serializedName: "registry",
                type: {
                    name: "Composite",
                    className: "ContainerRegistry"
                }
            },
            workingDirectory: {
                serializedName: "workingDirectory",
                type: {
                    name: "Enum",
                    allowedValues: ["TaskWorkingDirectory", "ContainerImageDefault"]
                }
            }
        }
    }
};
const CertificateReference = {
    type: {
        name: "Composite",
        className: "CertificateReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            storeLocation: {
                serializedName: "storeLocation",
                type: {
                    name: "Enum",
                    allowedValues: ["CurrentUser", "LocalMachine"]
                }
            },
            storeName: {
                serializedName: "storeName",
                type: {
                    name: "String"
                }
            },
            visibility: {
                serializedName: "visibility",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["StartTask", "Task", "RemoteUser"]
                        }
                    }
                }
            }
        }
    }
};
const ApplicationPackageReference = {
    type: {
        name: "Composite",
        className: "ApplicationPackageReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResizeOperationStatus = {
    type: {
        name: "Composite",
        className: "ResizeOperationStatus",
        modelProperties: {
            targetDedicatedNodes: {
                serializedName: "targetDedicatedNodes",
                type: {
                    name: "Number"
                }
            },
            targetLowPriorityNodes: {
                serializedName: "targetLowPriorityNodes",
                type: {
                    name: "Number"
                }
            },
            resizeTimeout: {
                serializedName: "resizeTimeout",
                type: {
                    name: "TimeSpan"
                }
            },
            nodeDeallocationOption: {
                serializedName: "nodeDeallocationOption",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Requeue",
                        "Terminate",
                        "TaskCompletion",
                        "RetainedData"
                    ]
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResizeError"
                        }
                    }
                }
            }
        }
    }
};
const ResizeError = {
    type: {
        name: "Composite",
        className: "ResizeError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResizeError"
                        }
                    }
                }
            }
        }
    }
};
const MountConfiguration = {
    type: {
        name: "Composite",
        className: "MountConfiguration",
        modelProperties: {
            azureBlobFileSystemConfiguration: {
                serializedName: "azureBlobFileSystemConfiguration",
                type: {
                    name: "Composite",
                    className: "AzureBlobFileSystemConfiguration"
                }
            },
            nfsMountConfiguration: {
                serializedName: "nfsMountConfiguration",
                type: {
                    name: "Composite",
                    className: "NFSMountConfiguration"
                }
            },
            cifsMountConfiguration: {
                serializedName: "cifsMountConfiguration",
                type: {
                    name: "Composite",
                    className: "CifsMountConfiguration"
                }
            },
            azureFileShareConfiguration: {
                serializedName: "azureFileShareConfiguration",
                type: {
                    name: "Composite",
                    className: "AzureFileShareConfiguration"
                }
            }
        }
    }
};
const AzureBlobFileSystemConfiguration = {
    type: {
        name: "Composite",
        className: "AzureBlobFileSystemConfiguration",
        modelProperties: {
            accountName: {
                serializedName: "accountName",
                required: true,
                type: {
                    name: "String"
                }
            },
            containerName: {
                serializedName: "containerName",
                required: true,
                type: {
                    name: "String"
                }
            },
            accountKey: {
                serializedName: "accountKey",
                type: {
                    name: "String"
                }
            },
            sasKey: {
                serializedName: "sasKey",
                type: {
                    name: "String"
                }
            },
            blobfuseOptions: {
                serializedName: "blobfuseOptions",
                type: {
                    name: "String"
                }
            },
            relativeMountPath: {
                serializedName: "relativeMountPath",
                required: true,
                type: {
                    name: "String"
                }
            },
            identityReference: {
                serializedName: "identityReference",
                type: {
                    name: "Composite",
                    className: "ComputeNodeIdentityReference"
                }
            }
        }
    }
};
const NFSMountConfiguration = {
    type: {
        name: "Composite",
        className: "NFSMountConfiguration",
        modelProperties: {
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            relativeMountPath: {
                serializedName: "relativeMountPath",
                required: true,
                type: {
                    name: "String"
                }
            },
            mountOptions: {
                serializedName: "mountOptions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CifsMountConfiguration = {
    type: {
        name: "Composite",
        className: "CifsMountConfiguration",
        modelProperties: {
            userName: {
                serializedName: "userName",
                required: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            relativeMountPath: {
                serializedName: "relativeMountPath",
                required: true,
                type: {
                    name: "String"
                }
            },
            mountOptions: {
                serializedName: "mountOptions",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFileShareConfiguration = {
    type: {
        name: "Composite",
        className: "AzureFileShareConfiguration",
        modelProperties: {
            accountName: {
                serializedName: "accountName",
                required: true,
                type: {
                    name: "String"
                }
            },
            azureFileUrl: {
                serializedName: "azureFileUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            accountKey: {
                serializedName: "accountKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            relativeMountPath: {
                serializedName: "relativeMountPath",
                required: true,
                type: {
                    name: "String"
                }
            },
            mountOptions: {
                serializedName: "mountOptions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BatchPoolIdentity = {
    type: {
        name: "Composite",
        className: "BatchPoolIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["UserAssigned", "None"]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentities" }
                    }
                }
            }
        }
    }
};
const OutboundEnvironmentEndpointCollection = {
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpointCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpoint = {
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDependency = {
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDetail = {
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            port: {
                serializedName: "port",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoStorageProperties = {
    type: {
        name: "Composite",
        className: "AutoStorageProperties",
        modelProperties: Object.assign(Object.assign({}, AutoStorageBaseProperties.type.modelProperties), { lastKeySync: {
                serializedName: "lastKeySync",
                required: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Cancelled"
                    ]
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, groupIds: {
                serializedName: "properties.groupIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            } })
    }
};
const ApplicationPackage = {
    type: {
        name: "Composite",
        className: "ApplicationPackage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Pending", "Active"]
                }
            }, format: {
                serializedName: "properties.format",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageUrl: {
                serializedName: "properties.storageUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageUrlExpiry: {
                serializedName: "properties.storageUrlExpiry",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastActivationTime: {
                serializedName: "properties.lastActivationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const Application = {
    type: {
        name: "Composite",
        className: "Application",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, allowUpdates: {
                serializedName: "properties.allowUpdates",
                type: {
                    name: "Boolean"
                }
            }, defaultVersion: {
                serializedName: "properties.defaultVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const Certificate = {
    type: {
        name: "Composite",
        className: "Certificate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { thumbprintAlgorithm: {
                serializedName: "properties.thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, format: {
                serializedName: "properties.format",
                type: {
                    name: "Enum",
                    allowedValues: ["Pfx", "Cer"]
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Deleting", "Failed"]
                }
            }, provisioningStateTransitionTime: {
                serializedName: "properties.provisioningStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, previousProvisioningState: {
                serializedName: "properties.previousProvisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Deleting", "Failed"]
                }
            }, previousProvisioningStateTransitionTime: {
                serializedName: "properties.previousProvisioningStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, publicData: {
                serializedName: "properties.publicData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleteCertificateError: {
                serializedName: "properties.deleteCertificateError",
                type: {
                    name: "Composite",
                    className: "DeleteCertificateError"
                }
            } })
    }
};
const CertificateCreateOrUpdateParameters = {
    type: {
        name: "Composite",
        className: "CertificateCreateOrUpdateParameters",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { thumbprintAlgorithm: {
                serializedName: "properties.thumbprintAlgorithm",
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, format: {
                serializedName: "properties.format",
                type: {
                    name: "Enum",
                    allowedValues: ["Pfx", "Cer"]
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            } })
    }
};
const DetectorResponse = {
    type: {
        name: "Composite",
        className: "DetectorResponse",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { value: {
                serializedName: "properties.value",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Pool = {
    type: {
        name: "Composite",
        className: "Pool",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "BatchPoolIdentity"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, lastModified: {
                serializedName: "properties.lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, creationTime: {
                serializedName: "properties.creationTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Deleting"]
                }
            }, provisioningStateTransitionTime: {
                serializedName: "properties.provisioningStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, allocationState: {
                serializedName: "properties.allocationState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Steady", "Resizing", "Stopping"]
                }
            }, allocationStateTransitionTime: {
                serializedName: "properties.allocationStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, vmSize: {
                serializedName: "properties.vmSize",
                type: {
                    name: "String"
                }
            }, deploymentConfiguration: {
                serializedName: "properties.deploymentConfiguration",
                type: {
                    name: "Composite",
                    className: "DeploymentConfiguration"
                }
            }, currentDedicatedNodes: {
                serializedName: "properties.currentDedicatedNodes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, currentLowPriorityNodes: {
                serializedName: "properties.currentLowPriorityNodes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, scaleSettings: {
                serializedName: "properties.scaleSettings",
                type: {
                    name: "Composite",
                    className: "ScaleSettings"
                }
            }, autoScaleRun: {
                serializedName: "properties.autoScaleRun",
                type: {
                    name: "Composite",
                    className: "AutoScaleRun"
                }
            }, interNodeCommunication: {
                serializedName: "properties.interNodeCommunication",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, networkConfiguration: {
                serializedName: "properties.networkConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkConfiguration"
                }
            }, taskSlotsPerNode: {
                defaultValue: 1,
                serializedName: "properties.taskSlotsPerNode",
                type: {
                    name: "Number"
                }
            }, taskSchedulingPolicy: {
                serializedName: "properties.taskSchedulingPolicy",
                type: {
                    name: "Composite",
                    className: "TaskSchedulingPolicy"
                }
            }, userAccounts: {
                serializedName: "properties.userAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UserAccount"
                        }
                    }
                }
            }, metadata: {
                serializedName: "properties.metadata",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetadataItem"
                        }
                    }
                }
            }, startTask: {
                serializedName: "properties.startTask",
                type: {
                    name: "Composite",
                    className: "StartTask"
                }
            }, certificates: {
                serializedName: "properties.certificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CertificateReference"
                        }
                    }
                }
            }, applicationPackages: {
                serializedName: "properties.applicationPackages",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationPackageReference"
                        }
                    }
                }
            }, applicationLicenses: {
                serializedName: "properties.applicationLicenses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, resizeOperationStatus: {
                serializedName: "properties.resizeOperationStatus",
                type: {
                    name: "Composite",
                    className: "ResizeOperationStatus"
                }
            }, mountConfiguration: {
                serializedName: "properties.mountConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MountConfiguration"
                        }
                    }
                }
            }, targetNodeCommunicationMode: {
                serializedName: "properties.targetNodeCommunicationMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Default", "Classic", "Simplified"]
                }
            }, currentNodeCommunicationMode: {
                serializedName: "properties.currentNodeCommunicationMode",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Default", "Classic", "Simplified"]
                }
            }, resourceTags: {
                serializedName: "properties.resourceTags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const BatchAccount = {
    type: {
        name: "Composite",
        className: "BatchAccount",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "BatchAccountIdentity"
                }
            }, accountEndpoint: {
                serializedName: "properties.accountEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nodeManagementEndpoint: {
                serializedName: "properties.nodeManagementEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Invalid",
                        "Creating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Cancelled"
                    ]
                }
            }, poolAllocationMode: {
                serializedName: "properties.poolAllocationMode",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["BatchService", "UserSubscription"]
                }
            }, keyVaultReference: {
                serializedName: "properties.keyVaultReference",
                type: {
                    name: "Composite",
                    className: "KeyVaultReference"
                }
            }, publicNetworkAccess: {
                defaultValue: "Enabled",
                serializedName: "properties.publicNetworkAccess",
                nullable: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, autoStorage: {
                serializedName: "properties.autoStorage",
                type: {
                    name: "Composite",
                    className: "AutoStorageProperties"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperties"
                }
            }, dedicatedCoreQuota: {
                serializedName: "properties.dedicatedCoreQuota",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            }, lowPriorityCoreQuota: {
                serializedName: "properties.lowPriorityCoreQuota",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Number"
                }
            }, dedicatedCoreQuotaPerVMFamily: {
                serializedName: "properties.dedicatedCoreQuotaPerVMFamily",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineFamilyCoreQuota"
                        }
                    }
                }
            }, dedicatedCoreQuotaPerVMFamilyEnforced: {
                serializedName: "properties.dedicatedCoreQuotaPerVMFamilyEnforced",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, poolQuota: {
                serializedName: "properties.poolQuota",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, activeJobAndJobScheduleQuota: {
                serializedName: "properties.activeJobAndJobScheduleQuota",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, allowedAuthenticationModes: {
                serializedName: "properties.allowedAuthenticationModes",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["SharedKey", "AAD", "TaskAuthenticationToken"]
                        }
                    }
                }
            } })
    }
};
const CertificateProperties = {
    type: {
        name: "Composite",
        className: "CertificateProperties",
        modelProperties: Object.assign(Object.assign({}, CertificateBaseProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Deleting", "Failed"]
                }
            }, provisioningStateTransitionTime: {
                serializedName: "provisioningStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, previousProvisioningState: {
                serializedName: "previousProvisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Succeeded", "Deleting", "Failed"]
                }
            }, previousProvisioningStateTransitionTime: {
                serializedName: "previousProvisioningStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, publicData: {
                serializedName: "publicData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleteCertificateError: {
                serializedName: "deleteCertificateError",
                type: {
                    name: "Composite",
                    className: "DeleteCertificateError"
                }
            } })
    }
};
const CertificateCreateOrUpdateProperties = {
    type: {
        name: "Composite",
        className: "CertificateCreateOrUpdateProperties",
        modelProperties: Object.assign(Object.assign({}, CertificateBaseProperties.type.modelProperties), { data: {
                serializedName: "data",
                required: true,
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            } })
    }
};
const BatchAccountCreateHeaders = {
    type: {
        name: "Composite",
        className: "BatchAccountCreateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BatchAccountDeleteHeaders = {
    type: {
        name: "Composite",
        className: "BatchAccountDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CertificateCreateHeaders = {
    type: {
        name: "Composite",
        className: "CertificateCreateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateUpdateHeaders = {
    type: {
        name: "Composite",
        className: "CertificateUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateDeleteHeaders = {
    type: {
        name: "Composite",
        className: "CertificateDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CertificateGetHeaders = {
    type: {
        name: "Composite",
        className: "CertificateGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateCancelDeletionHeaders = {
    type: {
        name: "Composite",
        className: "CertificateCancelDeletionHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionUpdateHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionUpdateHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PrivateEndpointConnectionDeleteHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PoolCreateHeaders = {
    type: {
        name: "Composite",
        className: "PoolCreateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PoolUpdateHeaders = {
    type: {
        name: "Composite",
        className: "PoolUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PoolDeleteHeaders = {
    type: {
        name: "Composite",
        className: "PoolDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PoolGetHeaders = {
    type: {
        name: "Composite",
        className: "PoolGetHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PoolDisableAutoScaleHeaders = {
    type: {
        name: "Composite",
        className: "PoolDisableAutoScaleHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PoolStopResizeHeaders = {
    type: {
        name: "Composite",
        className: "PoolStopResizeHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ActivateApplicationPackageParameters: ActivateApplicationPackageParameters,
    Application: Application,
    ApplicationPackage: ApplicationPackage,
    ApplicationPackageReference: ApplicationPackageReference,
    AutoScaleRun: AutoScaleRun,
    AutoScaleRunError: AutoScaleRunError,
    AutoScaleSettings: AutoScaleSettings,
    AutoStorageBaseProperties: AutoStorageBaseProperties,
    AutoStorageProperties: AutoStorageProperties,
    AutoUserSpecification: AutoUserSpecification,
    AzureBlobFileSystemConfiguration: AzureBlobFileSystemConfiguration,
    AzureFileShareConfiguration: AzureFileShareConfiguration,
    BatchAccount: BatchAccount,
    BatchAccountCreateHeaders: BatchAccountCreateHeaders,
    BatchAccountCreateParameters: BatchAccountCreateParameters,
    BatchAccountDeleteHeaders: BatchAccountDeleteHeaders,
    BatchAccountIdentity: BatchAccountIdentity,
    BatchAccountKeys: BatchAccountKeys,
    BatchAccountListResult: BatchAccountListResult,
    BatchAccountRegenerateKeyParameters: BatchAccountRegenerateKeyParameters,
    BatchAccountUpdateParameters: BatchAccountUpdateParameters,
    BatchLocationQuota: BatchLocationQuota,
    BatchPoolIdentity: BatchPoolIdentity,
    Certificate: Certificate,
    CertificateBaseProperties: CertificateBaseProperties,
    CertificateCancelDeletionHeaders: CertificateCancelDeletionHeaders,
    CertificateCreateHeaders: CertificateCreateHeaders,
    CertificateCreateOrUpdateParameters: CertificateCreateOrUpdateParameters,
    CertificateCreateOrUpdateProperties: CertificateCreateOrUpdateProperties,
    CertificateDeleteHeaders: CertificateDeleteHeaders,
    CertificateGetHeaders: CertificateGetHeaders,
    CertificateProperties: CertificateProperties,
    CertificateReference: CertificateReference,
    CertificateUpdateHeaders: CertificateUpdateHeaders,
    CheckNameAvailabilityParameters: CheckNameAvailabilityParameters,
    CheckNameAvailabilityResult: CheckNameAvailabilityResult,
    CifsMountConfiguration: CifsMountConfiguration,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    CloudServiceConfiguration: CloudServiceConfiguration,
    ComputeNodeIdentityReference: ComputeNodeIdentityReference,
    ContainerConfiguration: ContainerConfiguration,
    ContainerRegistry: ContainerRegistry,
    DataDisk: DataDisk,
    DeleteCertificateError: DeleteCertificateError,
    DeploymentConfiguration: DeploymentConfiguration,
    DetectorListResult: DetectorListResult,
    DetectorResponse: DetectorResponse,
    DiffDiskSettings: DiffDiskSettings,
    DiskEncryptionConfiguration: DiskEncryptionConfiguration,
    EncryptionProperties: EncryptionProperties,
    EndpointAccessProfile: EndpointAccessProfile,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    EnvironmentSetting: EnvironmentSetting,
    FixedScaleSettings: FixedScaleSettings,
    IPRule: IPRule,
    ImageReference: ImageReference,
    InboundNatPool: InboundNatPool,
    KeyVaultProperties: KeyVaultProperties,
    KeyVaultReference: KeyVaultReference,
    LinuxUserConfiguration: LinuxUserConfiguration,
    ListApplicationPackagesResult: ListApplicationPackagesResult,
    ListApplicationsResult: ListApplicationsResult,
    ListCertificatesResult: ListCertificatesResult,
    ListPoolsResult: ListPoolsResult,
    ListPrivateEndpointConnectionsResult: ListPrivateEndpointConnectionsResult,
    ListPrivateLinkResourcesResult: ListPrivateLinkResourcesResult,
    ManagedDisk: ManagedDisk,
    MetadataItem: MetadataItem,
    MountConfiguration: MountConfiguration,
    NFSMountConfiguration: NFSMountConfiguration,
    NetworkConfiguration: NetworkConfiguration,
    NetworkProfile: NetworkProfile,
    NetworkSecurityGroupRule: NetworkSecurityGroupRule,
    NodePlacementConfiguration: NodePlacementConfiguration,
    OSDisk: OSDisk,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationListResult: OperationListResult,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    OutboundEnvironmentEndpointCollection: OutboundEnvironmentEndpointCollection,
    Pool: Pool,
    PoolCreateHeaders: PoolCreateHeaders,
    PoolDeleteHeaders: PoolDeleteHeaders,
    PoolDisableAutoScaleHeaders: PoolDisableAutoScaleHeaders,
    PoolEndpointConfiguration: PoolEndpointConfiguration,
    PoolGetHeaders: PoolGetHeaders,
    PoolStopResizeHeaders: PoolStopResizeHeaders,
    PoolUpdateHeaders: PoolUpdateHeaders,
    PrivateEndpoint: PrivateEndpoint,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpointConnectionDeleteHeaders: PrivateEndpointConnectionDeleteHeaders,
    PrivateEndpointConnectionUpdateHeaders: PrivateEndpointConnectionUpdateHeaders,
    PrivateLinkResource: PrivateLinkResource,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    ProxyResource: ProxyResource,
    PublicIPAddressConfiguration: PublicIPAddressConfiguration,
    ResizeError: ResizeError,
    ResizeOperationStatus: ResizeOperationStatus,
    Resource: Resource,
    ResourceFile: ResourceFile,
    ScaleSettings: ScaleSettings,
    SecurityProfile: SecurityProfile,
    ServiceArtifactReference: ServiceArtifactReference,
    SkuCapability: SkuCapability,
    StartTask: StartTask,
    SupportedSku: SupportedSku,
    SupportedSkusResult: SupportedSkusResult,
    TaskContainerSettings: TaskContainerSettings,
    TaskSchedulingPolicy: TaskSchedulingPolicy,
    UefiSettings: UefiSettings,
    UserAccount: UserAccount,
    UserAssignedIdentities: UserAssignedIdentities,
    UserIdentity: UserIdentity,
    VMExtension: VMExtension,
    VirtualMachineConfiguration: VirtualMachineConfiguration,
    VirtualMachineFamilyCoreQuota: VirtualMachineFamilyCoreQuota,
    WindowsConfiguration: WindowsConfiguration,
    WindowsUserConfiguration: WindowsUserConfiguration
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: BatchAccountCreateParameters
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accountName = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-z0-9]+$"),
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-11-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: BatchAccountUpdateParameters
};
const accountName1 = {
    parameterPath: "accountName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]+$"),
            MaxLength: 24,
            MinLength: 3
        },
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: BatchAccountRegenerateKeyParameters
};
const detectorId = {
    parameterPath: "detectorId",
    mapper: {
        serializedName: "detectorId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ActivateApplicationPackageParameters
};
const applicationName = {
    parameterPath: "applicationName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_-]+$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "applicationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const versionName = {
    parameterPath: "versionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_-][a-zA-Z0-9_.-]*$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "versionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: ["options", "parameters"],
    mapper: ApplicationPackage
};
const maxresults = {
    parameterPath: ["options", "maxresults"],
    mapper: {
        serializedName: "maxresults",
        type: {
            name: "Number"
        }
    }
};
const parameters5 = {
    parameterPath: ["options", "parameters"],
    mapper: Application
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: Application
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: CheckNameAvailabilityParameters
};
const select = {
    parameterPath: ["options", "select"],
    mapper: {
        serializedName: "$select",
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: CertificateCreateOrUpdateParameters
};
const certificateName = {
    parameterPath: "certificateName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[\\w]+-[\\w]+$"),
            MaxLength: 45,
            MinLength: 5
        },
        serializedName: "certificateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: ["options", "ifNoneMatch"],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const privateLinkResourceName = {
    parameterPath: "privateLinkResourceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_-]+\\.?[a-fA-F0-9-]*$"),
            MaxLength: 101,
            MinLength: 1
        },
        serializedName: "privateLinkResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_-]+\\.?[a-fA-F0-9-]*$"),
            MaxLength: 101,
            MinLength: 1
        },
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: Pool
};
const poolName = {
    parameterPath: "poolName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9_-]+$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "poolName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BatchAccountOperations operations. */
class BatchAccountOperationsImpl {
    /**
     * Initialize a new instance of the class BatchAccountOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about the Batch accounts associated with the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets information about the Batch accounts associated with the specified resource group.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets information about the detectors available for a given Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listDetectors(resourceGroupName, accountName, options) {
        const iter = this.listDetectorsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDetectorsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listDetectorsPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDetectorsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDetectors(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDetectorsNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDetectorsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDetectorsPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDetectorsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Lists the endpoints that a Batch Compute Node under this Batch Account may call as part of Batch
     * service administration. If you are deploying a Pool inside of a virtual network that you specify,
     * you must make sure your network allows outbound access to these endpoints. Failure to allow access
     * to these endpoints may cause Batch to mark the affected nodes as unusable. For more information
     * about creating a pool inside of a virtual network, see
     * https://docs.microsoft.com/azure/batch/batch-virtual-network.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, accountName, options) {
        const iter = this.listOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listOutboundNetworkDependenciesEndpointsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listOutboundNetworkDependenciesEndpoints(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listOutboundNetworkDependenciesEndpointsNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listOutboundNetworkDependenciesEndpointsPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listOutboundNetworkDependenciesEndpointsPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listOutboundNetworkDependenciesEndpointsPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a new Batch account with the specified parameters. Existing accounts cannot be updated with
     * this API and should instead be updated with the Update Batch Account API.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName A name for the Batch account which must be unique within the region. Batch
     *                    account names must be between 3 and 24 characters in length and must use only numbers and lowercase
     *                    letters. This name is used as part of the DNS name that is used to access the Batch service in the
     *                    region in which the account is created. For example: http://accountname.region.batch.azure.com/.
     * @param parameters Additional parameters for account creation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, parameters, options },
                spec: createOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new Batch account with the specified parameters. Existing accounts cannot be updated with
     * this API and should instead be updated with the Update Batch Account API.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName A name for the Batch account which must be unique within the region. Batch
     *                    account names must be between 3 and 24 characters in length and must use only numbers and lowercase
     *                    letters. This name is used as part of the DNS name that is used to access the Batch service in the
     *                    region in which the account is created. For example: http://accountname.region.batch.azure.com/.
     * @param parameters Additional parameters for account creation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the properties of an existing Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param parameters Additional parameters for account update.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, updateOperationSpec$4);
    }
    /**
     * Deletes the specified Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, options },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getOperationSpec$6);
    }
    /**
     * Gets information about the Batch accounts associated with the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * Gets information about the Batch accounts associated with the specified resource group.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Synchronizes access keys for the auto-storage account configured for the specified Batch account,
     * only if storage key authentication is being used.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    synchronizeAutoStorageKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, synchronizeAutoStorageKeysOperationSpec);
    }
    /**
     * This operation applies only to Batch accounts with allowedAuthenticationModes containing
     * 'SharedKey'. If the Batch account doesn't contain 'SharedKey' in its allowedAuthenticationMode,
     * clients cannot use shared keys to authenticate, and must use another allowedAuthenticationModes
     * instead. In this case, regenerating the keys will fail.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param parameters The type of key to regenerate.
     * @param options The options parameters.
     */
    regenerateKey(resourceGroupName, accountName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, parameters, options }, regenerateKeyOperationSpec);
    }
    /**
     * This operation applies only to Batch accounts with allowedAuthenticationModes containing
     * 'SharedKey'. If the Batch account doesn't contain 'SharedKey' in its allowedAuthenticationMode,
     * clients cannot use shared keys to authenticate, and must use another allowedAuthenticationModes
     * instead. In this case, getting the keys will fail.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    getKeys(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getKeysOperationSpec);
    }
    /**
     * Gets information about the detectors available for a given Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listDetectors(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listDetectorsOperationSpec);
    }
    /**
     * Gets information about the given detector for a given Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param detectorId The name of the detector.
     * @param options The options parameters.
     */
    getDetector(resourceGroupName, accountName, detectorId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, detectorId, options }, getDetectorOperationSpec);
    }
    /**
     * Lists the endpoints that a Batch Compute Node under this Batch Account may call as part of Batch
     * service administration. If you are deploying a Pool inside of a virtual network that you specify,
     * you must make sure your network allows outbound access to these endpoints. Failure to allow access
     * to these endpoints may cause Batch to mark the affected nodes as unusable. For more information
     * about creating a pool inside of a virtual network, see
     * https://docs.microsoft.com/azure/batch/batch-virtual-network.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listOutboundNetworkDependenciesEndpoints(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListDetectorsNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListDetectors method.
     * @param options The options parameters.
     */
    _listDetectorsNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listDetectorsNextOperationSpec);
    }
    /**
     * ListOutboundNetworkDependenciesEndpointsNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListOutboundNetworkDependenciesEndpoints method.
     * @param options The options parameters.
     */
    _listOutboundNetworkDependenciesEndpointsNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listOutboundNetworkDependenciesEndpointsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BatchAccount
        },
        201: {
            bodyMapper: BatchAccount
        },
        202: {
            bodyMapper: BatchAccount
        },
        204: {
            bodyMapper: BatchAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        accountName,
        subscriptionId
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BatchAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchAccount
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Batch/batchAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchAccountListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchAccountListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const synchronizeAutoStorageKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/syncAutoStorageKeys",
    httpMethod: "POST",
    responses: {
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const regenerateKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/regenerateKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BatchAccountKeys
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const getKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BatchAccountKeys
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listDetectorsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/detectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getDetectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/detectors/{detectorId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        detectorId
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchAccountListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchAccountListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listDetectorsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectorListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listOutboundNetworkDependenciesEndpointsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundEnvironmentEndpointCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationPackageOperations operations. */
class ApplicationPackageOperationsImpl {
    /**
     * Initialize a new instance of the class ApplicationPackageOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the application packages in the specified application.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, applicationName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, applicationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, applicationName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, applicationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, applicationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, applicationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, applicationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, applicationName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Activates the specified application package. This should be done after the `ApplicationPackage` was
     * created and uploaded. This needs to be done before an `ApplicationPackage` can be used on Pools or
     * Tasks.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param versionName The version of the application.
     * @param parameters The parameters for the request.
     * @param options The options parameters.
     */
    activate(resourceGroupName, accountName, applicationName, versionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            applicationName,
            versionName,
            parameters,
            options
        }, activateOperationSpec);
    }
    /**
     * Creates an application package record. The record contains a storageUrl where the package should be
     * uploaded to.  Once it is uploaded the `ApplicationPackage` needs to be activated using
     * `ApplicationPackageActive` before it can be used. If the auto storage account was configured to use
     * storage keys, the URL returned will contain a SAS.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param versionName The version of the application.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, applicationName, versionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, versionName, options }, createOperationSpec$3);
    }
    /**
     * Deletes an application package record and its associated binary file.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param versionName The version of the application.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, applicationName, versionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, versionName, options }, deleteOperationSpec$4);
    }
    /**
     * Gets information about the specified application package.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param versionName The version of the application.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, applicationName, versionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, versionName, options }, getOperationSpec$5);
    }
    /**
     * Lists all of the application packages in the specified application.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, applicationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const activateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}/versions/{versionName}/activate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicationPackage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName,
        versionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const createOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}/versions/{versionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationPackage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName,
        versionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}/versions/{versionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName,
        versionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}/versions/{versionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationPackage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName,
        versionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListApplicationPackagesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, maxresults],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListApplicationPackagesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationOperations operations. */
class ApplicationOperationsImpl {
    /**
     * Initialize a new instance of the class ApplicationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the applications in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Adds an application to the specified Batch account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, options }, createOperationSpec$2);
    }
    /**
     * Deletes an application.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, options }, deleteOperationSpec$3);
    }
    /**
     * Gets information about the specified application.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, options }, getOperationSpec$4);
    }
    /**
     * Updates settings for the specified application.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param applicationName The name of the application. This must be unique within the account.
     * @param parameters The parameters for the request.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, applicationName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, applicationName, parameters, options }, updateOperationSpec$3);
    }
    /**
     * Lists all of the applications in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Application
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Application
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications/{applicationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Application
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        applicationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/applications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListApplicationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, maxresults],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListApplicationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Location operations. */
class LocationImpl {
    /**
     * Initialize a new instance of the class Location class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of Batch supported Virtual Machine VM sizes available at the given location.
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param options The options parameters.
     */
    listSupportedVirtualMachineSkus(locationName, options) {
        const iter = this.listSupportedVirtualMachineSkusPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSupportedVirtualMachineSkusPagingPage(locationName, options, settings);
            }
        };
    }
    listSupportedVirtualMachineSkusPagingPage(locationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedVirtualMachineSkusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSupportedVirtualMachineSkus(locationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSupportedVirtualMachineSkusNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSupportedVirtualMachineSkusPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedVirtualMachineSkusPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSupportedVirtualMachineSkusPagingPage(locationName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of Batch supported Cloud Service VM sizes available at the given location.
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param options The options parameters.
     */
    listSupportedCloudServiceSkus(locationName, options) {
        const iter = this.listSupportedCloudServiceSkusPagingAll(locationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSupportedCloudServiceSkusPagingPage(locationName, options, settings);
            }
        };
    }
    listSupportedCloudServiceSkusPagingPage(locationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedCloudServiceSkusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSupportedCloudServiceSkus(locationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSupportedCloudServiceSkusNext(locationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSupportedCloudServiceSkusPagingAll(locationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSupportedCloudServiceSkusPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSupportedCloudServiceSkusPagingPage(locationName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the Batch service quotas for the specified subscription at the given location.
     * @param locationName The region for which to retrieve Batch service quotas.
     * @param options The options parameters.
     */
    getQuotas(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, getQuotasOperationSpec);
    }
    /**
     * Gets the list of Batch supported Virtual Machine VM sizes available at the given location.
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param options The options parameters.
     */
    _listSupportedVirtualMachineSkus(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listSupportedVirtualMachineSkusOperationSpec);
    }
    /**
     * Gets the list of Batch supported Cloud Service VM sizes available at the given location.
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param options The options parameters.
     */
    _listSupportedCloudServiceSkus(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, listSupportedCloudServiceSkusOperationSpec);
    }
    /**
     * Checks whether the Batch account name is available in the specified region.
     * @param locationName The desired region for the name check.
     * @param parameters Properties needed to check the availability of a name.
     * @param options The options parameters.
     */
    checkNameAvailability(locationName, parameters, options) {
        return this.client.sendOperationRequest({ locationName, parameters, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListSupportedVirtualMachineSkusNext
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListSupportedVirtualMachineSkus method.
     * @param options The options parameters.
     */
    _listSupportedVirtualMachineSkusNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listSupportedVirtualMachineSkusNextOperationSpec);
    }
    /**
     * ListSupportedCloudServiceSkusNext
     * @param locationName The region for which to retrieve Batch service supported SKUs.
     * @param nextLink The nextLink from the previous successful call to the ListSupportedCloudServiceSkus
     *                 method.
     * @param options The options parameters.
     */
    _listSupportedCloudServiceSkusNext(locationName, nextLink, options) {
        return this.client.sendOperationRequest({ locationName, nextLink, options }, listSupportedCloudServiceSkusNextOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getQuotasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/quotas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BatchLocationQuota
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listSupportedVirtualMachineSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/virtualMachineSkus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SupportedSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        maxresults,
        filter
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listSupportedCloudServiceSkusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/cloudServiceSkus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SupportedSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        maxresults,
        filter
    ],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Batch/locations/{locationName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$5
};
const listSupportedVirtualMachineSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SupportedSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listSupportedCloudServiceSkusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SupportedSkusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists available operations for the Microsoft.Batch provider
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists available operations for the Microsoft.Batch provider
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.Batch/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CertificateOperations operations. */
class CertificateOperationsImpl {
    /**
     * Initialize a new instance of the class CertificateOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listByBatchAccount(resourceGroupName, accountName, options) {
        const iter = this.listByBatchAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBatchAccount(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBatchAccountNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBatchAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBatchAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listByBatchAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByBatchAccountOperationSpec$3);
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param parameters Additional parameters for certificate creation.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, certificateName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, certificateName, parameters, options }, createOperationSpec$1);
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param parameters Certificate entity to update.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, certificateName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, certificateName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, certificateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, certificateName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, certificateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, certificateName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, certificateName, options }, getOperationSpec$3);
    }
    /**
     * If you try to delete a certificate that is being used by a pool or compute node, the status of the
     * certificate changes to deleteFailed. If you decide that you want to continue using the certificate,
     * you can use this operation to set the status of the certificate back to active. If you intend to
     * delete the certificate, you do not need to run this operation after the deletion failed. You must
     * make sure that the certificate is not being used by any resources, and then you can try again to
     * delete the certificate.
     *
     * Warning: This operation is deprecated and will be removed after February, 2024. Please use the
     * [Azure KeyVault
     * Extension](https://learn.microsoft.com/azure/batch/batch-certificate-migration-guide) instead.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param certificateName The identifier for the certificate. This must be made up of algorithm and
     *                        thumbprint separated by a dash, and must match the certificate data in the request. For example
     *                        SHA1-a3d1c5.
     * @param options The options parameters.
     */
    cancelDeletion(resourceGroupName, accountName, certificateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, certificateName, options }, cancelDeletionOperationSpec);
    }
    /**
     * ListByBatchAccountNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListByBatchAccount method.
     * @param options The options parameters.
     */
    _listByBatchAccountNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listByBatchAccountNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByBatchAccountOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListCertificatesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        maxresults,
        filter,
        select
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates/{certificateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Certificate,
            headersMapper: CertificateCreateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        certificateName
    ],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates/{certificateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Certificate,
            headersMapper: CertificateUpdateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        certificateName
    ],
    headerParameters: [
        contentType,
        accept,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates/{certificateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates/{certificateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Certificate,
            headersMapper: CertificateGetHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const cancelDeletionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/certificates/{certificateName}/cancelDelete",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Certificate,
            headersMapper: CertificateCancelDeletionHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        certificateName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByBatchAccountNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListCertificatesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResourceOperations operations. */
class PrivateLinkResourceOperationsImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResourceOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the private link resources in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listByBatchAccount(resourceGroupName, accountName, options) {
        const iter = this.listByBatchAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBatchAccount(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBatchAccountNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBatchAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBatchAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the private link resources in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listByBatchAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByBatchAccountOperationSpec$2);
    }
    /**
     * Gets information about the specified private link resource.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateLinkResourceName The private link resource name. This must be unique within the
     *                                account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, privateLinkResourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, privateLinkResourceName, options }, getOperationSpec$2);
    }
    /**
     * ListByBatchAccountNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListByBatchAccount method.
     * @param options The options parameters.
     */
    _listByBatchAccountNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listByBatchAccountNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByBatchAccountOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPrivateLinkResourcesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, maxresults],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateLinkResources/{privateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        privateLinkResourceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByBatchAccountNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPrivateLinkResourcesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnectionOperations operations. */
class PrivateEndpointConnectionOperationsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnectionOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the private endpoint connections in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listByBatchAccount(resourceGroupName, accountName, options) {
        const iter = this.listByBatchAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBatchAccount(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBatchAccountNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBatchAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBatchAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the private endpoint connections in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listByBatchAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByBatchAccountOperationSpec$1);
    }
    /**
     * Gets information about the specified private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateEndpointConnectionName The private endpoint connection name. This must be unique
     *                                      within the account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Updates the properties of an existing private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateEndpointConnectionName The private endpoint connection name. This must be unique
     *                                      within the account.
     * @param parameters PrivateEndpointConnection properties that should be updated. Properties that are
     *                   supplied will be updated, any property not supplied will be unchanged.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    privateEndpointConnectionName,
                    parameters,
                    options
                },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the properties of an existing private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateEndpointConnectionName The private endpoint connection name. This must be unique
     *                                      within the account.
     * @param parameters PrivateEndpointConnection properties that should be updated. Properties that are
     *                   supplied will be updated, any property not supplied will be unchanged.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateEndpointConnectionName The private endpoint connection name. This must be unique
     *                                      within the account.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    accountName,
                    privateEndpointConnectionName,
                    options
                },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private endpoint connection.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param privateEndpointConnectionName The private endpoint connection name. This must be unique
     *                                      within the account.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByBatchAccountNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListByBatchAccount method.
     * @param options The options parameters.
     */
    _listByBatchAccountNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listByBatchAccountNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByBatchAccountOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPrivateEndpointConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, maxresults],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [
        contentType,
        accept,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: PrivateEndpointConnectionDeleteHeaders
        },
        201: {
            headersMapper: PrivateEndpointConnectionDeleteHeaders
        },
        202: {
            headersMapper: PrivateEndpointConnectionDeleteHeaders
        },
        204: {
            headersMapper: PrivateEndpointConnectionDeleteHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByBatchAccountNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPrivateEndpointConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PoolOperations operations. */
class PoolOperationsImpl {
    /**
     * Initialize a new instance of the class PoolOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the pools in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    listByBatchAccount(resourceGroupName, accountName, options) {
        const iter = this.listByBatchAccountPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings);
            }
        };
    }
    listByBatchAccountPagingPage(resourceGroupName, accountName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByBatchAccount(resourceGroupName, accountName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByBatchAccountNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByBatchAccountPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByBatchAccountPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByBatchAccountPagingPage(resourceGroupName, accountName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the pools in the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param options The options parameters.
     */
    _listByBatchAccount(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listByBatchAccountOperationSpec);
    }
    /**
     * Creates a new pool inside the specified account.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param parameters Additional parameters for pool creation.
     * @param options The options parameters.
     */
    create(resourceGroupName, accountName, poolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, parameters, options }, createOperationSpec);
    }
    /**
     * Updates the properties of an existing pool.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param parameters Pool properties that should be updated. Properties that are supplied will be
     *                   updated, any property not supplied will be unchanged.
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, poolName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, parameters, options }, updateOperationSpec);
    }
    /**
     * Deletes the specified pool.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, accountName, poolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, accountName, poolName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified pool.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, accountName, poolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, accountName, poolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified pool.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, poolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, options }, getOperationSpec);
    }
    /**
     * Disables automatic scaling for a pool.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param options The options parameters.
     */
    disableAutoScale(resourceGroupName, accountName, poolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, options }, disableAutoScaleOperationSpec);
    }
    /**
     * This does not restore the pool to its previous state before the resize operation: it only stops any
     * further changes being made, and the pool maintains its current state. After stopping, the pool
     * stabilizes at the number of nodes it was at when the stop operation was done. During the stop
     * operation, the pool allocation state changes first to stopping and then to steady. A resize
     * operation need not be an explicit resize pool request; this API can also be used to halt the initial
     * sizing of the pool when it is created.
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param poolName The pool name. This must be unique within the account.
     * @param options The options parameters.
     */
    stopResize(resourceGroupName, accountName, poolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, poolName, options }, stopResizeOperationSpec);
    }
    /**
     * ListByBatchAccountNext
     * @param resourceGroupName The name of the resource group that contains the Batch account.
     * @param accountName The name of the Batch account.
     * @param nextLink The nextLink from the previous successful call to the ListByBatchAccount method.
     * @param options The options parameters.
     */
    _listByBatchAccountNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listByBatchAccountNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByBatchAccountOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPoolsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        maxresults,
        filter,
        select
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1
    ],
    headerParameters: [accept],
    serializer
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Pool,
            headersMapper: PoolCreateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [
        contentType,
        accept,
        ifMatch,
        ifNoneMatch
    ],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Pool,
            headersMapper: PoolUpdateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [
        contentType,
        accept,
        ifMatch
    ],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Pool,
            headersMapper: PoolGetHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [accept],
    serializer
};
const disableAutoScaleOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}/disableAutoScale",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Pool,
            headersMapper: PoolDisableAutoScaleHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [accept],
    serializer
};
const stopResizeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Batch/batchAccounts/{accountName}/pools/{poolName}/stopResize",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Pool,
            headersMapper: PoolStopResizeHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        poolName
    ],
    headerParameters: [accept],
    serializer
};
const listByBatchAccountNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListPoolsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        accountName1,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class BatchManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the BatchManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The Azure subscription ID. This is a GUID-formatted string (e.g.
     *                       00000000-0000-0000-0000-000000000000)
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-batch/9.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-11-01";
        this.batchAccountOperations = new BatchAccountOperationsImpl(this);
        this.applicationPackageOperations = new ApplicationPackageOperationsImpl(this);
        this.applicationOperations = new ApplicationOperationsImpl(this);
        this.location = new LocationImpl(this);
        this.operations = new OperationsImpl(this);
        this.certificateOperations = new CertificateOperationsImpl(this);
        this.privateLinkResourceOperations = new PrivateLinkResourceOperationsImpl(this);
        this.privateEndpointConnectionOperations = new PrivateEndpointConnectionOperationsImpl(this);
        this.poolOperations = new PoolOperationsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.BatchManagementClient = BatchManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
