'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    KnownProvisioningState["Unknown"] = "Unknown";
    KnownProvisioningState["Updating"] = "Updating";
    KnownProvisioningState["Creating"] = "Creating";
    KnownProvisioningState["Deleting"] = "Deleting";
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link EncryptionStatus} that the service accepts. */
exports.KnownEncryptionStatus = void 0;
(function (KnownEncryptionStatus) {
    KnownEncryptionStatus["Enabled"] = "Enabled";
    KnownEncryptionStatus["Disabled"] = "Disabled";
})(exports.KnownEncryptionStatus || (exports.KnownEncryptionStatus = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateEndpointServiceConnectionStatus = void 0;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
    KnownPrivateEndpointServiceConnectionStatus["Disconnected"] = "Disconnected";
    KnownPrivateEndpointServiceConnectionStatus["Timeout"] = "Timeout";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DiagnoseResultLevel} that the service accepts. */
exports.KnownDiagnoseResultLevel = void 0;
(function (KnownDiagnoseResultLevel) {
    KnownDiagnoseResultLevel["Warning"] = "Warning";
    KnownDiagnoseResultLevel["Error"] = "Error";
    KnownDiagnoseResultLevel["Information"] = "Information";
})(exports.KnownDiagnoseResultLevel || (exports.KnownDiagnoseResultLevel = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
exports.KnownUsageUnit = void 0;
(function (KnownUsageUnit) {
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));
/** Known values of {@link BillingCurrency} that the service accepts. */
exports.KnownBillingCurrency = void 0;
(function (KnownBillingCurrency) {
    KnownBillingCurrency["USD"] = "USD";
})(exports.KnownBillingCurrency || (exports.KnownBillingCurrency = {}));
/** Known values of {@link UnitOfMeasure} that the service accepts. */
exports.KnownUnitOfMeasure = void 0;
(function (KnownUnitOfMeasure) {
    KnownUnitOfMeasure["OneHour"] = "OneHour";
})(exports.KnownUnitOfMeasure || (exports.KnownUnitOfMeasure = {}));
/** Known values of {@link VMPriceOSType} that the service accepts. */
exports.KnownVMPriceOSType = void 0;
(function (KnownVMPriceOSType) {
    KnownVMPriceOSType["Linux"] = "Linux";
    KnownVMPriceOSType["Windows"] = "Windows";
})(exports.KnownVMPriceOSType || (exports.KnownVMPriceOSType = {}));
/** Known values of {@link VMTier} that the service accepts. */
exports.KnownVMTier = void 0;
(function (KnownVMTier) {
    KnownVMTier["Standard"] = "Standard";
    KnownVMTier["LowPriority"] = "LowPriority";
    KnownVMTier["Spot"] = "Spot";
})(exports.KnownVMTier || (exports.KnownVMTier = {}));
/** Known values of {@link QuotaUnit} that the service accepts. */
exports.KnownQuotaUnit = void 0;
(function (KnownQuotaUnit) {
    KnownQuotaUnit["Count"] = "Count";
})(exports.KnownQuotaUnit || (exports.KnownQuotaUnit = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    KnownStatus["Undefined"] = "Undefined";
    KnownStatus["Success"] = "Success";
    KnownStatus["Failure"] = "Failure";
    KnownStatus["InvalidQuotaBelowClusterMinimum"] = "InvalidQuotaBelowClusterMinimum";
    KnownStatus["InvalidQuotaExceedsSubscriptionLimit"] = "InvalidQuotaExceedsSubscriptionLimit";
    KnownStatus["InvalidVMFamilyName"] = "InvalidVMFamilyName";
    KnownStatus["OperationNotSupportedForSku"] = "OperationNotSupportedForSku";
    KnownStatus["OperationNotEnabledForRegion"] = "OperationNotEnabledForRegion";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link ComputeType} that the service accepts. */
exports.KnownComputeType = void 0;
(function (KnownComputeType) {
    KnownComputeType["AKS"] = "AKS";
    KnownComputeType["Kubernetes"] = "Kubernetes";
    KnownComputeType["AmlCompute"] = "AmlCompute";
    KnownComputeType["ComputeInstance"] = "ComputeInstance";
    KnownComputeType["DataFactory"] = "DataFactory";
    KnownComputeType["VirtualMachine"] = "VirtualMachine";
    KnownComputeType["HDInsight"] = "HDInsight";
    KnownComputeType["Databricks"] = "Databricks";
    KnownComputeType["DataLakeAnalytics"] = "DataLakeAnalytics";
    KnownComputeType["SynapseSpark"] = "SynapseSpark";
})(exports.KnownComputeType || (exports.KnownComputeType = {}));
/** Known values of {@link UnderlyingResourceAction} that the service accepts. */
exports.KnownUnderlyingResourceAction = void 0;
(function (KnownUnderlyingResourceAction) {
    KnownUnderlyingResourceAction["Delete"] = "Delete";
    KnownUnderlyingResourceAction["Detach"] = "Detach";
})(exports.KnownUnderlyingResourceAction || (exports.KnownUnderlyingResourceAction = {}));
/** Known values of {@link NodeState} that the service accepts. */
exports.KnownNodeState = void 0;
(function (KnownNodeState) {
    KnownNodeState["Idle"] = "idle";
    KnownNodeState["Running"] = "running";
    KnownNodeState["Preparing"] = "preparing";
    KnownNodeState["Unusable"] = "unusable";
    KnownNodeState["Leaving"] = "leaving";
    KnownNodeState["Preempted"] = "preempted";
})(exports.KnownNodeState || (exports.KnownNodeState = {}));
/** Known values of {@link ValueFormat} that the service accepts. */
exports.KnownValueFormat = void 0;
(function (KnownValueFormat) {
    KnownValueFormat["Json"] = "JSON";
})(exports.KnownValueFormat || (exports.KnownValueFormat = {}));
/** Known values of {@link ReasonCode} that the service accepts. */
exports.KnownReasonCode = void 0;
(function (KnownReasonCode) {
    KnownReasonCode["NotSpecified"] = "NotSpecified";
    KnownReasonCode["NotAvailableForRegion"] = "NotAvailableForRegion";
    KnownReasonCode["NotAvailableForSubscription"] = "NotAvailableForSubscription";
})(exports.KnownReasonCode || (exports.KnownReasonCode = {}));
/** Known values of {@link ClusterPurpose} that the service accepts. */
exports.KnownClusterPurpose = void 0;
(function (KnownClusterPurpose) {
    KnownClusterPurpose["FastProd"] = "FastProd";
    KnownClusterPurpose["DenseProd"] = "DenseProd";
    KnownClusterPurpose["DevTest"] = "DevTest";
})(exports.KnownClusterPurpose || (exports.KnownClusterPurpose = {}));
/** Known values of {@link SslConfigurationStatus} that the service accepts. */
exports.KnownSslConfigurationStatus = void 0;
(function (KnownSslConfigurationStatus) {
    KnownSslConfigurationStatus["Disabled"] = "Disabled";
    KnownSslConfigurationStatus["Enabled"] = "Enabled";
    KnownSslConfigurationStatus["Auto"] = "Auto";
})(exports.KnownSslConfigurationStatus || (exports.KnownSslConfigurationStatus = {}));
/** Known values of {@link LoadBalancerType} that the service accepts. */
exports.KnownLoadBalancerType = void 0;
(function (KnownLoadBalancerType) {
    KnownLoadBalancerType["PublicIp"] = "PublicIp";
    KnownLoadBalancerType["InternalLoadBalancer"] = "InternalLoadBalancer";
})(exports.KnownLoadBalancerType || (exports.KnownLoadBalancerType = {}));
/** Known values of {@link OsType} that the service accepts. */
exports.KnownOsType = void 0;
(function (KnownOsType) {
    KnownOsType["Linux"] = "Linux";
    KnownOsType["Windows"] = "Windows";
})(exports.KnownOsType || (exports.KnownOsType = {}));
/** Known values of {@link VmPriority} that the service accepts. */
exports.KnownVmPriority = void 0;
(function (KnownVmPriority) {
    KnownVmPriority["Dedicated"] = "Dedicated";
    KnownVmPriority["LowPriority"] = "LowPriority";
})(exports.KnownVmPriority || (exports.KnownVmPriority = {}));
/** Known values of {@link RemoteLoginPortPublicAccess} that the service accepts. */
exports.KnownRemoteLoginPortPublicAccess = void 0;
(function (KnownRemoteLoginPortPublicAccess) {
    KnownRemoteLoginPortPublicAccess["Enabled"] = "Enabled";
    KnownRemoteLoginPortPublicAccess["Disabled"] = "Disabled";
    KnownRemoteLoginPortPublicAccess["NotSpecified"] = "NotSpecified";
})(exports.KnownRemoteLoginPortPublicAccess || (exports.KnownRemoteLoginPortPublicAccess = {}));
/** Known values of {@link AllocationState} that the service accepts. */
exports.KnownAllocationState = void 0;
(function (KnownAllocationState) {
    KnownAllocationState["Steady"] = "Steady";
    KnownAllocationState["Resizing"] = "Resizing";
})(exports.KnownAllocationState || (exports.KnownAllocationState = {}));
/** Known values of {@link ApplicationSharingPolicy} that the service accepts. */
exports.KnownApplicationSharingPolicy = void 0;
(function (KnownApplicationSharingPolicy) {
    KnownApplicationSharingPolicy["Personal"] = "Personal";
    KnownApplicationSharingPolicy["Shared"] = "Shared";
})(exports.KnownApplicationSharingPolicy || (exports.KnownApplicationSharingPolicy = {}));
/** Known values of {@link SshPublicAccess} that the service accepts. */
exports.KnownSshPublicAccess = void 0;
(function (KnownSshPublicAccess) {
    KnownSshPublicAccess["Enabled"] = "Enabled";
    KnownSshPublicAccess["Disabled"] = "Disabled";
})(exports.KnownSshPublicAccess || (exports.KnownSshPublicAccess = {}));
/** Known values of {@link ComputeInstanceState} that the service accepts. */
exports.KnownComputeInstanceState = void 0;
(function (KnownComputeInstanceState) {
    KnownComputeInstanceState["Creating"] = "Creating";
    KnownComputeInstanceState["CreateFailed"] = "CreateFailed";
    KnownComputeInstanceState["Deleting"] = "Deleting";
    KnownComputeInstanceState["Running"] = "Running";
    KnownComputeInstanceState["Restarting"] = "Restarting";
    KnownComputeInstanceState["JobRunning"] = "JobRunning";
    KnownComputeInstanceState["SettingUp"] = "SettingUp";
    KnownComputeInstanceState["SetupFailed"] = "SetupFailed";
    KnownComputeInstanceState["Starting"] = "Starting";
    KnownComputeInstanceState["Stopped"] = "Stopped";
    KnownComputeInstanceState["Stopping"] = "Stopping";
    KnownComputeInstanceState["UserSettingUp"] = "UserSettingUp";
    KnownComputeInstanceState["UserSetupFailed"] = "UserSetupFailed";
    KnownComputeInstanceState["Unknown"] = "Unknown";
    KnownComputeInstanceState["Unusable"] = "Unusable";
})(exports.KnownComputeInstanceState || (exports.KnownComputeInstanceState = {}));
/** Known values of {@link ComputeInstanceAuthorizationType} that the service accepts. */
exports.KnownComputeInstanceAuthorizationType = void 0;
(function (KnownComputeInstanceAuthorizationType) {
    KnownComputeInstanceAuthorizationType["Personal"] = "personal";
})(exports.KnownComputeInstanceAuthorizationType || (exports.KnownComputeInstanceAuthorizationType = {}));
/** Known values of {@link OperationName} that the service accepts. */
exports.KnownOperationName = void 0;
(function (KnownOperationName) {
    KnownOperationName["Create"] = "Create";
    KnownOperationName["Start"] = "Start";
    KnownOperationName["Stop"] = "Stop";
    KnownOperationName["Restart"] = "Restart";
    KnownOperationName["Reimage"] = "Reimage";
    KnownOperationName["Delete"] = "Delete";
})(exports.KnownOperationName || (exports.KnownOperationName = {}));
/** Known values of {@link OperationStatus} that the service accepts. */
exports.KnownOperationStatus = void 0;
(function (KnownOperationStatus) {
    KnownOperationStatus["InProgress"] = "InProgress";
    KnownOperationStatus["Succeeded"] = "Succeeded";
    KnownOperationStatus["CreateFailed"] = "CreateFailed";
    KnownOperationStatus["StartFailed"] = "StartFailed";
    KnownOperationStatus["StopFailed"] = "StopFailed";
    KnownOperationStatus["RestartFailed"] = "RestartFailed";
    KnownOperationStatus["ReimageFailed"] = "ReimageFailed";
    KnownOperationStatus["DeleteFailed"] = "DeleteFailed";
})(exports.KnownOperationStatus || (exports.KnownOperationStatus = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const EncryptionProperty = {
    type: {
        name: "Composite",
        className: "EncryptionProperty",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityForCmk"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            }
        }
    }
};
const IdentityForCmk = {
    type: {
        name: "Composite",
        className: "IdentityForCmk",
        modelProperties: {
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyVaultArmId: {
                serializedName: "keyVaultArmId",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyIdentifier: {
                serializedName: "keyIdentifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            identityClientId: {
                serializedName: "identityClientId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subnetArmId: {
                serializedName: "subnetArmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "SystemAssigned,UserAssigned",
                        "UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SharedPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "SharedPrivateLinkResource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            privateLinkResourceId: {
                serializedName: "properties.privateLinkResourceId",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            requestMessage: {
                serializedName: "properties.requestMessage",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotebookResourceInfo = {
    type: {
        name: "Composite",
        className: "NotebookResourceInfo",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            notebookPreparationError: {
                serializedName: "notebookPreparationError",
                type: {
                    name: "Composite",
                    className: "NotebookPreparationError"
                }
            }
        }
    }
};
const NotebookPreparationError = {
    type: {
        name: "Composite",
        className: "NotebookPreparationError",
        modelProperties: {
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceManagedResourcesSettings = {
    type: {
        name: "Composite",
        className: "ServiceManagedResourcesSettings",
        modelProperties: {
            cosmosDb: {
                serializedName: "cosmosDb",
                type: {
                    name: "Composite",
                    className: "CosmosDbSettings"
                }
            }
        }
    }
};
const CosmosDbSettings = {
    type: {
        name: "Composite",
        className: "CosmosDbSettings",
        modelProperties: {
            collectionsThroughput: {
                serializedName: "collectionsThroughput",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WorkspaceUpdateParameters = {
    type: {
        name: "Composite",
        className: "WorkspaceUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            friendlyName: {
                serializedName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            },
            imageBuildCompute: {
                serializedName: "properties.imageBuildCompute",
                type: {
                    name: "String"
                }
            },
            serviceManagedResourcesSettings: {
                serializedName: "properties.serviceManagedResourcesSettings",
                type: {
                    name: "Composite",
                    className: "ServiceManagedResourcesSettings"
                }
            },
            primaryUserAssignedIdentity: {
                serializedName: "properties.primaryUserAssignedIdentity",
                type: {
                    name: "String"
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceListResult = {
    type: {
        name: "Composite",
        className: "WorkspaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workspace"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnoseWorkspaceParameters = {
    type: {
        name: "Composite",
        className: "DiagnoseWorkspaceParameters",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DiagnoseRequestProperties"
                }
            }
        }
    }
};
const DiagnoseRequestProperties = {
    type: {
        name: "Composite",
        className: "DiagnoseRequestProperties",
        modelProperties: {
            udr: {
                serializedName: "udr",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            nsg: {
                serializedName: "nsg",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            resourceLock: {
                serializedName: "resourceLock",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            dnsResolution: {
                serializedName: "dnsResolution",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            storageAccount: {
                serializedName: "storageAccount",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            keyVault: {
                serializedName: "keyVault",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            containerRegistry: {
                serializedName: "containerRegistry",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            applicationInsights: {
                serializedName: "applicationInsights",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            },
            others: {
                serializedName: "others",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }
        }
    }
};
const DiagnoseResponseResult = {
    type: {
        name: "Composite",
        className: "DiagnoseResponseResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "DiagnoseResponseResultValue"
                }
            }
        }
    }
};
const DiagnoseResponseResultValue = {
    type: {
        name: "Composite",
        className: "DiagnoseResponseResultValue",
        modelProperties: {
            userDefinedRouteResults: {
                serializedName: "userDefinedRouteResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            networkSecurityRuleResults: {
                serializedName: "networkSecurityRuleResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            resourceLockResults: {
                serializedName: "resourceLockResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            dnsResolutionResults: {
                serializedName: "dnsResolutionResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            storageAccountResults: {
                serializedName: "storageAccountResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            keyVaultResults: {
                serializedName: "keyVaultResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            containerRegistryResults: {
                serializedName: "containerRegistryResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            applicationInsightsResults: {
                serializedName: "applicationInsightsResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            },
            otherResults: {
                serializedName: "otherResults",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnoseResult"
                        }
                    }
                }
            }
        }
    }
};
const DiagnoseResult = {
    type: {
        name: "Composite",
        className: "DiagnoseResult",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            level: {
                serializedName: "level",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListWorkspaceKeysResult = {
    type: {
        name: "Composite",
        className: "ListWorkspaceKeysResult",
        modelProperties: {
            userStorageKey: {
                serializedName: "userStorageKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userStorageResourceId: {
                serializedName: "userStorageResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            appInsightsInstrumentationKey: {
                serializedName: "appInsightsInstrumentationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            containerRegistryCredentials: {
                serializedName: "containerRegistryCredentials",
                type: {
                    name: "Composite",
                    className: "RegistryListCredentialsResult"
                }
            },
            notebookAccessKeys: {
                serializedName: "notebookAccessKeys",
                type: {
                    name: "Composite",
                    className: "ListNotebookKeysResult"
                }
            }
        }
    }
};
const RegistryListCredentialsResult = {
    type: {
        name: "Composite",
        className: "RegistryListCredentialsResult",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            passwords: {
                serializedName: "passwords",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Password"
                        }
                    }
                }
            }
        }
    }
};
const Password = {
    type: {
        name: "Composite",
        className: "Password",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListNotebookKeysResult = {
    type: {
        name: "Composite",
        className: "ListNotebookKeysResult",
        modelProperties: {
            primaryAccessKey: {
                serializedName: "primaryAccessKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondaryAccessKey: {
                serializedName: "secondaryAccessKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListUsagesResult = {
    type: {
        name: "Composite",
        className: "ListUsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amlWorkspaceLocation: {
                serializedName: "amlWorkspaceLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineSizeListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineSizeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineSize"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineSize = {
    type: {
        name: "Composite",
        className: "VirtualMachineSize",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vCPUs: {
                serializedName: "vCPUs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            gpus: {
                serializedName: "gpus",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            osVhdSizeMB: {
                serializedName: "osVhdSizeMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxResourceVolumeMB: {
                serializedName: "maxResourceVolumeMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            memoryGB: {
                serializedName: "memoryGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            lowPriorityCapable: {
                serializedName: "lowPriorityCapable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            premiumIO: {
                serializedName: "premiumIO",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            estimatedVMPrices: {
                serializedName: "estimatedVMPrices",
                type: {
                    name: "Composite",
                    className: "EstimatedVMPrices"
                }
            },
            supportedComputeTypes: {
                serializedName: "supportedComputeTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EstimatedVMPrices = {
    type: {
        name: "Composite",
        className: "EstimatedVMPrices",
        modelProperties: {
            billingCurrency: {
                serializedName: "billingCurrency",
                required: true,
                type: {
                    name: "String"
                }
            },
            unitOfMeasure: {
                serializedName: "unitOfMeasure",
                required: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EstimatedVMPrice"
                        }
                    }
                }
            }
        }
    }
};
const EstimatedVMPrice = {
    type: {
        name: "Composite",
        className: "EstimatedVMPrice",
        modelProperties: {
            retailPrice: {
                serializedName: "retailPrice",
                required: true,
                type: {
                    name: "Number"
                }
            },
            osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "String"
                }
            },
            vmTier: {
                serializedName: "vmTier",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaUpdateParameters = {
    type: {
        name: "Composite",
        className: "QuotaUpdateParameters",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QuotaBaseProperties"
                        }
                    }
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QuotaBaseProperties = {
    type: {
        name: "Composite",
        className: "QuotaBaseProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateWorkspaceQuotasResult = {
    type: {
        name: "Composite",
        className: "UpdateWorkspaceQuotasResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "UpdateWorkspaceQuotas"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateWorkspaceQuotas = {
    type: {
        name: "Composite",
        className: "UpdateWorkspaceQuotas",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListWorkspaceQuotas = {
    type: {
        name: "Composite",
        className: "ListWorkspaceQuotas",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceQuota"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceQuota = {
    type: {
        name: "Composite",
        className: "ResourceQuota",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amlWorkspaceLocation: {
                serializedName: "amlWorkspaceLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "ResourceName"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceName = {
    type: {
        name: "Composite",
        className: "ResourceName",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PaginatedComputeResourcesList = {
    type: {
        name: "Composite",
        className: "PaginatedComputeResourcesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Components1D3SwueSchemasComputeresourceAllof1 = {
    type: {
        name: "Composite",
        className: "Components1D3SwueSchemasComputeresourceAllof1",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "Compute"
                }
            }
        }
    }
};
const Compute = {
    type: {
        name: "Composite",
        className: "Compute",
        uberParent: "Compute",
        polymorphicDiscriminator: {
            serializedName: "computeType",
            clientName: "computeType"
        },
        modelProperties: {
            computeType: {
                serializedName: "computeType",
                required: true,
                type: {
                    name: "String"
                }
            },
            computeLocation: {
                serializedName: "computeLocation",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            modifiedOn: {
                serializedName: "modifiedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            provisioningErrors: {
                serializedName: "provisioningErrors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            isAttachedCompute: {
                serializedName: "isAttachedCompute",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            disableLocalAuth: {
                serializedName: "disableLocalAuth",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ClusterUpdateParameters = {
    type: {
        name: "Composite",
        className: "ClusterUpdateParameters",
        modelProperties: {
            properties: {
                serializedName: "properties.properties",
                type: {
                    name: "Composite",
                    className: "ScaleSettingsInformation"
                }
            }
        }
    }
};
const ScaleSettingsInformation = {
    type: {
        name: "Composite",
        className: "ScaleSettingsInformation",
        modelProperties: {
            scaleSettings: {
                serializedName: "scaleSettings",
                type: {
                    name: "Composite",
                    className: "ScaleSettings"
                }
            }
        }
    }
};
const ScaleSettings = {
    type: {
        name: "Composite",
        className: "ScaleSettings",
        modelProperties: {
            maxNodeCount: {
                serializedName: "maxNodeCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            minNodeCount: {
                defaultValue: 0,
                serializedName: "minNodeCount",
                type: {
                    name: "Number"
                }
            },
            nodeIdleTimeBeforeScaleDown: {
                serializedName: "nodeIdleTimeBeforeScaleDown",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const AmlComputeNodesInformation = {
    type: {
        name: "Composite",
        className: "AmlComputeNodesInformation",
        modelProperties: {
            nodes: {
                serializedName: "nodes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlComputeNodeInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlComputeNodeInformation = {
    type: {
        name: "Composite",
        className: "AmlComputeNodeInformation",
        modelProperties: {
            nodeId: {
                serializedName: "nodeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            nodeState: {
                serializedName: "nodeState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            runId: {
                serializedName: "runId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotebookAccessTokenResult = {
    type: {
        name: "Composite",
        className: "NotebookAccessTokenResult",
        modelProperties: {
            notebookResourceId: {
                serializedName: "notebookResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "hostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicDns: {
                serializedName: "publicDns",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            accessToken: {
                serializedName: "accessToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tokenType: {
                serializedName: "tokenType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expiresIn: {
                serializedName: "expiresIn",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            refreshToken: {
                serializedName: "refreshToken",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeSecrets = {
    type: {
        name: "Composite",
        className: "ComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: {
            serializedName: "computeType",
            clientName: "computeType"
        },
        modelProperties: {
            computeType: {
                serializedName: "computeType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ListStorageAccountKeysResult = {
    type: {
        name: "Composite",
        className: "ListStorageAccountKeysResult",
        modelProperties: {
            userStorageKey: {
                serializedName: "userStorageKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PaginatedWorkspaceConnectionsList = {
    type: {
        name: "Composite",
        className: "PaginatedWorkspaceConnectionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkspaceConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceConnection = {
    type: {
        name: "Composite",
        className: "WorkspaceConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "properties.category",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "properties.target",
                type: {
                    name: "String"
                }
            },
            authType: {
                serializedName: "properties.authType",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "properties.value",
                type: {
                    name: "String"
                }
            },
            valueFormat: {
                serializedName: "properties.valueFormat",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExternalFqdnResponse = {
    type: {
        name: "Composite",
        className: "ExternalFqdnResponse",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpoints"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpoints = {
    type: {
        name: "Composite",
        className: "FqdnEndpoints",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "FqdnEndpointsProperties"
                }
            }
        }
    }
};
const FqdnEndpointsProperties = {
    type: {
        name: "Composite",
        className: "FqdnEndpointsProperties",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpoint"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpoint = {
    type: {
        name: "Composite",
        className: "FqdnEndpoint",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FqdnEndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const FqdnEndpointDetail = {
    type: {
        name: "Composite",
        className: "FqdnEndpointDetail",
        modelProperties: {
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListAmlUserFeatureResult = {
    type: {
        name: "Composite",
        className: "ListAmlUserFeatureResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AmlUserFeature"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AmlUserFeature = {
    type: {
        name: "Composite",
        className: "AmlUserFeature",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuListResult = {
    type: {
        name: "Composite",
        className: "SkuListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkspaceSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceSku = {
    type: {
        name: "Composite",
        className: "WorkspaceSku",
        modelProperties: {
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locationInfo: {
                serializedName: "locationInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuLocationInfo"
                        }
                    }
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SKUCapability"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Restriction"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSkuLocationInfo = {
    type: {
        name: "Composite",
        className: "ResourceSkuLocationInfo",
        modelProperties: {
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            zones: {
                serializedName: "zones",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zoneDetails: {
                serializedName: "zoneDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceSkuZoneDetails"
                        }
                    }
                }
            }
        }
    }
};
const ResourceSkuZoneDetails = {
    type: {
        name: "Composite",
        className: "ResourceSkuZoneDetails",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SKUCapability"
                        }
                    }
                }
            }
        }
    }
};
const SKUCapability = {
    type: {
        name: "Composite",
        className: "SKUCapability",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Restriction = {
    type: {
        name: "Composite",
        className: "Restriction",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceId = {
    type: {
        name: "Composite",
        className: "ResourceId",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AKSProperties = {
    type: {
        name: "Composite",
        className: "AKSProperties",
        modelProperties: {
            clusterFqdn: {
                serializedName: "clusterFqdn",
                type: {
                    name: "String"
                }
            },
            systemServices: {
                serializedName: "systemServices",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SystemService"
                        }
                    }
                }
            },
            agentCount: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "agentCount",
                type: {
                    name: "Number"
                }
            },
            agentVmSize: {
                serializedName: "agentVmSize",
                type: {
                    name: "String"
                }
            },
            clusterPurpose: {
                defaultValue: "FastProd",
                serializedName: "clusterPurpose",
                type: {
                    name: "String"
                }
            },
            sslConfiguration: {
                serializedName: "sslConfiguration",
                type: {
                    name: "Composite",
                    className: "SslConfiguration"
                }
            },
            aksNetworkingConfiguration: {
                serializedName: "aksNetworkingConfiguration",
                type: {
                    name: "Composite",
                    className: "AksNetworkingConfiguration"
                }
            },
            loadBalancerType: {
                defaultValue: "PublicIp",
                serializedName: "loadBalancerType",
                type: {
                    name: "String"
                }
            },
            loadBalancerSubnet: {
                serializedName: "loadBalancerSubnet",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemService = {
    type: {
        name: "Composite",
        className: "SystemService",
        modelProperties: {
            systemServiceType: {
                serializedName: "systemServiceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SslConfiguration = {
    type: {
        name: "Composite",
        className: "SslConfiguration",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            cert: {
                serializedName: "cert",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            cname: {
                serializedName: "cname",
                type: {
                    name: "String"
                }
            },
            leafDomainLabel: {
                serializedName: "leafDomainLabel",
                type: {
                    name: "String"
                }
            },
            overwriteExistingDomain: {
                serializedName: "overwriteExistingDomain",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AksNetworkingConfiguration = {
    type: {
        name: "Composite",
        className: "AksNetworkingConfiguration",
        modelProperties: {
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            serviceCidr: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
                },
                serializedName: "serviceCidr",
                type: {
                    name: "String"
                }
            },
            dnsServiceIP: {
                constraints: {
                    Pattern: new RegExp("^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$")
                },
                serializedName: "dnsServiceIP",
                type: {
                    name: "String"
                }
            },
            dockerBridgeCidr: {
                constraints: {
                    Pattern: new RegExp("^([0-9]{1,3}\\.){3}[0-9]{1,3}(\\/([0-9]|[1-2][0-9]|3[0-2]))?$")
                },
                serializedName: "dockerBridgeCidr",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KubernetesSchema = {
    type: {
        name: "Composite",
        className: "KubernetesSchema",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "KubernetesProperties"
                }
            }
        }
    }
};
const KubernetesProperties = {
    type: {
        name: "Composite",
        className: "KubernetesProperties",
        modelProperties: {
            relayConnectionString: {
                serializedName: "relayConnectionString",
                type: {
                    name: "String"
                }
            },
            serviceBusConnectionString: {
                serializedName: "serviceBusConnectionString",
                type: {
                    name: "String"
                }
            },
            extensionPrincipalId: {
                serializedName: "extensionPrincipalId",
                type: {
                    name: "String"
                }
            },
            extensionInstanceReleaseTrain: {
                serializedName: "extensionInstanceReleaseTrain",
                type: {
                    name: "String"
                }
            },
            vcName: {
                serializedName: "vcName",
                type: {
                    name: "String"
                }
            },
            namespace: {
                defaultValue: "default",
                serializedName: "namespace",
                type: {
                    name: "String"
                }
            },
            defaultInstanceType: {
                serializedName: "defaultInstanceType",
                type: {
                    name: "String"
                }
            },
            instanceTypes: {
                serializedName: "instanceTypes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "InstanceTypeSchema" }
                    }
                }
            }
        }
    }
};
const InstanceTypeSchema = {
    type: {
        name: "Composite",
        className: "InstanceTypeSchema",
        modelProperties: {
            nodeSelector: {
                serializedName: "nodeSelector",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Composite",
                    className: "InstanceTypeSchemaResources"
                }
            }
        }
    }
};
const InstanceTypeSchemaResources = {
    type: {
        name: "Composite",
        className: "InstanceTypeSchemaResources",
        modelProperties: {
            requests: {
                serializedName: "requests",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            limits: {
                serializedName: "limits",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AmlComputeProperties = {
    type: {
        name: "Composite",
        className: "AmlComputeProperties",
        modelProperties: {
            osType: {
                defaultValue: "Linux",
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            vmPriority: {
                serializedName: "vmPriority",
                type: {
                    name: "String"
                }
            },
            virtualMachineImage: {
                serializedName: "virtualMachineImage",
                type: {
                    name: "Composite",
                    className: "VirtualMachineImage"
                }
            },
            isolatedNetwork: {
                serializedName: "isolatedNetwork",
                type: {
                    name: "Boolean"
                }
            },
            scaleSettings: {
                serializedName: "scaleSettings",
                type: {
                    name: "Composite",
                    className: "ScaleSettings"
                }
            },
            userAccountCredentials: {
                serializedName: "userAccountCredentials",
                type: {
                    name: "Composite",
                    className: "UserAccountCredentials"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "ResourceId"
                }
            },
            remoteLoginPortPublicAccess: {
                defaultValue: "NotSpecified",
                serializedName: "remoteLoginPortPublicAccess",
                type: {
                    name: "String"
                }
            },
            allocationState: {
                serializedName: "allocationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allocationStateTransitionTime: {
                serializedName: "allocationStateTransitionTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            errors: {
                serializedName: "errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            currentNodeCount: {
                serializedName: "currentNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            targetNodeCount: {
                serializedName: "targetNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            nodeStateCounts: {
                serializedName: "nodeStateCounts",
                type: {
                    name: "Composite",
                    className: "NodeStateCounts"
                }
            },
            enableNodePublicIp: {
                defaultValue: true,
                serializedName: "enableNodePublicIp",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineImage = {
    type: {
        name: "Composite",
        className: "VirtualMachineImage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserAccountCredentials = {
    type: {
        name: "Composite",
        className: "UserAccountCredentials",
        modelProperties: {
            adminUserName: {
                serializedName: "adminUserName",
                required: true,
                type: {
                    name: "String"
                }
            },
            adminUserSshPublicKey: {
                serializedName: "adminUserSshPublicKey",
                type: {
                    name: "String"
                }
            },
            adminUserPassword: {
                serializedName: "adminUserPassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeStateCounts = {
    type: {
        name: "Composite",
        className: "NodeStateCounts",
        modelProperties: {
            idleNodeCount: {
                serializedName: "idleNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            runningNodeCount: {
                serializedName: "runningNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            preparingNodeCount: {
                serializedName: "preparingNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            unusableNodeCount: {
                serializedName: "unusableNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            leavingNodeCount: {
                serializedName: "leavingNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            preemptedNodeCount: {
                serializedName: "preemptedNodeCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ComputeInstanceProperties = {
    type: {
        name: "Composite",
        className: "ComputeInstanceProperties",
        modelProperties: {
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "ResourceId"
                }
            },
            applicationSharingPolicy: {
                defaultValue: "Shared",
                serializedName: "applicationSharingPolicy",
                type: {
                    name: "String"
                }
            },
            sshSettings: {
                serializedName: "sshSettings",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceSshSettings"
                }
            },
            connectivityEndpoints: {
                serializedName: "connectivityEndpoints",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceConnectivityEndpoints"
                }
            },
            applications: {
                serializedName: "applications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeInstanceApplication"
                        }
                    }
                }
            },
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceCreatedBy"
                }
            },
            errors: {
                serializedName: "errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            computeInstanceAuthorizationType: {
                defaultValue: "personal",
                serializedName: "computeInstanceAuthorizationType",
                type: {
                    name: "String"
                }
            },
            personalComputeInstanceSettings: {
                serializedName: "personalComputeInstanceSettings",
                type: {
                    name: "Composite",
                    className: "PersonalComputeInstanceSettings"
                }
            },
            setupScripts: {
                serializedName: "setupScripts",
                type: {
                    name: "Composite",
                    className: "SetupScripts"
                }
            },
            lastOperation: {
                serializedName: "lastOperation",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceLastOperation"
                }
            }
        }
    }
};
const ComputeInstanceSshSettings = {
    type: {
        name: "Composite",
        className: "ComputeInstanceSshSettings",
        modelProperties: {
            sshPublicAccess: {
                defaultValue: "Disabled",
                serializedName: "sshPublicAccess",
                type: {
                    name: "String"
                }
            },
            adminUserName: {
                serializedName: "adminUserName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sshPort: {
                serializedName: "sshPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            adminPublicKey: {
                serializedName: "adminPublicKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceConnectivityEndpoints = {
    type: {
        name: "Composite",
        className: "ComputeInstanceConnectivityEndpoints",
        modelProperties: {
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceApplication = {
    type: {
        name: "Composite",
        className: "ComputeInstanceApplication",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            endpointUri: {
                serializedName: "endpointUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceCreatedBy = {
    type: {
        name: "Composite",
        className: "ComputeInstanceCreatedBy",
        modelProperties: {
            userName: {
                serializedName: "userName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userOrgId: {
                serializedName: "userOrgId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userId: {
                serializedName: "userId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PersonalComputeInstanceSettings = {
    type: {
        name: "Composite",
        className: "PersonalComputeInstanceSettings",
        modelProperties: {
            assignedUser: {
                serializedName: "assignedUser",
                type: {
                    name: "Composite",
                    className: "AssignedUser"
                }
            }
        }
    }
};
const AssignedUser = {
    type: {
        name: "Composite",
        className: "AssignedUser",
        modelProperties: {
            objectId: {
                serializedName: "objectId",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SetupScripts = {
    type: {
        name: "Composite",
        className: "SetupScripts",
        modelProperties: {
            scripts: {
                serializedName: "scripts",
                type: {
                    name: "Composite",
                    className: "ScriptsToExecute"
                }
            }
        }
    }
};
const ScriptsToExecute = {
    type: {
        name: "Composite",
        className: "ScriptsToExecute",
        modelProperties: {
            startupScript: {
                serializedName: "startupScript",
                type: {
                    name: "Composite",
                    className: "ScriptReference"
                }
            },
            creationScript: {
                serializedName: "creationScript",
                type: {
                    name: "Composite",
                    className: "ScriptReference"
                }
            }
        }
    }
};
const ScriptReference = {
    type: {
        name: "Composite",
        className: "ScriptReference",
        modelProperties: {
            scriptSource: {
                serializedName: "scriptSource",
                type: {
                    name: "String"
                }
            },
            scriptData: {
                serializedName: "scriptData",
                type: {
                    name: "String"
                }
            },
            scriptArguments: {
                serializedName: "scriptArguments",
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "timeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeInstanceLastOperation = {
    type: {
        name: "Composite",
        className: "ComputeInstanceLastOperation",
        modelProperties: {
            operationName: {
                serializedName: "operationName",
                type: {
                    name: "String"
                }
            },
            operationTime: {
                serializedName: "operationTime",
                type: {
                    name: "DateTime"
                }
            },
            operationStatus: {
                serializedName: "operationStatus",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineProperties = {
    type: {
        name: "Composite",
        className: "VirtualMachineProperties",
        modelProperties: {
            virtualMachineSize: {
                serializedName: "virtualMachineSize",
                type: {
                    name: "String"
                }
            },
            sshPort: {
                serializedName: "sshPort",
                type: {
                    name: "Number"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            },
            isNotebookInstanceCompute: {
                serializedName: "isNotebookInstanceCompute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineSshCredentials = {
    type: {
        name: "Composite",
        className: "VirtualMachineSshCredentials",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            publicKeyData: {
                serializedName: "publicKeyData",
                type: {
                    name: "String"
                }
            },
            privateKeyData: {
                serializedName: "privateKeyData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HDInsightProperties = {
    type: {
        name: "Composite",
        className: "HDInsightProperties",
        modelProperties: {
            sshPort: {
                serializedName: "sshPort",
                type: {
                    name: "Number"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            }
        }
    }
};
const DatabricksProperties = {
    type: {
        name: "Composite",
        className: "DatabricksProperties",
        modelProperties: {
            databricksAccessToken: {
                serializedName: "databricksAccessToken",
                type: {
                    name: "String"
                }
            },
            workspaceUrl: {
                serializedName: "workspaceUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataLakeAnalyticsProperties = {
    type: {
        name: "Composite",
        className: "DataLakeAnalyticsProperties",
        modelProperties: {
            dataLakeStoreAccountName: {
                serializedName: "dataLakeStoreAccountName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SynapseSparkProperties = {
    type: {
        name: "Composite",
        className: "SynapseSparkProperties",
        modelProperties: {
            autoScaleProperties: {
                serializedName: "autoScaleProperties",
                type: {
                    name: "Composite",
                    className: "AutoScaleProperties"
                }
            },
            autoPauseProperties: {
                serializedName: "autoPauseProperties",
                type: {
                    name: "Composite",
                    className: "AutoPauseProperties"
                }
            },
            sparkVersion: {
                serializedName: "sparkVersion",
                type: {
                    name: "String"
                }
            },
            nodeCount: {
                serializedName: "nodeCount",
                type: {
                    name: "Number"
                }
            },
            nodeSize: {
                serializedName: "nodeSize",
                type: {
                    name: "String"
                }
            },
            nodeSizeFamily: {
                serializedName: "nodeSizeFamily",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            resourceGroup: {
                serializedName: "resourceGroup",
                type: {
                    name: "String"
                }
            },
            workspaceName: {
                serializedName: "workspaceName",
                type: {
                    name: "String"
                }
            },
            poolName: {
                serializedName: "poolName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoScaleProperties = {
    type: {
        name: "Composite",
        className: "AutoScaleProperties",
        modelProperties: {
            minNodeCount: {
                serializedName: "minNodeCount",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            maxNodeCount: {
                serializedName: "maxNodeCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoPauseProperties = {
    type: {
        name: "Composite",
        className: "AutoPauseProperties",
        modelProperties: {
            delayInMinutes: {
                serializedName: "delayInMinutes",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ServicePrincipalCredentials = {
    type: {
        name: "Composite",
        className: "ServicePrincipalCredentials",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                required: true,
                type: {
                    name: "String"
                }
            },
            clientSecret: {
                serializedName: "clientSecret",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AksComputeSecretsProperties = {
    type: {
        name: "Composite",
        className: "AksComputeSecretsProperties",
        modelProperties: {
            userKubeConfig: {
                serializedName: "userKubeConfig",
                type: {
                    name: "String"
                }
            },
            adminKubeConfig: {
                serializedName: "adminKubeConfig",
                type: {
                    name: "String"
                }
            },
            imagePullSecretName: {
                serializedName: "imagePullSecretName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatabricksComputeSecretsProperties = {
    type: {
        name: "Composite",
        className: "DatabricksComputeSecretsProperties",
        modelProperties: {
            databricksAccessToken: {
                serializedName: "databricksAccessToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerResourceRequirements = {
    type: {
        name: "Composite",
        className: "ContainerResourceRequirements",
        modelProperties: {
            cpu: {
                serializedName: "cpu",
                type: {
                    name: "Number"
                }
            },
            cpuLimit: {
                serializedName: "cpuLimit",
                type: {
                    name: "Number"
                }
            },
            memoryInGB: {
                serializedName: "memoryInGB",
                type: {
                    name: "Number"
                }
            },
            memoryInGBLimit: {
                serializedName: "memoryInGBLimit",
                type: {
                    name: "Number"
                }
            },
            gpu: {
                serializedName: "gpu",
                type: {
                    name: "Number"
                }
            },
            fpga: {
                serializedName: "fpga",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Workspace = {
    type: {
        name: "Composite",
        className: "Workspace",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, workspaceId: {
                serializedName: "properties.workspaceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, friendlyName: {
                serializedName: "properties.friendlyName",
                type: {
                    name: "String"
                }
            }, keyVault: {
                serializedName: "properties.keyVault",
                type: {
                    name: "String"
                }
            }, applicationInsights: {
                serializedName: "properties.applicationInsights",
                type: {
                    name: "String"
                }
            }, containerRegistry: {
                serializedName: "properties.containerRegistry",
                nullable: true,
                type: {
                    name: "String"
                }
            }, storageAccount: {
                serializedName: "properties.storageAccount",
                type: {
                    name: "String"
                }
            }, discoveryUrl: {
                serializedName: "properties.discoveryUrl",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "EncryptionProperty"
                }
            }, hbiWorkspace: {
                defaultValue: false,
                serializedName: "properties.hbiWorkspace",
                type: {
                    name: "Boolean"
                }
            }, serviceProvisionedResourceGroup: {
                serializedName: "properties.serviceProvisionedResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkCount: {
                serializedName: "properties.privateLinkCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, imageBuildCompute: {
                serializedName: "properties.imageBuildCompute",
                type: {
                    name: "String"
                }
            }, allowPublicAccessWhenBehindVnet: {
                defaultValue: false,
                serializedName: "properties.allowPublicAccessWhenBehindVnet",
                type: {
                    name: "Boolean"
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, sharedPrivateLinkResources: {
                serializedName: "properties.sharedPrivateLinkResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SharedPrivateLinkResource"
                        }
                    }
                }
            }, notebookInfo: {
                serializedName: "properties.notebookInfo",
                type: {
                    name: "Composite",
                    className: "NotebookResourceInfo"
                }
            }, serviceManagedResourcesSettings: {
                serializedName: "properties.serviceManagedResourcesSettings",
                type: {
                    name: "Composite",
                    className: "ServiceManagedResourcesSettings"
                }
            }, primaryUserAssignedIdentity: {
                serializedName: "properties.primaryUserAssignedIdentity",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageHnsEnabled: {
                serializedName: "properties.storageHnsEnabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, mlFlowTrackingUri: {
                serializedName: "properties.mlFlowTrackingUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ComputeResource = {
    type: {
        name: "Composite",
        className: "ComputeResource",
        modelProperties: Object.assign(Object.assign(Object.assign({}, Resource.type.modelProperties), Components1D3SwueSchemasComputeresourceAllof1.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Aks = {
    serializedName: "AKS",
    type: {
        name: "Composite",
        className: "Aks",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AKSProperties"
                }
            } })
    }
};
const Kubernetes = {
    serializedName: "Kubernetes",
    type: {
        name: "Composite",
        className: "Kubernetes",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), KubernetesSchema.type.modelProperties)
    }
};
const AmlCompute = {
    serializedName: "AmlCompute",
    type: {
        name: "Composite",
        className: "AmlCompute",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AmlComputeProperties"
                }
            } })
    }
};
const ComputeInstance = {
    serializedName: "ComputeInstance",
    type: {
        name: "Composite",
        className: "ComputeInstance",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ComputeInstanceProperties"
                }
            } })
    }
};
const VirtualMachine = {
    serializedName: "VirtualMachine",
    type: {
        name: "Composite",
        className: "VirtualMachine",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VirtualMachineProperties"
                }
            } })
    }
};
const HDInsight = {
    serializedName: "HDInsight",
    type: {
        name: "Composite",
        className: "HDInsight",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "HDInsightProperties"
                }
            } })
    }
};
const DataFactory = {
    serializedName: "DataFactory",
    type: {
        name: "Composite",
        className: "DataFactory",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, Compute.type.modelProperties)
    }
};
const Databricks = {
    serializedName: "Databricks",
    type: {
        name: "Composite",
        className: "Databricks",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DatabricksProperties"
                }
            } })
    }
};
const DataLakeAnalytics = {
    serializedName: "DataLakeAnalytics",
    type: {
        name: "Composite",
        className: "DataLakeAnalytics",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "DataLakeAnalyticsProperties"
                }
            } })
    }
};
const SynapseSpark = {
    serializedName: "SynapseSpark",
    type: {
        name: "Composite",
        className: "SynapseSpark",
        uberParent: "Compute",
        polymorphicDiscriminator: Compute.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, Compute.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SynapseSparkProperties"
                }
            } })
    }
};
const AksComputeSecrets = {
    serializedName: "AKS",
    type: {
        name: "Composite",
        className: "AksComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), AksComputeSecretsProperties.type.modelProperties)
    }
};
const VirtualMachineSecrets = {
    serializedName: "VirtualMachine",
    type: {
        name: "Composite",
        className: "VirtualMachineSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), { administratorAccount: {
                serializedName: "administratorAccount",
                type: {
                    name: "Composite",
                    className: "VirtualMachineSshCredentials"
                }
            } })
    }
};
const DatabricksComputeSecrets = {
    serializedName: "Databricks",
    type: {
        name: "Composite",
        className: "DatabricksComputeSecrets",
        uberParent: "ComputeSecrets",
        polymorphicDiscriminator: ComputeSecrets.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ComputeSecrets.type.modelProperties), DatabricksComputeSecretsProperties.type.modelProperties)
    }
};
const WorkspacesDiagnoseHeaders = {
    type: {
        name: "Composite",
        className: "WorkspacesDiagnoseHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                constraints: {
                    InclusiveMaximum: 600,
                    InclusiveMinimum: 10
                },
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ComputeCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "ComputeCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ComputeDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    Compute: Compute,
    ComputeSecrets: ComputeSecrets,
    "Compute.AKS": Aks,
    "Compute.Kubernetes": Kubernetes,
    "Compute.AmlCompute": AmlCompute,
    "Compute.ComputeInstance": ComputeInstance,
    "Compute.VirtualMachine": VirtualMachine,
    "Compute.HDInsight": HDInsight,
    "Compute.DataFactory": DataFactory,
    "Compute.Databricks": Databricks,
    "Compute.DataLakeAnalytics": DataLakeAnalytics,
    "Compute.SynapseSpark": SynapseSpark,
    "ComputeSecrets.AKS": AksComputeSecrets,
    "ComputeSecrets.VirtualMachine": VirtualMachineSecrets,
    "ComputeSecrets.Databricks": DatabricksComputeSecrets
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    EncryptionProperty: EncryptionProperty,
    IdentityForCmk: IdentityForCmk,
    KeyVaultProperties: KeyVaultProperties,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    Identity: Identity,
    UserAssignedIdentity: UserAssignedIdentity,
    Sku: Sku,
    SystemData: SystemData,
    Resource: Resource,
    SharedPrivateLinkResource: SharedPrivateLinkResource,
    NotebookResourceInfo: NotebookResourceInfo,
    NotebookPreparationError: NotebookPreparationError,
    ServiceManagedResourcesSettings: ServiceManagedResourcesSettings,
    CosmosDbSettings: CosmosDbSettings,
    WorkspaceUpdateParameters: WorkspaceUpdateParameters,
    WorkspaceListResult: WorkspaceListResult,
    DiagnoseWorkspaceParameters: DiagnoseWorkspaceParameters,
    DiagnoseRequestProperties: DiagnoseRequestProperties,
    DiagnoseResponseResult: DiagnoseResponseResult,
    DiagnoseResponseResultValue: DiagnoseResponseResultValue,
    DiagnoseResult: DiagnoseResult,
    ListWorkspaceKeysResult: ListWorkspaceKeysResult,
    RegistryListCredentialsResult: RegistryListCredentialsResult,
    Password: Password,
    ListNotebookKeysResult: ListNotebookKeysResult,
    ListUsagesResult: ListUsagesResult,
    Usage: Usage,
    UsageName: UsageName,
    VirtualMachineSizeListResult: VirtualMachineSizeListResult,
    VirtualMachineSize: VirtualMachineSize,
    EstimatedVMPrices: EstimatedVMPrices,
    EstimatedVMPrice: EstimatedVMPrice,
    QuotaUpdateParameters: QuotaUpdateParameters,
    QuotaBaseProperties: QuotaBaseProperties,
    UpdateWorkspaceQuotasResult: UpdateWorkspaceQuotasResult,
    UpdateWorkspaceQuotas: UpdateWorkspaceQuotas,
    ListWorkspaceQuotas: ListWorkspaceQuotas,
    ResourceQuota: ResourceQuota,
    ResourceName: ResourceName,
    PaginatedComputeResourcesList: PaginatedComputeResourcesList,
    Components1D3SwueSchemasComputeresourceAllof1: Components1D3SwueSchemasComputeresourceAllof1,
    Compute: Compute,
    ClusterUpdateParameters: ClusterUpdateParameters,
    ScaleSettingsInformation: ScaleSettingsInformation,
    ScaleSettings: ScaleSettings,
    AmlComputeNodesInformation: AmlComputeNodesInformation,
    AmlComputeNodeInformation: AmlComputeNodeInformation,
    NotebookAccessTokenResult: NotebookAccessTokenResult,
    ComputeSecrets: ComputeSecrets,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ListStorageAccountKeysResult: ListStorageAccountKeysResult,
    PaginatedWorkspaceConnectionsList: PaginatedWorkspaceConnectionsList,
    WorkspaceConnection: WorkspaceConnection,
    ExternalFqdnResponse: ExternalFqdnResponse,
    FqdnEndpoints: FqdnEndpoints,
    FqdnEndpointsProperties: FqdnEndpointsProperties,
    FqdnEndpoint: FqdnEndpoint,
    FqdnEndpointDetail: FqdnEndpointDetail,
    ListAmlUserFeatureResult: ListAmlUserFeatureResult,
    AmlUserFeature: AmlUserFeature,
    SkuListResult: SkuListResult,
    WorkspaceSku: WorkspaceSku,
    ResourceSkuLocationInfo: ResourceSkuLocationInfo,
    ResourceSkuZoneDetails: ResourceSkuZoneDetails,
    SKUCapability: SKUCapability,
    Restriction: Restriction,
    ResourceId: ResourceId,
    AKSProperties: AKSProperties,
    SystemService: SystemService,
    SslConfiguration: SslConfiguration,
    AksNetworkingConfiguration: AksNetworkingConfiguration,
    KubernetesSchema: KubernetesSchema,
    KubernetesProperties: KubernetesProperties,
    InstanceTypeSchema: InstanceTypeSchema,
    InstanceTypeSchemaResources: InstanceTypeSchemaResources,
    AmlComputeProperties: AmlComputeProperties,
    VirtualMachineImage: VirtualMachineImage,
    UserAccountCredentials: UserAccountCredentials,
    NodeStateCounts: NodeStateCounts,
    ComputeInstanceProperties: ComputeInstanceProperties,
    ComputeInstanceSshSettings: ComputeInstanceSshSettings,
    ComputeInstanceConnectivityEndpoints: ComputeInstanceConnectivityEndpoints,
    ComputeInstanceApplication: ComputeInstanceApplication,
    ComputeInstanceCreatedBy: ComputeInstanceCreatedBy,
    PersonalComputeInstanceSettings: PersonalComputeInstanceSettings,
    AssignedUser: AssignedUser,
    SetupScripts: SetupScripts,
    ScriptsToExecute: ScriptsToExecute,
    ScriptReference: ScriptReference,
    ComputeInstanceLastOperation: ComputeInstanceLastOperation,
    VirtualMachineProperties: VirtualMachineProperties,
    VirtualMachineSshCredentials: VirtualMachineSshCredentials,
    HDInsightProperties: HDInsightProperties,
    DatabricksProperties: DatabricksProperties,
    DataLakeAnalyticsProperties: DataLakeAnalyticsProperties,
    SynapseSparkProperties: SynapseSparkProperties,
    AutoScaleProperties: AutoScaleProperties,
    AutoPauseProperties: AutoPauseProperties,
    ServicePrincipalCredentials: ServicePrincipalCredentials,
    AksComputeSecretsProperties: AksComputeSecretsProperties,
    DatabricksComputeSecretsProperties: DatabricksComputeSecretsProperties,
    ContainerResourceRequirements: ContainerResourceRequirements,
    PrivateEndpointConnection: PrivateEndpointConnection,
    Workspace: Workspace,
    ComputeResource: ComputeResource,
    PrivateLinkResource: PrivateLinkResource,
    Aks: Aks,
    Kubernetes: Kubernetes,
    AmlCompute: AmlCompute,
    ComputeInstance: ComputeInstance,
    VirtualMachine: VirtualMachine,
    HDInsight: HDInsight,
    DataFactory: DataFactory,
    Databricks: Databricks,
    DataLakeAnalytics: DataLakeAnalytics,
    SynapseSpark: SynapseSpark,
    AksComputeSecrets: AksComputeSecrets,
    VirtualMachineSecrets: VirtualMachineSecrets,
    DatabricksComputeSecrets: DatabricksComputeSecrets,
    WorkspacesDiagnoseHeaders: WorkspacesDiagnoseHeaders,
    ComputeCreateOrUpdateHeaders: ComputeCreateOrUpdateHeaders,
    ComputeDeleteHeaders: ComputeDeleteHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-07-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceName = {
    parameterPath: "workspaceName",
    mapper: {
        serializedName: "workspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Workspace
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: WorkspaceUpdateParameters
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: ["options", "parameters"],
    mapper: DiagnoseWorkspaceParameters
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: QuotaUpdateParameters
};
const computeName = {
    parameterPath: "computeName",
    mapper: {
        serializedName: "computeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ComputeResource
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ClusterUpdateParameters
};
const underlyingResourceAction = {
    parameterPath: "underlyingResourceAction",
    mapper: {
        serializedName: "underlyingResourceAction",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const properties = {
    parameterPath: "properties",
    mapper: PrivateEndpointConnection
};
const target = {
    parameterPath: ["options", "target"],
    mapper: {
        serializedName: "target",
        type: {
            name: "String"
        }
    }
};
const category = {
    parameterPath: ["options", "category"],
    mapper: {
        serializedName: "category",
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: WorkspaceConnection
};
const connectionName = {
    parameterPath: "connectionName",
    mapper: {
        serializedName: "connectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Azure Machine Learning Workspaces REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Azure Machine Learning Workspaces REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/providers/Microsoft.MachineLearningServices/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Workspaces operations. */
class WorkspacesImpl {
    /**
     * Initialize a new instance of the class Workspaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the available machine learning workspaces under the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the available machine learning workspaces under the specified subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listBySubscriptionPagingPage(options);
            }
        };
    }
    listBySubscriptionPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result = yield tslib.__await(this._listBySubscription(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the properties of the specified machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates a workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for creating or updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, parameters, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for creating or updating a machine learning workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a machine learning workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a machine learning workspace with the specified parameters.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param parameters The parameters for updating a machine learning workspace.
     * @param options The options parameters.
     */
    update(resourceGroupName, workspaceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Lists all the available machine learning workspaces under the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Diagnose workspace setup issue.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDiagnose(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, diagnoseOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Diagnose workspace setup issue.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginDiagnoseAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDiagnose(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listKeysOperationSpec$1);
    }
    /**
     * Resync all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginResyncKeys(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, resyncKeysOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resync all the keys associated with this workspace. This includes keys for the storage account, app
     * insights and password for container registry
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginResyncKeysAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResyncKeys(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the available machine learning workspaces under the specified subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * return notebook access token and refresh token
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listNotebookAccessToken(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listNotebookAccessTokenOperationSpec);
    }
    /**
     * Prepare a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginPrepareNotebook(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, options }, prepareNotebookOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Prepare a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    beginPrepareNotebookAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPrepareNotebook(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List storage account keys of a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listStorageAccountKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listStorageAccountKeysOperationSpec);
    }
    /**
     * List keys of a notebook.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listNotebookKeys(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listNotebookKeysOperationSpec);
    }
    /**
     * Called by Client (Portal, CLI, etc) to get a list of all external outbound dependencies (FQDNs)
     * programmatically.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    listOutboundNetworkDependenciesEndpoints(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOutboundNetworkDependenciesEndpointsOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const diagnoseOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/diagnose",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DiagnoseResponseResult
        },
        201: {
            bodyMapper: DiagnoseResponseResult
        },
        202: {
            bodyMapper: DiagnoseResponseResult
        },
        204: {
            bodyMapper: DiagnoseResponseResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listKeysOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListWorkspaceKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const resyncKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/resyncKeys",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNotebookAccessTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listNotebookAccessToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NotebookAccessTokenResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const prepareNotebookOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/prepareNotebook",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NotebookResourceInfo
        },
        201: {
            bodyMapper: NotebookResourceInfo
        },
        202: {
            bodyMapper: NotebookResourceInfo
        },
        204: {
            bodyMapper: NotebookResourceInfo
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listStorageAccountKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listStorageAccountKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListStorageAccountKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNotebookKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/listNotebookKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ListNotebookKeysResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listOutboundNetworkDependenciesEndpointsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExternalFqdnResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the current usage information as well as limits for AML resources for given subscription and
     * location.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the current usage information as well as limits for AML resources for given subscription and
     * location.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$8);
    }
    /**
     * ListNext
     * @param location The location for which resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachineSizes operations. */
class VirtualMachineSizesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineSizes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns supported VM Sizes in a location
     * @param location The location upon which virtual-machine-sizes is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/vmSizes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineSizeListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Quotas operations. */
class QuotasImpl {
    /**
     * Initialize a new instance of the class Quotas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the currently assigned Workspace Quotas based on VMFamily.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(location, options);
            }
        };
    }
    listPagingPage(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(location, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Update quota for each VM family in workspace.
     * @param location The location for update quota is queried.
     * @param parameters Quota update parameters.
     * @param options The options parameters.
     */
    update(location, parameters, options) {
        return this.client.sendOperationRequest({ location, parameters, options }, updateOperationSpec$1);
    }
    /**
     * Gets the currently assigned Workspace Quotas based on VMFamily.
     * @param location The location for which resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param location The location for which resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/updateQuotas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UpdateWorkspaceQuotasResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/locations/{location}/quotas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListWorkspaceQuotas
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListWorkspaceQuotas
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ComputeOperations operations. */
class ComputeOperationsImpl {
    /**
     * Initialize a new instance of the class ComputeOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets computes in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the details (e.g IP address, port etc) of all the compute nodes in the compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    listNodes(resourceGroupName, workspaceName, computeName, options) {
        const iter = this.listNodesPagingAll(resourceGroupName, workspaceName, computeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listNodesPagingPage(resourceGroupName, workspaceName, computeName, options);
            }
        };
    }
    listNodesPagingPage(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listNodesPagingPage_1() {
            let result = yield tslib.__await(this._listNodes(resourceGroupName, workspaceName, computeName, options));
            yield yield tslib.__await(result.nodes || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNodesNext(resourceGroupName, workspaceName, computeName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.nodes || []);
            }
        });
    }
    listNodesPagingAll(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listNodesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listNodesPagingPage(resourceGroupName, workspaceName, computeName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets computes in specified workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$5);
    }
    /**
     * Gets compute definition by its name. Any secrets (storage keys, service credentials, etc) are not
     * returned - use 'keys' nested resource to get them.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation. If your intent is to create a new compute, do a GET first to verify that
     * it does not exist yet.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Payload with Machine Learning compute definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, parameters, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation. If your intent is to create a new compute, do a GET first to verify that
     * it does not exist yet.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Payload with Machine Learning compute definition.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, computeName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates properties of a compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Additional parameters for cluster update.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, parameters, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates properties of a compute. This call will overwrite a compute if it exists. This is a
     * nonrecoverable operation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param parameters Additional parameters for cluster update.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, computeName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, computeName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes specified Machine Learning compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param underlyingResourceAction Delete the underlying compute if 'Delete', or detach the underlying
     *                                 compute from workspace if 'Detach'.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                workspaceName,
                computeName,
                underlyingResourceAction,
                options
            }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes specified Machine Learning compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param underlyingResourceAction Delete the underlying compute if 'Delete', or detach the underlying
     *                                 compute from workspace if 'Detach'.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, computeName, underlyingResourceAction, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the details (e.g IP address, port etc) of all the compute nodes in the compute.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    _listNodes(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, listNodesOperationSpec);
    }
    /**
     * Gets secrets related to Machine Learning compute (storage keys, service credentials, etc).
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    listKeys(resourceGroupName, workspaceName, computeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, options }, listKeysOperationSpec);
    }
    /**
     * Posts a start action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a start action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Posts a stop action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a stop action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Posts a restart action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, workspaceName, computeName, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Posts a restart action to a compute instance
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, workspaceName, computeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, workspaceName, computeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$2);
    }
    /**
     * ListNodesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param computeName Name of the Azure Machine Learning compute.
     * @param nextLink The nextLink from the previous successful call to the ListNodes method.
     * @param options The options parameters.
     */
    _listNodesNext(resourceGroupName, workspaceName, computeName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, computeName, nextLink, options }, listNodesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PaginatedComputeResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        201: {
            bodyMapper: ComputeResource
        },
        202: {
            bodyMapper: ComputeResource
        },
        204: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ComputeResource
        },
        201: {
            bodyMapper: ComputeResource
        },
        202: {
            bodyMapper: ComputeResource
        },
        204: {
            bodyMapper: ComputeResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, underlyingResourceAction],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNodesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/listNodes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AmlComputeNodesInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listKeysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/listKeys",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ComputeSecrets
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/computes/{computeName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PaginatedComputeResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, skip],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNodesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AmlComputeNodesInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink,
        computeName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the private endpoint connections associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the private endpoint connections associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$4);
    }
    /**
     * Gets the specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Update the state of specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param properties The private endpoint connection properties.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, workspaceName, privateEndpointConnectionName, properties, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            properties,
            options
        }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes the specified private endpoint connection associated with the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection associated with the
     *                                      workspace
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, deleteOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: properties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the private link resources that need to be created for a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceConnections operations. */
class WorkspaceConnectionsImpl {
    /**
     * Initialize a new instance of the class WorkspaceConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all connections under a AML workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all connections under a AML workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$2);
    }
    /**
     * Add a new workspace connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param parameters The object for creating or updating a new workspace connection
     * @param options The options parameters.
     */
    create(resourceGroupName, workspaceName, connectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, parameters, options }, createOperationSpec);
    }
    /**
     * Get the detail of a workspace connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, options }, getOperationSpec);
    }
    /**
     * Delete a workspace connection.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param connectionName Friendly name of the workspace connection
     * @param options The options parameters.
     */
    delete(resourceGroupName, workspaceName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, connectionName, options }, deleteOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PaginatedWorkspaceConnectionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        target,
        category
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkspaceConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/connections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceFeatures operations. */
class WorkspaceFeaturesImpl {
    /**
     * Initialize a new instance of the class WorkspaceFeatures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all enabled features for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, workspaceName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all enabled features for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName Name of Azure Machine Learning workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MachineLearningServices/workspaces/{workspaceName}/features",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListAmlUserFeatureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListAmlUserFeatureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        workspaceName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkspaceSkus operations. */
class WorkspaceSkusImpl {
    /**
     * Initialize a new instance of the class WorkspaceSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all skus with associated features
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all skus with associated features
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MachineLearningServices/workspaces/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class AzureMachineLearningWorkspaces extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AzureMachineLearningWorkspaces class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-machinelearningservices/5.0.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            const bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
            if (!bearerTokenAuthenticationPolicyFound) {
                this.pipeline.removePolicy({
                    name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
                });
                this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                    scopes: `${optionsWithDefaults.baseUri}/.default`,
                    challengeCallbacks: {
                        authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                    }
                }));
            }
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-07-01";
        this.operations = new OperationsImpl(this);
        this.workspaces = new WorkspacesImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualMachineSizes = new VirtualMachineSizesImpl(this);
        this.quotas = new QuotasImpl(this);
        this.computeOperations = new ComputeOperationsImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.workspaceConnections = new WorkspaceConnectionsImpl(this);
        this.workspaceFeatures = new WorkspaceFeaturesImpl(this);
        this.workspaceSkus = new WorkspaceSkusImpl(this);
    }
}

exports.AzureMachineLearningWorkspaces = AzureMachineLearningWorkspaces;
//# sourceMappingURL=index.js.map
