'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link Enum0} that the service accepts. */
exports.KnownEnum0 = void 0;
(function (KnownEnum0) {
    /** Available */
    KnownEnum0["Available"] = "Available";
    /** Unavailable */
    KnownEnum0["Unavailable"] = "Unavailable";
})(exports.KnownEnum0 || (exports.KnownEnum0 = {}));
/** Known values of {@link LegacyPeeringsKind} that the service accepts. */
exports.KnownLegacyPeeringsKind = void 0;
(function (KnownLegacyPeeringsKind) {
    /** Direct */
    KnownLegacyPeeringsKind["Direct"] = "Direct";
    /** Exchange */
    KnownLegacyPeeringsKind["Exchange"] = "Exchange";
})(exports.KnownLegacyPeeringsKind || (exports.KnownLegacyPeeringsKind = {}));
/** Known values of {@link Tier} that the service accepts. */
exports.KnownTier = void 0;
(function (KnownTier) {
    /** Basic */
    KnownTier["Basic"] = "Basic";
    /** Premium */
    KnownTier["Premium"] = "Premium";
})(exports.KnownTier || (exports.KnownTier = {}));
/** Known values of {@link Family} that the service accepts. */
exports.KnownFamily = void 0;
(function (KnownFamily) {
    /** Direct */
    KnownFamily["Direct"] = "Direct";
    /** Exchange */
    KnownFamily["Exchange"] = "Exchange";
})(exports.KnownFamily || (exports.KnownFamily = {}));
/** Known values of {@link Size} that the service accepts. */
exports.KnownSize = void 0;
(function (KnownSize) {
    /** Free */
    KnownSize["Free"] = "Free";
    /** Metered */
    KnownSize["Metered"] = "Metered";
    /** Unlimited */
    KnownSize["Unlimited"] = "Unlimited";
})(exports.KnownSize || (exports.KnownSize = {}));
/** Known values of {@link Kind} that the service accepts. */
exports.KnownKind = void 0;
(function (KnownKind) {
    /** Direct */
    KnownKind["Direct"] = "Direct";
    /** Exchange */
    KnownKind["Exchange"] = "Exchange";
})(exports.KnownKind || (exports.KnownKind = {}));
/** Known values of {@link SessionAddressProvider} that the service accepts. */
exports.KnownSessionAddressProvider = void 0;
(function (KnownSessionAddressProvider) {
    /** Microsoft */
    KnownSessionAddressProvider["Microsoft"] = "Microsoft";
    /** Peer */
    KnownSessionAddressProvider["Peer"] = "Peer";
})(exports.KnownSessionAddressProvider || (exports.KnownSessionAddressProvider = {}));
/** Known values of {@link ConnectionState} that the service accepts. */
exports.KnownConnectionState = void 0;
(function (KnownConnectionState) {
    /** None */
    KnownConnectionState["None"] = "None";
    /** PendingApproval */
    KnownConnectionState["PendingApproval"] = "PendingApproval";
    /** Approved */
    KnownConnectionState["Approved"] = "Approved";
    /** ProvisioningStarted */
    KnownConnectionState["ProvisioningStarted"] = "ProvisioningStarted";
    /** ProvisioningFailed */
    KnownConnectionState["ProvisioningFailed"] = "ProvisioningFailed";
    /** ProvisioningCompleted */
    KnownConnectionState["ProvisioningCompleted"] = "ProvisioningCompleted";
    /** Validating */
    KnownConnectionState["Validating"] = "Validating";
    /** Active */
    KnownConnectionState["Active"] = "Active";
})(exports.KnownConnectionState || (exports.KnownConnectionState = {}));
/** Known values of {@link SessionStateV4} that the service accepts. */
exports.KnownSessionStateV4 = void 0;
(function (KnownSessionStateV4) {
    /** None */
    KnownSessionStateV4["None"] = "None";
    /** Idle */
    KnownSessionStateV4["Idle"] = "Idle";
    /** Connect */
    KnownSessionStateV4["Connect"] = "Connect";
    /** Active */
    KnownSessionStateV4["Active"] = "Active";
    /** OpenSent */
    KnownSessionStateV4["OpenSent"] = "OpenSent";
    /** OpenConfirm */
    KnownSessionStateV4["OpenConfirm"] = "OpenConfirm";
    /** OpenReceived */
    KnownSessionStateV4["OpenReceived"] = "OpenReceived";
    /** Established */
    KnownSessionStateV4["Established"] = "Established";
    /** PendingAdd */
    KnownSessionStateV4["PendingAdd"] = "PendingAdd";
    /** PendingUpdate */
    KnownSessionStateV4["PendingUpdate"] = "PendingUpdate";
    /** PendingRemove */
    KnownSessionStateV4["PendingRemove"] = "PendingRemove";
})(exports.KnownSessionStateV4 || (exports.KnownSessionStateV4 = {}));
/** Known values of {@link SessionStateV6} that the service accepts. */
exports.KnownSessionStateV6 = void 0;
(function (KnownSessionStateV6) {
    /** None */
    KnownSessionStateV6["None"] = "None";
    /** Idle */
    KnownSessionStateV6["Idle"] = "Idle";
    /** Connect */
    KnownSessionStateV6["Connect"] = "Connect";
    /** Active */
    KnownSessionStateV6["Active"] = "Active";
    /** OpenSent */
    KnownSessionStateV6["OpenSent"] = "OpenSent";
    /** OpenConfirm */
    KnownSessionStateV6["OpenConfirm"] = "OpenConfirm";
    /** OpenReceived */
    KnownSessionStateV6["OpenReceived"] = "OpenReceived";
    /** Established */
    KnownSessionStateV6["Established"] = "Established";
    /** PendingAdd */
    KnownSessionStateV6["PendingAdd"] = "PendingAdd";
    /** PendingUpdate */
    KnownSessionStateV6["PendingUpdate"] = "PendingUpdate";
    /** PendingRemove */
    KnownSessionStateV6["PendingRemove"] = "PendingRemove";
})(exports.KnownSessionStateV6 || (exports.KnownSessionStateV6 = {}));
/** Known values of {@link DirectPeeringType} that the service accepts. */
exports.KnownDirectPeeringType = void 0;
(function (KnownDirectPeeringType) {
    /** Edge */
    KnownDirectPeeringType["Edge"] = "Edge";
    /** Transit */
    KnownDirectPeeringType["Transit"] = "Transit";
    /** Cdn */
    KnownDirectPeeringType["Cdn"] = "Cdn";
    /** Internal */
    KnownDirectPeeringType["Internal"] = "Internal";
    /** Ix */
    KnownDirectPeeringType["Ix"] = "Ix";
    /** IxRs */
    KnownDirectPeeringType["IxRs"] = "IxRs";
    /** Voice */
    KnownDirectPeeringType["Voice"] = "Voice";
})(exports.KnownDirectPeeringType || (exports.KnownDirectPeeringType = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link LookingGlassCommand} that the service accepts. */
exports.KnownLookingGlassCommand = void 0;
(function (KnownLookingGlassCommand) {
    /** Traceroute */
    KnownLookingGlassCommand["Traceroute"] = "Traceroute";
    /** Ping */
    KnownLookingGlassCommand["Ping"] = "Ping";
    /** BgpRoute */
    KnownLookingGlassCommand["BgpRoute"] = "BgpRoute";
})(exports.KnownLookingGlassCommand || (exports.KnownLookingGlassCommand = {}));
/** Known values of {@link LookingGlassSourceType} that the service accepts. */
exports.KnownLookingGlassSourceType = void 0;
(function (KnownLookingGlassSourceType) {
    /** EdgeSite */
    KnownLookingGlassSourceType["EdgeSite"] = "EdgeSite";
    /** AzureRegion */
    KnownLookingGlassSourceType["AzureRegion"] = "AzureRegion";
})(exports.KnownLookingGlassSourceType || (exports.KnownLookingGlassSourceType = {}));
/** Known values of {@link Command} that the service accepts. */
exports.KnownCommand = void 0;
(function (KnownCommand) {
    /** Traceroute */
    KnownCommand["Traceroute"] = "Traceroute";
    /** Ping */
    KnownCommand["Ping"] = "Ping";
    /** BgpRoute */
    KnownCommand["BgpRoute"] = "BgpRoute";
})(exports.KnownCommand || (exports.KnownCommand = {}));
/** Known values of {@link Role} that the service accepts. */
exports.KnownRole = void 0;
(function (KnownRole) {
    /** Noc */
    KnownRole["Noc"] = "Noc";
    /** Policy */
    KnownRole["Policy"] = "Policy";
    /** Technical */
    KnownRole["Technical"] = "Technical";
    /** Service */
    KnownRole["Service"] = "Service";
    /** Escalation */
    KnownRole["Escalation"] = "Escalation";
    /** Other */
    KnownRole["Other"] = "Other";
})(exports.KnownRole || (exports.KnownRole = {}));
/** Known values of {@link ValidationState} that the service accepts. */
exports.KnownValidationState = void 0;
(function (KnownValidationState) {
    /** None */
    KnownValidationState["None"] = "None";
    /** Pending */
    KnownValidationState["Pending"] = "Pending";
    /** Approved */
    KnownValidationState["Approved"] = "Approved";
    /** Failed */
    KnownValidationState["Failed"] = "Failed";
})(exports.KnownValidationState || (exports.KnownValidationState = {}));
/** Known values of {@link PeeringLocationsKind} that the service accepts. */
exports.KnownPeeringLocationsKind = void 0;
(function (KnownPeeringLocationsKind) {
    /** Direct */
    KnownPeeringLocationsKind["Direct"] = "Direct";
    /** Exchange */
    KnownPeeringLocationsKind["Exchange"] = "Exchange";
})(exports.KnownPeeringLocationsKind || (exports.KnownPeeringLocationsKind = {}));
/** Known values of {@link PeeringLocationsDirectPeeringType} that the service accepts. */
exports.KnownPeeringLocationsDirectPeeringType = void 0;
(function (KnownPeeringLocationsDirectPeeringType) {
    /** Edge */
    KnownPeeringLocationsDirectPeeringType["Edge"] = "Edge";
    /** Transit */
    KnownPeeringLocationsDirectPeeringType["Transit"] = "Transit";
    /** Cdn */
    KnownPeeringLocationsDirectPeeringType["Cdn"] = "Cdn";
    /** Internal */
    KnownPeeringLocationsDirectPeeringType["Internal"] = "Internal";
    /** Ix */
    KnownPeeringLocationsDirectPeeringType["Ix"] = "Ix";
    /** IxRs */
    KnownPeeringLocationsDirectPeeringType["IxRs"] = "IxRs";
    /** Voice */
    KnownPeeringLocationsDirectPeeringType["Voice"] = "Voice";
})(exports.KnownPeeringLocationsDirectPeeringType || (exports.KnownPeeringLocationsDirectPeeringType = {}));
/** Known values of {@link PrefixValidationState} that the service accepts. */
exports.KnownPrefixValidationState = void 0;
(function (KnownPrefixValidationState) {
    /** None */
    KnownPrefixValidationState["None"] = "None";
    /** Invalid */
    KnownPrefixValidationState["Invalid"] = "Invalid";
    /** Verified */
    KnownPrefixValidationState["Verified"] = "Verified";
    /** Failed */
    KnownPrefixValidationState["Failed"] = "Failed";
    /** Pending */
    KnownPrefixValidationState["Pending"] = "Pending";
    /** Warning */
    KnownPrefixValidationState["Warning"] = "Warning";
    /** Unknown */
    KnownPrefixValidationState["Unknown"] = "Unknown";
})(exports.KnownPrefixValidationState || (exports.KnownPrefixValidationState = {}));
/** Known values of {@link LearnedType} that the service accepts. */
exports.KnownLearnedType = void 0;
(function (KnownLearnedType) {
    /** None */
    KnownLearnedType["None"] = "None";
    /** ViaServiceProvider */
    KnownLearnedType["ViaServiceProvider"] = "ViaServiceProvider";
    /** ViaSession */
    KnownLearnedType["ViaSession"] = "ViaSession";
})(exports.KnownLearnedType || (exports.KnownLearnedType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CdnPeeringPrefixListResult = {
    type: {
        name: "Composite",
        className: "CdnPeeringPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CdnPeeringPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckServiceProviderAvailabilityInput = {
    type: {
        name: "Composite",
        className: "CheckServiceProviderAvailabilityInput",
        modelProperties: {
            peeringServiceLocation: {
                serializedName: "peeringServiceLocation",
                type: {
                    name: "String"
                }
            },
            peeringServiceProvider: {
                serializedName: "peeringServiceProvider",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringListResult = {
    type: {
        name: "Composite",
        className: "PeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Peering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringSku = {
    type: {
        name: "Composite",
        className: "PeeringSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringPropertiesDirect = {
    type: {
        name: "Composite",
        className: "PeeringPropertiesDirect",
        modelProperties: {
            connections: {
                serializedName: "connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DirectConnection"
                        }
                    }
                }
            },
            useForPeeringService: {
                serializedName: "useForPeeringService",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            peerAsn: {
                serializedName: "peerAsn",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            directPeeringType: {
                serializedName: "directPeeringType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DirectConnection = {
    type: {
        name: "Composite",
        className: "DirectConnection",
        modelProperties: {
            bandwidthInMbps: {
                serializedName: "bandwidthInMbps",
                type: {
                    name: "Number"
                }
            },
            provisionedBandwidthInMbps: {
                serializedName: "provisionedBandwidthInMbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            sessionAddressProvider: {
                serializedName: "sessionAddressProvider",
                type: {
                    name: "String"
                }
            },
            useForPeeringService: {
                serializedName: "useForPeeringService",
                type: {
                    name: "Boolean"
                }
            },
            microsoftTrackingId: {
                serializedName: "microsoftTrackingId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            peeringDBFacilityId: {
                serializedName: "peeringDBFacilityId",
                type: {
                    name: "Number"
                }
            },
            connectionState: {
                serializedName: "connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            bgpSession: {
                serializedName: "bgpSession",
                type: {
                    name: "Composite",
                    className: "BgpSession"
                }
            },
            connectionIdentifier: {
                serializedName: "connectionIdentifier",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BgpSession = {
    type: {
        name: "Composite",
        className: "BgpSession",
        modelProperties: {
            sessionPrefixV4: {
                serializedName: "sessionPrefixV4",
                type: {
                    name: "String"
                }
            },
            sessionPrefixV6: {
                serializedName: "sessionPrefixV6",
                type: {
                    name: "String"
                }
            },
            microsoftSessionIPv4Address: {
                serializedName: "microsoftSessionIPv4Address",
                type: {
                    name: "String"
                }
            },
            microsoftSessionIPv6Address: {
                serializedName: "microsoftSessionIPv6Address",
                type: {
                    name: "String"
                }
            },
            peerSessionIPv4Address: {
                serializedName: "peerSessionIPv4Address",
                type: {
                    name: "String"
                }
            },
            peerSessionIPv6Address: {
                serializedName: "peerSessionIPv6Address",
                type: {
                    name: "String"
                }
            },
            sessionStateV4: {
                serializedName: "sessionStateV4",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sessionStateV6: {
                serializedName: "sessionStateV6",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            maxPrefixesAdvertisedV4: {
                serializedName: "maxPrefixesAdvertisedV4",
                type: {
                    name: "Number"
                }
            },
            maxPrefixesAdvertisedV6: {
                serializedName: "maxPrefixesAdvertisedV6",
                type: {
                    name: "Number"
                }
            },
            md5AuthenticationKey: {
                serializedName: "md5AuthenticationKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringPropertiesExchange = {
    type: {
        name: "Composite",
        className: "PeeringPropertiesExchange",
        modelProperties: {
            connections: {
                serializedName: "connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExchangeConnection"
                        }
                    }
                }
            },
            peerAsn: {
                serializedName: "peerAsn",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const ExchangeConnection = {
    type: {
        name: "Composite",
        className: "ExchangeConnection",
        modelProperties: {
            peeringDBFacilityId: {
                serializedName: "peeringDBFacilityId",
                type: {
                    name: "Number"
                }
            },
            connectionState: {
                serializedName: "connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            bgpSession: {
                serializedName: "bgpSession",
                type: {
                    name: "Composite",
                    className: "BgpSession"
                }
            },
            connectionIdentifier: {
                serializedName: "connectionIdentifier",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LookingGlassOutput = {
    type: {
        name: "Composite",
        className: "LookingGlassOutput",
        modelProperties: {
            command: {
                serializedName: "command",
                type: {
                    name: "String"
                }
            },
            output: {
                serializedName: "output",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplayInfo"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplayInfo = {
    type: {
        name: "Composite",
        className: "OperationDisplayInfo",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            }
        }
    }
};
const MetricDimension = {
    type: {
        name: "Composite",
        className: "MetricDimension",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContactDetail = {
    type: {
        name: "Composite",
        className: "ContactDetail",
        modelProperties: {
            role: {
                serializedName: "role",
                type: {
                    name: "String"
                }
            },
            email: {
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                serializedName: "phone",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeerAsnListResult = {
    type: {
        name: "Composite",
        className: "PeerAsnListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerAsn"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringLocationListResult = {
    type: {
        name: "Composite",
        className: "PeeringLocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringLocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringLocationPropertiesDirect = {
    type: {
        name: "Composite",
        className: "PeeringLocationPropertiesDirect",
        modelProperties: {
            peeringFacilities: {
                serializedName: "peeringFacilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DirectPeeringFacility"
                        }
                    }
                }
            },
            bandwidthOffers: {
                serializedName: "bandwidthOffers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringBandwidthOffer"
                        }
                    }
                }
            }
        }
    }
};
const DirectPeeringFacility = {
    type: {
        name: "Composite",
        className: "DirectPeeringFacility",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            directPeeringType: {
                serializedName: "directPeeringType",
                type: {
                    name: "String"
                }
            },
            peeringDBFacilityId: {
                serializedName: "peeringDBFacilityId",
                type: {
                    name: "Number"
                }
            },
            peeringDBFacilityLink: {
                serializedName: "peeringDBFacilityLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringBandwidthOffer = {
    type: {
        name: "Composite",
        className: "PeeringBandwidthOffer",
        modelProperties: {
            offerName: {
                serializedName: "offerName",
                type: {
                    name: "String"
                }
            },
            valueInMbps: {
                serializedName: "valueInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PeeringLocationPropertiesExchange = {
    type: {
        name: "Composite",
        className: "PeeringLocationPropertiesExchange",
        modelProperties: {
            peeringFacilities: {
                serializedName: "peeringFacilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExchangePeeringFacility"
                        }
                    }
                }
            }
        }
    }
};
const ExchangePeeringFacility = {
    type: {
        name: "Composite",
        className: "ExchangePeeringFacility",
        modelProperties: {
            exchangeName: {
                serializedName: "exchangeName",
                type: {
                    name: "String"
                }
            },
            bandwidthInMbps: {
                serializedName: "bandwidthInMbps",
                type: {
                    name: "Number"
                }
            },
            microsoftIPv4Address: {
                serializedName: "microsoftIPv4Address",
                type: {
                    name: "String"
                }
            },
            microsoftIPv6Address: {
                serializedName: "microsoftIPv6Address",
                type: {
                    name: "String"
                }
            },
            facilityIPv4Prefix: {
                serializedName: "facilityIPv4Prefix",
                type: {
                    name: "String"
                }
            },
            facilityIPv6Prefix: {
                serializedName: "facilityIPv6Prefix",
                type: {
                    name: "String"
                }
            },
            peeringDBFacilityId: {
                serializedName: "peeringDBFacilityId",
                type: {
                    name: "Number"
                }
            },
            peeringDBFacilityLink: {
                serializedName: "peeringDBFacilityLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringRegisteredAsnListResult = {
    type: {
        name: "Composite",
        className: "PeeringRegisteredAsnListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringRegisteredAsn"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringRegisteredPrefixListResult = {
    type: {
        name: "Composite",
        className: "PeeringRegisteredPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringRegisteredPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceTags = {
    type: {
        name: "Composite",
        className: "ResourceTags",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PeeringReceivedRouteListResult = {
    type: {
        name: "Composite",
        className: "PeeringReceivedRouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringReceivedRoute"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringReceivedRoute = {
    type: {
        name: "Composite",
        className: "PeeringReceivedRoute",
        modelProperties: {
            prefix: {
                serializedName: "prefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            originAsValidationState: {
                serializedName: "originAsValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rpkiValidationState: {
                serializedName: "rpkiValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            trustAnchor: {
                serializedName: "trustAnchor",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            receivedTimestamp: {
                serializedName: "receivedTimestamp",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorTestListResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTestListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTest"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServiceCountryListResult = {
    type: {
        name: "Composite",
        className: "PeeringServiceCountryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringServiceCountry"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServiceLocationListResult = {
    type: {
        name: "Composite",
        className: "PeeringServiceLocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringServiceLocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServicePrefixEvent = {
    type: {
        name: "Composite",
        className: "PeeringServicePrefixEvent",
        modelProperties: {
            eventTimestamp: {
                serializedName: "eventTimestamp",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            eventType: {
                serializedName: "eventType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventSummary: {
                serializedName: "eventSummary",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventLevel: {
                serializedName: "eventLevel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            eventDescription: {
                serializedName: "eventDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServicePrefixListResult = {
    type: {
        name: "Composite",
        className: "PeeringServicePrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringServicePrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServiceProviderListResult = {
    type: {
        name: "Composite",
        className: "PeeringServiceProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringServiceProvider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeeringServiceSku = {
    type: {
        name: "Composite",
        className: "PeeringServiceSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogAnalyticsWorkspaceProperties = {
    type: {
        name: "Composite",
        className: "LogAnalyticsWorkspaceProperties",
        modelProperties: {
            workspaceID: {
                serializedName: "workspaceID",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectedAgents: {
                serializedName: "connectedAgents",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PeeringServiceListResult = {
    type: {
        name: "Composite",
        className: "PeeringServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CdnPeeringPrefix = {
    type: {
        name: "Composite",
        className: "CdnPeeringPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { prefix: {
                serializedName: "properties.prefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, azureRegion: {
                serializedName: "properties.azureRegion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, azureService: {
                serializedName: "properties.azureService",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isPrimaryRegion: {
                serializedName: "properties.isPrimaryRegion",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, bgpCommunity: {
                serializedName: "properties.bgpCommunity",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Peering = {
    type: {
        name: "Composite",
        className: "Peering",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PeeringSku"
                }
            }, kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, direct: {
                serializedName: "properties.direct",
                type: {
                    name: "Composite",
                    className: "PeeringPropertiesDirect"
                }
            }, exchange: {
                serializedName: "properties.exchange",
                type: {
                    name: "Composite",
                    className: "PeeringPropertiesExchange"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeerAsn = {
    type: {
        name: "Composite",
        className: "PeerAsn",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { peerAsn: {
                serializedName: "properties.peerAsn",
                type: {
                    name: "Number"
                }
            }, peerContactDetail: {
                serializedName: "properties.peerContactDetail",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContactDetail"
                        }
                    }
                }
            }, peerName: {
                serializedName: "properties.peerName",
                type: {
                    name: "String"
                }
            }, validationState: {
                serializedName: "properties.validationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringLocation = {
    type: {
        name: "Composite",
        className: "PeeringLocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, direct: {
                serializedName: "properties.direct",
                type: {
                    name: "Composite",
                    className: "PeeringLocationPropertiesDirect"
                }
            }, exchange: {
                serializedName: "properties.exchange",
                type: {
                    name: "Composite",
                    className: "PeeringLocationPropertiesExchange"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                type: {
                    name: "String"
                }
            }, country: {
                serializedName: "properties.country",
                type: {
                    name: "String"
                }
            }, azureRegion: {
                serializedName: "properties.azureRegion",
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringRegisteredAsn = {
    type: {
        name: "Composite",
        className: "PeeringRegisteredAsn",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { asn: {
                serializedName: "properties.asn",
                type: {
                    name: "Number"
                }
            }, peeringServicePrefixKey: {
                serializedName: "properties.peeringServicePrefixKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringRegisteredPrefix = {
    type: {
        name: "Composite",
        className: "PeeringRegisteredPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { prefix: {
                serializedName: "properties.prefix",
                type: {
                    name: "String"
                }
            }, prefixValidationState: {
                serializedName: "properties.prefixValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringServicePrefixKey: {
                serializedName: "properties.peeringServicePrefixKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionMonitorTest = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTest",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sourceAgent: {
                serializedName: "properties.sourceAgent",
                type: {
                    name: "String"
                }
            }, destination: {
                serializedName: "properties.destination",
                type: {
                    name: "String"
                }
            }, destinationPort: {
                serializedName: "properties.destinationPort",
                type: {
                    name: "Number"
                }
            }, testFrequencyInSec: {
                serializedName: "properties.testFrequencyInSec",
                type: {
                    name: "Number"
                }
            }, isTestSuccessful: {
                serializedName: "properties.isTestSuccessful",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, path: {
                serializedName: "properties.path",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringServiceCountry = {
    type: {
        name: "Composite",
        className: "PeeringServiceCountry",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const PeeringServiceLocation = {
    type: {
        name: "Composite",
        className: "PeeringServiceLocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { country: {
                serializedName: "properties.country",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, azureRegion: {
                serializedName: "properties.azureRegion",
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringServicePrefix = {
    type: {
        name: "Composite",
        className: "PeeringServicePrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { prefix: {
                serializedName: "properties.prefix",
                type: {
                    name: "String"
                }
            }, prefixValidationState: {
                serializedName: "properties.prefixValidationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, learnedType: {
                serializedName: "properties.learnedType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, events: {
                serializedName: "properties.events",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeeringServicePrefixEvent"
                        }
                    }
                }
            }, peeringServicePrefixKey: {
                serializedName: "properties.peeringServicePrefixKey",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeeringServiceProvider = {
    type: {
        name: "Composite",
        className: "PeeringServiceProvider",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { serviceProviderName: {
                serializedName: "properties.serviceProviderName",
                type: {
                    name: "String"
                }
            }, peeringLocations: {
                serializedName: "properties.peeringLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PeeringService = {
    type: {
        name: "Composite",
        className: "PeeringService",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PeeringServiceSku"
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, peeringServiceLocation: {
                serializedName: "properties.peeringServiceLocation",
                type: {
                    name: "String"
                }
            }, peeringServiceProvider: {
                serializedName: "properties.peeringServiceProvider",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, providerPrimaryPeeringLocation: {
                serializedName: "properties.providerPrimaryPeeringLocation",
                type: {
                    name: "String"
                }
            }, providerBackupPeeringLocation: {
                serializedName: "properties.providerBackupPeeringLocation",
                type: {
                    name: "String"
                }
            }, logAnalyticsWorkspaceProperties: {
                serializedName: "properties.logAnalyticsWorkspaceProperties",
                type: {
                    name: "Composite",
                    className: "LogAnalyticsWorkspaceProperties"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CdnPeeringPrefixListResult: CdnPeeringPrefixListResult,
    Resource: Resource,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    CheckServiceProviderAvailabilityInput: CheckServiceProviderAvailabilityInput,
    PeeringListResult: PeeringListResult,
    PeeringSku: PeeringSku,
    PeeringPropertiesDirect: PeeringPropertiesDirect,
    DirectConnection: DirectConnection,
    BgpSession: BgpSession,
    SubResource: SubResource,
    PeeringPropertiesExchange: PeeringPropertiesExchange,
    ExchangeConnection: ExchangeConnection,
    LookingGlassOutput: LookingGlassOutput,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplayInfo: OperationDisplayInfo,
    ServiceSpecification: ServiceSpecification,
    MetricSpecification: MetricSpecification,
    MetricDimension: MetricDimension,
    ContactDetail: ContactDetail,
    PeerAsnListResult: PeerAsnListResult,
    PeeringLocationListResult: PeeringLocationListResult,
    PeeringLocationPropertiesDirect: PeeringLocationPropertiesDirect,
    DirectPeeringFacility: DirectPeeringFacility,
    PeeringBandwidthOffer: PeeringBandwidthOffer,
    PeeringLocationPropertiesExchange: PeeringLocationPropertiesExchange,
    ExchangePeeringFacility: ExchangePeeringFacility,
    PeeringRegisteredAsnListResult: PeeringRegisteredAsnListResult,
    PeeringRegisteredPrefixListResult: PeeringRegisteredPrefixListResult,
    ResourceTags: ResourceTags,
    PeeringReceivedRouteListResult: PeeringReceivedRouteListResult,
    PeeringReceivedRoute: PeeringReceivedRoute,
    ConnectionMonitorTestListResult: ConnectionMonitorTestListResult,
    PeeringServiceCountryListResult: PeeringServiceCountryListResult,
    PeeringServiceLocationListResult: PeeringServiceLocationListResult,
    PeeringServicePrefixEvent: PeeringServicePrefixEvent,
    PeeringServicePrefixListResult: PeeringServicePrefixListResult,
    PeeringServiceProviderListResult: PeeringServiceProviderListResult,
    PeeringServiceSku: PeeringServiceSku,
    LogAnalyticsWorkspaceProperties: LogAnalyticsWorkspaceProperties,
    PeeringServiceListResult: PeeringServiceListResult,
    CdnPeeringPrefix: CdnPeeringPrefix,
    Peering: Peering,
    PeerAsn: PeerAsn,
    PeeringLocation: PeeringLocation,
    PeeringRegisteredAsn: PeeringRegisteredAsn,
    PeeringRegisteredPrefix: PeeringRegisteredPrefix,
    ConnectionMonitorTest: ConnectionMonitorTest,
    PeeringServiceCountry: PeeringServiceCountry,
    PeeringServiceLocation: PeeringServiceLocation,
    PeeringServicePrefix: PeeringServicePrefix,
    PeeringServiceProvider: PeeringServiceProvider,
    PeeringService: PeeringService
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const peeringLocation = {
    parameterPath: "peeringLocation",
    mapper: {
        serializedName: "peeringLocation",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const checkServiceProviderAvailabilityInput = {
    parameterPath: "checkServiceProviderAvailabilityInput",
    mapper: CheckServiceProviderAvailabilityInput
};
const kind = {
    parameterPath: "kind",
    mapper: {
        serializedName: "kind",
        required: true,
        type: {
            name: "String"
        }
    }
};
const asn = {
    parameterPath: ["options", "asn"],
    mapper: {
        serializedName: "asn",
        type: {
            name: "Number"
        }
    }
};
const command = {
    parameterPath: "command",
    mapper: {
        serializedName: "command",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sourceType = {
    parameterPath: "sourceType",
    mapper: {
        serializedName: "sourceType",
        required: true,
        type: {
            name: "String"
        }
    }
};
const sourceLocation = {
    parameterPath: "sourceLocation",
    mapper: {
        serializedName: "sourceLocation",
        required: true,
        type: {
            name: "String"
        }
    }
};
const destinationIP = {
    parameterPath: "destinationIP",
    mapper: {
        serializedName: "destinationIP",
        required: true,
        type: {
            name: "String"
        }
    }
};
const peerAsnName = {
    parameterPath: "peerAsnName",
    mapper: {
        serializedName: "peerAsnName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const peerAsn = {
    parameterPath: "peerAsn",
    mapper: PeerAsn
};
const kind1 = {
    parameterPath: "kind",
    mapper: {
        serializedName: "kind",
        required: true,
        type: {
            name: "String"
        }
    }
};
const directPeeringType = {
    parameterPath: ["options", "directPeeringType"],
    mapper: {
        serializedName: "directPeeringType",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const peeringName = {
    parameterPath: "peeringName",
    mapper: {
        serializedName: "peeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const registeredAsnName = {
    parameterPath: "registeredAsnName",
    mapper: {
        serializedName: "registeredAsnName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const registeredAsn = {
    parameterPath: "registeredAsn",
    mapper: PeeringRegisteredAsn
};
const registeredPrefixName = {
    parameterPath: "registeredPrefixName",
    mapper: {
        serializedName: "registeredPrefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const registeredPrefix = {
    parameterPath: "registeredPrefix",
    mapper: PeeringRegisteredPrefix
};
const peering = {
    parameterPath: "peering",
    mapper: Peering
};
const tags = {
    parameterPath: "tags",
    mapper: ResourceTags
};
const prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
        serializedName: "prefix",
        type: {
            name: "String"
        }
    }
};
const asPath = {
    parameterPath: ["options", "asPath"],
    mapper: {
        serializedName: "asPath",
        type: {
            name: "String"
        }
    }
};
const originAsValidationState = {
    parameterPath: ["options", "originAsValidationState"],
    mapper: {
        serializedName: "originAsValidationState",
        type: {
            name: "String"
        }
    }
};
const rpkiValidationState = {
    parameterPath: ["options", "rpkiValidationState"],
    mapper: {
        serializedName: "rpkiValidationState",
        type: {
            name: "String"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const peeringServiceName = {
    parameterPath: "peeringServiceName",
    mapper: {
        serializedName: "peeringServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectionMonitorTestName = {
    parameterPath: "connectionMonitorTestName",
    mapper: {
        serializedName: "connectionMonitorTestName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectionMonitorTest = {
    parameterPath: "connectionMonitorTest",
    mapper: ConnectionMonitorTest
};
const country = {
    parameterPath: ["options", "country"],
    mapper: {
        serializedName: "country",
        type: {
            name: "String"
        }
    }
};
const prefixName = {
    parameterPath: "prefixName",
    mapper: {
        serializedName: "prefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const peeringServicePrefix = {
    parameterPath: "peeringServicePrefix",
    mapper: PeeringServicePrefix
};
const peeringService = {
    parameterPath: "peeringService",
    mapper: PeeringService
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CdnPeeringPrefixes operations. */
class CdnPeeringPrefixesImpl {
    /**
     * Initialize a new instance of the class CdnPeeringPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the advertised prefixes for the specified peering location
     * @param peeringLocation The peering location.
     * @param options The options parameters.
     */
    list(peeringLocation, options) {
        const iter = this.listPagingAll(peeringLocation, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(peeringLocation, options, settings);
            }
        };
    }
    listPagingPage(peeringLocation, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(peeringLocation, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(peeringLocation, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(peeringLocation, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(peeringLocation, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the advertised prefixes for the specified peering location
     * @param peeringLocation The peering location.
     * @param options The options parameters.
     */
    _list(peeringLocation, options) {
        return this.client.sendOperationRequest({ peeringLocation, options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param peeringLocation The peering location.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(peeringLocation, nextLink, options) {
        return this.client.sendOperationRequest({ peeringLocation, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/cdnPeeringPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CdnPeeringPrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [peeringLocation, apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CdnPeeringPrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [peeringLocation, apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LegacyPeerings operations. */
class LegacyPeeringsImpl {
    /**
     * Initialize a new instance of the class LegacyPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the legacy peerings under the given subscription matching the specified kind and
     * location.
     * @param peeringLocation The location of the peering.
     * @param kind The kind of the peering.
     * @param options The options parameters.
     */
    list(peeringLocation, kind, options) {
        const iter = this.listPagingAll(peeringLocation, kind, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(peeringLocation, kind, options, settings);
            }
        };
    }
    listPagingPage(peeringLocation, kind, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(peeringLocation, kind, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(peeringLocation, kind, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(peeringLocation, kind, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(peeringLocation, kind, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the legacy peerings under the given subscription matching the specified kind and
     * location.
     * @param peeringLocation The location of the peering.
     * @param kind The kind of the peering.
     * @param options The options parameters.
     */
    _list(peeringLocation, kind, options) {
        return this.client.sendOperationRequest({ peeringLocation, kind, options }, listOperationSpec$5);
    }
    /**
     * ListNext
     * @param peeringLocation The location of the peering.
     * @param kind The kind of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(peeringLocation, kind, nextLink, options) {
        return this.client.sendOperationRequest({ peeringLocation, kind, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/legacyPeerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        peeringLocation,
        apiVersion,
        kind,
        asn
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        peeringLocation,
        apiVersion,
        kind,
        asn
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing LookingGlass operations. */
class LookingGlassImpl {
    /**
     * Initialize a new instance of the class LookingGlass class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Run looking glass functionality
     * @param command The command to be executed: ping, traceroute, bgpRoute.
     * @param sourceType The type of the source: Edge site or Azure Region.
     * @param sourceLocation The location of the source.
     * @param destinationIP The IP address of the destination.
     * @param options The options parameters.
     */
    invoke(command, sourceType, sourceLocation, destinationIP, options) {
        return this.client.sendOperationRequest({ command, sourceType, sourceLocation, destinationIP, options }, invokeOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const invokeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/lookingGlass",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LookingGlassOutput
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        command,
        sourceType,
        sourceLocation,
        destinationIP
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available API operations for peering resources.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available API operations for peering resources.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/providers/Microsoft.Peering/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeerAsns operations. */
class PeerAsnsImpl {
    /**
     * Initialize a new instance of the class PeerAsns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the peer ASNs under the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the peer ASN with the specified name under the given subscription.
     * @param peerAsnName The peer ASN name.
     * @param options The options parameters.
     */
    get(peerAsnName, options) {
        return this.client.sendOperationRequest({ peerAsnName, options }, getOperationSpec$6);
    }
    /**
     * Creates a new peer ASN or updates an existing peer ASN with the specified name under the given
     * subscription.
     * @param peerAsnName The peer ASN name.
     * @param peerAsn The peer ASN.
     * @param options The options parameters.
     */
    createOrUpdate(peerAsnName, peerAsn, options) {
        return this.client.sendOperationRequest({ peerAsnName, peerAsn, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * Deletes an existing peer ASN with the specified name under the given subscription.
     * @param peerAsnName The peer ASN name.
     * @param options The options parameters.
     */
    delete(peerAsnName, options) {
        return this.client.sendOperationRequest({ peerAsnName, options }, deleteOperationSpec$6);
    }
    /**
     * Lists all of the peer ASNs under the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peerAsns/{peerAsnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerAsn
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        peerAsnName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peerAsns/{peerAsnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PeerAsn
        },
        201: {
            bodyMapper: PeerAsn
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: peerAsn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        peerAsnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peerAsns/{peerAsnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        peerAsnName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peerAsns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerAsnListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$c
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerAsnListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeeringLocations operations. */
class PeeringLocationsImpl {
    /**
     * Initialize a new instance of the class PeeringLocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available peering locations for the specified kind of peering.
     * @param kind The kind of the peering.
     * @param options The options parameters.
     */
    list(kind, options) {
        const iter = this.listPagingAll(kind, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(kind, options, settings);
            }
        };
    }
    listPagingPage(kind, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(kind, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(kind, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(kind, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(kind, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available peering locations for the specified kind of peering.
     * @param kind The kind of the peering.
     * @param options The options parameters.
     */
    _list(kind, options) {
        return this.client.sendOperationRequest({ kind, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param kind The kind of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(kind, nextLink, options) {
        return this.client.sendOperationRequest({ kind, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peeringLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringLocationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        kind1,
        directPeeringType
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringLocationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        kind1,
        directPeeringType
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RegisteredAsns operations. */
class RegisteredAsnsImpl {
    /**
     * Initialize a new instance of the class RegisteredAsns class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all registered ASNs under the given subscription, resource group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    listByPeering(resourceGroupName, peeringName, options) {
        const iter = this.listByPeeringPagingAll(resourceGroupName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPeeringPagingPage(resourceGroupName, peeringName, options, settings);
            }
        };
    }
    listByPeeringPagingPage(resourceGroupName, peeringName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPeering(resourceGroupName, peeringName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPeeringNext(resourceGroupName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPeeringPagingAll(resourceGroupName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPeeringPagingPage(resourceGroupName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an existing registered ASN with the specified name under the given subscription, resource group
     * and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredAsnName The name of the registered ASN.
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringName, registeredAsnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, registeredAsnName, options }, getOperationSpec$5);
    }
    /**
     * Creates a new registered ASN with the specified name under the given subscription, resource group
     * and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredAsnName The name of the ASN.
     * @param registeredAsn The properties needed to create a registered ASN.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringName, registeredAsnName, registeredAsn, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringName,
            registeredAsnName,
            registeredAsn,
            options
        }, createOrUpdateOperationSpec$5);
    }
    /**
     * Deletes an existing registered ASN with the specified name under the given subscription, resource
     * group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredAsnName The name of the registered ASN.
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringName, registeredAsnName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, registeredAsnName, options }, deleteOperationSpec$5);
    }
    /**
     * Lists all registered ASNs under the given subscription, resource group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _listByPeering(resourceGroupName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, options }, listByPeeringOperationSpec$2);
    }
    /**
     * ListByPeeringNext
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the ListByPeering method.
     * @param options The options parameters.
     */
    _listByPeeringNext(resourceGroupName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, nextLink, options }, listByPeeringNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredAsns/{registeredAsnName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredAsn
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredAsnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredAsns/{registeredAsnName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredAsn
        },
        201: {
            bodyMapper: PeeringRegisteredAsn
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: registeredAsn,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredAsnName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredAsns/{registeredAsnName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredAsnName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByPeeringOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredAsns",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredAsnListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByPeeringNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredAsnListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RegisteredPrefixes operations. */
class RegisteredPrefixesImpl {
    /**
     * Initialize a new instance of the class RegisteredPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all registered prefixes under the given subscription, resource group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    listByPeering(resourceGroupName, peeringName, options) {
        const iter = this.listByPeeringPagingAll(resourceGroupName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPeeringPagingPage(resourceGroupName, peeringName, options, settings);
            }
        };
    }
    listByPeeringPagingPage(resourceGroupName, peeringName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPeering(resourceGroupName, peeringName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPeeringNext(resourceGroupName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPeeringPagingAll(resourceGroupName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPeeringPagingPage(resourceGroupName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an existing registered prefix with the specified name under the given subscription, resource
     * group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredPrefixName The name of the registered prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringName, registeredPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, registeredPrefixName, options }, getOperationSpec$4);
    }
    /**
     * Creates a new registered prefix with the specified name under the given subscription, resource group
     * and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredPrefixName The name of the registered prefix.
     * @param registeredPrefix The properties needed to create a registered prefix.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringName, registeredPrefixName, registeredPrefix, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringName,
            registeredPrefixName,
            registeredPrefix,
            options
        }, createOrUpdateOperationSpec$4);
    }
    /**
     * Deletes an existing registered prefix with the specified name under the given subscription, resource
     * group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param registeredPrefixName The name of the registered prefix.
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringName, registeredPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, registeredPrefixName, options }, deleteOperationSpec$4);
    }
    /**
     * Lists all registered prefixes under the given subscription, resource group and peering.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _listByPeering(resourceGroupName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, options }, listByPeeringOperationSpec$1);
    }
    /**
     * ListByPeeringNext
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the ListByPeering method.
     * @param options The options parameters.
     */
    _listByPeeringNext(resourceGroupName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, nextLink, options }, listByPeeringNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredPrefixes/{registeredPrefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredPrefix
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredPrefixes/{registeredPrefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredPrefix
        },
        201: {
            bodyMapper: PeeringRegisteredPrefix
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: registeredPrefix,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredPrefixes/{registeredPrefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName,
        registeredPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByPeeringOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/registeredPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredPrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByPeeringNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringRegisteredPrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Peerings operations. */
class PeeringsImpl {
    /**
     * Initialize a new instance of the class Peerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the peerings under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the peerings under the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets an existing peering with the specified name under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, options }, getOperationSpec$3);
    }
    /**
     * Creates a new peering or updates an existing peering with the specified name under the given
     * subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param peering The properties needed to create or update a peering.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringName, peering, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, peering, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes an existing peering with the specified name under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, options }, deleteOperationSpec$3);
    }
    /**
     * Updates tags for a peering with the specified name under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param tags The resource tags.
     * @param options The options parameters.
     */
    update(resourceGroupName, peeringName, tags, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, tags, options }, updateOperationSpec$1);
    }
    /**
     * Lists all of the peerings under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Lists all of the peerings under the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Peering
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Peering
        },
        201: {
            bodyMapper: Peering
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: peering,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Peering
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: tags,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ReceivedRoutes operations. */
class ReceivedRoutesImpl {
    /**
     * Initialize a new instance of the class ReceivedRoutes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the prefixes received over the specified peering under the given subscription and resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    listByPeering(resourceGroupName, peeringName, options) {
        const iter = this.listByPeeringPagingAll(resourceGroupName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPeeringPagingPage(resourceGroupName, peeringName, options, settings);
            }
        };
    }
    listByPeeringPagingPage(resourceGroupName, peeringName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPeering(resourceGroupName, peeringName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPeeringNext(resourceGroupName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPeeringPagingAll(resourceGroupName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPeeringPagingPage(resourceGroupName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the prefixes received over the specified peering under the given subscription and resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _listByPeering(resourceGroupName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, options }, listByPeeringOperationSpec);
    }
    /**
     * ListByPeeringNext
     * @param resourceGroupName The name of the resource group.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the ListByPeering method.
     * @param options The options parameters.
     */
    _listByPeeringNext(resourceGroupName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringName, nextLink, options }, listByPeeringNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByPeeringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peerings/{peeringName}/receivedRoutes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringReceivedRouteListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        prefix,
        asPath,
        originAsValidationState,
        rpkiValidationState,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByPeeringNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringReceivedRouteListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [
        apiVersion,
        prefix,
        asPath,
        originAsValidationState,
        rpkiValidationState,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectionMonitorTests operations. */
class ConnectionMonitorTestsImpl {
    /**
     * Initialize a new instance of the class ConnectionMonitorTests class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all connection monitor tests under the given subscription, resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param options The options parameters.
     */
    listByPeeringService(resourceGroupName, peeringServiceName, options) {
        const iter = this.listByPeeringServicePagingAll(resourceGroupName, peeringServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options, settings);
            }
        };
    }
    listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringServicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPeeringService(resourceGroupName, peeringServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPeeringServiceNext(resourceGroupName, peeringServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPeeringServicePagingAll(resourceGroupName, peeringServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an existing connection monitor test with the specified name under the given subscription,
     * resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param connectionMonitorTestName The name of the connection monitor test
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringServiceName, connectionMonitorTestName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringServiceName,
            connectionMonitorTestName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Creates or updates a connection monitor test with the specified name under the given subscription,
     * resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param connectionMonitorTestName The name of the connection monitor test
     * @param connectionMonitorTest The properties needed to create a connection monitor test
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringServiceName, connectionMonitorTestName, connectionMonitorTest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringServiceName,
            connectionMonitorTestName,
            connectionMonitorTest,
            options
        }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes an existing connection monitor test with the specified name under the given subscription,
     * resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param connectionMonitorTestName The name of the connection monitor test
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringServiceName, connectionMonitorTestName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringServiceName,
            connectionMonitorTestName,
            options
        }, deleteOperationSpec$2);
    }
    /**
     * Lists all connection monitor tests under the given subscription, resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param options The options parameters.
     */
    _listByPeeringService(resourceGroupName, peeringServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, options }, listByPeeringServiceOperationSpec$1);
    }
    /**
     * ListByPeeringServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param nextLink The nextLink from the previous successful call to the ListByPeeringService method.
     * @param options The options parameters.
     */
    _listByPeeringServiceNext(resourceGroupName, peeringServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, nextLink, options }, listByPeeringServiceNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/connectionMonitorTests/{connectionMonitorTestName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorTest
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        connectionMonitorTestName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/connectionMonitorTests/{connectionMonitorTestName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorTest
        },
        201: {
            bodyMapper: ConnectionMonitorTest
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: connectionMonitorTest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        connectionMonitorTestName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/connectionMonitorTests/{connectionMonitorTestName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        connectionMonitorTestName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByPeeringServiceOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/connectionMonitorTests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorTestListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByPeeringServiceNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorTestListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeeringServiceCountries operations. */
class PeeringServiceCountriesImpl {
    /**
     * Initialize a new instance of the class PeeringServiceCountries class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available countries for peering service.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available countries for peering service.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peeringServiceCountries",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceCountryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceCountryListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeeringServiceLocations operations. */
class PeeringServiceLocationsImpl {
    /**
     * Initialize a new instance of the class PeeringServiceLocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available locations for peering service.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available locations for peering service.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peeringServiceLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceLocationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, country],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceLocationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, country],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Prefixes operations. */
class PrefixesImpl {
    /**
     * Initialize a new instance of the class Prefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all prefixes under the given subscription, resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param options The options parameters.
     */
    listByPeeringService(resourceGroupName, peeringServiceName, options) {
        const iter = this.listByPeeringServicePagingAll(resourceGroupName, peeringServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options, settings);
            }
        };
    }
    listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringServicePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPeeringService(resourceGroupName, peeringServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPeeringServiceNext(resourceGroupName, peeringServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPeeringServicePagingAll(resourceGroupName, peeringServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPeeringServicePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByPeeringServicePagingPage(resourceGroupName, peeringServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets an existing prefix with the specified name under the given subscription, resource group and
     * peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param prefixName The name of the prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringServiceName, prefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, prefixName, options }, getOperationSpec$1);
    }
    /**
     * Creates a new prefix with the specified name under the given subscription, resource group and
     * peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param prefixName The name of the prefix.
     * @param peeringServicePrefix The properties needed to create a prefix.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringServiceName, prefixName, peeringServicePrefix, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            peeringServiceName,
            prefixName,
            peeringServicePrefix,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes an existing prefix with the specified name under the given subscription, resource group and
     * peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param prefixName The name of the prefix.
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringServiceName, prefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, prefixName, options }, deleteOperationSpec$1);
    }
    /**
     * Lists all prefixes under the given subscription, resource group and peering service.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param options The options parameters.
     */
    _listByPeeringService(resourceGroupName, peeringServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, options }, listByPeeringServiceOperationSpec);
    }
    /**
     * ListByPeeringServiceNext
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param nextLink The nextLink from the previous successful call to the ListByPeeringService method.
     * @param options The options parameters.
     */
    _listByPeeringServiceNext(resourceGroupName, peeringServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, nextLink, options }, listByPeeringServiceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/prefixes/{prefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServicePrefix
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        prefixName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/prefixes/{prefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PeeringServicePrefix
        },
        201: {
            bodyMapper: PeeringServicePrefix
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: peeringServicePrefix,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        prefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/prefixes/{prefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName,
        prefixName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByPeeringServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}/prefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServicePrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByPeeringServiceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServicePrefixListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeeringServiceProviders operations. */
class PeeringServiceProvidersImpl {
    /**
     * Initialize a new instance of the class PeeringServiceProviders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available peering service locations for the specified kind of peering.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available peering service locations for the specified kind of peering.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peeringServiceProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceProviderListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceProviderListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeeringServices operations. */
class PeeringServicesImpl {
    /**
     * Initialize a new instance of the class PeeringServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the peering services under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the peerings under the given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets an existing peering service with the specified name under the given subscription and resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, peeringServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, options }, getOperationSpec);
    }
    /**
     * Creates a new peering service or updates an existing peering with the specified name under the given
     * subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param peeringService The properties needed to create or update a peering service.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, peeringServiceName, peeringService, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, peeringService, options }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes an existing peering service with the specified name under the given subscription and
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param options The options parameters.
     */
    delete(resourceGroupName, peeringServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, options }, deleteOperationSpec);
    }
    /**
     * Updates tags for a peering service with the specified name under the given subscription and resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param peeringServiceName The name of the peering service.
     * @param tags The resource tags.
     * @param options The options parameters.
     */
    update(resourceGroupName, peeringServiceName, tags, options) {
        return this.client.sendOperationRequest({ resourceGroupName, peeringServiceName, tags, options }, updateOperationSpec);
    }
    /**
     * Lists all of the peering services under the given subscription and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Lists all of the peerings under the given subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Initialize Peering Service for Connection Monitor functionality
     * @param options The options parameters.
     */
    initializeConnectionMonitor(options) {
        return this.client.sendOperationRequest({ options }, initializeConnectionMonitorOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PeeringService
        },
        201: {
            bodyMapper: PeeringService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: peeringService,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices/{peeringServiceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PeeringService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: tags,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        peeringServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Peering/peeringServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/peeringServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const initializeConnectionMonitorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/initializeConnectionMonitor",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeeringServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class PeeringManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the PeeringManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The Azure subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-peering/2.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-06-01";
        this.cdnPeeringPrefixes = new CdnPeeringPrefixesImpl(this);
        this.legacyPeerings = new LegacyPeeringsImpl(this);
        this.lookingGlass = new LookingGlassImpl(this);
        this.operations = new OperationsImpl(this);
        this.peerAsns = new PeerAsnsImpl(this);
        this.peeringLocations = new PeeringLocationsImpl(this);
        this.registeredAsns = new RegisteredAsnsImpl(this);
        this.registeredPrefixes = new RegisteredPrefixesImpl(this);
        this.peerings = new PeeringsImpl(this);
        this.receivedRoutes = new ReceivedRoutesImpl(this);
        this.connectionMonitorTests = new ConnectionMonitorTestsImpl(this);
        this.peeringServiceCountries = new PeeringServiceCountriesImpl(this);
        this.peeringServiceLocations = new PeeringServiceLocationsImpl(this);
        this.prefixes = new PrefixesImpl(this);
        this.peeringServiceProviders = new PeeringServiceProvidersImpl(this);
        this.peeringServices = new PeeringServicesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
    /**
     * Checks if the peering service provider is present within 1000 miles of customer's location
     * @param checkServiceProviderAvailabilityInput The CheckServiceProviderAvailabilityInput indicating
     *                                              customer location and service provider.
     * @param options The options parameters.
     */
    checkServiceProviderAvailability(checkServiceProviderAvailabilityInput, options) {
        return this.sendOperationRequest({ checkServiceProviderAvailabilityInput, options }, checkServiceProviderAvailabilityOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkServiceProviderAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Peering/checkServiceProviderAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: checkServiceProviderAvailabilityInput,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};

exports.PeeringManagementClient = PeeringManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
