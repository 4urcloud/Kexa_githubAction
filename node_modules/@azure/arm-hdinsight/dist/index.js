'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link OSType} that the service accepts. */
exports.KnownOSType = void 0;
(function (KnownOSType) {
    /** Windows */
    KnownOSType["Windows"] = "Windows";
    /** Linux */
    KnownOSType["Linux"] = "Linux";
})(exports.KnownOSType || (exports.KnownOSType = {}));
/** Known values of {@link Tier} that the service accepts. */
exports.KnownTier = void 0;
(function (KnownTier) {
    /** Standard */
    KnownTier["Standard"] = "Standard";
    /** Premium */
    KnownTier["Premium"] = "Premium";
})(exports.KnownTier || (exports.KnownTier = {}));
/** Known values of {@link DirectoryType} that the service accepts. */
exports.KnownDirectoryType = void 0;
(function (KnownDirectoryType) {
    /** ActiveDirectory */
    KnownDirectoryType["ActiveDirectory"] = "ActiveDirectory";
})(exports.KnownDirectoryType || (exports.KnownDirectoryType = {}));
/** Known values of {@link DaysOfWeek} that the service accepts. */
exports.KnownDaysOfWeek = void 0;
(function (KnownDaysOfWeek) {
    /** Monday */
    KnownDaysOfWeek["Monday"] = "Monday";
    /** Tuesday */
    KnownDaysOfWeek["Tuesday"] = "Tuesday";
    /** Wednesday */
    KnownDaysOfWeek["Wednesday"] = "Wednesday";
    /** Thursday */
    KnownDaysOfWeek["Thursday"] = "Thursday";
    /** Friday */
    KnownDaysOfWeek["Friday"] = "Friday";
    /** Saturday */
    KnownDaysOfWeek["Saturday"] = "Saturday";
    /** Sunday */
    KnownDaysOfWeek["Sunday"] = "Sunday";
})(exports.KnownDaysOfWeek || (exports.KnownDaysOfWeek = {}));
/** Known values of {@link JsonWebKeyEncryptionAlgorithm} that the service accepts. */
exports.KnownJsonWebKeyEncryptionAlgorithm = void 0;
(function (KnownJsonWebKeyEncryptionAlgorithm) {
    /** RSAOaep */
    KnownJsonWebKeyEncryptionAlgorithm["RSAOaep"] = "RSA-OAEP";
    /** RSAOaep256 */
    KnownJsonWebKeyEncryptionAlgorithm["RSAOaep256"] = "RSA-OAEP-256";
    /** RSA15 */
    KnownJsonWebKeyEncryptionAlgorithm["RSA15"] = "RSA1_5";
})(exports.KnownJsonWebKeyEncryptionAlgorithm || (exports.KnownJsonWebKeyEncryptionAlgorithm = {}));
/** Known values of {@link ResourceProviderConnection} that the service accepts. */
exports.KnownResourceProviderConnection = void 0;
(function (KnownResourceProviderConnection) {
    /** Inbound */
    KnownResourceProviderConnection["Inbound"] = "Inbound";
    /** Outbound */
    KnownResourceProviderConnection["Outbound"] = "Outbound";
})(exports.KnownResourceProviderConnection || (exports.KnownResourceProviderConnection = {}));
/** Known values of {@link PrivateLink} that the service accepts. */
exports.KnownPrivateLink = void 0;
(function (KnownPrivateLink) {
    /** Disabled */
    KnownPrivateLink["Disabled"] = "Disabled";
    /** Enabled */
    KnownPrivateLink["Enabled"] = "Enabled";
})(exports.KnownPrivateLink || (exports.KnownPrivateLink = {}));
/** Known values of {@link PrivateLinkConfigurationProvisioningState} that the service accepts. */
exports.KnownPrivateLinkConfigurationProvisioningState = void 0;
(function (KnownPrivateLinkConfigurationProvisioningState) {
    /** InProgress */
    KnownPrivateLinkConfigurationProvisioningState["InProgress"] = "InProgress";
    /** Failed */
    KnownPrivateLinkConfigurationProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownPrivateLinkConfigurationProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPrivateLinkConfigurationProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownPrivateLinkConfigurationProvisioningState["Deleting"] = "Deleting";
})(exports.KnownPrivateLinkConfigurationProvisioningState || (exports.KnownPrivateLinkConfigurationProvisioningState = {}));
/** Known values of {@link PrivateIPAllocationMethod} that the service accepts. */
exports.KnownPrivateIPAllocationMethod = void 0;
(function (KnownPrivateIPAllocationMethod) {
    /** Dynamic */
    KnownPrivateIPAllocationMethod["Dynamic"] = "dynamic";
    /** Static */
    KnownPrivateIPAllocationMethod["Static"] = "static";
})(exports.KnownPrivateIPAllocationMethod || (exports.KnownPrivateIPAllocationMethod = {}));
/** Known values of {@link ResourceIdentityType} that the service accepts. */
exports.KnownResourceIdentityType = void 0;
(function (KnownResourceIdentityType) {
    /** SystemAssigned */
    KnownResourceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownResourceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownResourceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned, UserAssigned";
    /** None */
    KnownResourceIdentityType["None"] = "None";
})(exports.KnownResourceIdentityType || (exports.KnownResourceIdentityType = {}));
/** Known values of {@link HDInsightClusterProvisioningState} that the service accepts. */
exports.KnownHDInsightClusterProvisioningState = void 0;
(function (KnownHDInsightClusterProvisioningState) {
    /** InProgress */
    KnownHDInsightClusterProvisioningState["InProgress"] = "InProgress";
    /** Failed */
    KnownHDInsightClusterProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownHDInsightClusterProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownHDInsightClusterProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownHDInsightClusterProvisioningState["Deleting"] = "Deleting";
})(exports.KnownHDInsightClusterProvisioningState || (exports.KnownHDInsightClusterProvisioningState = {}));
/** Known values of {@link PrivateLinkServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateLinkServiceConnectionStatus = void 0;
(function (KnownPrivateLinkServiceConnectionStatus) {
    /** Approved */
    KnownPrivateLinkServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateLinkServiceConnectionStatus["Rejected"] = "Rejected";
    /** Pending */
    KnownPrivateLinkServiceConnectionStatus["Pending"] = "Pending";
    /** Removed */
    KnownPrivateLinkServiceConnectionStatus["Removed"] = "Removed";
})(exports.KnownPrivateLinkServiceConnectionStatus || (exports.KnownPrivateLinkServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** InProgress */
    KnownPrivateEndpointConnectionProvisioningState["InProgress"] = "InProgress";
    /** Updating */
    KnownPrivateEndpointConnectionProvisioningState["Updating"] = "Updating";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Canceled */
    KnownPrivateEndpointConnectionProvisioningState["Canceled"] = "Canceled";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link RoleName} that the service accepts. */
exports.KnownRoleName = void 0;
(function (KnownRoleName) {
    /** Workernode */
    KnownRoleName["Workernode"] = "workernode";
})(exports.KnownRoleName || (exports.KnownRoleName = {}));
/** Known values of {@link AsyncOperationState} that the service accepts. */
exports.KnownAsyncOperationState = void 0;
(function (KnownAsyncOperationState) {
    /** InProgress */
    KnownAsyncOperationState["InProgress"] = "InProgress";
    /** Succeeded */
    KnownAsyncOperationState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownAsyncOperationState["Failed"] = "Failed";
})(exports.KnownAsyncOperationState || (exports.KnownAsyncOperationState = {}));
/** Known values of {@link FilterMode} that the service accepts. */
exports.KnownFilterMode = void 0;
(function (KnownFilterMode) {
    /** Exclude */
    KnownFilterMode["Exclude"] = "Exclude";
    /** Include */
    KnownFilterMode["Include"] = "Include";
    /** Recommend */
    KnownFilterMode["Recommend"] = "Recommend";
    /** Default */
    KnownFilterMode["Default"] = "Default";
})(exports.KnownFilterMode || (exports.KnownFilterMode = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ClusterCreateParametersExtended = {
    type: {
        name: "Composite",
        className: "ClusterCreateParametersExtended",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ClusterCreateProperties"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ClusterIdentity"
                }
            }
        }
    }
};
const ClusterCreateProperties = {
    type: {
        name: "Composite",
        className: "ClusterCreateProperties",
        modelProperties: {
            clusterVersion: {
                serializedName: "clusterVersion",
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            clusterDefinition: {
                serializedName: "clusterDefinition",
                type: {
                    name: "Composite",
                    className: "ClusterDefinition"
                }
            },
            kafkaRestProperties: {
                serializedName: "kafkaRestProperties",
                type: {
                    name: "Composite",
                    className: "KafkaRestProperties"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            computeProfile: {
                serializedName: "computeProfile",
                type: {
                    name: "Composite",
                    className: "ComputeProfile"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            },
            diskEncryptionProperties: {
                serializedName: "diskEncryptionProperties",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionProperties"
                }
            },
            encryptionInTransitProperties: {
                serializedName: "encryptionInTransitProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionInTransitProperties"
                }
            },
            minSupportedTlsVersion: {
                serializedName: "minSupportedTlsVersion",
                type: {
                    name: "String"
                }
            },
            networkProperties: {
                serializedName: "networkProperties",
                type: {
                    name: "Composite",
                    className: "NetworkProperties"
                }
            },
            computeIsolationProperties: {
                serializedName: "computeIsolationProperties",
                type: {
                    name: "Composite",
                    className: "ComputeIsolationProperties"
                }
            },
            privateLinkConfigurations: {
                serializedName: "privateLinkConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const ClusterDefinition = {
    type: {
        name: "Composite",
        className: "ClusterDefinition",
        modelProperties: {
            blueprint: {
                serializedName: "blueprint",
                type: {
                    name: "String"
                }
            },
            kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            },
            componentVersion: {
                serializedName: "componentVersion",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            configurations: {
                serializedName: "configurations",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const KafkaRestProperties = {
    type: {
        name: "Composite",
        className: "KafkaRestProperties",
        modelProperties: {
            clientGroupInfo: {
                serializedName: "clientGroupInfo",
                type: {
                    name: "Composite",
                    className: "ClientGroupInfo"
                }
            },
            configurationOverride: {
                serializedName: "configurationOverride",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ClientGroupInfo = {
    type: {
        name: "Composite",
        className: "ClientGroupInfo",
        modelProperties: {
            groupName: {
                serializedName: "groupName",
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityProfile = {
    type: {
        name: "Composite",
        className: "SecurityProfile",
        modelProperties: {
            directoryType: {
                serializedName: "directoryType",
                type: {
                    name: "String"
                }
            },
            domain: {
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            organizationalUnitDN: {
                serializedName: "organizationalUnitDN",
                type: {
                    name: "String"
                }
            },
            ldapsUrls: {
                serializedName: "ldapsUrls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            domainUsername: {
                serializedName: "domainUsername",
                type: {
                    name: "String"
                }
            },
            domainUserPassword: {
                serializedName: "domainUserPassword",
                type: {
                    name: "String"
                }
            },
            clusterUsersGroupDNs: {
                serializedName: "clusterUsersGroupDNs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            aaddsResourceId: {
                serializedName: "aaddsResourceId",
                type: {
                    name: "String"
                }
            },
            msiResourceId: {
                serializedName: "msiResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeProfile = {
    type: {
        name: "Composite",
        className: "ComputeProfile",
        modelProperties: {
            roles: {
                serializedName: "roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Role"
                        }
                    }
                }
            }
        }
    }
};
const Role = {
    type: {
        name: "Composite",
        className: "Role",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            minInstanceCount: {
                serializedName: "minInstanceCount",
                type: {
                    name: "Number"
                }
            },
            targetInstanceCount: {
                serializedName: "targetInstanceCount",
                type: {
                    name: "Number"
                }
            },
            vMGroupName: {
                serializedName: "VMGroupName",
                type: {
                    name: "String"
                }
            },
            autoscaleConfiguration: {
                serializedName: "autoscale",
                type: {
                    name: "Composite",
                    className: "Autoscale"
                }
            },
            hardwareProfile: {
                serializedName: "hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            },
            osProfile: {
                serializedName: "osProfile",
                type: {
                    name: "Composite",
                    className: "OsProfile"
                }
            },
            virtualNetworkProfile: {
                serializedName: "virtualNetworkProfile",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkProfile"
                }
            },
            dataDisksGroups: {
                serializedName: "dataDisksGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDisksGroups"
                        }
                    }
                }
            },
            scriptActions: {
                serializedName: "scriptActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptAction"
                        }
                    }
                }
            },
            encryptDataDisks: {
                defaultValue: false,
                serializedName: "encryptDataDisks",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Autoscale = {
    type: {
        name: "Composite",
        className: "Autoscale",
        modelProperties: {
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "AutoscaleCapacity"
                }
            },
            recurrence: {
                serializedName: "recurrence",
                type: {
                    name: "Composite",
                    className: "AutoscaleRecurrence"
                }
            }
        }
    }
};
const AutoscaleCapacity = {
    type: {
        name: "Composite",
        className: "AutoscaleCapacity",
        modelProperties: {
            minInstanceCount: {
                serializedName: "minInstanceCount",
                type: {
                    name: "Number"
                }
            },
            maxInstanceCount: {
                serializedName: "maxInstanceCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoscaleRecurrence = {
    type: {
        name: "Composite",
        className: "AutoscaleRecurrence",
        modelProperties: {
            timeZone: {
                serializedName: "timeZone",
                type: {
                    name: "String"
                }
            },
            schedule: {
                serializedName: "schedule",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutoscaleSchedule"
                        }
                    }
                }
            }
        }
    }
};
const AutoscaleSchedule = {
    type: {
        name: "Composite",
        className: "AutoscaleSchedule",
        modelProperties: {
            days: {
                serializedName: "days",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            timeAndCapacity: {
                serializedName: "timeAndCapacity",
                type: {
                    name: "Composite",
                    className: "AutoscaleTimeAndCapacity"
                }
            }
        }
    }
};
const AutoscaleTimeAndCapacity = {
    type: {
        name: "Composite",
        className: "AutoscaleTimeAndCapacity",
        modelProperties: {
            time: {
                serializedName: "time",
                type: {
                    name: "String"
                }
            },
            minInstanceCount: {
                serializedName: "minInstanceCount",
                type: {
                    name: "Number"
                }
            },
            maxInstanceCount: {
                serializedName: "maxInstanceCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const HardwareProfile = {
    type: {
        name: "Composite",
        className: "HardwareProfile",
        modelProperties: {
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OsProfile = {
    type: {
        name: "Composite",
        className: "OsProfile",
        modelProperties: {
            linuxOperatingSystemProfile: {
                serializedName: "linuxOperatingSystemProfile",
                type: {
                    name: "Composite",
                    className: "LinuxOperatingSystemProfile"
                }
            }
        }
    }
};
const LinuxOperatingSystemProfile = {
    type: {
        name: "Composite",
        className: "LinuxOperatingSystemProfile",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            sshProfile: {
                serializedName: "sshProfile",
                type: {
                    name: "Composite",
                    className: "SshProfile"
                }
            }
        }
    }
};
const SshProfile = {
    type: {
        name: "Composite",
        className: "SshProfile",
        modelProperties: {
            publicKeys: {
                serializedName: "publicKeys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SshPublicKey"
                        }
                    }
                }
            }
        }
    }
};
const SshPublicKey = {
    type: {
        name: "Composite",
        className: "SshPublicKey",
        modelProperties: {
            certificateData: {
                serializedName: "certificateData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkProfile = {
    type: {
        name: "Composite",
        className: "VirtualNetworkProfile",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataDisksGroups = {
    type: {
        name: "Composite",
        className: "DataDisksGroups",
        modelProperties: {
            disksPerNode: {
                serializedName: "disksPerNode",
                type: {
                    name: "Number"
                }
            },
            storageAccountType: {
                serializedName: "storageAccountType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ScriptAction = {
    type: {
        name: "Composite",
        className: "ScriptAction",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageProfile = {
    type: {
        name: "Composite",
        className: "StorageProfile",
        modelProperties: {
            storageaccounts: {
                serializedName: "storageaccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            }
        }
    }
};
const StorageAccount = {
    type: {
        name: "Composite",
        className: "StorageAccount",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                type: {
                    name: "Boolean"
                }
            },
            container: {
                serializedName: "container",
                type: {
                    name: "String"
                }
            },
            fileSystem: {
                serializedName: "fileSystem",
                type: {
                    name: "String"
                }
            },
            key: {
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            msiResourceId: {
                serializedName: "msiResourceId",
                type: {
                    name: "String"
                }
            },
            saskey: {
                serializedName: "saskey",
                type: {
                    name: "String"
                }
            },
            fileshare: {
                serializedName: "fileshare",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskEncryptionProperties = {
    type: {
        name: "Composite",
        className: "DiskEncryptionProperties",
        modelProperties: {
            vaultUri: {
                serializedName: "vaultUri",
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                type: {
                    name: "String"
                }
            },
            encryptionAlgorithm: {
                serializedName: "encryptionAlgorithm",
                type: {
                    name: "String"
                }
            },
            msiResourceId: {
                serializedName: "msiResourceId",
                type: {
                    name: "String"
                }
            },
            encryptionAtHost: {
                defaultValue: false,
                serializedName: "encryptionAtHost",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EncryptionInTransitProperties = {
    type: {
        name: "Composite",
        className: "EncryptionInTransitProperties",
        modelProperties: {
            isEncryptionInTransitEnabled: {
                defaultValue: false,
                serializedName: "isEncryptionInTransitEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkProperties = {
    type: {
        name: "Composite",
        className: "NetworkProperties",
        modelProperties: {
            resourceProviderConnection: {
                serializedName: "resourceProviderConnection",
                type: {
                    name: "String"
                }
            },
            privateLink: {
                serializedName: "privateLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeIsolationProperties = {
    type: {
        name: "Composite",
        className: "ComputeIsolationProperties",
        modelProperties: {
            enableComputeIsolation: {
                defaultValue: false,
                serializedName: "enableComputeIsolation",
                type: {
                    name: "Boolean"
                }
            },
            hostSku: {
                serializedName: "hostSku",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkConfiguration = {
    type: {
        name: "Composite",
        className: "PrivateLinkConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                required: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const IPConfiguration = {
    type: {
        name: "Composite",
        className: "IPConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            },
            privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            },
            privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            },
            subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "ResourceId"
                }
            }
        }
    }
};
const ResourceId = {
    type: {
        name: "Composite",
        className: "ResourceId",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterIdentity = {
    type: {
        name: "Composite",
        className: "ClusterIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterGetProperties = {
    type: {
        name: "Composite",
        className: "ClusterGetProperties",
        modelProperties: {
            clusterVersion: {
                serializedName: "clusterVersion",
                type: {
                    name: "String"
                }
            },
            clusterHdpVersion: {
                serializedName: "clusterHdpVersion",
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            clusterId: {
                serializedName: "clusterId",
                type: {
                    name: "String"
                }
            },
            clusterDefinition: {
                serializedName: "clusterDefinition",
                type: {
                    name: "Composite",
                    className: "ClusterDefinition"
                }
            },
            kafkaRestProperties: {
                serializedName: "kafkaRestProperties",
                type: {
                    name: "Composite",
                    className: "KafkaRestProperties"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            computeProfile: {
                serializedName: "computeProfile",
                type: {
                    name: "Composite",
                    className: "ComputeProfile"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                type: {
                    name: "String"
                }
            },
            createdDate: {
                serializedName: "createdDate",
                type: {
                    name: "String"
                }
            },
            clusterState: {
                serializedName: "clusterState",
                type: {
                    name: "String"
                }
            },
            quotaInfo: {
                serializedName: "quotaInfo",
                type: {
                    name: "Composite",
                    className: "QuotaInfo"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Errors"
                        }
                    }
                }
            },
            connectivityEndpoints: {
                serializedName: "connectivityEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityEndpoint"
                        }
                    }
                }
            },
            diskEncryptionProperties: {
                serializedName: "diskEncryptionProperties",
                type: {
                    name: "Composite",
                    className: "DiskEncryptionProperties"
                }
            },
            encryptionInTransitProperties: {
                serializedName: "encryptionInTransitProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionInTransitProperties"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            },
            minSupportedTlsVersion: {
                serializedName: "minSupportedTlsVersion",
                type: {
                    name: "String"
                }
            },
            excludedServicesConfig: {
                serializedName: "excludedServicesConfig",
                type: {
                    name: "Composite",
                    className: "ExcludedServicesConfig"
                }
            },
            networkProperties: {
                serializedName: "networkProperties",
                type: {
                    name: "Composite",
                    className: "NetworkProperties"
                }
            },
            computeIsolationProperties: {
                serializedName: "computeIsolationProperties",
                type: {
                    name: "Composite",
                    className: "ComputeIsolationProperties"
                }
            },
            privateLinkConfigurations: {
                serializedName: "privateLinkConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkConfiguration"
                        }
                    }
                }
            },
            privateEndpointConnections: {
                serializedName: "privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const QuotaInfo = {
    type: {
        name: "Composite",
        className: "QuotaInfo",
        modelProperties: {
            coresUsed: {
                serializedName: "coresUsed",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Errors = {
    type: {
        name: "Composite",
        className: "Errors",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityEndpoint = {
    type: {
        name: "Composite",
        className: "ConnectivityEndpoint",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExcludedServicesConfig = {
    type: {
        name: "Composite",
        className: "ExcludedServicesConfig",
        modelProperties: {
            excludedServicesConfigId: {
                serializedName: "excludedServicesConfigId",
                type: {
                    name: "String"
                }
            },
            excludedServicesList: {
                serializedName: "excludedServicesList",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceAutoGenerated = {
    type: {
        name: "Composite",
        className: "ResourceAutoGenerated",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterPatchParameters = {
    type: {
        name: "Composite",
        className: "ClusterPatchParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                nullable: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ClusterListResult = {
    type: {
        name: "Composite",
        className: "ClusterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cluster"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterResizeParameters = {
    type: {
        name: "Composite",
        className: "ClusterResizeParameters",
        modelProperties: {
            targetInstanceCount: {
                serializedName: "targetInstanceCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AutoscaleConfigurationUpdateParameter = {
    type: {
        name: "Composite",
        className: "AutoscaleConfigurationUpdateParameter",
        modelProperties: {
            autoscale: {
                serializedName: "autoscale",
                type: {
                    name: "Composite",
                    className: "Autoscale"
                }
            }
        }
    }
};
const ClusterDiskEncryptionParameters = {
    type: {
        name: "Composite",
        className: "ClusterDiskEncryptionParameters",
        modelProperties: {
            vaultUri: {
                serializedName: "vaultUri",
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewaySettings = {
    type: {
        name: "Composite",
        className: "GatewaySettings",
        modelProperties: {
            isCredentialEnabled: {
                serializedName: "restAuthCredential\\.isEnabled",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userName: {
                serializedName: "restAuthCredential\\.username",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "restAuthCredential\\.password",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpdateGatewaySettingsParameters = {
    type: {
        name: "Composite",
        className: "UpdateGatewaySettingsParameters",
        modelProperties: {
            isCredentialEnabled: {
                defaultValue: true,
                serializedName: "restAuthCredential\\.isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            userName: {
                serializedName: "restAuthCredential\\.username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "restAuthCredential\\.password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AsyncOperationResult = {
    type: {
        name: "Composite",
        className: "AsyncOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "Errors"
                }
            }
        }
    }
};
const UpdateClusterIdentityCertificateParameters = {
    type: {
        name: "Composite",
        className: "UpdateClusterIdentityCertificateParameters",
        modelProperties: {
            applicationId: {
                serializedName: "applicationId",
                type: {
                    name: "String"
                }
            },
            certificate: {
                serializedName: "certificate",
                type: {
                    name: "String"
                }
            },
            certificatePassword: {
                serializedName: "certificatePassword",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationListResult = {
    type: {
        name: "Composite",
        className: "ApplicationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Application"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationProperties = {
    type: {
        name: "Composite",
        className: "ApplicationProperties",
        modelProperties: {
            computeProfile: {
                serializedName: "computeProfile",
                type: {
                    name: "Composite",
                    className: "ComputeProfile"
                }
            },
            installScriptActions: {
                serializedName: "installScriptActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptAction"
                        }
                    }
                }
            },
            uninstallScriptActions: {
                serializedName: "uninstallScriptActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptAction"
                        }
                    }
                }
            },
            httpsEndpoints: {
                serializedName: "httpsEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGetHttpsEndpoint"
                        }
                    }
                }
            },
            sshEndpoints: {
                serializedName: "sshEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGetEndpoint"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            applicationType: {
                serializedName: "applicationType",
                type: {
                    name: "String"
                }
            },
            applicationState: {
                serializedName: "applicationState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Errors"
                        }
                    }
                }
            },
            createdDate: {
                serializedName: "createdDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            marketplaceIdentifier: {
                serializedName: "marketplaceIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateLinkConfigurations: {
                serializedName: "privateLinkConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const RuntimeScriptAction = {
    type: {
        name: "Composite",
        className: "RuntimeScriptAction",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "String"
                }
            },
            roles: {
                serializedName: "roles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            applicationName: {
                serializedName: "applicationName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGetHttpsEndpoint = {
    type: {
        name: "Composite",
        className: "ApplicationGetHttpsEndpoint",
        modelProperties: {
            accessModes: {
                serializedName: "accessModes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            destinationPort: {
                serializedName: "destinationPort",
                type: {
                    name: "Number"
                }
            },
            publicPort: {
                serializedName: "publicPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            },
            subDomainSuffix: {
                serializedName: "subDomainSuffix",
                type: {
                    name: "String"
                }
            },
            disableGatewayAuth: {
                serializedName: "disableGatewayAuth",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGetEndpoint = {
    type: {
        name: "Composite",
        className: "ApplicationGetEndpoint",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            destinationPort: {
                serializedName: "destinationPort",
                type: {
                    name: "Number"
                }
            },
            publicPort: {
                serializedName: "publicPort",
                type: {
                    name: "Number"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CapabilitiesResult = {
    type: {
        name: "Composite",
        className: "CapabilitiesResult",
        modelProperties: {
            versions: {
                serializedName: "versions",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "VersionsCapability" }
                    }
                }
            },
            regions: {
                serializedName: "regions",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Composite", className: "RegionsCapability" } }
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            quota: {
                serializedName: "quota",
                type: {
                    name: "Composite",
                    className: "QuotaCapability"
                }
            }
        }
    }
};
const VersionsCapability = {
    type: {
        name: "Composite",
        className: "VersionsCapability",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VersionSpec"
                        }
                    }
                }
            }
        }
    }
};
const VersionSpec = {
    type: {
        name: "Composite",
        className: "VersionSpec",
        modelProperties: {
            friendlyName: {
                serializedName: "friendlyName",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            isDefault: {
                serializedName: "isDefault",
                type: {
                    name: "Boolean"
                }
            },
            componentVersions: {
                serializedName: "componentVersions",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const RegionsCapability = {
    type: {
        name: "Composite",
        className: "RegionsCapability",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const QuotaCapability = {
    type: {
        name: "Composite",
        className: "QuotaCapability",
        modelProperties: {
            coresUsed: {
                serializedName: "coresUsed",
                type: {
                    name: "Number"
                }
            },
            maxCoresAllowed: {
                serializedName: "maxCoresAllowed",
                type: {
                    name: "Number"
                }
            },
            regionalQuotas: {
                serializedName: "regionalQuotas",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RegionalQuotaCapability"
                        }
                    }
                }
            }
        }
    }
};
const RegionalQuotaCapability = {
    type: {
        name: "Composite",
        className: "RegionalQuotaCapability",
        modelProperties: {
            regionName: {
                serializedName: "regionName",
                type: {
                    name: "String"
                }
            },
            coresUsed: {
                serializedName: "coresUsed",
                type: {
                    name: "Number"
                }
            },
            coresAvailable: {
                serializedName: "coresAvailable",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const UsagesListResult = {
    type: {
        name: "Composite",
        className: "UsagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "LocalizedName"
                }
            }
        }
    }
};
const LocalizedName = {
    type: {
        name: "Composite",
        className: "LocalizedName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BillingResponseListResult = {
    type: {
        name: "Composite",
        className: "BillingResponseListResult",
        modelProperties: {
            vmSizes: {
                serializedName: "vmSizes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vmSizesWithEncryptionAtHost: {
                serializedName: "vmSizesWithEncryptionAtHost",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vmSizeFilters: {
                serializedName: "vmSizeFilters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VmSizeCompatibilityFilterV2"
                        }
                    }
                }
            },
            vmSizeProperties: {
                serializedName: "vmSizeProperties",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VmSizeProperty"
                        }
                    }
                }
            },
            billingResources: {
                serializedName: "billingResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BillingResources"
                        }
                    }
                }
            }
        }
    }
};
const VmSizeCompatibilityFilterV2 = {
    type: {
        name: "Composite",
        className: "VmSizeCompatibilityFilterV2",
        modelProperties: {
            filterMode: {
                serializedName: "filterMode",
                type: {
                    name: "String"
                }
            },
            regions: {
                serializedName: "regions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            clusterFlavors: {
                serializedName: "clusterFlavors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nodeTypes: {
                serializedName: "nodeTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            clusterVersions: {
                serializedName: "clusterVersions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vmSizes: {
                serializedName: "vmSizes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            espApplied: {
                serializedName: "espApplied",
                type: {
                    name: "String"
                }
            },
            computeIsolationSupported: {
                serializedName: "computeIsolationSupported",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VmSizeProperty = {
    type: {
        name: "Composite",
        className: "VmSizeProperty",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            cores: {
                serializedName: "cores",
                type: {
                    name: "Number"
                }
            },
            dataDiskStorageTier: {
                serializedName: "dataDiskStorageTier",
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                type: {
                    name: "String"
                }
            },
            maxDataDiskCount: {
                serializedName: "maxDataDiskCount",
                type: {
                    name: "Number"
                }
            },
            memoryInMb: {
                serializedName: "memoryInMb",
                type: {
                    name: "Number"
                }
            },
            supportedByVirtualMachines: {
                serializedName: "supportedByVirtualMachines",
                type: {
                    name: "Boolean"
                }
            },
            supportedByWebWorkerRoles: {
                serializedName: "supportedByWebWorkerRoles",
                type: {
                    name: "Boolean"
                }
            },
            virtualMachineResourceDiskSizeInMb: {
                serializedName: "virtualMachineResourceDiskSizeInMb",
                type: {
                    name: "Number"
                }
            },
            webWorkerResourceDiskSizeInMb: {
                serializedName: "webWorkerResourceDiskSizeInMb",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const BillingResources = {
    type: {
        name: "Composite",
        className: "BillingResources",
        modelProperties: {
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            billingMeters: {
                serializedName: "billingMeters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BillingMeters"
                        }
                    }
                }
            },
            diskBillingMeters: {
                serializedName: "diskBillingMeters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiskBillingMeters"
                        }
                    }
                }
            }
        }
    }
};
const BillingMeters = {
    type: {
        name: "Composite",
        className: "BillingMeters",
        modelProperties: {
            meterParameter: {
                serializedName: "meterParameter",
                type: {
                    name: "String"
                }
            },
            meter: {
                serializedName: "meter",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskBillingMeters = {
    type: {
        name: "Composite",
        className: "DiskBillingMeters",
        modelProperties: {
            diskRpMeter: {
                serializedName: "diskRpMeter",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NameAvailabilityCheckRequestParameters = {
    type: {
        name: "Composite",
        className: "NameAvailabilityCheckRequestParameters",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NameAvailabilityCheckResult = {
    type: {
        name: "Composite",
        className: "NameAvailabilityCheckResult",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterCreateValidationResult = {
    type: {
        name: "Composite",
        className: "ClusterCreateValidationResult",
        modelProperties: {
            validationErrors: {
                serializedName: "validationErrors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ValidationErrorInfo"
                        }
                    }
                }
            },
            validationWarnings: {
                serializedName: "validationWarnings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ValidationErrorInfo"
                        }
                    }
                }
            },
            estimatedCreationDuration: {
                serializedName: "estimatedCreationDuration",
                type: {
                    name: "TimeSpan"
                }
            },
            aaddsResourcesDetails: {
                serializedName: "aaddsResourcesDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AaddsResourceDetails"
                        }
                    }
                }
            }
        }
    }
};
const ValidationErrorInfo = {
    type: {
        name: "Composite",
        className: "ValidationErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            errorResource: {
                serializedName: "errorResource",
                type: {
                    name: "String"
                }
            },
            messageArguments: {
                serializedName: "messageArguments",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AaddsResourceDetails = {
    type: {
        name: "Composite",
        className: "AaddsResourceDetails",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            initialSyncComplete: {
                serializedName: "initialSyncComplete",
                type: {
                    name: "Boolean"
                }
            },
            ldapsEnabled: {
                serializedName: "ldapsEnabled",
                type: {
                    name: "Boolean"
                }
            },
            ldapsPublicCertificateInBase64: {
                serializedName: "ldapsPublicCertificateInBase64",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterConfigurations = {
    type: {
        name: "Composite",
        className: "ClusterConfigurations",
        modelProperties: {
            configurations: {
                serializedName: "configurations",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "String" } } }
                    }
                }
            }
        }
    }
};
const ClusterMonitoringRequest = {
    type: {
        name: "Composite",
        className: "ClusterMonitoringRequest",
        modelProperties: {
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                serializedName: "primaryKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterMonitoringResponse = {
    type: {
        name: "Composite",
        className: "ClusterMonitoringResponse",
        modelProperties: {
            clusterMonitoringEnabled: {
                serializedName: "clusterMonitoringEnabled",
                type: {
                    name: "Boolean"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureMonitorRequest = {
    type: {
        name: "Composite",
        className: "AzureMonitorRequest",
        modelProperties: {
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                serializedName: "primaryKey",
                type: {
                    name: "String"
                }
            },
            selectedConfigurations: {
                serializedName: "selectedConfigurations",
                type: {
                    name: "Composite",
                    className: "AzureMonitorSelectedConfigurations"
                }
            }
        }
    }
};
const AzureMonitorSelectedConfigurations = {
    type: {
        name: "Composite",
        className: "AzureMonitorSelectedConfigurations",
        modelProperties: {
            configurationVersion: {
                serializedName: "configurationVersion",
                type: {
                    name: "String"
                }
            },
            globalConfigurations: {
                serializedName: "globalConfigurations",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            tableList: {
                serializedName: "tableList",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureMonitorTableConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const AzureMonitorTableConfiguration = {
    type: {
        name: "Composite",
        className: "AzureMonitorTableConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureMonitorResponse = {
    type: {
        name: "Composite",
        className: "AzureMonitorResponse",
        modelProperties: {
            clusterMonitoringEnabled: {
                serializedName: "clusterMonitoringEnabled",
                type: {
                    name: "Boolean"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            selectedConfigurations: {
                serializedName: "selectedConfigurations",
                type: {
                    name: "Composite",
                    className: "AzureMonitorSelectedConfigurations"
                }
            }
        }
    }
};
const Extension = {
    type: {
        name: "Composite",
        className: "Extension",
        modelProperties: {
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            primaryKey: {
                serializedName: "primaryKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExecuteScriptActionParameters = {
    type: {
        name: "Composite",
        className: "ExecuteScriptActionParameters",
        modelProperties: {
            scriptActions: {
                serializedName: "scriptActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptAction"
                        }
                    }
                }
            },
            persistOnSuccess: {
                serializedName: "persistOnSuccess",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ScriptActionsList = {
    type: {
        name: "Composite",
        className: "ScriptActionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptActionDetail"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptActionExecutionSummary = {
    type: {
        name: "Composite",
        className: "ScriptActionExecutionSummary",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            instanceCount: {
                serializedName: "instanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ScriptActionExecutionHistoryList = {
    type: {
        name: "Composite",
        className: "ScriptActionExecutionHistoryList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptActionDetail"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OperationProperties"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationProperties = {
    type: {
        name: "Composite",
        className: "OperationProperties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecifications"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecifications = {
    type: {
        name: "Composite",
        className: "MetricSpecifications",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            },
            isInternal: {
                serializedName: "isInternal",
                type: {
                    name: "Boolean"
                }
            },
            delegateMetricNameOverride: {
                serializedName: "delegateMetricNameOverride",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            }
        }
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const HostInfo = {
    type: {
        name: "Composite",
        className: "HostInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            effectiveDiskEncryptionKeyUrl: {
                serializedName: "effectiveDiskEncryptionKeyUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const ClusterListPersistedScriptActionsResult = {
    type: {
        name: "Composite",
        className: "ClusterListPersistedScriptActionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RuntimeScriptAction"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptActionPersistedGetResponseSpec = {
    type: {
        name: "Composite",
        className: "ScriptActionPersistedGetResponseSpec",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            uri: {
                serializedName: "uri",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "String"
                }
            },
            roles: {
                serializedName: "roles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            applicationName: {
                serializedName: "applicationName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterCreateRequestValidationParameters = {
    type: {
        name: "Composite",
        className: "ClusterCreateRequestValidationParameters",
        modelProperties: Object.assign(Object.assign({}, ClusterCreateParametersExtended.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            }, fetchAaddsResource: {
                serializedName: "fetchAaddsResource",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, linkIdentifier: {
                serializedName: "properties.linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, ResourceAutoGenerated.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, ResourceAutoGenerated.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const RuntimeScriptActionDetail = {
    type: {
        name: "Composite",
        className: "RuntimeScriptActionDetail",
        modelProperties: Object.assign(Object.assign({}, RuntimeScriptAction.type.modelProperties), { scriptExecutionId: {
                serializedName: "scriptExecutionId",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, executionSummary: {
                serializedName: "executionSummary",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptActionExecutionSummary"
                        }
                    }
                }
            }, debugInformation: {
                serializedName: "debugInformation",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Application = {
    type: {
        name: "Composite",
        className: "Application",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ApplicationProperties"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const Cluster = {
    type: {
        name: "Composite",
        className: "Cluster",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ClusterGetProperties"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ClusterIdentity"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ClusterCreateParametersExtended: ClusterCreateParametersExtended,
    ClusterCreateProperties: ClusterCreateProperties,
    ClusterDefinition: ClusterDefinition,
    KafkaRestProperties: KafkaRestProperties,
    ClientGroupInfo: ClientGroupInfo,
    SecurityProfile: SecurityProfile,
    ComputeProfile: ComputeProfile,
    Role: Role,
    Autoscale: Autoscale,
    AutoscaleCapacity: AutoscaleCapacity,
    AutoscaleRecurrence: AutoscaleRecurrence,
    AutoscaleSchedule: AutoscaleSchedule,
    AutoscaleTimeAndCapacity: AutoscaleTimeAndCapacity,
    HardwareProfile: HardwareProfile,
    OsProfile: OsProfile,
    LinuxOperatingSystemProfile: LinuxOperatingSystemProfile,
    SshProfile: SshProfile,
    SshPublicKey: SshPublicKey,
    VirtualNetworkProfile: VirtualNetworkProfile,
    DataDisksGroups: DataDisksGroups,
    ScriptAction: ScriptAction,
    StorageProfile: StorageProfile,
    StorageAccount: StorageAccount,
    DiskEncryptionProperties: DiskEncryptionProperties,
    EncryptionInTransitProperties: EncryptionInTransitProperties,
    NetworkProperties: NetworkProperties,
    ComputeIsolationProperties: ComputeIsolationProperties,
    PrivateLinkConfiguration: PrivateLinkConfiguration,
    IPConfiguration: IPConfiguration,
    ResourceId: ResourceId,
    ClusterIdentity: ClusterIdentity,
    UserAssignedIdentity: UserAssignedIdentity,
    ClusterGetProperties: ClusterGetProperties,
    QuotaInfo: QuotaInfo,
    Errors: Errors,
    ConnectivityEndpoint: ConnectivityEndpoint,
    ExcludedServicesConfig: ExcludedServicesConfig,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    SystemData: SystemData,
    Resource: Resource,
    ResourceAutoGenerated: ResourceAutoGenerated,
    ErrorResponse: ErrorResponse,
    ClusterPatchParameters: ClusterPatchParameters,
    ClusterListResult: ClusterListResult,
    ClusterResizeParameters: ClusterResizeParameters,
    AutoscaleConfigurationUpdateParameter: AutoscaleConfigurationUpdateParameter,
    ClusterDiskEncryptionParameters: ClusterDiskEncryptionParameters,
    GatewaySettings: GatewaySettings,
    UpdateGatewaySettingsParameters: UpdateGatewaySettingsParameters,
    AsyncOperationResult: AsyncOperationResult,
    UpdateClusterIdentityCertificateParameters: UpdateClusterIdentityCertificateParameters,
    ApplicationListResult: ApplicationListResult,
    ApplicationProperties: ApplicationProperties,
    RuntimeScriptAction: RuntimeScriptAction,
    ApplicationGetHttpsEndpoint: ApplicationGetHttpsEndpoint,
    ApplicationGetEndpoint: ApplicationGetEndpoint,
    CapabilitiesResult: CapabilitiesResult,
    VersionsCapability: VersionsCapability,
    VersionSpec: VersionSpec,
    RegionsCapability: RegionsCapability,
    QuotaCapability: QuotaCapability,
    RegionalQuotaCapability: RegionalQuotaCapability,
    UsagesListResult: UsagesListResult,
    Usage: Usage,
    LocalizedName: LocalizedName,
    BillingResponseListResult: BillingResponseListResult,
    VmSizeCompatibilityFilterV2: VmSizeCompatibilityFilterV2,
    VmSizeProperty: VmSizeProperty,
    BillingResources: BillingResources,
    BillingMeters: BillingMeters,
    DiskBillingMeters: DiskBillingMeters,
    NameAvailabilityCheckRequestParameters: NameAvailabilityCheckRequestParameters,
    NameAvailabilityCheckResult: NameAvailabilityCheckResult,
    ClusterCreateValidationResult: ClusterCreateValidationResult,
    ValidationErrorInfo: ValidationErrorInfo,
    AaddsResourceDetails: AaddsResourceDetails,
    ClusterConfigurations: ClusterConfigurations,
    ClusterMonitoringRequest: ClusterMonitoringRequest,
    ClusterMonitoringResponse: ClusterMonitoringResponse,
    AzureMonitorRequest: AzureMonitorRequest,
    AzureMonitorSelectedConfigurations: AzureMonitorSelectedConfigurations,
    AzureMonitorTableConfiguration: AzureMonitorTableConfiguration,
    AzureMonitorResponse: AzureMonitorResponse,
    Extension: Extension,
    ExecuteScriptActionParameters: ExecuteScriptActionParameters,
    ScriptActionsList: ScriptActionsList,
    ScriptActionExecutionSummary: ScriptActionExecutionSummary,
    ScriptActionExecutionHistoryList: ScriptActionExecutionHistoryList,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationProperties: OperationProperties,
    ServiceSpecification: ServiceSpecification,
    MetricSpecifications: MetricSpecifications,
    Dimension: Dimension,
    HostInfo: HostInfo,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    ClusterListPersistedScriptActionsResult: ClusterListPersistedScriptActionsResult,
    ScriptActionPersistedGetResponseSpec: ScriptActionPersistedGetResponseSpec,
    ClusterCreateRequestValidationParameters: ClusterCreateRequestValidationParameters,
    PrivateEndpointConnection: PrivateEndpointConnection,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    PrivateLinkResource: PrivateLinkResource,
    RuntimeScriptActionDetail: RuntimeScriptActionDetail,
    Application: Application,
    Cluster: Cluster
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: ClusterCreateParametersExtended
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clusterName = {
    parameterPath: "clusterName",
    mapper: {
        serializedName: "clusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ClusterPatchParameters
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ClusterResizeParameters
};
const roleName = {
    parameterPath: "roleName",
    mapper: {
        serializedName: "roleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: AutoscaleConfigurationUpdateParameter
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ClusterDiskEncryptionParameters
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: UpdateGatewaySettingsParameters
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: UpdateClusterIdentityCertificateParameters
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ExecuteScriptActionParameters
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const applicationName = {
    parameterPath: "applicationName",
    mapper: {
        serializedName: "applicationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: Application
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: NameAvailabilityCheckRequestParameters
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: ClusterCreateRequestValidationParameters
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: {
        serializedName: "parameters",
        required: true,
        type: {
            name: "Dictionary",
            value: { type: { name: "String" } }
        }
    }
};
const configurationName = {
    parameterPath: "configurationName",
    mapper: {
        serializedName: "configurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: ClusterMonitoringRequest
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: AzureMonitorRequest
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: Extension
};
const extensionName = {
    parameterPath: "extensionName",
    mapper: {
        serializedName: "extensionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scriptName = {
    parameterPath: "scriptName",
    mapper: {
        serializedName: "scriptName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scriptExecutionId = {
    parameterPath: "scriptExecutionId",
    mapper: {
        serializedName: "scriptExecutionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const hosts = {
    parameterPath: "hosts",
    mapper: {
        serializedName: "hosts",
        required: true,
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateLinkResourceName = {
    parameterPath: "privateLinkResourceName",
    mapper: {
        serializedName: "privateLinkResourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Clusters operations. */
class ClustersImpl {
    /**
     * Initialize a new instance of the class Clusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the HDInsight clusters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the HDInsight clusters under the subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates a new HDInsight cluster with the specified parameters.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster create request.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, createOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new HDInsight cluster with the specified parameters.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster create request.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch HDInsight cluster with the specified parameters.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster patch request.
     * @param options The options parameters.
     */
    update(resourceGroupName, clusterName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, parameters, options }, updateOperationSpec$1);
    }
    /**
     * Deletes the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getOperationSpec$5);
    }
    /**
     * Lists the HDInsight clusters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Resizes the specified HDInsight cluster to the specified size.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param roleName The constant value for the roleName
     * @param parameters The parameters for the resize operation.
     * @param options The options parameters.
     */
    beginResize(resourceGroupName, clusterName, roleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, roleName, parameters, options }, resizeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resizes the specified HDInsight cluster to the specified size.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param roleName The constant value for the roleName
     * @param parameters The parameters for the resize operation.
     * @param options The options parameters.
     */
    beginResizeAndWait(resourceGroupName, clusterName, roleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResize(resourceGroupName, clusterName, roleName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the Autoscale Configuration for HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param roleName The constant value for the roleName
     * @param parameters The parameters for the update autoscale configuration operation.
     * @param options The options parameters.
     */
    beginUpdateAutoScaleConfiguration(resourceGroupName, clusterName, roleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, roleName, parameters, options }, updateAutoScaleConfigurationOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the Autoscale Configuration for HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param roleName The constant value for the roleName
     * @param parameters The parameters for the update autoscale configuration operation.
     * @param options The options parameters.
     */
    beginUpdateAutoScaleConfigurationAndWait(resourceGroupName, clusterName, roleName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateAutoScaleConfiguration(resourceGroupName, clusterName, roleName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the HDInsight clusters under the subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$2);
    }
    /**
     * Rotate disk encryption key of the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The parameters for the disk encryption operation.
     * @param options The options parameters.
     */
    beginRotateDiskEncryptionKey(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, rotateDiskEncryptionKeyOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Rotate disk encryption key of the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The parameters for the disk encryption operation.
     * @param options The options parameters.
     */
    beginRotateDiskEncryptionKeyAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRotateDiskEncryptionKey(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the gateway settings for the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    getGatewaySettings(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getGatewaySettingsOperationSpec);
    }
    /**
     * Configures the gateway settings on the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdateGatewaySettings(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, updateGatewaySettingsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Configures the gateway settings on the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdateGatewaySettingsAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateGatewaySettings(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The the async operation status.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getAzureAsyncOperationStatus(resourceGroupName, clusterName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, operationId, options }, getAzureAsyncOperationStatusOperationSpec$3);
    }
    /**
     * Updates the cluster identity certificate.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdateIdentityCertificate(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, updateIdentityCertificateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the cluster identity certificate.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdateIdentityCertificateAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateIdentityCertificate(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Executes script actions on the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The parameters for executing script actions.
     * @param options The options parameters.
     */
    beginExecuteScriptActions(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, executeScriptActionsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Executes script actions on the specified HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The parameters for executing script actions.
     * @param options The options parameters.
     */
    beginExecuteScriptActionsAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExecuteScriptActions(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const resizeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/roles/{roleName}/resize",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        roleName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const updateAutoScaleConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/roles/{roleName}/autoscale",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        roleName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$a
};
const rotateDiskEncryptionKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/rotatediskencryptionkey",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const getGatewaySettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/getGatewaySettings",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewaySettings
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateGatewaySettingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/updateGatewaySettings",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const getAzureAsyncOperationStatusOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/azureasyncoperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateIdentityCertificateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/updateClusterIdentityCertificate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const executeScriptActionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/executeScriptActions",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        404: {
            isError: true
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$a
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Applications operations. */
class ApplicationsImpl {
    /**
     * Initialize a new instance of the class Applications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the applications for the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        const iter = this.listByClusterPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByClusterPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listByClusterPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCluster(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByClusterNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByClusterPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByClusterPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the applications for the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec$4);
    }
    /**
     * Gets properties of the specified application.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, options }, getOperationSpec$4);
    }
    /**
     * Creates applications for the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param parameters The application create request.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, applicationName, parameters, options }, createOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates applications for the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param parameters The application create request.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, clusterName, applicationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified application on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, applicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, applicationName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified application on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, applicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, applicationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the async operation status.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param applicationName The constant value for the application name.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getAzureAsyncOperationStatus(resourceGroupName, clusterName, applicationName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, operationId, options }, getAzureAsyncOperationStatusOperationSpec$2);
    }
    /**
     * ListByClusterNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListByCluster method.
     * @param options The options parameters.
     */
    _listByClusterNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listByClusterNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByClusterOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Application
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Application
        },
        201: {
            bodyMapper: Application
        },
        202: {
            bodyMapper: Application
        },
        204: {
            bodyMapper: Application
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        applicationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getAzureAsyncOperationStatusOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/applications/{applicationName}/azureasyncoperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        operationId,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByClusterNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Locations operations. */
class LocationsImpl {
    /**
     * Initialize a new instance of the class Locations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the capabilities for the specified location.
     * @param location The Azure location (region) for which to make the request.
     * @param options The options parameters.
     */
    getCapabilities(location, options) {
        return this.client.sendOperationRequest({ location, options }, getCapabilitiesOperationSpec);
    }
    /**
     * Lists the usages for the specified location.
     * @param location The Azure location (region) for which to make the request.
     * @param options The options parameters.
     */
    listUsages(location, options) {
        return this.client.sendOperationRequest({ location, options }, listUsagesOperationSpec);
    }
    /**
     * Lists the billingSpecs for the specified subscription and location.
     * @param location The Azure location (region) for which to make the request.
     * @param options The options parameters.
     */
    listBillingSpecs(location, options) {
        return this.client.sendOperationRequest({ location, options }, listBillingSpecsOperationSpec);
    }
    /**
     * Get the async operation status.
     * @param location The Azure location (region) for which to make the request.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getAzureAsyncOperationStatus(location, operationId, options) {
        return this.client.sendOperationRequest({ location, operationId, options }, getAzureAsyncOperationStatusOperationSpec$1);
    }
    /**
     * Check the cluster name is available or not.
     * @param location The Azure location (region) for which to make the request.
     * @param parameters The request spec of checking name availability.
     * @param options The options parameters.
     */
    checkNameAvailability(location, parameters, options) {
        return this.client.sendOperationRequest({ location, parameters, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * Validate the cluster create request spec is valid or not.
     * @param location The Azure location (region) for which to make the request.
     * @param parameters The cluster create request specification.
     * @param options The options parameters.
     */
    validateClusterCreateRequest(location, parameters, options) {
        return this.client.sendOperationRequest({ location, parameters, options }, validateClusterCreateRequestOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getCapabilitiesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/capabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CapabilitiesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listUsagesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listBillingSpecsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/billingSpecs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BillingResponseListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getAzureAsyncOperationStatusOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/azureasyncoperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        operationId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NameAvailabilityCheckResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};
const validateClusterCreateRequestOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.HDInsight/locations/{location}/validateCreateRequest",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClusterCreateValidationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Configurations operations. */
class ConfigurationsImpl {
    /**
     * Initialize a new instance of the class Configurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all configuration information for an HDI cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listOperationSpec$1);
    }
    /**
     * Configures the HTTP settings on the specified cluster. This API is deprecated, please use
     * UpdateGatewaySettings in cluster endpoint instead.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param configurationName The name of the cluster configuration.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                clusterName,
                configurationName,
                parameters,
                options
            }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Configures the HTTP settings on the specified cluster. This API is deprecated, please use
     * UpdateGatewaySettings in cluster endpoint instead.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param configurationName The name of the cluster configuration.
     * @param parameters The cluster configurations.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, configurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, configurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The configuration object for the specified cluster. This API is not recommended and might be removed
     * in the future. Please consider using List configurations API instead.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param configurationName The name of the cluster configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, configurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, configurationName, options }, getOperationSpec$3);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClusterConfigurations
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations/{configurationName}",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        configurationName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$7
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/configurations/{configurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Dictionary", value: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Extensions operations. */
class ExtensionsImpl {
    /**
     * Initialize a new instance of the class Extensions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Enables the Operations Management Suite (OMS) on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The Operations Management Suite (OMS) workspace parameters.
     * @param options The options parameters.
     */
    beginEnableMonitoring(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, enableMonitoringOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enables the Operations Management Suite (OMS) on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The Operations Management Suite (OMS) workspace parameters.
     * @param options The options parameters.
     */
    beginEnableMonitoringAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnableMonitoring(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of Operations Management Suite (OMS) on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    getMonitoringStatus(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getMonitoringStatusOperationSpec);
    }
    /**
     * Disables the Operations Management Suite (OMS) on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDisableMonitoring(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, options }, disableMonitoringOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disables the Operations Management Suite (OMS) on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDisableMonitoringAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisableMonitoring(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Enables the Azure Monitor on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The Log Analytics workspace parameters.
     * @param options The options parameters.
     */
    beginEnableAzureMonitor(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, parameters, options }, enableAzureMonitorOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enables the Azure Monitor on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param parameters The Log Analytics workspace parameters.
     * @param options The options parameters.
     */
    beginEnableAzureMonitorAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginEnableAzureMonitor(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the status of Azure Monitor on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    getAzureMonitorStatus(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getAzureMonitorStatusOperationSpec);
    }
    /**
     * Disables the Azure Monitor on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDisableAzureMonitor(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, options }, disableAzureMonitorOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disables the Azure Monitor on the HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    beginDisableAzureMonitorAndWait(resourceGroupName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisableAzureMonitor(resourceGroupName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates an HDInsight cluster extension.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param parameters The cluster extensions create request.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, clusterName, extensionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, extensionName, parameters, options }, createOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates an HDInsight cluster extension.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param parameters The cluster extensions create request.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, clusterName, extensionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, clusterName, extensionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the extension properties for the specified HDInsight cluster extension.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, extensionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, extensionName, options }, getOperationSpec$2);
    }
    /**
     * Deletes the specified extension for HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, extensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, extensionName, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified extension for HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, extensionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, extensionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the async operation status.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param extensionName The name of the cluster extension.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getAzureAsyncOperationStatus(resourceGroupName, clusterName, extensionName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, extensionName, operationId, options }, getAzureAsyncOperationStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const enableMonitoringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
    httpMethod: "PUT",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const getMonitoringStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterMonitoringResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const disableMonitoringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/clustermonitoring",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const enableAzureMonitorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
    httpMethod: "PUT",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const getAzureMonitorStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureMonitorResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const disableAzureMonitorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/azureMonitor",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
    httpMethod: "PUT",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        extensionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$6
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterMonitoringResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        extensionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        extensionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getAzureAsyncOperationStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/extensions/{extensionName}/azureAsyncOperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        operationId,
        extensionName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScriptActions operations. */
class ScriptActionsImpl {
    /**
     * Initialize a new instance of the class ScriptActions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the persisted script actions for the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        const iter = this.listByClusterPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByClusterPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listByClusterPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCluster(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByClusterNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByClusterPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByClusterPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes a specified persisted script action of the cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param scriptName The name of the script.
     * @param options The options parameters.
     */
    delete(resourceGroupName, clusterName, scriptName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, scriptName, options }, deleteOperationSpec$1);
    }
    /**
     * Lists all the persisted script actions for the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec$3);
    }
    /**
     * Gets the script execution detail for the given script execution ID.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param scriptExecutionId The script execution Id
     * @param options The options parameters.
     */
    getExecutionDetail(resourceGroupName, clusterName, scriptExecutionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, scriptExecutionId, options }, getExecutionDetailOperationSpec);
    }
    /**
     * Gets the async operation status of execution operation.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getExecutionAsyncOperationStatus(resourceGroupName, clusterName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, operationId, options }, getExecutionAsyncOperationStatusOperationSpec);
    }
    /**
     * ListByClusterNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListByCluster method.
     * @param options The options parameters.
     */
    _listByClusterNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listByClusterNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptActions/{scriptName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        scriptName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByClusterOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptActions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptActionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getExecutionDetailOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory/{scriptExecutionId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RuntimeScriptActionDetail
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        scriptExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getExecutionAsyncOperationStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/executeScriptActions/azureasyncoperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByClusterNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptActionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScriptExecutionHistory operations. */
class ScriptExecutionHistoryImpl {
    /**
     * Initialize a new instance of the class ScriptExecutionHistory class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all scripts' execution history for the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        const iter = this.listByClusterPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByClusterPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listByClusterPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCluster(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByClusterNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByClusterPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByClusterPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all scripts' execution history for the specified cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec$2);
    }
    /**
     * Promotes the specified ad-hoc script execution to a persisted script.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param scriptExecutionId The script execution Id
     * @param options The options parameters.
     */
    promote(resourceGroupName, clusterName, scriptExecutionId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, scriptExecutionId, options }, promoteOperationSpec);
    }
    /**
     * ListByClusterNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListByCluster method.
     * @param options The options parameters.
     */
    _listByClusterNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listByClusterNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByClusterOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptActionExecutionHistoryList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const promoteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/scriptExecutionHistory/{scriptExecutionId}/promote",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        scriptExecutionId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByClusterNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptActionExecutionHistoryList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available HDInsight REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available HDInsight REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.HDInsight/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the HDInsight clusters hosts
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listHosts(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listHostsOperationSpec);
    }
    /**
     * Restarts the specified HDInsight cluster hosts.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param hosts The list of hosts to restart
     * @param options The options parameters.
     */
    beginRestartHosts(resourceGroupName, clusterName, hosts, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, clusterName, hosts, options }, restartHostsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restarts the specified HDInsight cluster hosts.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param hosts The list of hosts to restart
     * @param options The options parameters.
     */
    beginRestartHostsAndWait(resourceGroupName, clusterName, hosts, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestartHosts(resourceGroupName, clusterName, hosts, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the async operation status.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param operationId The long running operation id.
     * @param options The options parameters.
     */
    getAsyncOperationStatus(resourceGroupName, clusterName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, operationId, options }, getAsyncOperationStatusOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listHostsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/listHosts",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "HostInfo" } }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const restartHostsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/restartHosts",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: hosts,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$2
};
const getAsyncOperationStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/restartHosts/azureasyncoperations/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AsyncOperationResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the private endpoint connections for a HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        const iter = this.listByClusterPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByClusterPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listByClusterPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByCluster(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByClusterNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByClusterPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByClusterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByClusterPagingPage(resourceGroupName, clusterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists the private endpoint connections for a HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    _listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec$1);
    }
    /**
     * Approve or reject a private endpoint connection manually.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters The private endpoint connection create or update request.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                clusterName,
                privateEndpointConnectionName,
                parameters,
                options
            }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Approve or reject a private endpoint connection manually.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param parameters The private endpoint connection create or update request.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, privateEndpointConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, privateEndpointConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specific private endpoint connection.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            clusterName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$1);
    }
    /**
     * Deletes the specific private endpoint connection.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                clusterName,
                privateEndpointConnectionName,
                options
            }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specific private endpoint connection.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateEndpointConnectionName The name of the private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByClusterNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param nextLink The nextLink from the previous successful call to the ListByCluster method.
     * @param options The options parameters.
     */
    _listByClusterNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listByClusterNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByClusterOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointConnectionName
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByClusterNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the private link resources in a HDInsight cluster.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param options The options parameters.
     */
    listByCluster(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listByClusterOperationSpec);
    }
    /**
     * Gets the specific private link resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster.
     * @param privateLinkResourceName The name of the private link resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, privateLinkResourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, privateLinkResourceName, options }, getOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByClusterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.HDInsight/clusters/{clusterName}/privateLinkResources/{privateLinkResourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateLinkResourceName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class HDInsightManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the HDInsightManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription credentials which uniquely identify Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-hdinsight/1.2.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-06-01";
        this.clusters = new ClustersImpl(this);
        this.applications = new ApplicationsImpl(this);
        this.locations = new LocationsImpl(this);
        this.configurations = new ConfigurationsImpl(this);
        this.extensions = new ExtensionsImpl(this);
        this.scriptActions = new ScriptActionsImpl(this);
        this.scriptExecutionHistory = new ScriptExecutionHistoryImpl(this);
        this.operations = new OperationsImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.HDInsightManagementClient = HDInsightManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
