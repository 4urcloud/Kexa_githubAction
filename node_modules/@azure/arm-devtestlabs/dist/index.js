'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link StorageType} that the service accepts. */
exports.KnownStorageType = void 0;
(function (KnownStorageType) {
    /** Standard */
    KnownStorageType["Standard"] = "Standard";
    /** Premium */
    KnownStorageType["Premium"] = "Premium";
    /** StandardSSD */
    KnownStorageType["StandardSSD"] = "StandardSSD";
})(exports.KnownStorageType || (exports.KnownStorageType = {}));
/** Known values of {@link PremiumDataDisk} that the service accepts. */
exports.KnownPremiumDataDisk = void 0;
(function (KnownPremiumDataDisk) {
    /** Disabled */
    KnownPremiumDataDisk["Disabled"] = "Disabled";
    /** Enabled */
    KnownPremiumDataDisk["Enabled"] = "Enabled";
})(exports.KnownPremiumDataDisk || (exports.KnownPremiumDataDisk = {}));
/** Known values of {@link EnvironmentPermission} that the service accepts. */
exports.KnownEnvironmentPermission = void 0;
(function (KnownEnvironmentPermission) {
    /** Reader */
    KnownEnvironmentPermission["Reader"] = "Reader";
    /** Contributor */
    KnownEnvironmentPermission["Contributor"] = "Contributor";
})(exports.KnownEnvironmentPermission || (exports.KnownEnvironmentPermission = {}));
/** Known values of {@link EnableStatus} that the service accepts. */
exports.KnownEnableStatus = void 0;
(function (KnownEnableStatus) {
    /** Enabled */
    KnownEnableStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownEnableStatus["Disabled"] = "Disabled";
})(exports.KnownEnableStatus || (exports.KnownEnableStatus = {}));
/** Known values of {@link HttpStatusCode} that the service accepts. */
exports.KnownHttpStatusCode = void 0;
(function (KnownHttpStatusCode) {
    /** Continue */
    KnownHttpStatusCode["Continue"] = "Continue";
    /** SwitchingProtocols */
    KnownHttpStatusCode["SwitchingProtocols"] = "SwitchingProtocols";
    /** OK */
    KnownHttpStatusCode["OK"] = "OK";
    /** Created */
    KnownHttpStatusCode["Created"] = "Created";
    /** Accepted */
    KnownHttpStatusCode["Accepted"] = "Accepted";
    /** NonAuthoritativeInformation */
    KnownHttpStatusCode["NonAuthoritativeInformation"] = "NonAuthoritativeInformation";
    /** NoContent */
    KnownHttpStatusCode["NoContent"] = "NoContent";
    /** ResetContent */
    KnownHttpStatusCode["ResetContent"] = "ResetContent";
    /** PartialContent */
    KnownHttpStatusCode["PartialContent"] = "PartialContent";
    /** MultipleChoices */
    KnownHttpStatusCode["MultipleChoices"] = "MultipleChoices";
    /** Ambiguous */
    KnownHttpStatusCode["Ambiguous"] = "Ambiguous";
    /** MovedPermanently */
    KnownHttpStatusCode["MovedPermanently"] = "MovedPermanently";
    /** Moved */
    KnownHttpStatusCode["Moved"] = "Moved";
    /** Found */
    KnownHttpStatusCode["Found"] = "Found";
    /** Redirect */
    KnownHttpStatusCode["Redirect"] = "Redirect";
    /** SeeOther */
    KnownHttpStatusCode["SeeOther"] = "SeeOther";
    /** RedirectMethod */
    KnownHttpStatusCode["RedirectMethod"] = "RedirectMethod";
    /** NotModified */
    KnownHttpStatusCode["NotModified"] = "NotModified";
    /** UseProxy */
    KnownHttpStatusCode["UseProxy"] = "UseProxy";
    /** Unused */
    KnownHttpStatusCode["Unused"] = "Unused";
    /** TemporaryRedirect */
    KnownHttpStatusCode["TemporaryRedirect"] = "TemporaryRedirect";
    /** RedirectKeepVerb */
    KnownHttpStatusCode["RedirectKeepVerb"] = "RedirectKeepVerb";
    /** BadRequest */
    KnownHttpStatusCode["BadRequest"] = "BadRequest";
    /** Unauthorized */
    KnownHttpStatusCode["Unauthorized"] = "Unauthorized";
    /** PaymentRequired */
    KnownHttpStatusCode["PaymentRequired"] = "PaymentRequired";
    /** Forbidden */
    KnownHttpStatusCode["Forbidden"] = "Forbidden";
    /** NotFound */
    KnownHttpStatusCode["NotFound"] = "NotFound";
    /** MethodNotAllowed */
    KnownHttpStatusCode["MethodNotAllowed"] = "MethodNotAllowed";
    /** NotAcceptable */
    KnownHttpStatusCode["NotAcceptable"] = "NotAcceptable";
    /** ProxyAuthenticationRequired */
    KnownHttpStatusCode["ProxyAuthenticationRequired"] = "ProxyAuthenticationRequired";
    /** RequestTimeout */
    KnownHttpStatusCode["RequestTimeout"] = "RequestTimeout";
    /** Conflict */
    KnownHttpStatusCode["Conflict"] = "Conflict";
    /** Gone */
    KnownHttpStatusCode["Gone"] = "Gone";
    /** LengthRequired */
    KnownHttpStatusCode["LengthRequired"] = "LengthRequired";
    /** PreconditionFailed */
    KnownHttpStatusCode["PreconditionFailed"] = "PreconditionFailed";
    /** RequestEntityTooLarge */
    KnownHttpStatusCode["RequestEntityTooLarge"] = "RequestEntityTooLarge";
    /** RequestUriTooLong */
    KnownHttpStatusCode["RequestUriTooLong"] = "RequestUriTooLong";
    /** UnsupportedMediaType */
    KnownHttpStatusCode["UnsupportedMediaType"] = "UnsupportedMediaType";
    /** RequestedRangeNotSatisfiable */
    KnownHttpStatusCode["RequestedRangeNotSatisfiable"] = "RequestedRangeNotSatisfiable";
    /** ExpectationFailed */
    KnownHttpStatusCode["ExpectationFailed"] = "ExpectationFailed";
    /** UpgradeRequired */
    KnownHttpStatusCode["UpgradeRequired"] = "UpgradeRequired";
    /** InternalServerError */
    KnownHttpStatusCode["InternalServerError"] = "InternalServerError";
    /** NotImplemented */
    KnownHttpStatusCode["NotImplemented"] = "NotImplemented";
    /** BadGateway */
    KnownHttpStatusCode["BadGateway"] = "BadGateway";
    /** ServiceUnavailable */
    KnownHttpStatusCode["ServiceUnavailable"] = "ServiceUnavailable";
    /** GatewayTimeout */
    KnownHttpStatusCode["GatewayTimeout"] = "GatewayTimeout";
    /** HttpVersionNotSupported */
    KnownHttpStatusCode["HttpVersionNotSupported"] = "HttpVersionNotSupported";
})(exports.KnownHttpStatusCode || (exports.KnownHttpStatusCode = {}));
/** Known values of {@link SourceControlType} that the service accepts. */
exports.KnownSourceControlType = void 0;
(function (KnownSourceControlType) {
    /** VsoGit */
    KnownSourceControlType["VsoGit"] = "VsoGit";
    /** GitHub */
    KnownSourceControlType["GitHub"] = "GitHub";
    /** StorageAccount */
    KnownSourceControlType["StorageAccount"] = "StorageAccount";
})(exports.KnownSourceControlType || (exports.KnownSourceControlType = {}));
/** Known values of {@link FileUploadOptions} that the service accepts. */
exports.KnownFileUploadOptions = void 0;
(function (KnownFileUploadOptions) {
    /** UploadFilesAndGenerateSasTokens */
    KnownFileUploadOptions["UploadFilesAndGenerateSasTokens"] = "UploadFilesAndGenerateSasTokens";
    /** None */
    KnownFileUploadOptions["None"] = "None";
})(exports.KnownFileUploadOptions || (exports.KnownFileUploadOptions = {}));
/** Known values of {@link TargetCostStatus} that the service accepts. */
exports.KnownTargetCostStatus = void 0;
(function (KnownTargetCostStatus) {
    /** Enabled */
    KnownTargetCostStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownTargetCostStatus["Disabled"] = "Disabled";
})(exports.KnownTargetCostStatus || (exports.KnownTargetCostStatus = {}));
/** Known values of {@link CostThresholdStatus} that the service accepts. */
exports.KnownCostThresholdStatus = void 0;
(function (KnownCostThresholdStatus) {
    /** Enabled */
    KnownCostThresholdStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownCostThresholdStatus["Disabled"] = "Disabled";
})(exports.KnownCostThresholdStatus || (exports.KnownCostThresholdStatus = {}));
/** Known values of {@link ReportingCycleType} that the service accepts. */
exports.KnownReportingCycleType = void 0;
(function (KnownReportingCycleType) {
    /** CalendarMonth */
    KnownReportingCycleType["CalendarMonth"] = "CalendarMonth";
    /** Custom */
    KnownReportingCycleType["Custom"] = "Custom";
})(exports.KnownReportingCycleType || (exports.KnownReportingCycleType = {}));
/** Known values of {@link CostType} that the service accepts. */
exports.KnownCostType = void 0;
(function (KnownCostType) {
    /** Unavailable */
    KnownCostType["Unavailable"] = "Unavailable";
    /** Reported */
    KnownCostType["Reported"] = "Reported";
    /** Projected */
    KnownCostType["Projected"] = "Projected";
})(exports.KnownCostType || (exports.KnownCostType = {}));
/** Known values of {@link WindowsOsState} that the service accepts. */
exports.KnownWindowsOsState = void 0;
(function (KnownWindowsOsState) {
    /** NonSysprepped */
    KnownWindowsOsState["NonSysprepped"] = "NonSysprepped";
    /** SysprepRequested */
    KnownWindowsOsState["SysprepRequested"] = "SysprepRequested";
    /** SysprepApplied */
    KnownWindowsOsState["SysprepApplied"] = "SysprepApplied";
})(exports.KnownWindowsOsState || (exports.KnownWindowsOsState = {}));
/** Known values of {@link LinuxOsState} that the service accepts. */
exports.KnownLinuxOsState = void 0;
(function (KnownLinuxOsState) {
    /** NonDeprovisioned */
    KnownLinuxOsState["NonDeprovisioned"] = "NonDeprovisioned";
    /** DeprovisionRequested */
    KnownLinuxOsState["DeprovisionRequested"] = "DeprovisionRequested";
    /** DeprovisionApplied */
    KnownLinuxOsState["DeprovisionApplied"] = "DeprovisionApplied";
})(exports.KnownLinuxOsState || (exports.KnownLinuxOsState = {}));
/** Known values of {@link CustomImageOsType} that the service accepts. */
exports.KnownCustomImageOsType = void 0;
(function (KnownCustomImageOsType) {
    /** Windows */
    KnownCustomImageOsType["Windows"] = "Windows";
    /** Linux */
    KnownCustomImageOsType["Linux"] = "Linux";
    /** None */
    KnownCustomImageOsType["None"] = "None";
})(exports.KnownCustomImageOsType || (exports.KnownCustomImageOsType = {}));
/** Known values of {@link TransportProtocol} that the service accepts. */
exports.KnownTransportProtocol = void 0;
(function (KnownTransportProtocol) {
    /** Tcp */
    KnownTransportProtocol["Tcp"] = "Tcp";
    /** Udp */
    KnownTransportProtocol["Udp"] = "Udp";
})(exports.KnownTransportProtocol || (exports.KnownTransportProtocol = {}));
/** Known values of {@link HostCachingOptions} that the service accepts. */
exports.KnownHostCachingOptions = void 0;
(function (KnownHostCachingOptions) {
    /** None */
    KnownHostCachingOptions["None"] = "None";
    /** ReadOnly */
    KnownHostCachingOptions["ReadOnly"] = "ReadOnly";
    /** ReadWrite */
    KnownHostCachingOptions["ReadWrite"] = "ReadWrite";
})(exports.KnownHostCachingOptions || (exports.KnownHostCachingOptions = {}));
/** Known values of {@link NotificationChannelEventType} that the service accepts. */
exports.KnownNotificationChannelEventType = void 0;
(function (KnownNotificationChannelEventType) {
    /** AutoShutdown */
    KnownNotificationChannelEventType["AutoShutdown"] = "AutoShutdown";
    /** Cost */
    KnownNotificationChannelEventType["Cost"] = "Cost";
})(exports.KnownNotificationChannelEventType || (exports.KnownNotificationChannelEventType = {}));
/** Known values of {@link PolicyStatus} that the service accepts. */
exports.KnownPolicyStatus = void 0;
(function (KnownPolicyStatus) {
    /** Enabled */
    KnownPolicyStatus["Enabled"] = "Enabled";
    /** Disabled */
    KnownPolicyStatus["Disabled"] = "Disabled";
})(exports.KnownPolicyStatus || (exports.KnownPolicyStatus = {}));
/** Known values of {@link PolicyFactName} that the service accepts. */
exports.KnownPolicyFactName = void 0;
(function (KnownPolicyFactName) {
    /** UserOwnedLabVmCount */
    KnownPolicyFactName["UserOwnedLabVmCount"] = "UserOwnedLabVmCount";
    /** UserOwnedLabPremiumVmCount */
    KnownPolicyFactName["UserOwnedLabPremiumVmCount"] = "UserOwnedLabPremiumVmCount";
    /** LabVmCount */
    KnownPolicyFactName["LabVmCount"] = "LabVmCount";
    /** LabPremiumVmCount */
    KnownPolicyFactName["LabPremiumVmCount"] = "LabPremiumVmCount";
    /** LabVmSize */
    KnownPolicyFactName["LabVmSize"] = "LabVmSize";
    /** GalleryImage */
    KnownPolicyFactName["GalleryImage"] = "GalleryImage";
    /** UserOwnedLabVmCountInSubnet */
    KnownPolicyFactName["UserOwnedLabVmCountInSubnet"] = "UserOwnedLabVmCountInSubnet";
    /** LabTargetCost */
    KnownPolicyFactName["LabTargetCost"] = "LabTargetCost";
    /** EnvironmentTemplate */
    KnownPolicyFactName["EnvironmentTemplate"] = "EnvironmentTemplate";
    /** ScheduleEditPermission */
    KnownPolicyFactName["ScheduleEditPermission"] = "ScheduleEditPermission";
})(exports.KnownPolicyFactName || (exports.KnownPolicyFactName = {}));
/** Known values of {@link PolicyEvaluatorType} that the service accepts. */
exports.KnownPolicyEvaluatorType = void 0;
(function (KnownPolicyEvaluatorType) {
    /** AllowedValuesPolicy */
    KnownPolicyEvaluatorType["AllowedValuesPolicy"] = "AllowedValuesPolicy";
    /** MaxValuePolicy */
    KnownPolicyEvaluatorType["MaxValuePolicy"] = "MaxValuePolicy";
})(exports.KnownPolicyEvaluatorType || (exports.KnownPolicyEvaluatorType = {}));
/** Known values of {@link ManagedIdentityType} that the service accepts. */
exports.KnownManagedIdentityType = void 0;
(function (KnownManagedIdentityType) {
    /** None */
    KnownManagedIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedIdentityType || (exports.KnownManagedIdentityType = {}));
/** Known values of {@link VirtualMachineCreationSource} that the service accepts. */
exports.KnownVirtualMachineCreationSource = void 0;
(function (KnownVirtualMachineCreationSource) {
    /** FromCustomImage */
    KnownVirtualMachineCreationSource["FromCustomImage"] = "FromCustomImage";
    /** FromGalleryImage */
    KnownVirtualMachineCreationSource["FromGalleryImage"] = "FromGalleryImage";
    /** FromSharedGalleryImage */
    KnownVirtualMachineCreationSource["FromSharedGalleryImage"] = "FromSharedGalleryImage";
})(exports.KnownVirtualMachineCreationSource || (exports.KnownVirtualMachineCreationSource = {}));
/** Known values of {@link UsagePermissionType} that the service accepts. */
exports.KnownUsagePermissionType = void 0;
(function (KnownUsagePermissionType) {
    /** Default */
    KnownUsagePermissionType["Default"] = "Default";
    /** Deny */
    KnownUsagePermissionType["Deny"] = "Deny";
    /** Allow */
    KnownUsagePermissionType["Allow"] = "Allow";
})(exports.KnownUsagePermissionType || (exports.KnownUsagePermissionType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ProviderOperationResult = {
    type: {
        name: "Composite",
        className: "ProviderOperationResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationMetadata"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationMetadata = {
    type: {
        name: "Composite",
        className: "OperationMetadata",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationMetadataDisplay"
                }
            }
        }
    }
};
const OperationMetadataDisplay = {
    type: {
        name: "Composite",
        className: "OperationMetadataDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const LabList = {
    type: {
        name: "Composite",
        className: "LabList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Lab"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabAnnouncementProperties = {
    type: {
        name: "Composite",
        className: "LabAnnouncementProperties",
        modelProperties: {
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            markdown: {
                serializedName: "markdown",
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "String"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                type: {
                    name: "DateTime"
                }
            },
            expired: {
                serializedName: "expired",
                type: {
                    name: "Boolean"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uniqueIdentifier: {
                serializedName: "uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabSupportProperties = {
    type: {
        name: "Composite",
        className: "LabSupportProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "String"
                }
            },
            markdown: {
                serializedName: "markdown",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const OperationResult = {
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "OperationError"
                }
            }
        }
    }
};
const OperationError = {
    type: {
        name: "Composite",
        className: "OperationError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduleList = {
    type: {
        name: "Composite",
        className: "ScheduleList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Schedule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WeekDetails = {
    type: {
        name: "Composite",
        className: "WeekDetails",
        modelProperties: {
            weekdays: {
                serializedName: "weekdays",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            time: {
                serializedName: "time",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DayDetails = {
    type: {
        name: "Composite",
        className: "DayDetails",
        modelProperties: {
            time: {
                serializedName: "time",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HourDetails = {
    type: {
        name: "Composite",
        className: "HourDetails",
        modelProperties: {
            minute: {
                serializedName: "minute",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NotificationSettings = {
    type: {
        name: "Composite",
        className: "NotificationSettings",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            timeInMinutes: {
                serializedName: "timeInMinutes",
                type: {
                    name: "Number"
                }
            },
            webhookUrl: {
                serializedName: "webhookUrl",
                type: {
                    name: "String"
                }
            },
            emailRecipient: {
                serializedName: "emailRecipient",
                type: {
                    name: "String"
                }
            },
            notificationLocale: {
                serializedName: "notificationLocale",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArtifactSourceList = {
    type: {
        name: "Composite",
        className: "ArtifactSourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactSource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArmTemplateList = {
    type: {
        name: "Composite",
        className: "ArmTemplateList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArmTemplate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParametersValueFileInfo = {
    type: {
        name: "Composite",
        className: "ParametersValueFileInfo",
        modelProperties: {
            fileName: {
                serializedName: "fileName",
                type: {
                    name: "String"
                }
            },
            parametersValueInfo: {
                serializedName: "parametersValueInfo",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ArtifactList = {
    type: {
        name: "Composite",
        className: "ArtifactList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Artifact"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateArmTemplateRequest = {
    type: {
        name: "Composite",
        className: "GenerateArmTemplateRequest",
        modelProperties: {
            virtualMachineName: {
                serializedName: "virtualMachineName",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterInfo"
                        }
                    }
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            fileUploadOptions: {
                serializedName: "fileUploadOptions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParameterInfo = {
    type: {
        name: "Composite",
        className: "ParameterInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArmTemplateInfo = {
    type: {
        name: "Composite",
        className: "ArmTemplateInfo",
        modelProperties: {
            template: {
                serializedName: "template",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const UpdateResource = {
    type: {
        name: "Composite",
        className: "UpdateResource",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const TargetCostProperties = {
    type: {
        name: "Composite",
        className: "TargetCostProperties",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "Number"
                }
            },
            costThresholds: {
                serializedName: "costThresholds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CostThresholdProperties"
                        }
                    }
                }
            },
            cycleStartDateTime: {
                serializedName: "cycleStartDateTime",
                type: {
                    name: "DateTime"
                }
            },
            cycleEndDateTime: {
                serializedName: "cycleEndDateTime",
                type: {
                    name: "DateTime"
                }
            },
            cycleType: {
                serializedName: "cycleType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CostThresholdProperties = {
    type: {
        name: "Composite",
        className: "CostThresholdProperties",
        modelProperties: {
            thresholdId: {
                serializedName: "thresholdId",
                type: {
                    name: "String"
                }
            },
            percentageThreshold: {
                serializedName: "percentageThreshold",
                type: {
                    name: "Composite",
                    className: "PercentageCostThresholdProperties"
                }
            },
            displayOnChart: {
                serializedName: "displayOnChart",
                type: {
                    name: "String"
                }
            },
            sendNotificationWhenExceeded: {
                serializedName: "sendNotificationWhenExceeded",
                type: {
                    name: "String"
                }
            },
            notificationSent: {
                serializedName: "notificationSent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PercentageCostThresholdProperties = {
    type: {
        name: "Composite",
        className: "PercentageCostThresholdProperties",
        modelProperties: {
            thresholdValue: {
                serializedName: "thresholdValue",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LabCostSummaryProperties = {
    type: {
        name: "Composite",
        className: "LabCostSummaryProperties",
        modelProperties: {
            estimatedLabCost: {
                serializedName: "estimatedLabCost",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LabCostDetailsProperties = {
    type: {
        name: "Composite",
        className: "LabCostDetailsProperties",
        modelProperties: {
            date: {
                serializedName: "date",
                type: {
                    name: "DateTime"
                }
            },
            cost: {
                serializedName: "cost",
                type: {
                    name: "Number"
                }
            },
            costType: {
                serializedName: "costType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabResourceCostProperties = {
    type: {
        name: "Composite",
        className: "LabResourceCostProperties",
        modelProperties: {
            resourcename: {
                serializedName: "resourcename",
                type: {
                    name: "String"
                }
            },
            resourceUId: {
                serializedName: "resourceUId",
                type: {
                    name: "String"
                }
            },
            resourceCost: {
                serializedName: "resourceCost",
                type: {
                    name: "Number"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            resourceOwner: {
                serializedName: "resourceOwner",
                type: {
                    name: "String"
                }
            },
            resourcePricingTier: {
                serializedName: "resourcePricingTier",
                type: {
                    name: "String"
                }
            },
            resourceStatus: {
                serializedName: "resourceStatus",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            externalResourceId: {
                serializedName: "externalResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomImageList = {
    type: {
        name: "Composite",
        className: "CustomImageList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomImage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomImagePropertiesFromVm = {
    type: {
        name: "Composite",
        className: "CustomImagePropertiesFromVm",
        modelProperties: {
            sourceVmId: {
                serializedName: "sourceVmId",
                type: {
                    name: "String"
                }
            },
            windowsOsInfo: {
                serializedName: "windowsOsInfo",
                type: {
                    name: "Composite",
                    className: "WindowsOsInfo"
                }
            },
            linuxOsInfo: {
                serializedName: "linuxOsInfo",
                type: {
                    name: "Composite",
                    className: "LinuxOsInfo"
                }
            }
        }
    }
};
const WindowsOsInfo = {
    type: {
        name: "Composite",
        className: "WindowsOsInfo",
        modelProperties: {
            windowsOsState: {
                serializedName: "windowsOsState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LinuxOsInfo = {
    type: {
        name: "Composite",
        className: "LinuxOsInfo",
        modelProperties: {
            linuxOsState: {
                serializedName: "linuxOsState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomImagePropertiesCustom = {
    type: {
        name: "Composite",
        className: "CustomImagePropertiesCustom",
        modelProperties: {
            imageName: {
                serializedName: "imageName",
                type: {
                    name: "String"
                }
            },
            sysPrep: {
                serializedName: "sysPrep",
                type: {
                    name: "Boolean"
                }
            },
            osType: {
                serializedName: "osType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataDiskStorageTypeInfo = {
    type: {
        name: "Composite",
        className: "DataDiskStorageTypeInfo",
        modelProperties: {
            lun: {
                serializedName: "lun",
                type: {
                    name: "String"
                }
            },
            storageType: {
                serializedName: "storageType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomImagePropertiesFromPlan = {
    type: {
        name: "Composite",
        className: "CustomImagePropertiesFromPlan",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FormulaList = {
    type: {
        name: "Composite",
        className: "FormulaList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Formula"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabVirtualMachineCreationParameter = {
    type: {
        name: "Composite",
        className: "LabVirtualMachineCreationParameter",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            bulkCreationParameters: {
                serializedName: "properties.bulkCreationParameters",
                type: {
                    name: "Composite",
                    className: "BulkCreationParameters"
                }
            },
            notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            },
            ownerObjectId: {
                defaultValue: "dynamicValue",
                serializedName: "properties.ownerObjectId",
                type: {
                    name: "String"
                }
            },
            ownerUserPrincipalName: {
                serializedName: "properties.ownerUserPrincipalName",
                type: {
                    name: "String"
                }
            },
            createdDate: {
                serializedName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            },
            customImageId: {
                serializedName: "properties.customImageId",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "properties.size",
                type: {
                    name: "String"
                }
            },
            userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            },
            sshKey: {
                serializedName: "properties.sshKey",
                type: {
                    name: "String"
                }
            },
            isAuthenticationWithSshKey: {
                serializedName: "properties.isAuthenticationWithSshKey",
                type: {
                    name: "Boolean"
                }
            },
            labSubnetName: {
                serializedName: "properties.labSubnetName",
                type: {
                    name: "String"
                }
            },
            labVirtualNetworkId: {
                serializedName: "properties.labVirtualNetworkId",
                type: {
                    name: "String"
                }
            },
            disallowPublicIpAddress: {
                defaultValue: false,
                serializedName: "properties.disallowPublicIpAddress",
                type: {
                    name: "Boolean"
                }
            },
            artifacts: {
                serializedName: "properties.artifacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactInstallProperties"
                        }
                    }
                }
            },
            galleryImageReference: {
                serializedName: "properties.galleryImageReference",
                type: {
                    name: "Composite",
                    className: "GalleryImageReference"
                }
            },
            planId: {
                serializedName: "properties.planId",
                type: {
                    name: "String"
                }
            },
            networkInterface: {
                serializedName: "properties.networkInterface",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceProperties"
                }
            },
            expirationDate: {
                serializedName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            },
            allowClaim: {
                defaultValue: false,
                serializedName: "properties.allowClaim",
                type: {
                    name: "Boolean"
                }
            },
            storageType: {
                defaultValue: "labStorageType",
                serializedName: "properties.storageType",
                type: {
                    name: "String"
                }
            },
            environmentId: {
                serializedName: "properties.environmentId",
                type: {
                    name: "String"
                }
            },
            dataDiskParameters: {
                serializedName: "properties.dataDiskParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDiskProperties"
                        }
                    }
                }
            },
            scheduleParameters: {
                serializedName: "properties.scheduleParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScheduleCreationParameter"
                        }
                    }
                }
            }
        }
    }
};
const BulkCreationParameters = {
    type: {
        name: "Composite",
        className: "BulkCreationParameters",
        modelProperties: {
            instanceCount: {
                serializedName: "instanceCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ArtifactInstallProperties = {
    type: {
        name: "Composite",
        className: "ArtifactInstallProperties",
        modelProperties: {
            artifactId: {
                serializedName: "artifactId",
                type: {
                    name: "String"
                }
            },
            artifactTitle: {
                serializedName: "artifactTitle",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactParameterProperties"
                        }
                    }
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            deploymentStatusMessage: {
                serializedName: "deploymentStatusMessage",
                type: {
                    name: "String"
                }
            },
            vmExtensionStatusMessage: {
                serializedName: "vmExtensionStatusMessage",
                type: {
                    name: "String"
                }
            },
            installTime: {
                serializedName: "installTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ArtifactParameterProperties = {
    type: {
        name: "Composite",
        className: "ArtifactParameterProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageReference = {
    type: {
        name: "Composite",
        className: "GalleryImageReference",
        modelProperties: {
            offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceProperties = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceProperties",
        modelProperties: {
            virtualNetworkId: {
                serializedName: "virtualNetworkId",
                type: {
                    name: "String"
                }
            },
            subnetId: {
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            publicIpAddressId: {
                serializedName: "publicIpAddressId",
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                type: {
                    name: "String"
                }
            },
            dnsName: {
                serializedName: "dnsName",
                type: {
                    name: "String"
                }
            },
            rdpAuthority: {
                serializedName: "rdpAuthority",
                type: {
                    name: "String"
                }
            },
            sshAuthority: {
                serializedName: "sshAuthority",
                type: {
                    name: "String"
                }
            },
            sharedPublicIpAddressConfiguration: {
                serializedName: "sharedPublicIpAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "SharedPublicIpAddressConfiguration"
                }
            }
        }
    }
};
const SharedPublicIpAddressConfiguration = {
    type: {
        name: "Composite",
        className: "SharedPublicIpAddressConfiguration",
        modelProperties: {
            inboundNatRules: {
                serializedName: "inboundNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            }
        }
    }
};
const InboundNatRule = {
    type: {
        name: "Composite",
        className: "InboundNatRule",
        modelProperties: {
            transportProtocol: {
                serializedName: "transportProtocol",
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                serializedName: "frontendPort",
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DataDiskProperties = {
    type: {
        name: "Composite",
        className: "DataDiskProperties",
        modelProperties: {
            attachNewDataDiskOptions: {
                serializedName: "attachNewDataDiskOptions",
                type: {
                    name: "Composite",
                    className: "AttachNewDataDiskOptions"
                }
            },
            existingLabDiskId: {
                serializedName: "existingLabDiskId",
                type: {
                    name: "String"
                }
            },
            hostCaching: {
                serializedName: "hostCaching",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AttachNewDataDiskOptions = {
    type: {
        name: "Composite",
        className: "AttachNewDataDiskOptions",
        modelProperties: {
            diskSizeGiB: {
                serializedName: "diskSizeGiB",
                type: {
                    name: "Number"
                }
            },
            diskName: {
                serializedName: "diskName",
                type: {
                    name: "String"
                }
            },
            diskType: {
                serializedName: "diskType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduleCreationParameter = {
    type: {
        name: "Composite",
        className: "ScheduleCreationParameter",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            },
            taskType: {
                serializedName: "properties.taskType",
                type: {
                    name: "String"
                }
            },
            weeklyRecurrence: {
                serializedName: "properties.weeklyRecurrence",
                type: {
                    name: "Composite",
                    className: "WeekDetails"
                }
            },
            dailyRecurrence: {
                serializedName: "properties.dailyRecurrence",
                type: {
                    name: "Composite",
                    className: "DayDetails"
                }
            },
            hourlyRecurrence: {
                serializedName: "properties.hourlyRecurrence",
                type: {
                    name: "Composite",
                    className: "HourDetails"
                }
            },
            timeZoneId: {
                serializedName: "properties.timeZoneId",
                type: {
                    name: "String"
                }
            },
            notificationSettings: {
                serializedName: "properties.notificationSettings",
                type: {
                    name: "Composite",
                    className: "NotificationSettings"
                }
            },
            targetResourceId: {
                serializedName: "properties.targetResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FormulaPropertiesFromVm = {
    type: {
        name: "Composite",
        className: "FormulaPropertiesFromVm",
        modelProperties: {
            labVmId: {
                serializedName: "labVmId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GalleryImageList = {
    type: {
        name: "Composite",
        className: "GalleryImageList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GalleryImage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotificationChannelList = {
    type: {
        name: "Composite",
        className: "NotificationChannelList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NotificationChannel"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Event = {
    type: {
        name: "Composite",
        className: "Event",
        modelProperties: {
            eventName: {
                serializedName: "eventName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NotifyParameters = {
    type: {
        name: "Composite",
        className: "NotifyParameters",
        modelProperties: {
            eventName: {
                serializedName: "eventName",
                type: {
                    name: "String"
                }
            },
            jsonPayload: {
                serializedName: "jsonPayload",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EvaluatePoliciesRequest = {
    type: {
        name: "Composite",
        className: "EvaluatePoliciesRequest",
        modelProperties: {
            policies: {
                serializedName: "policies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EvaluatePoliciesProperties"
                        }
                    }
                }
            }
        }
    }
};
const EvaluatePoliciesProperties = {
    type: {
        name: "Composite",
        className: "EvaluatePoliciesProperties",
        modelProperties: {
            factName: {
                serializedName: "factName",
                type: {
                    name: "String"
                }
            },
            factData: {
                serializedName: "factData",
                type: {
                    name: "String"
                }
            },
            valueOffset: {
                serializedName: "valueOffset",
                type: {
                    name: "String"
                }
            },
            userObjectId: {
                serializedName: "userObjectId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EvaluatePoliciesResponse = {
    type: {
        name: "Composite",
        className: "EvaluatePoliciesResponse",
        modelProperties: {
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicySetResult"
                        }
                    }
                }
            }
        }
    }
};
const PolicySetResult = {
    type: {
        name: "Composite",
        className: "PolicySetResult",
        modelProperties: {
            hasError: {
                serializedName: "hasError",
                type: {
                    name: "Boolean"
                }
            },
            policyViolations: {
                serializedName: "policyViolations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PolicyViolation"
                        }
                    }
                }
            }
        }
    }
};
const PolicyViolation = {
    type: {
        name: "Composite",
        className: "PolicyViolation",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicyList = {
    type: {
        name: "Composite",
        className: "PolicyList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Policy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdentityProperties = {
    type: {
        name: "Composite",
        className: "IdentityProperties",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            clientSecretUrl: {
                serializedName: "clientSecretUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserList = {
    type: {
        name: "Composite",
        className: "UserList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "User"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserIdentity = {
    type: {
        name: "Composite",
        className: "UserIdentity",
        modelProperties: {
            principalName: {
                serializedName: "principalName",
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            objectId: {
                serializedName: "objectId",
                type: {
                    name: "String"
                }
            },
            appId: {
                serializedName: "appId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserSecretStore = {
    type: {
        name: "Composite",
        className: "UserSecretStore",
        modelProperties: {
            keyVaultUri: {
                serializedName: "keyVaultUri",
                type: {
                    name: "String"
                }
            },
            keyVaultId: {
                serializedName: "keyVaultId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskList = {
    type: {
        name: "Composite",
        className: "DiskList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Disk"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AttachDiskProperties = {
    type: {
        name: "Composite",
        className: "AttachDiskProperties",
        modelProperties: {
            leasedByLabVmId: {
                serializedName: "leasedByLabVmId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DetachDiskProperties = {
    type: {
        name: "Composite",
        className: "DetachDiskProperties",
        modelProperties: {
            leasedByLabVmId: {
                serializedName: "leasedByLabVmId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DtlEnvironmentList = {
    type: {
        name: "Composite",
        className: "DtlEnvironmentList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DtlEnvironment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EnvironmentDeploymentProperties = {
    type: {
        name: "Composite",
        className: "EnvironmentDeploymentProperties",
        modelProperties: {
            armTemplateId: {
                serializedName: "armTemplateId",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArmTemplateParameterProperties"
                        }
                    }
                }
            }
        }
    }
};
const ArmTemplateParameterProperties = {
    type: {
        name: "Composite",
        className: "ArmTemplateParameterProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecretList = {
    type: {
        name: "Composite",
        className: "SecretList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Secret"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceFabricList = {
    type: {
        name: "Composite",
        className: "ServiceFabricList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceFabric"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabVirtualMachineList = {
    type: {
        name: "Composite",
        className: "LabVirtualMachineList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabVirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArtifactDeploymentStatusProperties = {
    type: {
        name: "Composite",
        className: "ArtifactDeploymentStatusProperties",
        modelProperties: {
            deploymentStatus: {
                serializedName: "deploymentStatus",
                type: {
                    name: "String"
                }
            },
            artifactsApplied: {
                serializedName: "artifactsApplied",
                type: {
                    name: "Number"
                }
            },
            totalArtifacts: {
                serializedName: "totalArtifacts",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ComputeVmProperties = {
    type: {
        name: "Composite",
        className: "ComputeVmProperties",
        modelProperties: {
            statuses: {
                serializedName: "statuses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeVmInstanceViewStatus"
                        }
                    }
                }
            },
            osType: {
                serializedName: "osType",
                type: {
                    name: "String"
                }
            },
            vmSize: {
                serializedName: "vmSize",
                type: {
                    name: "String"
                }
            },
            networkInterfaceId: {
                serializedName: "networkInterfaceId",
                type: {
                    name: "String"
                }
            },
            osDiskId: {
                serializedName: "osDiskId",
                type: {
                    name: "String"
                }
            },
            dataDiskIds: {
                serializedName: "dataDiskIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dataDisks: {
                serializedName: "dataDisks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ComputeDataDisk"
                        }
                    }
                }
            }
        }
    }
};
const ComputeVmInstanceViewStatus = {
    type: {
        name: "Composite",
        className: "ComputeVmInstanceViewStatus",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            displayStatus: {
                serializedName: "displayStatus",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ComputeDataDisk = {
    type: {
        name: "Composite",
        className: "ComputeDataDisk",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            diskUri: {
                serializedName: "diskUri",
                type: {
                    name: "String"
                }
            },
            managedDiskId: {
                serializedName: "managedDiskId",
                type: {
                    name: "String"
                }
            },
            diskSizeGiB: {
                serializedName: "diskSizeGiB",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplyArtifactsRequest = {
    type: {
        name: "Composite",
        className: "ApplyArtifactsRequest",
        modelProperties: {
            artifacts: {
                serializedName: "artifacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactInstallProperties"
                        }
                    }
                }
            }
        }
    }
};
const DetachDataDiskProperties = {
    type: {
        name: "Composite",
        className: "DetachDataDiskProperties",
        modelProperties: {
            existingLabDiskId: {
                serializedName: "existingLabDiskId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RdpConnection = {
    type: {
        name: "Composite",
        className: "RdpConnection",
        modelProperties: {
            contents: {
                serializedName: "contents",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResizeLabVirtualMachineProperties = {
    type: {
        name: "Composite",
        className: "ResizeLabVirtualMachineProperties",
        modelProperties: {
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkList = {
    type: {
        name: "Composite",
        className: "VirtualNetworkList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Subnet = {
    type: {
        name: "Composite",
        className: "Subnet",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            labSubnetName: {
                serializedName: "labSubnetName",
                type: {
                    name: "String"
                }
            },
            allowPublicIp: {
                serializedName: "allowPublicIp",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExternalSubnet = {
    type: {
        name: "Composite",
        className: "ExternalSubnet",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubnetOverride = {
    type: {
        name: "Composite",
        className: "SubnetOverride",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            labSubnetName: {
                serializedName: "labSubnetName",
                type: {
                    name: "String"
                }
            },
            useInVmCreationPermission: {
                serializedName: "useInVmCreationPermission",
                type: {
                    name: "String"
                }
            },
            usePublicIpAddressPermission: {
                serializedName: "usePublicIpAddressPermission",
                type: {
                    name: "String"
                }
            },
            sharedPublicIpAddressConfiguration: {
                serializedName: "sharedPublicIpAddressConfiguration",
                type: {
                    name: "Composite",
                    className: "SubnetSharedPublicIpAddressConfiguration"
                }
            },
            virtualNetworkPoolName: {
                serializedName: "virtualNetworkPoolName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubnetSharedPublicIpAddressConfiguration = {
    type: {
        name: "Composite",
        className: "SubnetSharedPublicIpAddressConfiguration",
        modelProperties: {
            allowedPorts: {
                serializedName: "allowedPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Port"
                        }
                    }
                }
            }
        }
    }
};
const Port = {
    type: {
        name: "Composite",
        className: "Port",
        modelProperties: {
            transportProtocol: {
                serializedName: "transportProtocol",
                type: {
                    name: "String"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExportResourceUsageParameters = {
    type: {
        name: "Composite",
        className: "ExportResourceUsageParameters",
        modelProperties: {
            blobStorageAbsoluteSasUri: {
                serializedName: "blobStorageAbsoluteSasUri",
                type: {
                    name: "String"
                }
            },
            usageStartDate: {
                serializedName: "usageStartDate",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const GenerateUploadUriParameter = {
    type: {
        name: "Composite",
        className: "GenerateUploadUriParameter",
        modelProperties: {
            blobName: {
                serializedName: "blobName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateUploadUriResponse = {
    type: {
        name: "Composite",
        className: "GenerateUploadUriResponse",
        modelProperties: {
            uploadUri: {
                serializedName: "uploadUri",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImportLabVirtualMachineRequest = {
    type: {
        name: "Composite",
        className: "ImportLabVirtualMachineRequest",
        modelProperties: {
            sourceVirtualMachineResourceId: {
                serializedName: "sourceVirtualMachineResourceId",
                type: {
                    name: "String"
                }
            },
            destinationVirtualMachineName: {
                serializedName: "destinationVirtualMachineName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabVhdList = {
    type: {
        name: "Composite",
        className: "LabVhdList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabVhd"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabVhd = {
    type: {
        name: "Composite",
        className: "LabVhd",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RetargetScheduleProperties = {
    type: {
        name: "Composite",
        className: "RetargetScheduleProperties",
        modelProperties: {
            currentResourceId: {
                serializedName: "currentResourceId",
                type: {
                    name: "String"
                }
            },
            targetResourceId: {
                serializedName: "targetResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceRunnerList = {
    type: {
        name: "Composite",
        className: "ServiceRunnerList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceRunner"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ShutdownNotificationContent = {
    type: {
        name: "Composite",
        className: "ShutdownNotificationContent",
        modelProperties: {
            skipUrl: {
                serializedName: "skipUrl",
                type: {
                    name: "String"
                }
            },
            delayUrl60: {
                serializedName: "delayUrl60",
                type: {
                    name: "String"
                }
            },
            delayUrl120: {
                serializedName: "delayUrl120",
                type: {
                    name: "String"
                }
            },
            vmName: {
                serializedName: "vmName",
                type: {
                    name: "String"
                }
            },
            guid: {
                serializedName: "guid",
                type: {
                    name: "String"
                }
            },
            owner: {
                serializedName: "owner",
                type: {
                    name: "String"
                }
            },
            vmUrl: {
                serializedName: "vmUrl",
                type: {
                    name: "String"
                }
            },
            minutesUntilShutdown: {
                serializedName: "minutesUntilShutdown",
                type: {
                    name: "String"
                }
            },
            eventType: {
                serializedName: "eventType",
                type: {
                    name: "String"
                }
            },
            text: {
                serializedName: "text",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            resourceGroupName: {
                serializedName: "resourceGroupName",
                type: {
                    name: "String"
                }
            },
            labName: {
                serializedName: "labName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Lab = {
    type: {
        name: "Composite",
        className: "Lab",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { defaultStorageAccount: {
                serializedName: "properties.defaultStorageAccount",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultPremiumStorageAccount: {
                serializedName: "properties.defaultPremiumStorageAccount",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, artifactsStorageAccount: {
                serializedName: "properties.artifactsStorageAccount",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, premiumDataDiskStorageAccount: {
                serializedName: "properties.premiumDataDiskStorageAccount",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vaultName: {
                serializedName: "properties.vaultName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, labStorageType: {
                serializedName: "properties.labStorageType",
                type: {
                    name: "String"
                }
            }, mandatoryArtifactsResourceIdsLinux: {
                serializedName: "properties.mandatoryArtifactsResourceIdsLinux",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, mandatoryArtifactsResourceIdsWindows: {
                serializedName: "properties.mandatoryArtifactsResourceIdsWindows",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, premiumDataDisks: {
                serializedName: "properties.premiumDataDisks",
                type: {
                    name: "String"
                }
            }, environmentPermission: {
                serializedName: "properties.environmentPermission",
                type: {
                    name: "String"
                }
            }, announcement: {
                serializedName: "properties.announcement",
                type: {
                    name: "Composite",
                    className: "LabAnnouncementProperties"
                }
            }, support: {
                serializedName: "properties.support",
                type: {
                    name: "Composite",
                    className: "LabSupportProperties"
                }
            }, vmCreationResourceGroup: {
                serializedName: "properties.vmCreationResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicIpId: {
                serializedName: "properties.publicIpId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancerId: {
                serializedName: "properties.loadBalancerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, networkSecurityGroupId: {
                serializedName: "properties.networkSecurityGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, extendedProperties: {
                serializedName: "properties.extendedProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Schedule = {
    type: {
        name: "Composite",
        className: "Schedule",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, taskType: {
                serializedName: "properties.taskType",
                type: {
                    name: "String"
                }
            }, weeklyRecurrence: {
                serializedName: "properties.weeklyRecurrence",
                type: {
                    name: "Composite",
                    className: "WeekDetails"
                }
            }, dailyRecurrence: {
                serializedName: "properties.dailyRecurrence",
                type: {
                    name: "Composite",
                    className: "DayDetails"
                }
            }, hourlyRecurrence: {
                serializedName: "properties.hourlyRecurrence",
                type: {
                    name: "Composite",
                    className: "HourDetails"
                }
            }, timeZoneId: {
                serializedName: "properties.timeZoneId",
                type: {
                    name: "String"
                }
            }, notificationSettings: {
                serializedName: "properties.notificationSettings",
                type: {
                    name: "Composite",
                    className: "NotificationSettings"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, targetResourceId: {
                serializedName: "properties.targetResourceId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ArtifactSource = {
    type: {
        name: "Composite",
        className: "ArtifactSource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                type: {
                    name: "String"
                }
            }, sourceType: {
                serializedName: "properties.sourceType",
                type: {
                    name: "String"
                }
            }, folderPath: {
                serializedName: "properties.folderPath",
                type: {
                    name: "String"
                }
            }, armTemplateFolderPath: {
                serializedName: "properties.armTemplateFolderPath",
                type: {
                    name: "String"
                }
            }, branchRef: {
                serializedName: "properties.branchRef",
                type: {
                    name: "String"
                }
            }, securityToken: {
                serializedName: "properties.securityToken",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ArmTemplate = {
    type: {
        name: "Composite",
        className: "ArmTemplate",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, icon: {
                serializedName: "properties.icon",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, contents: {
                serializedName: "properties.contents",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, parametersValueFilesInfo: {
                serializedName: "properties.parametersValueFilesInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParametersValueFileInfo"
                        }
                    }
                }
            }, enabled: {
                serializedName: "properties.enabled",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Artifact = {
    type: {
        name: "Composite",
        className: "Artifact",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { title: {
                serializedName: "properties.title",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, filePath: {
                serializedName: "properties.filePath",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, icon: {
                serializedName: "properties.icon",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, targetOsType: {
                serializedName: "properties.targetOsType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const LabCost = {
    type: {
        name: "Composite",
        className: "LabCost",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { targetCost: {
                serializedName: "properties.targetCost",
                type: {
                    name: "Composite",
                    className: "TargetCostProperties"
                }
            }, labCostSummary: {
                serializedName: "properties.labCostSummary",
                type: {
                    name: "Composite",
                    className: "LabCostSummaryProperties"
                }
            }, labCostDetails: {
                serializedName: "properties.labCostDetails",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabCostDetailsProperties"
                        }
                    }
                }
            }, resourceCosts: {
                serializedName: "properties.resourceCosts",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabResourceCostProperties"
                        }
                    }
                }
            }, currencyCode: {
                serializedName: "properties.currencyCode",
                type: {
                    name: "String"
                }
            }, startDateTime: {
                serializedName: "properties.startDateTime",
                type: {
                    name: "DateTime"
                }
            }, endDateTime: {
                serializedName: "properties.endDateTime",
                type: {
                    name: "DateTime"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const CustomImage = {
    type: {
        name: "Composite",
        className: "CustomImage",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { vm: {
                serializedName: "properties.vm",
                type: {
                    name: "Composite",
                    className: "CustomImagePropertiesFromVm"
                }
            }, vhd: {
                serializedName: "properties.vhd",
                type: {
                    name: "Composite",
                    className: "CustomImagePropertiesCustom"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, author: {
                serializedName: "properties.author",
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, managedImageId: {
                serializedName: "properties.managedImageId",
                type: {
                    name: "String"
                }
            }, managedSnapshotId: {
                serializedName: "properties.managedSnapshotId",
                type: {
                    name: "String"
                }
            }, dataDiskStorageInfo: {
                serializedName: "properties.dataDiskStorageInfo",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDiskStorageTypeInfo"
                        }
                    }
                }
            }, customImagePlan: {
                serializedName: "properties.customImagePlan",
                type: {
                    name: "Composite",
                    className: "CustomImagePropertiesFromPlan"
                }
            }, isPlanAuthorized: {
                serializedName: "properties.isPlanAuthorized",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Formula = {
    type: {
        name: "Composite",
        className: "Formula",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, author: {
                serializedName: "properties.author",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                type: {
                    name: "String"
                }
            }, creationDate: {
                serializedName: "properties.creationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, formulaContent: {
                serializedName: "properties.formulaContent",
                type: {
                    name: "Composite",
                    className: "LabVirtualMachineCreationParameter"
                }
            }, vm: {
                serializedName: "properties.vm",
                type: {
                    name: "Composite",
                    className: "FormulaPropertiesFromVm"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const GalleryImage = {
    type: {
        name: "Composite",
        className: "GalleryImage",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { author: {
                serializedName: "properties.author",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, imageReference: {
                serializedName: "properties.imageReference",
                type: {
                    name: "Composite",
                    className: "GalleryImageReference"
                }
            }, icon: {
                serializedName: "properties.icon",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, planId: {
                serializedName: "properties.planId",
                type: {
                    name: "String"
                }
            }, isPlanAuthorized: {
                serializedName: "properties.isPlanAuthorized",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NotificationChannel = {
    type: {
        name: "Composite",
        className: "NotificationChannel",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { webHookUrl: {
                serializedName: "properties.webHookUrl",
                type: {
                    name: "String"
                }
            }, emailRecipient: {
                serializedName: "properties.emailRecipient",
                type: {
                    name: "String"
                }
            }, notificationLocale: {
                serializedName: "properties.notificationLocale",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, events: {
                serializedName: "properties.events",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Event"
                        }
                    }
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Policy = {
    type: {
        name: "Composite",
        className: "Policy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                type: {
                    name: "String"
                }
            }, factName: {
                serializedName: "properties.factName",
                type: {
                    name: "String"
                }
            }, factData: {
                serializedName: "properties.factData",
                type: {
                    name: "String"
                }
            }, threshold: {
                serializedName: "properties.threshold",
                type: {
                    name: "String"
                }
            }, evaluatorType: {
                serializedName: "properties.evaluatorType",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceRunner = {
    type: {
        name: "Composite",
        className: "ServiceRunner",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "IdentityProperties"
                }
            } })
    }
};
const User = {
    type: {
        name: "Composite",
        className: "User",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "properties.identity",
                type: {
                    name: "Composite",
                    className: "UserIdentity"
                }
            }, secretStore: {
                serializedName: "properties.secretStore",
                type: {
                    name: "Composite",
                    className: "UserSecretStore"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Disk = {
    type: {
        name: "Composite",
        className: "Disk",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { diskType: {
                serializedName: "properties.diskType",
                type: {
                    name: "String"
                }
            }, diskSizeGiB: {
                serializedName: "properties.diskSizeGiB",
                type: {
                    name: "Number"
                }
            }, leasedByLabVmId: {
                serializedName: "properties.leasedByLabVmId",
                type: {
                    name: "String"
                }
            }, diskBlobName: {
                serializedName: "properties.diskBlobName",
                type: {
                    name: "String"
                }
            }, diskUri: {
                serializedName: "properties.diskUri",
                type: {
                    name: "String"
                }
            }, storageAccountId: {
                serializedName: "properties.storageAccountId",
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, hostCaching: {
                serializedName: "properties.hostCaching",
                type: {
                    name: "String"
                }
            }, managedDiskId: {
                serializedName: "properties.managedDiskId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DtlEnvironment = {
    type: {
        name: "Composite",
        className: "DtlEnvironment",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { deploymentProperties: {
                serializedName: "properties.deploymentProperties",
                type: {
                    name: "Composite",
                    className: "EnvironmentDeploymentProperties"
                }
            }, armTemplateDisplayName: {
                serializedName: "properties.armTemplateDisplayName",
                type: {
                    name: "String"
                }
            }, resourceGroupId: {
                serializedName: "properties.resourceGroupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdByUser: {
                serializedName: "properties.createdByUser",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Secret = {
    type: {
        name: "Composite",
        className: "Secret",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { value: {
                serializedName: "properties.value",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicableSchedule = {
    type: {
        name: "Composite",
        className: "ApplicableSchedule",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { labVmsShutdown: {
                serializedName: "properties.labVmsShutdown",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            }, labVmsStartup: {
                serializedName: "properties.labVmsStartup",
                type: {
                    name: "Composite",
                    className: "Schedule"
                }
            } })
    }
};
const ServiceFabric = {
    type: {
        name: "Composite",
        className: "ServiceFabric",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { externalServiceFabricId: {
                serializedName: "properties.externalServiceFabricId",
                type: {
                    name: "String"
                }
            }, environmentId: {
                serializedName: "properties.environmentId",
                type: {
                    name: "String"
                }
            }, applicableSchedule: {
                serializedName: "properties.applicableSchedule",
                type: {
                    name: "Composite",
                    className: "ApplicableSchedule"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LabVirtualMachine = {
    type: {
        name: "Composite",
        className: "LabVirtualMachine",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }, ownerObjectId: {
                defaultValue: "dynamicValue",
                serializedName: "properties.ownerObjectId",
                type: {
                    name: "String"
                }
            }, ownerUserPrincipalName: {
                serializedName: "properties.ownerUserPrincipalName",
                type: {
                    name: "String"
                }
            }, createdByUserId: {
                serializedName: "properties.createdByUserId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdByUser: {
                serializedName: "properties.createdByUser",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                type: {
                    name: "DateTime"
                }
            }, computeId: {
                serializedName: "properties.computeId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customImageId: {
                serializedName: "properties.customImageId",
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, size: {
                serializedName: "properties.size",
                type: {
                    name: "String"
                }
            }, userName: {
                serializedName: "properties.userName",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, sshKey: {
                serializedName: "properties.sshKey",
                type: {
                    name: "String"
                }
            }, isAuthenticationWithSshKey: {
                serializedName: "properties.isAuthenticationWithSshKey",
                type: {
                    name: "Boolean"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, labSubnetName: {
                serializedName: "properties.labSubnetName",
                type: {
                    name: "String"
                }
            }, labVirtualNetworkId: {
                serializedName: "properties.labVirtualNetworkId",
                type: {
                    name: "String"
                }
            }, disallowPublicIpAddress: {
                defaultValue: false,
                serializedName: "properties.disallowPublicIpAddress",
                type: {
                    name: "Boolean"
                }
            }, artifacts: {
                serializedName: "properties.artifacts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactInstallProperties"
                        }
                    }
                }
            }, artifactDeploymentStatus: {
                serializedName: "properties.artifactDeploymentStatus",
                type: {
                    name: "Composite",
                    className: "ArtifactDeploymentStatusProperties"
                }
            }, galleryImageReference: {
                serializedName: "properties.galleryImageReference",
                type: {
                    name: "Composite",
                    className: "GalleryImageReference"
                }
            }, planId: {
                serializedName: "properties.planId",
                type: {
                    name: "String"
                }
            }, computeVm: {
                serializedName: "properties.computeVm",
                type: {
                    name: "Composite",
                    className: "ComputeVmProperties"
                }
            }, networkInterface: {
                serializedName: "properties.networkInterface",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceProperties"
                }
            }, applicableSchedule: {
                serializedName: "properties.applicableSchedule",
                type: {
                    name: "Composite",
                    className: "ApplicableSchedule"
                }
            }, expirationDate: {
                serializedName: "properties.expirationDate",
                type: {
                    name: "DateTime"
                }
            }, allowClaim: {
                defaultValue: false,
                serializedName: "properties.allowClaim",
                type: {
                    name: "Boolean"
                }
            }, storageType: {
                defaultValue: "labStorageType",
                serializedName: "properties.storageType",
                type: {
                    name: "String"
                }
            }, virtualMachineCreationSource: {
                serializedName: "properties.virtualMachineCreationSource",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, environmentId: {
                serializedName: "properties.environmentId",
                type: {
                    name: "String"
                }
            }, dataDiskParameters: {
                serializedName: "properties.dataDiskParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataDiskProperties"
                        }
                    }
                }
            }, scheduleParameters: {
                serializedName: "properties.scheduleParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScheduleCreationParameter"
                        }
                    }
                }
            }, lastKnownPowerState: {
                serializedName: "properties.lastKnownPowerState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetwork",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { allowedSubnets: {
                serializedName: "properties.allowedSubnets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, externalProviderResourceId: {
                serializedName: "properties.externalProviderResourceId",
                type: {
                    name: "String"
                }
            }, externalSubnets: {
                serializedName: "properties.externalSubnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExternalSubnet"
                        }
                    }
                }
            }, subnetOverrides: {
                serializedName: "properties.subnetOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubnetOverride"
                        }
                    }
                }
            }, createdDate: {
                serializedName: "properties.createdDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uniqueIdentifier: {
                serializedName: "properties.uniqueIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ArtifactSourceFragment = {
    type: {
        name: "Composite",
        className: "ArtifactSourceFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const CustomImageFragment = {
    type: {
        name: "Composite",
        className: "CustomImageFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const FormulaFragment = {
    type: {
        name: "Composite",
        className: "FormulaFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const NotificationChannelFragment = {
    type: {
        name: "Composite",
        className: "NotificationChannelFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const PolicyFragment = {
    type: {
        name: "Composite",
        className: "PolicyFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const ScheduleFragment = {
    type: {
        name: "Composite",
        className: "ScheduleFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const UserFragment = {
    type: {
        name: "Composite",
        className: "UserFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const DiskFragment = {
    type: {
        name: "Composite",
        className: "DiskFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const DtlEnvironmentFragment = {
    type: {
        name: "Composite",
        className: "DtlEnvironmentFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const SecretFragment = {
    type: {
        name: "Composite",
        className: "SecretFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const ServiceFabricFragment = {
    type: {
        name: "Composite",
        className: "ServiceFabricFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const LabVirtualMachineFragment = {
    type: {
        name: "Composite",
        className: "LabVirtualMachineFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const VirtualNetworkFragment = {
    type: {
        name: "Composite",
        className: "VirtualNetworkFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const LabFragment = {
    type: {
        name: "Composite",
        className: "LabFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};
const ApplicableScheduleFragment = {
    type: {
        name: "Composite",
        className: "ApplicableScheduleFragment",
        modelProperties: Object.assign({}, UpdateResource.type.modelProperties)
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ProviderOperationResult: ProviderOperationResult,
    OperationMetadata: OperationMetadata,
    OperationMetadataDisplay: OperationMetadataDisplay,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    LabList: LabList,
    LabAnnouncementProperties: LabAnnouncementProperties,
    LabSupportProperties: LabSupportProperties,
    Resource: Resource,
    OperationResult: OperationResult,
    OperationError: OperationError,
    ScheduleList: ScheduleList,
    WeekDetails: WeekDetails,
    DayDetails: DayDetails,
    HourDetails: HourDetails,
    NotificationSettings: NotificationSettings,
    ArtifactSourceList: ArtifactSourceList,
    ArmTemplateList: ArmTemplateList,
    ParametersValueFileInfo: ParametersValueFileInfo,
    ArtifactList: ArtifactList,
    GenerateArmTemplateRequest: GenerateArmTemplateRequest,
    ParameterInfo: ParameterInfo,
    ArmTemplateInfo: ArmTemplateInfo,
    UpdateResource: UpdateResource,
    TargetCostProperties: TargetCostProperties,
    CostThresholdProperties: CostThresholdProperties,
    PercentageCostThresholdProperties: PercentageCostThresholdProperties,
    LabCostSummaryProperties: LabCostSummaryProperties,
    LabCostDetailsProperties: LabCostDetailsProperties,
    LabResourceCostProperties: LabResourceCostProperties,
    CustomImageList: CustomImageList,
    CustomImagePropertiesFromVm: CustomImagePropertiesFromVm,
    WindowsOsInfo: WindowsOsInfo,
    LinuxOsInfo: LinuxOsInfo,
    CustomImagePropertiesCustom: CustomImagePropertiesCustom,
    DataDiskStorageTypeInfo: DataDiskStorageTypeInfo,
    CustomImagePropertiesFromPlan: CustomImagePropertiesFromPlan,
    FormulaList: FormulaList,
    LabVirtualMachineCreationParameter: LabVirtualMachineCreationParameter,
    BulkCreationParameters: BulkCreationParameters,
    ArtifactInstallProperties: ArtifactInstallProperties,
    ArtifactParameterProperties: ArtifactParameterProperties,
    GalleryImageReference: GalleryImageReference,
    NetworkInterfaceProperties: NetworkInterfaceProperties,
    SharedPublicIpAddressConfiguration: SharedPublicIpAddressConfiguration,
    InboundNatRule: InboundNatRule,
    DataDiskProperties: DataDiskProperties,
    AttachNewDataDiskOptions: AttachNewDataDiskOptions,
    ScheduleCreationParameter: ScheduleCreationParameter,
    FormulaPropertiesFromVm: FormulaPropertiesFromVm,
    GalleryImageList: GalleryImageList,
    NotificationChannelList: NotificationChannelList,
    Event: Event,
    NotifyParameters: NotifyParameters,
    EvaluatePoliciesRequest: EvaluatePoliciesRequest,
    EvaluatePoliciesProperties: EvaluatePoliciesProperties,
    EvaluatePoliciesResponse: EvaluatePoliciesResponse,
    PolicySetResult: PolicySetResult,
    PolicyViolation: PolicyViolation,
    PolicyList: PolicyList,
    IdentityProperties: IdentityProperties,
    UserList: UserList,
    UserIdentity: UserIdentity,
    UserSecretStore: UserSecretStore,
    DiskList: DiskList,
    AttachDiskProperties: AttachDiskProperties,
    DetachDiskProperties: DetachDiskProperties,
    DtlEnvironmentList: DtlEnvironmentList,
    EnvironmentDeploymentProperties: EnvironmentDeploymentProperties,
    ArmTemplateParameterProperties: ArmTemplateParameterProperties,
    SecretList: SecretList,
    ServiceFabricList: ServiceFabricList,
    LabVirtualMachineList: LabVirtualMachineList,
    ArtifactDeploymentStatusProperties: ArtifactDeploymentStatusProperties,
    ComputeVmProperties: ComputeVmProperties,
    ComputeVmInstanceViewStatus: ComputeVmInstanceViewStatus,
    ComputeDataDisk: ComputeDataDisk,
    ApplyArtifactsRequest: ApplyArtifactsRequest,
    DetachDataDiskProperties: DetachDataDiskProperties,
    RdpConnection: RdpConnection,
    ResizeLabVirtualMachineProperties: ResizeLabVirtualMachineProperties,
    VirtualNetworkList: VirtualNetworkList,
    Subnet: Subnet,
    ExternalSubnet: ExternalSubnet,
    SubnetOverride: SubnetOverride,
    SubnetSharedPublicIpAddressConfiguration: SubnetSharedPublicIpAddressConfiguration,
    Port: Port,
    ExportResourceUsageParameters: ExportResourceUsageParameters,
    GenerateUploadUriParameter: GenerateUploadUriParameter,
    GenerateUploadUriResponse: GenerateUploadUriResponse,
    ImportLabVirtualMachineRequest: ImportLabVirtualMachineRequest,
    LabVhdList: LabVhdList,
    LabVhd: LabVhd,
    RetargetScheduleProperties: RetargetScheduleProperties,
    ServiceRunnerList: ServiceRunnerList,
    ShutdownNotificationContent: ShutdownNotificationContent,
    Lab: Lab,
    Schedule: Schedule,
    ArtifactSource: ArtifactSource,
    ArmTemplate: ArmTemplate,
    Artifact: Artifact,
    LabCost: LabCost,
    CustomImage: CustomImage,
    Formula: Formula,
    GalleryImage: GalleryImage,
    NotificationChannel: NotificationChannel,
    Policy: Policy,
    ServiceRunner: ServiceRunner,
    User: User,
    Disk: Disk,
    DtlEnvironment: DtlEnvironment,
    Secret: Secret,
    ApplicableSchedule: ApplicableSchedule,
    ServiceFabric: ServiceFabric,
    LabVirtualMachine: LabVirtualMachine,
    VirtualNetwork: VirtualNetwork,
    ArtifactSourceFragment: ArtifactSourceFragment,
    CustomImageFragment: CustomImageFragment,
    FormulaFragment: FormulaFragment,
    NotificationChannelFragment: NotificationChannelFragment,
    PolicyFragment: PolicyFragment,
    ScheduleFragment: ScheduleFragment,
    UserFragment: UserFragment,
    DiskFragment: DiskFragment,
    DtlEnvironmentFragment: DtlEnvironmentFragment,
    SecretFragment: SecretFragment,
    ServiceFabricFragment: ServiceFabricFragment,
    LabVirtualMachineFragment: LabVirtualMachineFragment,
    VirtualNetworkFragment: VirtualNetworkFragment,
    LabFragment: LabFragment,
    ApplicableScheduleFragment: ApplicableScheduleFragment
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2018-09-15",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "$orderby",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const lab = {
    parameterPath: "lab",
    mapper: Lab
};
const lab1 = {
    parameterPath: "lab",
    mapper: LabFragment
};
const labVirtualMachineCreationParameter = {
    parameterPath: "labVirtualMachineCreationParameter",
    mapper: LabVirtualMachineCreationParameter
};
const exportResourceUsageParameters = {
    parameterPath: "exportResourceUsageParameters",
    mapper: ExportResourceUsageParameters
};
const generateUploadUriParameter = {
    parameterPath: "generateUploadUriParameter",
    mapper: GenerateUploadUriParameter
};
const importLabVirtualMachineRequest = {
    parameterPath: "importLabVirtualMachineRequest",
    mapper: ImportLabVirtualMachineRequest
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const schedule = {
    parameterPath: "schedule",
    mapper: Schedule
};
const schedule1 = {
    parameterPath: "schedule",
    mapper: ScheduleFragment
};
const retargetScheduleProperties = {
    parameterPath: "retargetScheduleProperties",
    mapper: RetargetScheduleProperties
};
const labName = {
    parameterPath: "labName",
    mapper: {
        serializedName: "labName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const artifactSource = {
    parameterPath: "artifactSource",
    mapper: ArtifactSource
};
const artifactSource1 = {
    parameterPath: "artifactSource",
    mapper: ArtifactSourceFragment
};
const artifactSourceName = {
    parameterPath: "artifactSourceName",
    mapper: {
        serializedName: "artifactSourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const generateArmTemplateRequest = {
    parameterPath: "generateArmTemplateRequest",
    mapper: GenerateArmTemplateRequest
};
const labCost = {
    parameterPath: "labCost",
    mapper: LabCost
};
const customImage = {
    parameterPath: "customImage",
    mapper: CustomImage
};
const customImage1 = {
    parameterPath: "customImage",
    mapper: CustomImageFragment
};
const formula = {
    parameterPath: "formula",
    mapper: Formula
};
const formula1 = {
    parameterPath: "formula",
    mapper: FormulaFragment
};
const notificationChannel = {
    parameterPath: "notificationChannel",
    mapper: NotificationChannel
};
const notificationChannel1 = {
    parameterPath: "notificationChannel",
    mapper: NotificationChannelFragment
};
const notifyParameters = {
    parameterPath: "notifyParameters",
    mapper: NotifyParameters
};
const evaluatePoliciesRequest = {
    parameterPath: "evaluatePoliciesRequest",
    mapper: EvaluatePoliciesRequest
};
const policySetName = {
    parameterPath: "policySetName",
    mapper: {
        serializedName: "policySetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policy = {
    parameterPath: "policy",
    mapper: Policy
};
const policy1 = {
    parameterPath: "policy",
    mapper: PolicyFragment
};
const serviceRunner = {
    parameterPath: "serviceRunner",
    mapper: ServiceRunner
};
const user = {
    parameterPath: "user",
    mapper: User
};
const user1 = {
    parameterPath: "user",
    mapper: UserFragment
};
const userName = {
    parameterPath: "userName",
    mapper: {
        serializedName: "userName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const disk = {
    parameterPath: "disk",
    mapper: Disk
};
const disk1 = {
    parameterPath: "disk",
    mapper: DiskFragment
};
const attachDiskProperties = {
    parameterPath: "attachDiskProperties",
    mapper: AttachDiskProperties
};
const detachDiskProperties = {
    parameterPath: "detachDiskProperties",
    mapper: DetachDiskProperties
};
const dtlEnvironment = {
    parameterPath: "dtlEnvironment",
    mapper: DtlEnvironment
};
const dtlEnvironment1 = {
    parameterPath: "dtlEnvironment",
    mapper: DtlEnvironmentFragment
};
const secret = {
    parameterPath: "secret",
    mapper: Secret
};
const secret1 = {
    parameterPath: "secret",
    mapper: SecretFragment
};
const serviceFabric = {
    parameterPath: "serviceFabric",
    mapper: ServiceFabric
};
const serviceFabric1 = {
    parameterPath: "serviceFabric",
    mapper: ServiceFabricFragment
};
const serviceFabricName = {
    parameterPath: "serviceFabricName",
    mapper: {
        serializedName: "serviceFabricName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const labVirtualMachine = {
    parameterPath: "labVirtualMachine",
    mapper: LabVirtualMachine
};
const labVirtualMachine1 = {
    parameterPath: "labVirtualMachine",
    mapper: LabVirtualMachineFragment
};
const dataDiskProperties = {
    parameterPath: "dataDiskProperties",
    mapper: DataDiskProperties
};
const applyArtifactsRequest = {
    parameterPath: "applyArtifactsRequest",
    mapper: ApplyArtifactsRequest
};
const detachDataDiskProperties = {
    parameterPath: "detachDataDiskProperties",
    mapper: DetachDataDiskProperties
};
const resizeLabVirtualMachineProperties = {
    parameterPath: "resizeLabVirtualMachineProperties",
    mapper: ResizeLabVirtualMachineProperties
};
const virtualMachineName = {
    parameterPath: "virtualMachineName",
    mapper: {
        serializedName: "virtualMachineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetwork = {
    parameterPath: "virtualNetwork",
    mapper: VirtualNetwork
};
const virtualNetwork1 = {
    parameterPath: "virtualNetwork",
    mapper: VirtualNetworkFragment
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ProviderOperations operations. */
class ProviderOperationsImpl {
    /**
     * Initialize a new instance of the class ProviderOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Result of the request to list REST API operations
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Result of the request to list REST API operations
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$i);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$i = {
    path: "/providers/Microsoft.DevTestLab/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProviderOperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Labs operations. */
class LabsImpl {
    /**
     * Initialize a new instance of the class Labs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List labs in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List labs in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List disk images available for custom image creation.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    listVhds(resourceGroupName, name, options) {
        const iter = this.listVhdsPagingAll(resourceGroupName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVhdsPagingPage(resourceGroupName, name, options, settings);
            }
        };
    }
    listVhdsPagingPage(resourceGroupName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVhdsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVhds(resourceGroupName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVhdsNext(resourceGroupName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVhdsPagingAll(resourceGroupName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVhdsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVhdsPagingPage(resourceGroupName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List labs in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * List labs in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Get lab.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$l);
    }
    /**
     * Create or replace an existing lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param lab A lab.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, name, lab, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, lab, options }, createOrUpdateOperationSpec$i);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param lab A lab.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, name, lab, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, name, lab, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, deleteOperationSpec$h);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of labs. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param lab A lab.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, lab, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, lab, options }, updateOperationSpec$g);
    }
    /**
     * Claim a random claimable virtual machine in the lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    beginClaimAnyVm(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, claimAnyVmOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Claim a random claimable virtual machine in the lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    beginClaimAnyVmAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginClaimAnyVm(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create virtual machines in a lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param labVirtualMachineCreationParameter Properties for creating a virtual machine.
     * @param options The options parameters.
     */
    beginCreateEnvironment(resourceGroupName, name, labVirtualMachineCreationParameter, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, labVirtualMachineCreationParameter, options }, createEnvironmentOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create virtual machines in a lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param labVirtualMachineCreationParameter Properties for creating a virtual machine.
     * @param options The options parameters.
     */
    beginCreateEnvironmentAndWait(resourceGroupName, name, labVirtualMachineCreationParameter, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateEnvironment(resourceGroupName, name, labVirtualMachineCreationParameter, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Exports the lab resource usage into a storage account This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param exportResourceUsageParameters The parameters of the export operation.
     * @param options The options parameters.
     */
    beginExportResourceUsage(resourceGroupName, name, exportResourceUsageParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, exportResourceUsageParameters, options }, exportResourceUsageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Exports the lab resource usage into a storage account This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param exportResourceUsageParameters The parameters of the export operation.
     * @param options The options parameters.
     */
    beginExportResourceUsageAndWait(resourceGroupName, name, exportResourceUsageParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExportResourceUsage(resourceGroupName, name, exportResourceUsageParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generate a URI for uploading custom disk images to a Lab.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param generateUploadUriParameter Properties for generating an upload URI.
     * @param options The options parameters.
     */
    generateUploadUri(resourceGroupName, name, generateUploadUriParameter, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, generateUploadUriParameter, options }, generateUploadUriOperationSpec);
    }
    /**
     * Import a virtual machine into a different lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param importLabVirtualMachineRequest This represents the payload required to import a virtual
     *                                       machine from a different lab into the current one
     * @param options The options parameters.
     */
    beginImportVirtualMachine(resourceGroupName, name, importLabVirtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, importLabVirtualMachineRequest, options }, importVirtualMachineOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Import a virtual machine into a different lab. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param importLabVirtualMachineRequest This represents the payload required to import a virtual
     *                                       machine from a different lab into the current one
     * @param options The options parameters.
     */
    beginImportVirtualMachineAndWait(resourceGroupName, name, importLabVirtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginImportVirtualMachine(resourceGroupName, name, importLabVirtualMachineRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List disk images available for custom image creation.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param options The options parameters.
     */
    _listVhds(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, listVhdsOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListVhdsNext
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the ListVhds method.
     * @param options The options parameters.
     */
    _listVhdsNext(resourceGroupName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, nextLink, options }, listVhdsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DevTestLab/labs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Lab
        },
        201: {
            bodyMapper: Lab
        },
        202: {
            bodyMapper: Lab
        },
        204: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: lab,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const updateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: lab1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const claimAnyVmOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/claimAnyVm",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const createEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/createEnvironment",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: labVirtualMachineCreationParameter,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const exportResourceUsageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/exportResourceUsage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: exportResourceUsageParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const generateUploadUriOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/generateUploadUri",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateUploadUriResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: generateUploadUriParameter,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const importVirtualMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/importVirtualMachine",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: importLabVirtualMachineRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$n
};
const listVhdsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{name}/listVhds",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LabVhdList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listVhdsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabVhdList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get operation.
     * @param locationName The name of the location.
     * @param name The name of the operation.
     * @param options The options parameters.
     */
    get(locationName, name, options) {
        return this.client.sendOperationRequest({ locationName, name, options }, getOperationSpec$k);
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DevTestLab/locations/{locationName}/operations/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResult
        },
        202: {
            bodyMapper: OperationResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        name,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GlobalSchedules operations. */
class GlobalSchedulesImpl {
    /**
     * Initialize a new instance of the class GlobalSchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List schedules in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List schedules in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List schedules in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * List schedules in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Get schedule.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    get(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, getOperationSpec$j);
    }
    /**
     * Create or replace an existing schedule.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, name, schedule, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, schedule, options }, createOrUpdateOperationSpec$h);
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    delete(resourceGroupName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, options }, deleteOperationSpec$g);
    }
    /**
     * Allows modifying tags of schedules. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    update(resourceGroupName, name, schedule, options) {
        return this.client.sendOperationRequest({ resourceGroupName, name, schedule, options }, updateOperationSpec$f);
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecute(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, options }, executeOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecuteAndWait(resourceGroupName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExecute(resourceGroupName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a schedule's target resource Id. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param retargetScheduleProperties Properties for retargeting a virtual machine schedule.
     * @param options The options parameters.
     */
    beginRetarget(resourceGroupName, name, retargetScheduleProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, name, retargetScheduleProperties, options }, retargetOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a schedule's target resource Id. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param name The name of the schedule.
     * @param retargetScheduleProperties Properties for retargeting a virtual machine schedule.
     * @param options The options parameters.
     */
    beginRetargetAndWait(resourceGroupName, name, retargetScheduleProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRetarget(resourceGroupName, name, retargetScheduleProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.DevTestLab/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const updateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const executeOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const retargetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/schedules/{name}/retarget",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: retargetScheduleProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ArtifactSources operations. */
class ArtifactSourcesImpl {
    /**
     * Initialize a new instance of the class ArtifactSources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List artifact sources in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List artifact sources in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$h);
    }
    /**
     * Get artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the artifact source.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$i);
    }
    /**
     * Create or replace an existing artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the artifact source.
     * @param artifactSource Properties of an artifact source.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, name, artifactSource, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, artifactSource, options }, createOrUpdateOperationSpec$g);
    }
    /**
     * Delete artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the artifact source.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, deleteOperationSpec$f);
    }
    /**
     * Allows modifying tags of artifact sources. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the artifact source.
     * @param artifactSource Properties of an artifact source.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, artifactSource, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, artifactSource, options }, updateOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactSourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactSource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ArtifactSource
        },
        201: {
            bodyMapper: ArtifactSource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: artifactSource,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const updateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ArtifactSource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: artifactSource1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactSourceList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ArmTemplates operations. */
class ArmTemplatesImpl {
    /**
     * Initialize a new instance of the class ArmTemplates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List azure resource manager templates in a given artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, artifactSourceName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, artifactSourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, artifactSourceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, artifactSourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, artifactSourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, artifactSourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, artifactSourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, artifactSourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List azure resource manager templates in a given artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, artifactSourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, options }, listOperationSpec$g);
    }
    /**
     * Get azure resource manager template.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param name The name of the azure resource manager template.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, artifactSourceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, name, options }, getOperationSpec$h);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, artifactSourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{artifactSourceName}/armtemplates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArmTemplateList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{artifactSourceName}/armtemplates/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArmTemplate
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArmTemplateList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Artifacts operations. */
class ArtifactsImpl {
    /**
     * Initialize a new instance of the class Artifacts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List artifacts in a given artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, artifactSourceName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, artifactSourceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, artifactSourceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, artifactSourceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, artifactSourceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, artifactSourceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, artifactSourceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, artifactSourceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List artifacts in a given artifact source.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, artifactSourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, options }, listOperationSpec$f);
    }
    /**
     * Get artifact.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param name The name of the artifact.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, artifactSourceName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, name, options }, getOperationSpec$g);
    }
    /**
     * Generates an ARM template for the given artifact, uploads the required files to a storage account,
     * and validates the generated artifact.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param name The name of the artifact.
     * @param generateArmTemplateRequest Parameters for generating an ARM template for deploying artifacts.
     * @param options The options parameters.
     */
    generateArmTemplate(resourceGroupName, labName, artifactSourceName, name, generateArmTemplateRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            artifactSourceName,
            name,
            generateArmTemplateRequest,
            options
        }, generateArmTemplateOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param artifactSourceName The name of the artifact source.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, artifactSourceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, artifactSourceName, nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{artifactSourceName}/artifacts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{artifactSourceName}/artifacts/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Artifact
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const generateArmTemplateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/artifactsources/{artifactSourceName}/artifacts/{name}/generateArmTemplate",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ArmTemplateInfo
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: generateArmTemplateRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        artifactSourceName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Costs operations. */
class CostsImpl {
    /**
     * Initialize a new instance of the class Costs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get cost.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the cost.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$f);
    }
    /**
     * Create or replace an existing cost.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the cost.
     * @param labCost A cost item.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, name, labCost, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, labCost, options }, createOrUpdateOperationSpec$f);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/costs/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabCost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/costs/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LabCost
        },
        201: {
            bodyMapper: LabCost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: labCost,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomImages operations. */
class CustomImagesImpl {
    /**
     * Initialize a new instance of the class CustomImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List custom images in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List custom images in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$e);
    }
    /**
     * Get custom image.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$e);
    }
    /**
     * Create or replace an existing custom image. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param customImage A custom image.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, name, customImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, customImage, options }, createOrUpdateOperationSpec$e);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing custom image. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param customImage A custom image.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, name, customImage, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, name, customImage, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete custom image. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, deleteOperationSpec$e);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete custom image. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of custom images. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the custom image.
     * @param customImage A custom image.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, customImage, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, customImage, options }, updateOperationSpec$d);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/customimages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/customimages/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/customimages/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomImage
        },
        201: {
            bodyMapper: CustomImage
        },
        202: {
            bodyMapper: CustomImage
        },
        204: {
            bodyMapper: CustomImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: customImage,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/customimages/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/customimages/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CustomImage
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: customImage1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Formulas operations. */
class FormulasImpl {
    /**
     * Initialize a new instance of the class Formulas class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List formulas in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List formulas in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$d);
    }
    /**
     * Get formula.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the formula.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$d);
    }
    /**
     * Create or replace an existing formula. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the formula.
     * @param formula A formula for creating a VM, specifying an image base and other parameters
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, name, formula, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, formula, options }, createOrUpdateOperationSpec$d);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing formula. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the formula.
     * @param formula A formula for creating a VM, specifying an image base and other parameters
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, name, formula, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, name, formula, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete formula.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the formula.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, deleteOperationSpec$d);
    }
    /**
     * Allows modifying tags of formulas. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the formula.
     * @param formula A formula for creating a VM, specifying an image base and other parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, formula, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, formula, options }, updateOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/formulas",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FormulaList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/formulas/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Formula
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/formulas/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Formula
        },
        201: {
            bodyMapper: Formula
        },
        202: {
            bodyMapper: Formula
        },
        204: {
            bodyMapper: Formula
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: formula,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/formulas/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const updateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/formulas/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Formula
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: formula1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FormulaList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GalleryImages operations. */
class GalleryImagesImpl {
    /**
     * Initialize a new instance of the class GalleryImages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List gallery images in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List gallery images in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/galleryimages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GalleryImageList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NotificationChannels operations. */
class NotificationChannelsImpl {
    /**
     * Initialize a new instance of the class NotificationChannels class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List notification channels in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List notification channels in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$b);
    }
    /**
     * Get notification channel.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the notification channel.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$c);
    }
    /**
     * Create or replace an existing notification channel.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the notification channel.
     * @param notificationChannel A notification.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, name, notificationChannel, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, notificationChannel, options }, createOrUpdateOperationSpec$c);
    }
    /**
     * Delete notification channel.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the notification channel.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, deleteOperationSpec$c);
    }
    /**
     * Allows modifying tags of notification channels. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the notification channel.
     * @param notificationChannel A notification.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, notificationChannel, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, notificationChannel, options }, updateOperationSpec$b);
    }
    /**
     * Send notification to provided channel.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the notification channel.
     * @param notifyParameters Properties for generating a Notification.
     * @param options The options parameters.
     */
    notify(resourceGroupName, labName, name, notifyParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, notifyParameters, options }, notifyOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationChannelList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationChannel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NotificationChannel
        },
        201: {
            bodyMapper: NotificationChannel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: notificationChannel,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const updateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NotificationChannel
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: notificationChannel1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const notifyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/notificationchannels/{name}/notify",
    httpMethod: "POST",
    responses: {
        200: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: notifyParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NotificationChannelList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PolicySets operations. */
class PolicySetsImpl {
    /**
     * Initialize a new instance of the class PolicySets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Evaluates lab policy.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the policy set.
     * @param evaluatePoliciesRequest Request body for evaluating a policy set.
     * @param options The options parameters.
     */
    evaluatePolicies(resourceGroupName, labName, name, evaluatePoliciesRequest, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, evaluatePoliciesRequest, options }, evaluatePoliciesOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const evaluatePoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{name}/evaluatePolicies",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EvaluatePoliciesResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: evaluatePoliciesRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Policies operations. */
class PoliciesImpl {
    /**
     * Initialize a new instance of the class Policies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List policies in a given policy set.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, policySetName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, policySetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, policySetName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, policySetName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, policySetName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, policySetName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, policySetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, policySetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List policies in a given policy set.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, policySetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, options }, listOperationSpec$a);
    }
    /**
     * Get policy.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param name The name of the policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, policySetName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, name, options }, getOperationSpec$b);
    }
    /**
     * Create or replace an existing policy.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param name The name of the policy.
     * @param policy A Policy.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, policySetName, name, policy, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, name, policy, options }, createOrUpdateOperationSpec$b);
    }
    /**
     * Delete policy.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param name The name of the policy.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, policySetName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, name, options }, deleteOperationSpec$b);
    }
    /**
     * Allows modifying tags of policies. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param name The name of the policy.
     * @param policy A Policy.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, policySetName, name, policy, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, name, policy, options }, updateOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param policySetName The name of the policy set.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, policySetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, policySetName, nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{policySetName}/policies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        policySetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{policySetName}/policies/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Policy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        policySetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{policySetName}/policies/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Policy
        },
        201: {
            bodyMapper: Policy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: policy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        policySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{policySetName}/policies/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        policySetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const updateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/policysets/{policySetName}/policies/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Policy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: policy1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        policySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PolicyList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        policySetName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Schedules operations. */
class SchedulesImpl {
    /**
     * Initialize a new instance of the class Schedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List schedules in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all applicable schedules
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    listApplicable(resourceGroupName, labName, name, options) {
        const iter = this.listApplicablePagingAll(resourceGroupName, labName, name, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listApplicablePagingPage(resourceGroupName, labName, name, options, settings);
            }
        };
    }
    listApplicablePagingPage(resourceGroupName, labName, name, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listApplicablePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listApplicable(resourceGroupName, labName, name, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listApplicableNext(resourceGroupName, labName, name, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listApplicablePagingAll(resourceGroupName, labName, name, options) {
        return tslib.__asyncGenerator(this, arguments, function* listApplicablePagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listApplicablePagingPage(resourceGroupName, labName, name, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List schedules in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$9);
    }
    /**
     * Get schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$a);
    }
    /**
     * Create or replace an existing schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, name, schedule, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, schedule, options }, createOrUpdateOperationSpec$a);
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, deleteOperationSpec$a);
    }
    /**
     * Allows modifying tags of schedules. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, schedule, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, schedule, options }, updateOperationSpec$9);
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecute(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, executeOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecuteAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExecute(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all applicable schedules
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    _listApplicable(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, listApplicableOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$9);
    }
    /**
     * ListApplicableNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the schedule.
     * @param nextLink The nextLink from the previous successful call to the ListApplicable method.
     * @param options The options parameters.
     */
    _listApplicableNext(resourceGroupName, labName, name, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, nextLink, options }, listApplicableNextOperationSpec);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const updateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const executeOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listApplicableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/schedules/{name}/listApplicable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listApplicableNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServiceRunners operations. */
class ServiceRunnersImpl {
    /**
     * Initialize a new instance of the class ServiceRunners class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get service runner.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the service runner.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$9);
    }
    /**
     * Create or replace an existing service runner.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the service runner.
     * @param serviceRunner A container for a managed identity to execute DevTest lab services.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, name, serviceRunner, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, serviceRunner, options }, createOrUpdateOperationSpec$9);
    }
    /**
     * Delete service runner.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the service runner.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, deleteOperationSpec$9);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/servicerunners/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceRunner
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/servicerunners/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceRunner
        },
        201: {
            bodyMapper: ServiceRunner
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: serviceRunner,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/servicerunners/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Users operations. */
class UsersImpl {
    /**
     * Initialize a new instance of the class Users class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List user profiles in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List user profiles in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$8);
    }
    /**
     * Get user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$8);
    }
    /**
     * Create or replace an existing user profile. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param user Profile of a lab user.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, name, user, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, user, options }, createOrUpdateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing user profile. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param user Profile of a lab user.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, name, user, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, name, user, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete user profile. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete user profile. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of user profiles. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the user profile.
     * @param user Profile of a lab user.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, user, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, user, options }, updateOperationSpec$8);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: user,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const updateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: user1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UserList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Disks operations. */
class DisksImpl {
    /**
     * Initialize a new instance of the class Disks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List disks in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, userName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, userName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, userName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, userName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, userName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, userName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, userName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, userName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List disks in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, userName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, options }, listOperationSpec$7);
    }
    /**
     * Get disk.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, getOperationSpec$7);
    }
    /**
     * Create or replace an existing disk. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param disk A Disk.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, userName, name, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, disk, options }, createOrUpdateOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing disk. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param disk A Disk.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, userName, name, disk, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, userName, name, disk, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete disk. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete disk. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, userName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of disks. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param disk A Disk.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, userName, name, disk, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, disk, options }, updateOperationSpec$7);
    }
    /**
     * Attach and create the lease of the disk to the virtual machine. This operation can take a while to
     * complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param attachDiskProperties Properties of the disk to attach.
     * @param options The options parameters.
     */
    beginAttach(resourceGroupName, labName, userName, name, attachDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                labName,
                userName,
                name,
                attachDiskProperties,
                options
            }, attachOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Attach and create the lease of the disk to the virtual machine. This operation can take a while to
     * complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param attachDiskProperties Properties of the disk to attach.
     * @param options The options parameters.
     */
    beginAttachAndWait(resourceGroupName, labName, userName, name, attachDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAttach(resourceGroupName, labName, userName, name, attachDiskProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Detach and break the lease of the disk attached to the virtual machine. This operation can take a
     * while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param detachDiskProperties Properties of the disk to detach.
     * @param options The options parameters.
     */
    beginDetach(resourceGroupName, labName, userName, name, detachDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                labName,
                userName,
                name,
                detachDiskProperties,
                options
            }, detachOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Detach and break the lease of the disk attached to the virtual machine. This operation can take a
     * while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the disk.
     * @param detachDiskProperties Properties of the disk to detach.
     * @param options The options parameters.
     */
    beginDetachAndWait(resourceGroupName, labName, userName, name, detachDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDetach(resourceGroupName, labName, userName, name, detachDiskProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, userName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Disk
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Disk
        },
        201: {
            bodyMapper: Disk
        },
        202: {
            bodyMapper: Disk
        },
        204: {
            bodyMapper: Disk
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: disk,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Disk
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: disk1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const attachOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}/attach",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: attachDiskProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const detachOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/disks/{name}/detach",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: detachDiskProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiskList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Environments operations. */
class EnvironmentsImpl {
    /**
     * Initialize a new instance of the class Environments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List environments in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, userName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, userName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, userName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, userName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, userName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, userName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, userName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, userName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List environments in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, userName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, options }, listOperationSpec$6);
    }
    /**
     * Get environment.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, getOperationSpec$6);
    }
    /**
     * Create or replace an existing environment. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param dtlEnvironment An environment, which is essentially an ARM template deployment.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, userName, name, dtlEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, dtlEnvironment, options }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing environment. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param dtlEnvironment An environment, which is essentially an ARM template deployment.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, userName, name, dtlEnvironment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, userName, name, dtlEnvironment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete environment. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete environment. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, userName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of environments. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the environment.
     * @param dtlEnvironment An environment, which is essentially an ARM template deployment.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, userName, name, dtlEnvironment, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, dtlEnvironment, options }, updateOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, userName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/environments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DtlEnvironmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/environments/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DtlEnvironment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/environments/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DtlEnvironment
        },
        201: {
            bodyMapper: DtlEnvironment
        },
        202: {
            bodyMapper: DtlEnvironment
        },
        204: {
            bodyMapper: DtlEnvironment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: dtlEnvironment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/environments/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const updateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/environments/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DtlEnvironment
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: dtlEnvironment1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DtlEnvironmentList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Secrets operations. */
class SecretsImpl {
    /**
     * Initialize a new instance of the class Secrets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List secrets in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, userName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, userName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, userName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, userName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, userName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, userName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, userName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, userName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List secrets in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, userName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, options }, listOperationSpec$5);
    }
    /**
     * Get secret.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the secret.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, getOperationSpec$5);
    }
    /**
     * Create or replace an existing secret. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the secret.
     * @param secret A secret.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, userName, name, secret, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, secret, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing secret. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the secret.
     * @param secret A secret.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, userName, name, secret, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, userName, name, secret, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete secret.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the secret.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, deleteOperationSpec$5);
    }
    /**
     * Allows modifying tags of secrets. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the secret.
     * @param secret A secret.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, userName, name, secret, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, secret, options }, updateOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, userName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/secrets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/secrets/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/secrets/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Secret
        },
        201: {
            bodyMapper: Secret
        },
        202: {
            bodyMapper: Secret
        },
        204: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: secret,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/secrets/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/secrets/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Secret
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: secret1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecretList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceFabrics operations. */
class ServiceFabricsImpl {
    /**
     * Initialize a new instance of the class ServiceFabrics class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List service fabrics in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, userName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, userName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, userName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, userName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, userName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, userName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, userName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, userName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List service fabrics in a given user profile.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, userName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, options }, listOperationSpec$4);
    }
    /**
     * Get service fabric.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, getOperationSpec$4);
    }
    /**
     * Create or replace an existing service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param serviceFabric A Service Fabric.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, userName, name, serviceFabric, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, serviceFabric, options }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param serviceFabric A Service Fabric.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, userName, name, serviceFabric, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, userName, name, serviceFabric, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, userName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of service fabrics. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param serviceFabric A Service Fabric.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, userName, name, serviceFabric, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, serviceFabric, options }, updateOperationSpec$4);
    }
    /**
     * Lists the applicable start/stop schedules, if any.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    listApplicableSchedules(resourceGroupName, labName, userName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, name, options }, listApplicableSchedulesOperationSpec$1);
    }
    /**
     * Start a service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, options }, startOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start a service fabric. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, labName, userName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop a service fabric This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, name, options }, stopOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stop a service fabric This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param name The name of the service fabric.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, labName, userName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, labName, userName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, userName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceFabricList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceFabric
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceFabric
        },
        201: {
            bodyMapper: ServiceFabric
        },
        202: {
            bodyMapper: ServiceFabric
        },
        204: {
            bodyMapper: ServiceFabric
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: serviceFabric,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ServiceFabric
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: serviceFabric1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listApplicableSchedulesOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}/listApplicableSchedules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicableSchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const stopOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{name}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceFabricList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceFabricSchedules operations. */
class ServiceFabricSchedulesImpl {
    /**
     * Initialize a new instance of the class ServiceFabricSchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List schedules in a given service fabric.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, userName, serviceFabricName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, userName, serviceFabricName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, userName, serviceFabricName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, userName, serviceFabricName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, userName, serviceFabricName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, userName, serviceFabricName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, userName, serviceFabricName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, userName, serviceFabricName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List schedules in a given service fabric.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, userName, serviceFabricName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, serviceFabricName, options }, listOperationSpec$3);
    }
    /**
     * Get schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, serviceFabricName, name, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            userName,
            serviceFabricName,
            name,
            options
        }, getOperationSpec$3);
    }
    /**
     * Create or replace an existing schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, userName, serviceFabricName, name, schedule, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            userName,
            serviceFabricName,
            name,
            schedule,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, userName, serviceFabricName, name, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            userName,
            serviceFabricName,
            name,
            options
        }, deleteOperationSpec$3);
    }
    /**
     * Allows modifying tags of schedules. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, userName, serviceFabricName, name, schedule, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            userName,
            serviceFabricName,
            name,
            schedule,
            options
        }, updateOperationSpec$3);
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecute(resourceGroupName, labName, userName, serviceFabricName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                labName,
                userName,
                serviceFabricName,
                name,
                options
            }, executeOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecuteAndWait(resourceGroupName, labName, userName, serviceFabricName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExecute(resourceGroupName, labName, userName, serviceFabricName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param userName The name of the user profile.
     * @param serviceFabricName The name of the service fabric.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, userName, serviceFabricName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            userName,
            serviceFabricName,
            nextLink,
            options
        }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const executeOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/users/{userName}/servicefabrics/{serviceFabricName}/schedules/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        userName,
        serviceFabricName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List virtual machines in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List virtual machines in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec$2);
    }
    /**
     * Get virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec$2);
    }
    /**
     * Create or replace an existing virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param labVirtualMachine A virtual machine.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, name, labVirtualMachine, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, labVirtualMachine, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param labVirtualMachine A virtual machine.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, name, labVirtualMachine, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, name, labVirtualMachine, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of virtual machines. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param labVirtualMachine A virtual machine.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, labVirtualMachine, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, labVirtualMachine, options }, updateOperationSpec$2);
    }
    /**
     * Attach a new or existing data disk to virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param dataDiskProperties Request body for adding a new or existing data disk to a virtual machine.
     * @param options The options parameters.
     */
    beginAddDataDisk(resourceGroupName, labName, name, dataDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, dataDiskProperties, options }, addDataDiskOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Attach a new or existing data disk to virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param dataDiskProperties Request body for adding a new or existing data disk to a virtual machine.
     * @param options The options parameters.
     */
    beginAddDataDiskAndWait(resourceGroupName, labName, name, dataDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginAddDataDisk(resourceGroupName, labName, name, dataDiskProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Apply artifacts to virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param applyArtifactsRequest Request body for applying artifacts to a virtual machine.
     * @param options The options parameters.
     */
    beginApplyArtifacts(resourceGroupName, labName, name, applyArtifactsRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, applyArtifactsRequest, options }, applyArtifactsOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Apply artifacts to virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param applyArtifactsRequest Request body for applying artifacts to a virtual machine.
     * @param options The options parameters.
     */
    beginApplyArtifactsAndWait(resourceGroupName, labName, name, applyArtifactsRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginApplyArtifacts(resourceGroupName, labName, name, applyArtifactsRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Take ownership of an existing virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginClaim(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, claimOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Take ownership of an existing virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginClaimAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginClaim(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Detach the specified disk from the virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param detachDataDiskProperties Request body for detaching data disk from a virtual machine.
     * @param options The options parameters.
     */
    beginDetachDataDisk(resourceGroupName, labName, name, detachDataDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, detachDataDiskProperties, options }, detachDataDiskOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Detach the specified disk from the virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param detachDataDiskProperties Request body for detaching data disk from a virtual machine.
     * @param options The options parameters.
     */
    beginDetachDataDiskAndWait(resourceGroupName, labName, name, detachDataDiskProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDetachDataDisk(resourceGroupName, labName, name, detachDataDiskProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a string that represents the contents of the RDP file for the virtual machine
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    getRdpFileContents(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getRdpFileContentsOperationSpec);
    }
    /**
     * Lists the applicable start/stop schedules, if any.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    listApplicableSchedules(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, listApplicableSchedulesOperationSpec);
    }
    /**
     * Redeploy a virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeploy(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, redeployOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Redeploy a virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRedeployAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRedeploy(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resize Virtual Machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param resizeLabVirtualMachineProperties Request body for resizing a virtual machine.
     * @param options The options parameters.
     */
    beginResize(resourceGroupName, labName, name, resizeLabVirtualMachineProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                labName,
                name,
                resizeLabVirtualMachineProperties,
                options
            }, resizeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resize Virtual Machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param resizeLabVirtualMachineProperties Request body for resizing a virtual machine.
     * @param options The options parameters.
     */
    beginResizeAndWait(resourceGroupName, labName, name, resizeLabVirtualMachineProperties, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResize(resourceGroupName, labName, name, resizeLabVirtualMachineProperties, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restart a virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restart a virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Start a virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start a virtual machine. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop a virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stop a virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Transfers all data disks attached to the virtual machine to be owned by the current user. This
     * operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginTransferDisks(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, transferDisksOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Transfers all data disks attached to the virtual machine to be owned by the current user. This
     * operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginTransferDisksAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginTransferDisks(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Release ownership of an existing virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginUnClaim(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, unClaimOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Release ownership of an existing virtual machine This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual machine.
     * @param options The options parameters.
     */
    beginUnClaimAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUnClaim(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabVirtualMachineList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabVirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LabVirtualMachine
        },
        201: {
            bodyMapper: LabVirtualMachine
        },
        202: {
            bodyMapper: LabVirtualMachine
        },
        204: {
            bodyMapper: LabVirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: labVirtualMachine,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LabVirtualMachine
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: labVirtualMachine1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const addDataDiskOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/addDataDisk",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: dataDiskProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const applyArtifactsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/applyArtifacts",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: applyArtifactsRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const claimOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/claim",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const detachDataDiskOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/detachDataDisk",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: detachDataDiskProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getRdpFileContentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/getRdpFileContents",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: RdpConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listApplicableSchedulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/listApplicableSchedules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicableSchedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const redeployOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/redeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const resizeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/resize",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: resizeLabVirtualMachineProperties,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const transferDisksOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/transferDisks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const unClaimOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{name}/unClaim",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabVirtualMachineList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineSchedules operations. */
class VirtualMachineSchedulesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineSchedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List schedules in a given virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, virtualMachineName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, virtualMachineName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, virtualMachineName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, virtualMachineName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, virtualMachineName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, virtualMachineName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, virtualMachineName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List schedules in a given virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, virtualMachineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, virtualMachineName, options }, listOperationSpec$1);
    }
    /**
     * Get schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, virtualMachineName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, virtualMachineName, name, options }, getOperationSpec$1);
    }
    /**
     * Create or replace an existing schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, virtualMachineName, name, schedule, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            virtualMachineName,
            name,
            schedule,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Delete schedule.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    delete(resourceGroupName, labName, virtualMachineName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, virtualMachineName, name, options }, deleteOperationSpec$1);
    }
    /**
     * Allows modifying tags of schedules. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param schedule A schedule.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, virtualMachineName, name, schedule, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            labName,
            virtualMachineName,
            name,
            schedule,
            options
        }, updateOperationSpec$1);
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecute(resourceGroupName, labName, virtualMachineName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, name, options }, executeOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Execute a schedule. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param name The name of the schedule.
     * @param options The options parameters.
     */
    beginExecuteAndWait(resourceGroupName, labName, virtualMachineName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginExecute(resourceGroupName, labName, virtualMachineName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param virtualMachineName The name of the virtual machine.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, virtualMachineName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, virtualMachineName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: schedule1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const executeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualmachines/{virtualMachineName}/schedules/{name}/execute",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScheduleList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworks operations. */
class VirtualNetworksImpl {
    /**
     * Initialize a new instance of the class VirtualNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List virtual networks in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    list(resourceGroupName, labName, options) {
        const iter = this.listPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List virtual networks in a given lab.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param options The options parameters.
     */
    _list(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listOperationSpec);
    }
    /**
     * Get virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, options }, getOperationSpec);
    }
    /**
     * Create or replace an existing virtual network. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param virtualNetwork A virtual network.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, name, virtualNetwork, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, virtualNetwork, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or replace an existing virtual network. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param virtualNetwork A virtual network.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, name, virtualNetwork, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, name, virtualNetwork, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete virtual network. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, name, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete virtual network. This operation can take a while to complete.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, name, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, name, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Allows modifying tags of virtual networks. All other properties will be ignored.
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param name The name of the virtual network.
     * @param virtualNetwork A virtual network.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, name, virtualNetwork, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, name, virtualNetwork, options }, updateOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param labName The name of the lab.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualnetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualnetworks/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualnetworks/{name}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        201: {
            bodyMapper: VirtualNetwork
        },
        202: {
            bodyMapper: VirtualNetwork
        },
        204: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualNetwork,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualnetworks/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept],
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DevTestLab/labs/{labName}/virtualnetworks/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualNetwork1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        name,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        expand,
        filter,
        top,
        orderby
    ],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class DevTestLabsClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the DevTestLabsClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-devtestlabs/4.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2018-09-15";
        this.providerOperations = new ProviderOperationsImpl(this);
        this.labs = new LabsImpl(this);
        this.operations = new OperationsImpl(this);
        this.globalSchedules = new GlobalSchedulesImpl(this);
        this.artifactSources = new ArtifactSourcesImpl(this);
        this.armTemplates = new ArmTemplatesImpl(this);
        this.artifacts = new ArtifactsImpl(this);
        this.costs = new CostsImpl(this);
        this.customImages = new CustomImagesImpl(this);
        this.formulas = new FormulasImpl(this);
        this.galleryImages = new GalleryImagesImpl(this);
        this.notificationChannels = new NotificationChannelsImpl(this);
        this.policySets = new PolicySetsImpl(this);
        this.policies = new PoliciesImpl(this);
        this.schedules = new SchedulesImpl(this);
        this.serviceRunners = new ServiceRunnersImpl(this);
        this.users = new UsersImpl(this);
        this.disks = new DisksImpl(this);
        this.environments = new EnvironmentsImpl(this);
        this.secrets = new SecretsImpl(this);
        this.serviceFabrics = new ServiceFabricsImpl(this);
        this.serviceFabricSchedules = new ServiceFabricSchedulesImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.virtualMachineSchedules = new VirtualMachineSchedulesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.DevTestLabsClient = DevTestLabsClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
