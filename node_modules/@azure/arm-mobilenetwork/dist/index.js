'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Unknown */
    KnownProvisioningState["Unknown"] = "Unknown";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Accepted */
    KnownProvisioningState["Accepted"] = "Accepted";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
    /** Deleted */
    KnownProvisioningState["Deleted"] = "Deleted";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link NaptEnabled} that the service accepts. */
exports.KnownNaptEnabled = void 0;
(function (KnownNaptEnabled) {
    /** NAPT is enabled */
    KnownNaptEnabled["Enabled"] = "Enabled";
    /** NAPT is disabled */
    KnownNaptEnabled["Disabled"] = "Disabled";
})(exports.KnownNaptEnabled || (exports.KnownNaptEnabled = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DiagnosticsPackageStatus} that the service accepts. */
exports.KnownDiagnosticsPackageStatus = void 0;
(function (KnownDiagnosticsPackageStatus) {
    /** NotStarted */
    KnownDiagnosticsPackageStatus["NotStarted"] = "NotStarted";
    /** Collecting */
    KnownDiagnosticsPackageStatus["Collecting"] = "Collecting";
    /** Collected */
    KnownDiagnosticsPackageStatus["Collected"] = "Collected";
    /** Error */
    KnownDiagnosticsPackageStatus["Error"] = "Error";
})(exports.KnownDiagnosticsPackageStatus || (exports.KnownDiagnosticsPackageStatus = {}));
/** Known values of {@link PacketCaptureStatus} that the service accepts. */
exports.KnownPacketCaptureStatus = void 0;
(function (KnownPacketCaptureStatus) {
    /** NotStarted */
    KnownPacketCaptureStatus["NotStarted"] = "NotStarted";
    /** Running */
    KnownPacketCaptureStatus["Running"] = "Running";
    /** Stopped */
    KnownPacketCaptureStatus["Stopped"] = "Stopped";
    /** Error */
    KnownPacketCaptureStatus["Error"] = "Error";
})(exports.KnownPacketCaptureStatus || (exports.KnownPacketCaptureStatus = {}));
/** Known values of {@link DesiredInstallationState} that the service accepts. */
exports.KnownDesiredInstallationState = void 0;
(function (KnownDesiredInstallationState) {
    /** Don't install the packet core. */
    KnownDesiredInstallationState["Uninstalled"] = "Uninstalled";
    /** Install the packet core. */
    KnownDesiredInstallationState["Installed"] = "Installed";
})(exports.KnownDesiredInstallationState || (exports.KnownDesiredInstallationState = {}));
/** Known values of {@link InstallationState} that the service accepts. */
exports.KnownInstallationState = void 0;
(function (KnownInstallationState) {
    /** The packet core is uninstalled. */
    KnownInstallationState["Uninstalled"] = "Uninstalled";
    /** The packet core is installing. */
    KnownInstallationState["Installing"] = "Installing";
    /** The packet core is installed. */
    KnownInstallationState["Installed"] = "Installed";
    /** The packet core is updating its configuration. */
    KnownInstallationState["Updating"] = "Updating";
    /** The packet core is upgrading to a different software version. */
    KnownInstallationState["Upgrading"] = "Upgrading";
    /** The packet core is uninstalling. */
    KnownInstallationState["Uninstalling"] = "Uninstalling";
    /** The packet core is reinstalling. */
    KnownInstallationState["Reinstalling"] = "Reinstalling";
    /** The packet core is rolling back to its previous version. */
    KnownInstallationState["RollingBack"] = "RollingBack";
    /** The packet core is in failed state. */
    KnownInstallationState["Failed"] = "Failed";
})(exports.KnownInstallationState || (exports.KnownInstallationState = {}));
/** Known values of {@link ReinstallRequired} that the service accepts. */
exports.KnownReinstallRequired = void 0;
(function (KnownReinstallRequired) {
    /** A reinstall of the packet core is required. */
    KnownReinstallRequired["Required"] = "Required";
    /** A reinstall of the packet core is not required. */
    KnownReinstallRequired["NotRequired"] = "NotRequired";
})(exports.KnownReinstallRequired || (exports.KnownReinstallRequired = {}));
/** Known values of {@link InstallationReason} that the service accepts. */
exports.KnownInstallationReason = void 0;
(function (KnownInstallationReason) {
    /** The packet core has not been installed as the mobile network does not have any applicable configured slices. */
    KnownInstallationReason["NoSlices"] = "NoSlices";
    /** The packet core has not been installed as there is no configured data plane for this packet core. */
    KnownInstallationReason["NoPacketCoreDataPlane"] = "NoPacketCoreDataPlane";
    /** The packet core has not been installed as the packet core has no attached data networks. */
    KnownInstallationReason["NoAttachedDataNetworks"] = "NoAttachedDataNetworks";
    /** A reinstall is required as the packet core is running with out-of-date PLMN ID. */
    KnownInstallationReason["PublicLandMobileNetworkIdentifierHasChanged"] = "PublicLandMobileNetworkIdentifierHasChanged";
    /** A reinstall is required as the packet core is running with out-of-date control plane access interface information. */
    KnownInstallationReason["ControlPlaneAccessInterfaceHasChanged"] = "ControlPlaneAccessInterfaceHasChanged";
    /** A reinstall is required as the packet core is running with out-of-date user plane core interface. */
    KnownInstallationReason["UserPlaneAccessInterfaceHasChanged"] = "UserPlaneAccessInterfaceHasChanged";
    /** A reinstall is required as the packet core is running with out-of-date user plane access interface. */
    KnownInstallationReason["UserPlaneDataInterfaceHasChanged"] = "UserPlaneDataInterfaceHasChanged";
    /** A reinstall is required as the packet core is running with out-of-date control plane access network virtual IP address. */
    KnownInstallationReason["ControlPlaneAccessVirtualIpv4AddressesHasChanged"] = "ControlPlaneAccessVirtualIpv4AddressesHasChanged";
    /** A reinstall is required as the packet core is running with out-of-date user plane access network virtual IP address. */
    KnownInstallationReason["UserPlaneAccessVirtualIpv4AddressesHasChanged"] = "UserPlaneAccessVirtualIpv4AddressesHasChanged";
})(exports.KnownInstallationReason || (exports.KnownInstallationReason = {}));
/** Known values of {@link PlatformType} that the service accepts. */
exports.KnownPlatformType = void 0;
(function (KnownPlatformType) {
    /** If this option is chosen, you must set one of "azureStackEdgeDevice", "connectedCluster" or "customLocation". If multiple are set, they must be consistent with each other. */
    KnownPlatformType["AKSHCI"] = "AKS-HCI";
    /** If this option is chosen, you must set one of "azureStackHciCluster", "connectedCluster" or "customLocation". If multiple are set, they must be consistent with each other. */
    KnownPlatformType["ThreePAzureStackHCI"] = "3P-AZURE-STACK-HCI";
})(exports.KnownPlatformType || (exports.KnownPlatformType = {}));
/** Known values of {@link BillingSku} that the service accepts. */
exports.KnownBillingSku = void 0;
(function (KnownBillingSku) {
    /** 100 Mbps, 20 active SIMs plan, 2 RANs */
    KnownBillingSku["G0"] = "G0";
    /** 1 Gbps, 100 active SIMs plan, 5 RANs */
    KnownBillingSku["G1"] = "G1";
    /** 2 Gbps, 200 active SIMs plan, 10 RANs */
    KnownBillingSku["G2"] = "G2";
    /** 5 Gbps, 500 active SIMs plan */
    KnownBillingSku["G5"] = "G5";
    /** 10 Gbps, 1000 active SIMs plan */
    KnownBillingSku["G10"] = "G10";
})(exports.KnownBillingSku || (exports.KnownBillingSku = {}));
/** Known values of {@link AuthenticationType} that the service accepts. */
exports.KnownAuthenticationType = void 0;
(function (KnownAuthenticationType) {
    /** Use AAD SSO to authenticate the user (this requires internet access). */
    KnownAuthenticationType["AAD"] = "AAD";
    /** Use locally stored passwords to authenticate the user. */
    KnownAuthenticationType["Password"] = "Password";
})(exports.KnownAuthenticationType || (exports.KnownAuthenticationType = {}));
/** Known values of {@link CertificateProvisioningState} that the service accepts. */
exports.KnownCertificateProvisioningState = void 0;
(function (KnownCertificateProvisioningState) {
    /** The certificate has not been provisioned. */
    KnownCertificateProvisioningState["NotProvisioned"] = "NotProvisioned";
    /** The certificate has been provisioned. */
    KnownCertificateProvisioningState["Provisioned"] = "Provisioned";
    /** The certificate failed to be provisioned. The "reason" property explains why. */
    KnownCertificateProvisioningState["Failed"] = "Failed";
})(exports.KnownCertificateProvisioningState || (exports.KnownCertificateProvisioningState = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));
/** Known values of {@link VersionState} that the service accepts. */
exports.KnownVersionState = void 0;
(function (KnownVersionState) {
    /** The state of this version is unknown. */
    KnownVersionState["Unknown"] = "Unknown";
    /** This version is a preview and is not suitable for production use. */
    KnownVersionState["Preview"] = "Preview";
    /** This version is currently being validated. */
    KnownVersionState["Validating"] = "Validating";
    /** This version failed validation. */
    KnownVersionState["ValidationFailed"] = "ValidationFailed";
    /** This version is active and suitable for production use. */
    KnownVersionState["Active"] = "Active";
    /** This version is deprecated and is no longer supported. */
    KnownVersionState["Deprecated"] = "Deprecated";
})(exports.KnownVersionState || (exports.KnownVersionState = {}));
/** Known values of {@link RecommendedVersion} that the service accepts. */
exports.KnownRecommendedVersion = void 0;
(function (KnownRecommendedVersion) {
    /** This is the recommended version to use for new packet core control plane deployments. */
    KnownRecommendedVersion["Recommended"] = "Recommended";
    /** This is not the recommended version to use for new packet core control plane deployments. */
    KnownRecommendedVersion["NotRecommended"] = "NotRecommended";
})(exports.KnownRecommendedVersion || (exports.KnownRecommendedVersion = {}));
/** Known values of {@link ObsoleteVersion} that the service accepts. */
exports.KnownObsoleteVersion = void 0;
(function (KnownObsoleteVersion) {
    /** This version is obsolete for use in new packet core control plane deployments. */
    KnownObsoleteVersion["Obsolete"] = "Obsolete";
    /** This version is not obsolete for use in new packet core control plane deployments. */
    KnownObsoleteVersion["NotObsolete"] = "NotObsolete";
})(exports.KnownObsoleteVersion || (exports.KnownObsoleteVersion = {}));
/** Known values of {@link PreemptionCapability} that the service accepts. */
exports.KnownPreemptionCapability = void 0;
(function (KnownPreemptionCapability) {
    /** Cannot preempt */
    KnownPreemptionCapability["NotPreempt"] = "NotPreempt";
    /** May preempt */
    KnownPreemptionCapability["MayPreempt"] = "MayPreempt";
})(exports.KnownPreemptionCapability || (exports.KnownPreemptionCapability = {}));
/** Known values of {@link PreemptionVulnerability} that the service accepts. */
exports.KnownPreemptionVulnerability = void 0;
(function (KnownPreemptionVulnerability) {
    /** Cannot be preempted */
    KnownPreemptionVulnerability["NotPreemptable"] = "NotPreemptable";
    /** May be preempted */
    KnownPreemptionVulnerability["Preemptable"] = "Preemptable";
})(exports.KnownPreemptionVulnerability || (exports.KnownPreemptionVulnerability = {}));
/** Known values of {@link TrafficControlPermission} that the service accepts. */
exports.KnownTrafficControlPermission = void 0;
(function (KnownTrafficControlPermission) {
    /** Traffic matching this rule is allowed to flow. */
    KnownTrafficControlPermission["Enabled"] = "Enabled";
    /** Traffic matching this rule is not allowed to flow. */
    KnownTrafficControlPermission["Blocked"] = "Blocked";
})(exports.KnownTrafficControlPermission || (exports.KnownTrafficControlPermission = {}));
/** Known values of {@link SdfDirection} that the service accepts. */
exports.KnownSdfDirection = void 0;
(function (KnownSdfDirection) {
    /** Traffic flowing from the UE to the data network. */
    KnownSdfDirection["Uplink"] = "Uplink";
    /** Traffic flowing from the data network to the UE. */
    KnownSdfDirection["Downlink"] = "Downlink";
    /** Traffic flowing both to and from the UE. */
    KnownSdfDirection["Bidirectional"] = "Bidirectional";
})(exports.KnownSdfDirection || (exports.KnownSdfDirection = {}));
/** Known values of {@link SimState} that the service accepts. */
exports.KnownSimState = void 0;
(function (KnownSimState) {
    /** The SIM is disabled because not all configuration required for enabling is present. */
    KnownSimState["Disabled"] = "Disabled";
    /** The SIM is enabled. */
    KnownSimState["Enabled"] = "Enabled";
    /** The SIM cannot be enabled because some of the associated configuration is invalid. */
    KnownSimState["Invalid"] = "Invalid";
})(exports.KnownSimState || (exports.KnownSimState = {}));
/** Known values of {@link SiteProvisioningState} that the service accepts. */
exports.KnownSiteProvisioningState = void 0;
(function (KnownSiteProvisioningState) {
    /** The resource should not be provisioned on this site. */
    KnownSiteProvisioningState["NotApplicable"] = "NotApplicable";
    /** The resource is being added to this site. */
    KnownSiteProvisioningState["Adding"] = "Adding";
    /** The resource is being updated on this site. */
    KnownSiteProvisioningState["Updating"] = "Updating";
    /** The resource is being deleted from this site. */
    KnownSiteProvisioningState["Deleting"] = "Deleting";
    /** The resource is provisioned on this site. */
    KnownSiteProvisioningState["Provisioned"] = "Provisioned";
    /** The resource failed to be provisioned on this site. */
    KnownSiteProvisioningState["Failed"] = "Failed";
})(exports.KnownSiteProvisioningState || (exports.KnownSiteProvisioningState = {}));
/** Known values of {@link PduSessionType} that the service accepts. */
exports.KnownPduSessionType = void 0;
(function (KnownPduSessionType) {
    /** IPv4 */
    KnownPduSessionType["IPv4"] = "IPv4";
    /** IPv6 */
    KnownPduSessionType["IPv6"] = "IPv6";
})(exports.KnownPduSessionType || (exports.KnownPduSessionType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const InterfaceProperties = {
    type: {
        name: "Composite",
        className: "InterfaceProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            ipv4Address: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "ipv4Address",
                type: {
                    name: "String"
                }
            },
            ipv4Subnet: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$")
                },
                serializedName: "ipv4Subnet",
                type: {
                    name: "String"
                }
            },
            ipv4Gateway: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "ipv4Gateway",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NaptConfiguration = {
    type: {
        name: "Composite",
        className: "NaptConfiguration",
        modelProperties: {
            enabled: {
                defaultValue: "Enabled",
                serializedName: "enabled",
                type: {
                    name: "String"
                }
            },
            portRange: {
                serializedName: "portRange",
                type: {
                    name: "Composite",
                    className: "PortRange"
                }
            },
            portReuseHoldTime: {
                serializedName: "portReuseHoldTime",
                type: {
                    name: "Composite",
                    className: "PortReuseHoldTimes"
                }
            },
            pinholeLimits: {
                defaultValue: 65536,
                constraints: {
                    InclusiveMaximum: 65536,
                    InclusiveMinimum: 1
                },
                serializedName: "pinholeLimits",
                type: {
                    name: "Number"
                }
            },
            pinholeTimeouts: {
                serializedName: "pinholeTimeouts",
                type: {
                    name: "Composite",
                    className: "PinholeTimeouts"
                }
            }
        }
    }
};
const PortRange = {
    type: {
        name: "Composite",
        className: "PortRange",
        modelProperties: {
            minPort: {
                defaultValue: 1024,
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1024
                },
                serializedName: "minPort",
                type: {
                    name: "Number"
                }
            },
            maxPort: {
                defaultValue: 49999,
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1024
                },
                serializedName: "maxPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PortReuseHoldTimes = {
    type: {
        name: "Composite",
        className: "PortReuseHoldTimes",
        modelProperties: {
            tcp: {
                defaultValue: 120,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "tcp",
                type: {
                    name: "Number"
                }
            },
            udp: {
                defaultValue: 60,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "udp",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PinholeTimeouts = {
    type: {
        name: "Composite",
        className: "PinholeTimeouts",
        modelProperties: {
            tcp: {
                defaultValue: 180,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "tcp",
                type: {
                    name: "Number"
                }
            },
            udp: {
                defaultValue: 30,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "udp",
                type: {
                    name: "Number"
                }
            },
            icmp: {
                defaultValue: 30,
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "icmp",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const TagsObject = {
    type: {
        name: "Composite",
        className: "TagsObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const AttachedDataNetworkListResult = {
    type: {
        name: "Composite",
        className: "AttachedDataNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AttachedDataNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataNetworkListResult = {
    type: {
        name: "Composite",
        className: "DataNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsPackageListResult = {
    type: {
        name: "Composite",
        className: "DiagnosticsPackageListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DiagnosticsPackage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlmnId = {
    type: {
        name: "Composite",
        className: "PlmnId",
        modelProperties: {
            mcc: {
                constraints: {
                    Pattern: new RegExp("^\\d{3}$")
                },
                serializedName: "mcc",
                required: true,
                type: {
                    name: "String"
                }
            },
            mnc: {
                constraints: {
                    Pattern: new RegExp("^\\d{2,3}$")
                },
                serializedName: "mnc",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MobileNetworkListResult = {
    type: {
        name: "Composite",
        className: "MobileNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MobileNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationList = {
    type: {
        name: "Composite",
        className: "OperationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AsyncOperationStatus = {
    type: {
        name: "Composite",
        className: "AsyncOperationStatus",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            percentComplete: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "percentComplete",
                type: {
                    name: "Number"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const PacketCaptureListResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCapture"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Installation = {
    type: {
        name: "Composite",
        className: "Installation",
        modelProperties: {
            desiredState: {
                serializedName: "desiredState",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reinstallRequired: {
                serializedName: "reinstallRequired",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reasons: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "reasons",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "Composite",
                    className: "AsyncOperationId"
                }
            }
        }
    }
};
const AsyncOperationId = {
    type: {
        name: "Composite",
        className: "AsyncOperationId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[^/?#]+\\/[lL][oO][cC][aA][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[oO][pP][eE][rR][aA][tT][iI][oO][nN][sS][tT][aA][tT][uU][sS][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteResourceId = {
    type: {
        name: "Composite",
        className: "SiteResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+\\/[sS][iI][tT][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlatformConfiguration = {
    type: {
        name: "Composite",
        className: "PlatformConfiguration",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            azureStackEdgeDevice: {
                serializedName: "azureStackEdgeDevice",
                type: {
                    name: "Composite",
                    className: "AzureStackEdgeDeviceResourceId"
                }
            },
            azureStackEdgeDevices: {
                serializedName: "azureStackEdgeDevices",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureStackEdgeDeviceResourceId"
                        }
                    }
                }
            },
            azureStackHciCluster: {
                serializedName: "azureStackHciCluster",
                type: {
                    name: "Composite",
                    className: "AzureStackHCIClusterResourceId"
                }
            },
            connectedCluster: {
                serializedName: "connectedCluster",
                type: {
                    name: "Composite",
                    className: "ConnectedClusterResourceId"
                }
            },
            customLocation: {
                serializedName: "customLocation",
                type: {
                    name: "Composite",
                    className: "CustomLocationResourceId"
                }
            }
        }
    }
};
const AzureStackEdgeDeviceResourceId = {
    type: {
        name: "Composite",
        className: "AzureStackEdgeDeviceResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[dD][aA][tT][aA][bB][oO][xX][eE][dD][gG][eE]\\/[dD][aA][tT][aA][bB][oO][xX][eE][dD][gG][eE][dD][eE][vV][iI][cC][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureStackHCIClusterResourceId = {
    type: {
        name: "Composite",
        className: "AzureStackHCIClusterResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[aA][zZ][uU][rR][eE][sS][tT][aA][cC][kK][hH][cC][iI]\\/[cC][lL][uU][sS][tT][eE][rR][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectedClusterResourceId = {
    type: {
        name: "Composite",
        className: "ConnectedClusterResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[kK][uU][bB][eE][rR][nN][eE][tT][eE][sS]\\/[cC][oO][nN][nN][eE][cC][tT][eE][dD][cC][lL][uU][sS][tT][eE][rR][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomLocationResourceId = {
    type: {
        name: "Composite",
        className: "CustomLocationResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[eE][xX][tT][eE][nN][dD][eE][dD][lL][oO][cC][aA][tT][iI][oO][nN]\\/[cC][uU][sS][tT][oO][mM][lL][oO][cC][aA][tT][iI][oO][nN][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LocalDiagnosticsAccessConfiguration = {
    type: {
        name: "Composite",
        className: "LocalDiagnosticsAccessConfiguration",
        modelProperties: {
            authenticationType: {
                serializedName: "authenticationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            httpsServerCertificate: {
                serializedName: "httpsServerCertificate",
                type: {
                    name: "Composite",
                    className: "HttpsServerCertificate"
                }
            }
        }
    }
};
const HttpsServerCertificate = {
    type: {
        name: "Composite",
        className: "HttpsServerCertificate",
        modelProperties: {
            certificateUrl: {
                serializedName: "certificateUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            provisioning: {
                serializedName: "provisioning",
                type: {
                    name: "Composite",
                    className: "CertificateProvisioning"
                }
            }
        }
    }
};
const CertificateProvisioning = {
    type: {
        name: "Composite",
        className: "CertificateProvisioning",
        modelProperties: {
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsUploadConfiguration = {
    type: {
        name: "Composite",
        className: "DiagnosticsUploadConfiguration",
        modelProperties: {
            storageAccountContainerUrl: {
                serializedName: "storageAccountContainerUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EventHubConfiguration = {
    type: {
        name: "Composite",
        className: "EventHubConfiguration",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[eE][vV][eE][nN][tT][hH][uU][bB]\\/[nN][aA][mM][eE][sS][pP][aA][cC][eE][sS]\\/[^/?#]+\\/[eV][vV][eE][nN][tT][hH][uU][bB][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            reportingInterval: {
                defaultValue: 1800,
                constraints: {
                    InclusiveMaximum: 3600,
                    InclusiveMinimum: 30
                },
                serializedName: "reportingInterval",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SignalingConfiguration = {
    type: {
        name: "Composite",
        className: "SignalingConfiguration",
        modelProperties: {
            nasReroute: {
                serializedName: "nasReroute",
                type: {
                    name: "Composite",
                    className: "NASRerouteConfiguration"
                }
            }
        }
    }
};
const NASRerouteConfiguration = {
    type: {
        name: "Composite",
        className: "NASRerouteConfiguration",
        modelProperties: {
            macroMmeGroupId: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "macroMmeGroupId",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const IdentityAndTagsObject = {
    type: {
        name: "Composite",
        className: "IdentityAndTagsObject",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PacketCoreControlPlaneListResult = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlaneListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCoreControlPlane"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCoreControlPlaneCollectDiagnosticsPackage = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlaneCollectDiagnosticsPackage",
        modelProperties: {
            storageAccountBlobUrl: {
                serializedName: "storageAccountBlobUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Platform = {
    type: {
        name: "Composite",
        className: "Platform",
        modelProperties: {
            platformType: {
                serializedName: "platformType",
                type: {
                    name: "String"
                }
            },
            versionState: {
                serializedName: "versionState",
                type: {
                    name: "String"
                }
            },
            minimumPlatformSoftwareVersion: {
                serializedName: "minimumPlatformSoftwareVersion",
                type: {
                    name: "String"
                }
            },
            maximumPlatformSoftwareVersion: {
                serializedName: "maximumPlatformSoftwareVersion",
                type: {
                    name: "String"
                }
            },
            recommendedVersion: {
                serializedName: "recommendedVersion",
                type: {
                    name: "String"
                }
            },
            obsoleteVersion: {
                serializedName: "obsoleteVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCoreControlPlaneVersionListResult = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlaneVersionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCoreControlPlaneVersion"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCoreDataPlaneListResult = {
    type: {
        name: "Composite",
        className: "PacketCoreDataPlaneListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCoreDataPlane"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QosPolicy = {
    type: {
        name: "Composite",
        className: "QosPolicy",
        modelProperties: {
            fiveQi: {
                constraints: {
                    InclusiveMaximum: 127,
                    InclusiveMinimum: 1
                },
                serializedName: "5qi",
                type: {
                    name: "Number"
                }
            },
            allocationAndRetentionPriorityLevel: {
                constraints: {
                    InclusiveMaximum: 15,
                    InclusiveMinimum: 1
                },
                serializedName: "allocationAndRetentionPriorityLevel",
                type: {
                    name: "Number"
                }
            },
            preemptionCapability: {
                serializedName: "preemptionCapability",
                type: {
                    name: "String"
                }
            },
            preemptionVulnerability: {
                serializedName: "preemptionVulnerability",
                type: {
                    name: "String"
                }
            },
            maximumBitRate: {
                serializedName: "maximumBitRate",
                type: {
                    name: "Composite",
                    className: "Ambr"
                }
            }
        }
    }
};
const Ambr = {
    type: {
        name: "Composite",
        className: "Ambr",
        modelProperties: {
            uplink: {
                constraints: {
                    Pattern: new RegExp("^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$")
                },
                serializedName: "uplink",
                required: true,
                type: {
                    name: "String"
                }
            },
            downlink: {
                constraints: {
                    Pattern: new RegExp("^\\d+(\\.\\d+)? (bps|Kbps|Mbps|Gbps|Tbps)$")
                },
                serializedName: "downlink",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PccRuleConfiguration = {
    type: {
        name: "Composite",
        className: "PccRuleConfiguration",
        modelProperties: {
            ruleName: {
                constraints: {
                    Pattern: new RegExp("^(?!(default|requested|service)$)[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
                    MaxLength: 64
                },
                serializedName: "ruleName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rulePrecedence: {
                constraints: {
                    InclusiveMaximum: 255,
                    InclusiveMinimum: 0
                },
                serializedName: "rulePrecedence",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ruleQosPolicy: {
                serializedName: "ruleQosPolicy",
                type: {
                    name: "Composite",
                    className: "PccRuleQosPolicy"
                }
            },
            trafficControl: {
                serializedName: "trafficControl",
                type: {
                    name: "String"
                }
            },
            serviceDataFlowTemplates: {
                constraints: {
                    MinItems: 1,
                    MaxItems: 15,
                    UniqueItems: true
                },
                serializedName: "serviceDataFlowTemplates",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceDataFlowTemplate"
                        }
                    }
                }
            }
        }
    }
};
const ServiceDataFlowTemplate = {
    type: {
        name: "Composite",
        className: "ServiceDataFlowTemplate",
        modelProperties: {
            templateName: {
                constraints: {
                    Pattern: new RegExp("^(?!(default|requested|service)$)[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
                    MaxLength: 64
                },
                serializedName: "templateName",
                required: true,
                type: {
                    name: "String"
                }
            },
            direction: {
                serializedName: "direction",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "protocol",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(ip|[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            remoteIpList: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "remoteIpList",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(any|(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2])))$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ports: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "ports",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^([1-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])(-([1-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ServiceListResult = {
    type: {
        name: "Composite",
        className: "ServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Service"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommonSimPropertiesFormat = {
    type: {
        name: "Composite",
        className: "CommonSimPropertiesFormat",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            simState: {
                serializedName: "simState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            siteProvisioningState: {
                serializedName: "siteProvisioningState",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            internationalMobileSubscriberIdentity: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{5,15}$")
                },
                serializedName: "internationalMobileSubscriberIdentity",
                required: true,
                type: {
                    name: "String"
                }
            },
            integratedCircuitCardIdentifier: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{10,20}$")
                },
                serializedName: "integratedCircuitCardIdentifier",
                type: {
                    name: "String"
                }
            },
            deviceType: {
                serializedName: "deviceType",
                type: {
                    name: "String"
                }
            },
            simPolicy: {
                serializedName: "simPolicy",
                type: {
                    name: "Composite",
                    className: "SimPolicyResourceId"
                }
            },
            staticIpConfiguration: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "staticIpConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimStaticIpProperties"
                        }
                    }
                }
            },
            vendorName: {
                serializedName: "vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vendorKeyFingerprint: {
                serializedName: "vendorKeyFingerprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimPolicyResourceId = {
    type: {
        name: "Composite",
        className: "SimPolicyResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+\\/[sS][iI][mM][pP][oO][lL][iI][cC][iI][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimStaticIpProperties = {
    type: {
        name: "Composite",
        className: "SimStaticIpProperties",
        modelProperties: {
            attachedDataNetwork: {
                serializedName: "attachedDataNetwork",
                type: {
                    name: "Composite",
                    className: "AttachedDataNetworkResourceId"
                }
            },
            slice: {
                serializedName: "slice",
                type: {
                    name: "Composite",
                    className: "SliceResourceId"
                }
            },
            staticIp: {
                serializedName: "staticIp",
                type: {
                    name: "Composite",
                    className: "SimStaticIpPropertiesStaticIp"
                }
            }
        }
    }
};
const AttachedDataNetworkResourceId = {
    type: {
        name: "Composite",
        className: "AttachedDataNetworkResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[pP][aA][cC][kK][eE][tT][cC][oO][rR][eE][cC][oO][nN][tT][rR][oO][lL][pP][lL][aA][nN][eE][sS]\\/[^/?#]+\\/[pP][aA][cC][kK][eE][tT][cC][oO][rR][eE][dD][aA][tT][aA][pP][lL][aA][nN][eE][sS]\\/[^/?#]+\\/[aA][tT][tT][aA][cC][hH][eE][dD][dD][aA][tT][aA][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SliceResourceId = {
    type: {
        name: "Composite",
        className: "SliceResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+\\/[sS][lL][iI][cC][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimStaticIpPropertiesStaticIp = {
    type: {
        name: "Composite",
        className: "SimStaticIpPropertiesStaticIp",
        modelProperties: {
            ipv4Address: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "ipv4Address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimListResult = {
    type: {
        name: "Composite",
        className: "SimListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Sim"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimUploadList = {
    type: {
        name: "Composite",
        className: "SimUploadList",
        modelProperties: {
            sims: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "sims",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimNameAndProperties"
                        }
                    }
                }
            }
        }
    }
};
const SimNameAndProperties = {
    type: {
        name: "Composite",
        className: "SimNameAndProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            simState: {
                serializedName: "properties.simState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            siteProvisioningState: {
                serializedName: "properties.siteProvisioningState",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            internationalMobileSubscriberIdentity: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{5,15}$")
                },
                serializedName: "properties.internationalMobileSubscriberIdentity",
                required: true,
                type: {
                    name: "String"
                }
            },
            integratedCircuitCardIdentifier: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{10,20}$")
                },
                serializedName: "properties.integratedCircuitCardIdentifier",
                type: {
                    name: "String"
                }
            },
            deviceType: {
                serializedName: "properties.deviceType",
                type: {
                    name: "String"
                }
            },
            simPolicy: {
                serializedName: "properties.simPolicy",
                type: {
                    name: "Composite",
                    className: "SimPolicyResourceId"
                }
            },
            staticIpConfiguration: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.staticIpConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimStaticIpProperties"
                        }
                    }
                }
            },
            vendorName: {
                serializedName: "properties.vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vendorKeyFingerprint: {
                serializedName: "properties.vendorKeyFingerprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            authenticationKey: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "properties.authenticationKey",
                type: {
                    name: "String"
                }
            },
            operatorKeyCode: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "properties.operatorKeyCode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimDeleteList = {
    type: {
        name: "Composite",
        className: "SimDeleteList",
        modelProperties: {
            sims: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "sims",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const EncryptedSimUploadList = {
    type: {
        name: "Composite",
        className: "EncryptedSimUploadList",
        modelProperties: {
            version: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "version",
                required: true,
                type: {
                    name: "Number"
                }
            },
            azureKeyIdentifier: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "azureKeyIdentifier",
                required: true,
                type: {
                    name: "Number"
                }
            },
            vendorKeyFingerprint: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]+$")
                },
                serializedName: "vendorKeyFingerprint",
                required: true,
                type: {
                    name: "String"
                }
            },
            encryptedTransportKey: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]+$")
                },
                serializedName: "encryptedTransportKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            signedTransportKey: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]+$")
                },
                serializedName: "signedTransportKey",
                required: true,
                type: {
                    name: "String"
                }
            },
            sims: {
                constraints: {
                    MinItems: 1
                },
                serializedName: "sims",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimNameAndEncryptedProperties"
                        }
                    }
                }
            }
        }
    }
};
const SimNameAndEncryptedProperties = {
    type: {
        name: "Composite",
        className: "SimNameAndEncryptedProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            simState: {
                serializedName: "properties.simState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            siteProvisioningState: {
                serializedName: "properties.siteProvisioningState",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            internationalMobileSubscriberIdentity: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{5,15}$")
                },
                serializedName: "properties.internationalMobileSubscriberIdentity",
                required: true,
                type: {
                    name: "String"
                }
            },
            integratedCircuitCardIdentifier: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{10,20}$")
                },
                serializedName: "properties.integratedCircuitCardIdentifier",
                type: {
                    name: "String"
                }
            },
            deviceType: {
                serializedName: "properties.deviceType",
                type: {
                    name: "String"
                }
            },
            simPolicy: {
                serializedName: "properties.simPolicy",
                type: {
                    name: "Composite",
                    className: "SimPolicyResourceId"
                }
            },
            staticIpConfiguration: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.staticIpConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimStaticIpProperties"
                        }
                    }
                }
            },
            vendorName: {
                serializedName: "properties.vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vendorKeyFingerprint: {
                serializedName: "properties.vendorKeyFingerprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            encryptedCredentials: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]+$")
                },
                serializedName: "properties.encryptedCredentials",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultKey = {
    type: {
        name: "Composite",
        className: "KeyVaultKey",
        modelProperties: {
            keyUrl: {
                serializedName: "keyUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MobileNetworkResourceId = {
    type: {
        name: "Composite",
        className: "MobileNetworkResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimGroupListResult = {
    type: {
        name: "Composite",
        className: "SimGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SliceConfiguration = {
    type: {
        name: "Composite",
        className: "SliceConfiguration",
        modelProperties: {
            slice: {
                serializedName: "slice",
                type: {
                    name: "Composite",
                    className: "SliceResourceId"
                }
            },
            defaultDataNetwork: {
                serializedName: "defaultDataNetwork",
                type: {
                    name: "Composite",
                    className: "DataNetworkResourceId"
                }
            },
            dataNetworkConfigurations: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "dataNetworkConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataNetworkConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const DataNetworkResourceId = {
    type: {
        name: "Composite",
        className: "DataNetworkResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+\\/[dD][aA][tT][aA][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DataNetworkConfiguration = {
    type: {
        name: "Composite",
        className: "DataNetworkConfiguration",
        modelProperties: {
            dataNetwork: {
                serializedName: "dataNetwork",
                type: {
                    name: "Composite",
                    className: "DataNetworkResourceId"
                }
            },
            sessionAmbr: {
                serializedName: "sessionAmbr",
                type: {
                    name: "Composite",
                    className: "Ambr"
                }
            },
            fiveQi: {
                constraints: {
                    InclusiveMaximum: 255,
                    InclusiveMinimum: 0
                },
                serializedName: "5qi",
                type: {
                    name: "Number"
                }
            },
            allocationAndRetentionPriorityLevel: {
                constraints: {
                    InclusiveMaximum: 15,
                    InclusiveMinimum: 1
                },
                serializedName: "allocationAndRetentionPriorityLevel",
                type: {
                    name: "Number"
                }
            },
            preemptionCapability: {
                serializedName: "preemptionCapability",
                type: {
                    name: "String"
                }
            },
            preemptionVulnerability: {
                serializedName: "preemptionVulnerability",
                type: {
                    name: "String"
                }
            },
            defaultSessionType: {
                serializedName: "defaultSessionType",
                type: {
                    name: "String"
                }
            },
            additionalAllowedSessionTypes: {
                constraints: {
                    MaxItems: 1
                },
                serializedName: "additionalAllowedSessionTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            allowedServices: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "allowedServices",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceResourceId"
                        }
                    }
                }
            },
            maximumNumberOfBufferedPackets: {
                defaultValue: 10,
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "maximumNumberOfBufferedPackets",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceResourceId = {
    type: {
        name: "Composite",
        className: "ServiceResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK][sS]\\/[^/?#]+\\/[sS][eE][rR][vV][iI][cC][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimPolicyListResult = {
    type: {
        name: "Composite",
        className: "SimPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteListResult = {
    type: {
        name: "Composite",
        className: "SiteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Site"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SiteDeletePacketCore = {
    type: {
        name: "Composite",
        className: "SiteDeletePacketCore",
        modelProperties: {
            packetCore: {
                serializedName: "packetCore",
                type: {
                    name: "Composite",
                    className: "PacketCoreControlPlaneResourceId"
                }
            }
        }
    }
};
const PacketCoreControlPlaneResourceId = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlaneResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[pP][aA][cC][kK][eE][tT][cC][oO][rR][eE][cC][oO][nN][tT][rR][oO][lL][pP][lL][aA][nN][eE][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Snssai = {
    type: {
        name: "Composite",
        className: "Snssai",
        modelProperties: {
            sst: {
                constraints: {
                    InclusiveMaximum: 255,
                    InclusiveMinimum: 0
                },
                serializedName: "sst",
                required: true,
                type: {
                    name: "Number"
                }
            },
            sd: {
                constraints: {
                    Pattern: new RegExp("^[A-Fa-f0-9]{6}$")
                },
                serializedName: "sd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SliceListResult = {
    type: {
        name: "Composite",
        className: "SliceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Slice"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SimGroupResourceId = {
    type: {
        name: "Composite",
        className: "SimGroupResourceId",
        modelProperties: {
            id: {
                constraints: {
                    Pattern: new RegExp("^\\/[sS][uU][bB][sS][cC][rR][iI][pP][tT][iI][oO][nN][sS]\\/[^/?#]+\\/[rR][eE][sS][oO][uU][rR][cC][eE][gG][rR][oO][uU][pP][sS]\\/[^/?#]+\\/[pP][rR][oO][vV][iI][dD][eE][rR][sS]\\/[mM][iI][cC][rR][oO][sS][oO][fF][tT]\\.[mM][oO][bB][iI][lL][eE][nN][eE][tT][wW][oO][rR][kK]\\/[sS][iI][mM][gG][rR][oO][uU][pP][sS]\\/[^/?#]+$")
                },
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Arp = {
    type: {
        name: "Composite",
        className: "Arp",
        modelProperties: {
            priorityLevel: {
                constraints: {
                    InclusiveMaximum: 15,
                    InclusiveMinimum: 1
                },
                serializedName: "priorityLevel",
                required: true,
                type: {
                    name: "Number"
                }
            },
            preemptCap: {
                serializedName: "preemptCap",
                required: true,
                type: {
                    name: "String"
                }
            },
            preemptVuln: {
                serializedName: "preemptVuln",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const PccRuleQosPolicy = {
    type: {
        name: "Composite",
        className: "PccRuleQosPolicy",
        modelProperties: Object.assign(Object.assign({}, QosPolicy.type.modelProperties), { guaranteedBitRate: {
                serializedName: "guaranteedBitRate",
                type: {
                    name: "Composite",
                    className: "Ambr"
                }
            } })
    }
};
const SimPropertiesFormat = {
    type: {
        name: "Composite",
        className: "SimPropertiesFormat",
        modelProperties: Object.assign(Object.assign({}, CommonSimPropertiesFormat.type.modelProperties), { authenticationKey: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "authenticationKey",
                type: {
                    name: "String"
                }
            }, operatorKeyCode: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "operatorKeyCode",
                type: {
                    name: "String"
                }
            } })
    }
};
const EncryptedSimPropertiesFormat = {
    type: {
        name: "Composite",
        className: "EncryptedSimPropertiesFormat",
        modelProperties: Object.assign(Object.assign({}, CommonSimPropertiesFormat.type.modelProperties), { encryptedCredentials: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]+$")
                },
                serializedName: "encryptedCredentials",
                type: {
                    name: "String"
                }
            } })
    }
};
const AttachedDataNetwork = {
    type: {
        name: "Composite",
        className: "AttachedDataNetwork",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, userPlaneDataInterface: {
                serializedName: "properties.userPlaneDataInterface",
                type: {
                    name: "Composite",
                    className: "InterfaceProperties"
                }
            }, dnsAddresses: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "properties.dnsAddresses",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }, naptConfiguration: {
                serializedName: "properties.naptConfiguration",
                type: {
                    name: "Composite",
                    className: "NaptConfiguration"
                }
            }, userEquipmentAddressPoolPrefix: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.userEquipmentAddressPoolPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }, userEquipmentStaticAddressPoolPrefix: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.userEquipmentStaticAddressPoolPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const DataNetwork = {
    type: {
        name: "Composite",
        className: "DataNetwork",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const MobileNetwork = {
    type: {
        name: "Composite",
        className: "MobileNetwork",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicLandMobileNetworkIdentifier: {
                serializedName: "properties.publicLandMobileNetworkIdentifier",
                type: {
                    name: "Composite",
                    className: "PlmnId"
                }
            }, serviceKey: {
                serializedName: "properties.serviceKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PacketCoreControlPlane = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlane",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, installation: {
                serializedName: "properties.installation",
                type: {
                    name: "Composite",
                    className: "Installation"
                }
            }, sites: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.sites",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SiteResourceId"
                        }
                    }
                }
            }, platform: {
                serializedName: "properties.platform",
                type: {
                    name: "Composite",
                    className: "PlatformConfiguration"
                }
            }, coreNetworkTechnology: {
                defaultValue: "5GC",
                serializedName: "properties.coreNetworkTechnology",
                type: {
                    name: "Enum",
                    allowedValues: ["5GC", "EPC", "EPC + 5GC"]
                }
            }, version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            }, installedVersion: {
                serializedName: "properties.installedVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rollbackVersion: {
                serializedName: "properties.rollbackVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, controlPlaneAccessInterface: {
                serializedName: "properties.controlPlaneAccessInterface",
                type: {
                    name: "Composite",
                    className: "InterfaceProperties"
                }
            }, controlPlaneAccessVirtualIpv4Addresses: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "properties.controlPlaneAccessVirtualIpv4Addresses",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sku: {
                serializedName: "properties.sku",
                required: true,
                type: {
                    name: "String"
                }
            }, ueMtu: {
                defaultValue: 1440,
                constraints: {
                    InclusiveMaximum: 1930,
                    InclusiveMinimum: 1280
                },
                serializedName: "properties.ueMtu",
                type: {
                    name: "Number"
                }
            }, localDiagnosticsAccess: {
                serializedName: "properties.localDiagnosticsAccess",
                type: {
                    name: "Composite",
                    className: "LocalDiagnosticsAccessConfiguration"
                }
            }, diagnosticsUpload: {
                serializedName: "properties.diagnosticsUpload",
                type: {
                    name: "Composite",
                    className: "DiagnosticsUploadConfiguration"
                }
            }, eventHub: {
                serializedName: "properties.eventHub",
                type: {
                    name: "Composite",
                    className: "EventHubConfiguration"
                }
            }, signaling: {
                serializedName: "properties.signaling",
                type: {
                    name: "Composite",
                    className: "SignalingConfiguration"
                }
            }, interopSettings: {
                serializedName: "properties.interopSettings",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            } })
    }
};
const PacketCoreDataPlane = {
    type: {
        name: "Composite",
        className: "PacketCoreDataPlane",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, userPlaneAccessInterface: {
                serializedName: "properties.userPlaneAccessInterface",
                type: {
                    name: "Composite",
                    className: "InterfaceProperties"
                }
            }, userPlaneAccessVirtualIpv4Addresses: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "properties.userPlaneAccessVirtualIpv4Addresses",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Service = {
    type: {
        name: "Composite",
        className: "Service",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, servicePrecedence: {
                constraints: {
                    InclusiveMaximum: 255,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.servicePrecedence",
                required: true,
                type: {
                    name: "Number"
                }
            }, serviceQosPolicy: {
                serializedName: "properties.serviceQosPolicy",
                type: {
                    name: "Composite",
                    className: "QosPolicy"
                }
            }, pccRules: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.pccRules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PccRuleConfiguration"
                        }
                    }
                }
            } })
    }
};
const SimGroup = {
    type: {
        name: "Composite",
        className: "SimGroup",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryptionKey: {
                serializedName: "properties.encryptionKey",
                type: {
                    name: "Composite",
                    className: "KeyVaultKey"
                }
            }, mobileNetwork: {
                serializedName: "properties.mobileNetwork",
                type: {
                    name: "Composite",
                    className: "MobileNetworkResourceId"
                }
            } })
    }
};
const SimPolicy = {
    type: {
        name: "Composite",
        className: "SimPolicy",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, siteProvisioningState: {
                serializedName: "properties.siteProvisioningState",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, ueAmbr: {
                serializedName: "properties.ueAmbr",
                type: {
                    name: "Composite",
                    className: "Ambr"
                }
            }, defaultSlice: {
                serializedName: "properties.defaultSlice",
                type: {
                    name: "Composite",
                    className: "SliceResourceId"
                }
            }, rfspIndex: {
                constraints: {
                    InclusiveMaximum: 256,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.rfspIndex",
                type: {
                    name: "Number"
                }
            }, registrationTimer: {
                defaultValue: 3240,
                constraints: {
                    InclusiveMinimum: 30
                },
                serializedName: "properties.registrationTimer",
                type: {
                    name: "Number"
                }
            }, sliceConfigurations: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.sliceConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SliceConfiguration"
                        }
                    }
                }
            } })
    }
};
const Site = {
    type: {
        name: "Composite",
        className: "Site",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, networkFunctions: {
                serializedName: "properties.networkFunctions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const Slice = {
    type: {
        name: "Composite",
        className: "Slice",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, snssai: {
                serializedName: "properties.snssai",
                type: {
                    name: "Composite",
                    className: "Snssai"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const DiagnosticsPackage = {
    type: {
        name: "Composite",
        className: "DiagnosticsPackage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, reason: {
                serializedName: "properties.reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PacketCapture = {
    type: {
        name: "Composite",
        className: "PacketCapture",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, reason: {
                serializedName: "properties.reason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, captureStartTime: {
                serializedName: "properties.captureStartTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, networkInterfaces: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            }, totalBytesPerSession: {
                defaultValue: 67108864,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 1000
                },
                serializedName: "properties.totalBytesPerSession",
                type: {
                    name: "Number"
                }
            }, timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 5
                },
                serializedName: "properties.timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            }, outputFiles: {
                serializedName: "properties.outputFiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const PacketCoreControlPlaneVersion = {
    type: {
        name: "Composite",
        className: "PacketCoreControlPlaneVersion",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, platforms: {
                serializedName: "properties.platforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Platform"
                        }
                    }
                }
            } })
    }
};
const Sim = {
    type: {
        name: "Composite",
        className: "Sim",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, simState: {
                serializedName: "properties.simState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, siteProvisioningState: {
                serializedName: "properties.siteProvisioningState",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, internationalMobileSubscriberIdentity: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{5,15}$")
                },
                serializedName: "properties.internationalMobileSubscriberIdentity",
                required: true,
                type: {
                    name: "String"
                }
            }, integratedCircuitCardIdentifier: {
                constraints: {
                    Pattern: new RegExp("^[0-9]{10,20}$")
                },
                serializedName: "properties.integratedCircuitCardIdentifier",
                type: {
                    name: "String"
                }
            }, deviceType: {
                serializedName: "properties.deviceType",
                type: {
                    name: "String"
                }
            }, simPolicy: {
                serializedName: "properties.simPolicy",
                type: {
                    name: "Composite",
                    className: "SimPolicyResourceId"
                }
            }, staticIpConfiguration: {
                constraints: {
                    MinItems: 1,
                    UniqueItems: true
                },
                serializedName: "properties.staticIpConfiguration",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SimStaticIpProperties"
                        }
                    }
                }
            }, vendorName: {
                serializedName: "properties.vendorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vendorKeyFingerprint: {
                serializedName: "properties.vendorKeyFingerprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authenticationKey: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "properties.authenticationKey",
                type: {
                    name: "String"
                }
            }, operatorKeyCode: {
                constraints: {
                    Pattern: new RegExp("^[0-9a-fA-F]{32}$")
                },
                serializedName: "properties.operatorKeyCode",
                type: {
                    name: "String"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Ambr: Ambr,
    Arp: Arp,
    AsyncOperationId: AsyncOperationId,
    AsyncOperationStatus: AsyncOperationStatus,
    AttachedDataNetwork: AttachedDataNetwork,
    AttachedDataNetworkListResult: AttachedDataNetworkListResult,
    AttachedDataNetworkResourceId: AttachedDataNetworkResourceId,
    AzureStackEdgeDeviceResourceId: AzureStackEdgeDeviceResourceId,
    AzureStackHCIClusterResourceId: AzureStackHCIClusterResourceId,
    CertificateProvisioning: CertificateProvisioning,
    CommonSimPropertiesFormat: CommonSimPropertiesFormat,
    ConnectedClusterResourceId: ConnectedClusterResourceId,
    CustomLocationResourceId: CustomLocationResourceId,
    DataNetwork: DataNetwork,
    DataNetworkConfiguration: DataNetworkConfiguration,
    DataNetworkListResult: DataNetworkListResult,
    DataNetworkResourceId: DataNetworkResourceId,
    DiagnosticsPackage: DiagnosticsPackage,
    DiagnosticsPackageListResult: DiagnosticsPackageListResult,
    DiagnosticsUploadConfiguration: DiagnosticsUploadConfiguration,
    EncryptedSimPropertiesFormat: EncryptedSimPropertiesFormat,
    EncryptedSimUploadList: EncryptedSimUploadList,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ErrorDetail: ErrorDetail,
    ErrorResponse: ErrorResponse,
    EventHubConfiguration: EventHubConfiguration,
    HttpsServerCertificate: HttpsServerCertificate,
    IdentityAndTagsObject: IdentityAndTagsObject,
    Installation: Installation,
    InterfaceProperties: InterfaceProperties,
    KeyVaultKey: KeyVaultKey,
    LocalDiagnosticsAccessConfiguration: LocalDiagnosticsAccessConfiguration,
    ManagedServiceIdentity: ManagedServiceIdentity,
    MobileNetwork: MobileNetwork,
    MobileNetworkListResult: MobileNetworkListResult,
    MobileNetworkResourceId: MobileNetworkResourceId,
    NASRerouteConfiguration: NASRerouteConfiguration,
    NaptConfiguration: NaptConfiguration,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationList: OperationList,
    PacketCapture: PacketCapture,
    PacketCaptureListResult: PacketCaptureListResult,
    PacketCoreControlPlane: PacketCoreControlPlane,
    PacketCoreControlPlaneCollectDiagnosticsPackage: PacketCoreControlPlaneCollectDiagnosticsPackage,
    PacketCoreControlPlaneListResult: PacketCoreControlPlaneListResult,
    PacketCoreControlPlaneResourceId: PacketCoreControlPlaneResourceId,
    PacketCoreControlPlaneVersion: PacketCoreControlPlaneVersion,
    PacketCoreControlPlaneVersionListResult: PacketCoreControlPlaneVersionListResult,
    PacketCoreDataPlane: PacketCoreDataPlane,
    PacketCoreDataPlaneListResult: PacketCoreDataPlaneListResult,
    PccRuleConfiguration: PccRuleConfiguration,
    PccRuleQosPolicy: PccRuleQosPolicy,
    PinholeTimeouts: PinholeTimeouts,
    Platform: Platform,
    PlatformConfiguration: PlatformConfiguration,
    PlmnId: PlmnId,
    PortRange: PortRange,
    PortReuseHoldTimes: PortReuseHoldTimes,
    ProxyResource: ProxyResource,
    QosPolicy: QosPolicy,
    Resource: Resource,
    Service: Service,
    ServiceDataFlowTemplate: ServiceDataFlowTemplate,
    ServiceListResult: ServiceListResult,
    ServiceResourceId: ServiceResourceId,
    SignalingConfiguration: SignalingConfiguration,
    Sim: Sim,
    SimDeleteList: SimDeleteList,
    SimGroup: SimGroup,
    SimGroupListResult: SimGroupListResult,
    SimGroupResourceId: SimGroupResourceId,
    SimListResult: SimListResult,
    SimNameAndEncryptedProperties: SimNameAndEncryptedProperties,
    SimNameAndProperties: SimNameAndProperties,
    SimPolicy: SimPolicy,
    SimPolicyListResult: SimPolicyListResult,
    SimPolicyResourceId: SimPolicyResourceId,
    SimPropertiesFormat: SimPropertiesFormat,
    SimStaticIpProperties: SimStaticIpProperties,
    SimStaticIpPropertiesStaticIp: SimStaticIpPropertiesStaticIp,
    SimUploadList: SimUploadList,
    Site: Site,
    SiteDeletePacketCore: SiteDeletePacketCore,
    SiteListResult: SiteListResult,
    SiteResourceId: SiteResourceId,
    Slice: Slice,
    SliceConfiguration: SliceConfiguration,
    SliceListResult: SliceListResult,
    SliceResourceId: SliceResourceId,
    Snssai: Snssai,
    SubResource: SubResource,
    SystemData: SystemData,
    TagsObject: TagsObject,
    TrackedResource: TrackedResource,
    UserAssignedIdentity: UserAssignedIdentity
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const packetCoreControlPlaneName = {
    parameterPath: "packetCoreControlPlaneName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "packetCoreControlPlaneName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const packetCoreDataPlaneName = {
    parameterPath: "packetCoreDataPlaneName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "packetCoreDataPlaneName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const attachedDataNetworkName = {
    parameterPath: "attachedDataNetworkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])*(\\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])*)*$"),
            MaxLength: 64
        },
        serializedName: "attachedDataNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-09-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: AttachedDataNetwork
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: TagsObject
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const mobileNetworkName = {
    parameterPath: "mobileNetworkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "mobileNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dataNetworkName = {
    parameterPath: "dataNetworkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])*(\\.[a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])*)*$"),
            MaxLength: 64
        },
        serializedName: "dataNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: DataNetwork
};
const diagnosticsPackageName = {
    parameterPath: "diagnosticsPackageName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "diagnosticsPackageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: MobileNetwork
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: PacketCapture
};
const packetCaptureName = {
    parameterPath: "packetCaptureName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "packetCaptureName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: PacketCoreControlPlane
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: IdentityAndTagsObject
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: PacketCoreControlPlaneCollectDiagnosticsPackage
};
const versionName = {
    parameterPath: "versionName",
    mapper: {
        serializedName: "versionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: PacketCoreDataPlane
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^(?!(default|requested|service)$)[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "serviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: Service
};
const simGroupName = {
    parameterPath: "simGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "simGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const simName = {
    parameterPath: "simName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "simName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: Sim
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: SimUploadList
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: SimDeleteList
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: EncryptedSimUploadList
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: SimGroup
};
const simPolicyName = {
    parameterPath: "simPolicyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "simPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: SimPolicy
};
const siteName = {
    parameterPath: "siteName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "siteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: Site
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: SiteDeletePacketCore
};
const sliceName = {
    parameterPath: "sliceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9][a-zA-Z0-9_-]*$"),
            MaxLength: 64
        },
        serializedName: "sliceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: Slice
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AttachedDataNetworks operations. */
class AttachedDataNetworksImpl {
    /**
     * Initialize a new instance of the class AttachedDataNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the attached data networks associated with a packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param options The options parameters.
     */
    listByPacketCoreDataPlane(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        const iter = this.listByPacketCoreDataPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPacketCoreDataPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options, settings);
            }
        };
    }
    listByPacketCoreDataPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreDataPlanePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreDataPlane(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreDataPlaneNext(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPacketCoreDataPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreDataPlanePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByPacketCoreDataPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified attached data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCoreDataPlaneName,
                    attachedDataNetworkName,
                    options
                },
                spec: deleteOperationSpec$c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified attached data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified attached data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param options The options parameters.
     */
    get(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            attachedDataNetworkName,
            options
        }, getOperationSpec$d);
    }
    /**
     * Creates or updates an attached data network. Must be created in the same location as its parent
     * packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param parameters Parameters supplied to the create or update attached data network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCoreDataPlaneName,
                    attachedDataNetworkName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an attached data network. Must be created in the same location as its parent
     * packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param parameters Parameters supplied to the create or update attached data network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an attached data network tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param attachedDataNetworkName The name of the attached data network.
     * @param parameters Parameters supplied to update attached data network tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, attachedDataNetworkName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            attachedDataNetworkName,
            parameters,
            options
        }, updateTagsOperationSpec$9);
    }
    /**
     * Gets all the attached data networks associated with a packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param options The options parameters.
     */
    _listByPacketCoreDataPlane(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            options
        }, listByPacketCoreDataPlaneOperationSpec);
    }
    /**
     * ListByPacketCoreDataPlaneNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param nextLink The nextLink from the previous successful call to the ListByPacketCoreDataPlane
     *                 method.
     * @param options The options parameters.
     */
    _listByPacketCoreDataPlaneNext(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            nextLink,
            options
        }, listByPacketCoreDataPlaneNextOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}/attachedDataNetworks/{attachedDataNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName,
        attachedDataNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}/attachedDataNetworks/{attachedDataNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AttachedDataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName,
        attachedDataNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}/attachedDataNetworks/{attachedDataNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AttachedDataNetwork
        },
        201: {
            bodyMapper: AttachedDataNetwork
        },
        202: {
            bodyMapper: AttachedDataNetwork
        },
        204: {
            bodyMapper: AttachedDataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName,
        attachedDataNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const updateTagsOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}/attachedDataNetworks/{attachedDataNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AttachedDataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName,
        attachedDataNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listByPacketCoreDataPlaneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}/attachedDataNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AttachedDataNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByPacketCoreDataPlaneNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AttachedDataNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DataNetworks operations. */
class DataNetworksImpl {
    /**
     * Initialize a new instance of the class DataNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all data networks in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        const iter = this.listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings);
            }
        };
    }
    listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByMobileNetwork(resourceGroupName, mobileNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByMobileNetworkNext(resourceGroupName, mobileNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, dataNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, dataNetworkName, options },
                spec: deleteOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, dataNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, dataNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified data network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, dataNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, dataNetworkName, options }, getOperationSpec$c);
    }
    /**
     * Creates or updates a data network. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param parameters Parameters supplied to the create or update data network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, dataNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    dataNetworkName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a data network. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param parameters Parameters supplied to the create or update data network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, dataNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, dataNetworkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates data network tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param dataNetworkName The name of the data network.
     * @param parameters Parameters supplied to update data network tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, dataNetworkName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            mobileNetworkName,
            dataNetworkName,
            parameters,
            options
        }, updateTagsOperationSpec$8);
    }
    /**
     * Lists all data networks in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    _listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, listByMobileNetworkOperationSpec$4);
    }
    /**
     * ListByMobileNetworkNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param nextLink The nextLink from the previous successful call to the ListByMobileNetwork method.
     * @param options The options parameters.
     */
    _listByMobileNetworkNext(resourceGroupName, mobileNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, nextLink, options }, listByMobileNetworkNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/dataNetworks/{dataNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        dataNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/dataNetworks/{dataNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        dataNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/dataNetworks/{dataNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DataNetwork
        },
        201: {
            bodyMapper: DataNetwork
        },
        202: {
            bodyMapper: DataNetwork
        },
        204: {
            bodyMapper: DataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        dataNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const updateTagsOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/dataNetworks/{dataNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DataNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        dataNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const listByMobileNetworkOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/dataNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByMobileNetworkNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DataNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DiagnosticsPackages operations. */
class DiagnosticsPackagesImpl {
    /**
     * Initialize a new instance of the class DiagnosticsPackages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the diagnostics packages under a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        const iter = this.listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings);
            }
        };
    }
    listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a diagnostics package.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param diagnosticsPackageName The name of the diagnostics package.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    diagnosticsPackageName,
                    options
                },
                spec: createOrUpdateOperationSpec$a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a diagnostics package.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param diagnosticsPackageName The name of the diagnostics package.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified diagnostics package.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param diagnosticsPackageName The name of the diagnostics package.
     * @param options The options parameters.
     */
    get(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            diagnosticsPackageName,
            options
        }, getOperationSpec$b);
    }
    /**
     * Deletes the specified diagnostics package.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param diagnosticsPackageName The name of the diagnostics package.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    diagnosticsPackageName,
                    options
                },
                spec: deleteOperationSpec$a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified diagnostics package.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param diagnosticsPackageName The name of the diagnostics package.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, packetCoreControlPlaneName, diagnosticsPackageName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the diagnostics packages under a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, options }, listByPacketCoreControlPlaneOperationSpec$2);
    }
    /**
     * ListByPacketCoreControlPlaneNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param nextLink The nextLink from the previous successful call to the ListByPacketCoreControlPlane
     *                 method.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, nextLink, options }, listByPacketCoreControlPlaneNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/diagnosticsPackages/{diagnosticsPackageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DiagnosticsPackage
        },
        201: {
            bodyMapper: DiagnosticsPackage
        },
        202: {
            bodyMapper: DiagnosticsPackage
        },
        204: {
            bodyMapper: DiagnosticsPackage
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        diagnosticsPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/diagnosticsPackages/{diagnosticsPackageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsPackage
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        diagnosticsPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/diagnosticsPackages/{diagnosticsPackageName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        diagnosticsPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByPacketCoreControlPlaneOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/diagnosticsPackages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsPackageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByPacketCoreControlPlaneNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DiagnosticsPackageListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing MobileNetworks operations. */
class MobileNetworksImpl {
    /**
     * Initialize a new instance of the class MobileNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the mobile networks in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the mobile networks in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, options },
                spec: deleteOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, getOperationSpec$a);
    }
    /**
     * Creates or updates a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param parameters Parameters supplied to the create or update mobile network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, parameters, options },
                spec: createOrUpdateOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param parameters Parameters supplied to the create or update mobile network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates mobile network tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param parameters Parameters supplied to update mobile network tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, parameters, options }, updateTagsOperationSpec$7);
    }
    /**
     * Lists all the mobile networks in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * Lists all the mobile networks in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MobileNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: MobileNetwork
        },
        201: {
            bodyMapper: MobileNetwork
        },
        202: {
            bodyMapper: MobileNetwork
        },
        204: {
            bodyMapper: MobileNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const updateTagsOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: MobileNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MobileNetwork/mobileNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MobileNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MobileNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MobileNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: MobileNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of the operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of the operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.MobileNetwork/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCaptures operations. */
class PacketCapturesImpl {
    /**
     * Initialize a new instance of the class PacketCaptures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the packet capture sessions under a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        const iter = this.listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings);
            }
        };
    }
    listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a packet capture.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters supplied to the create or update packet capture operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCaptureName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a packet capture.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters supplied to the create or update packet capture operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified packet capture session.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    get(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCaptureName,
            options
        }, getOperationSpec$9);
    }
    /**
     * Deletes the specified packet capture.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCaptureName,
                    options
                },
                spec: deleteOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified packet capture.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop a packet capture session.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCaptureName,
                    options
                },
                spec: stopOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stop a packet capture session.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, packetCoreControlPlaneName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the packet capture sessions under a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, options }, listByPacketCoreControlPlaneOperationSpec$1);
    }
    /**
     * ListByPacketCoreControlPlaneNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param nextLink The nextLink from the previous successful call to the ListByPacketCoreControlPlane
     *                 method.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, nextLink, options }, listByPacketCoreControlPlaneNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCaptures/{packetCaptureName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PacketCapture
        },
        201: {
            bodyMapper: PacketCapture
        },
        202: {
            bodyMapper: PacketCapture
        },
        204: {
            bodyMapper: PacketCapture
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCaptureName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCaptures/{packetCaptureName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCapture
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCaptures/{packetCaptureName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCaptures/{packetCaptureName}/stop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByPacketCoreControlPlaneOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCaptures",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByPacketCoreControlPlaneNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCoreControlPlanes operations. */
class PacketCoreControlPlanesImpl {
    /**
     * Initialize a new instance of the class PacketCoreControlPlanes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the packet core control planes in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the packet core control planes in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, packetCoreControlPlaneName, options },
                spec: deleteOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, packetCoreControlPlaneName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    get(resourceGroupName, packetCoreControlPlaneName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, options }, getOperationSpec$8);
    }
    /**
     * Creates or updates a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param parameters Parameters supplied to the create or update packet core control plane operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param parameters Parameters supplied to the create or update packet core control plane operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, packetCoreControlPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch packet core control plane resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param parameters Parameters supplied to patch packet core control plane resource.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, packetCoreControlPlaneName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, parameters, options }, updateTagsOperationSpec$6);
    }
    /**
     * Lists all the packet core control planes in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Lists all the packet core control planes in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Roll back the specified packet core control plane to the previous version, "rollbackVersion".
     * Multiple consecutive rollbacks are not possible. This action may cause a service outage.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginRollback(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, packetCoreControlPlaneName, options },
                spec: rollbackOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Roll back the specified packet core control plane to the previous version, "rollbackVersion".
     * Multiple consecutive rollbacks are not possible. This action may cause a service outage.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginRollbackAndWait(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRollback(resourceGroupName, packetCoreControlPlaneName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reinstall the specified packet core control plane. This action will remove any transaction state
     * from the packet core to return it to a known state. This action will cause a service outage.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginReinstall(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, packetCoreControlPlaneName, options },
                spec: reinstallOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Reinstall the specified packet core control plane. This action will remove any transaction state
     * from the packet core to return it to a known state. This action will cause a service outage.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    beginReinstallAndWait(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReinstall(resourceGroupName, packetCoreControlPlaneName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Collect a diagnostics package for the specified packet core control plane. This action will upload
     * the diagnostics to a storage account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param parameters Parameters supplied to the packet core control plane collect diagnostics package
     *                   operation.
     * @param options The options parameters.
     */
    beginCollectDiagnosticsPackage(resourceGroupName, packetCoreControlPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    parameters,
                    options
                },
                spec: collectDiagnosticsPackageOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Collect a diagnostics package for the specified packet core control plane. This action will upload
     * the diagnostics to a storage account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param parameters Parameters supplied to the packet core control plane collect diagnostics package
     *                   operation.
     * @param options The options parameters.
     */
    beginCollectDiagnosticsPackageAndWait(resourceGroupName, packetCoreControlPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCollectDiagnosticsPackage(resourceGroupName, packetCoreControlPlaneName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlane
        },
        201: {
            bodyMapper: PacketCoreControlPlane
        },
        202: {
            bodyMapper: PacketCoreControlPlane
        },
        204: {
            bodyMapper: PacketCoreControlPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const updateTagsOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const rollbackOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/rollback",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const reinstallOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/reinstall",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const collectDiagnosticsPackageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/collectDiagnosticsPackage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCoreControlPlaneVersions operations. */
class PacketCoreControlPlaneVersionsImpl {
    /**
     * Initialize a new instance of the class PacketCoreControlPlaneVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all supported packet core control planes versions.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all supported packet core control planes versions.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets information about the specified packet core control plane version.
     * @param versionName The name of the packet core control plane version.
     * @param options The options parameters.
     */
    get(versionName, options) {
        return this.client.sendOperationRequest({ versionName, options }, getOperationSpec$7);
    }
    /**
     * Lists all supported packet core control planes versions.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Gets information about the specified packet core control plane version.
     * @param versionName The name of the packet core control plane version.
     * @param options The options parameters.
     */
    getBySubscription(versionName, options) {
        return this.client.sendOperationRequest({ versionName, options }, getBySubscriptionOperationSpec);
    }
    /**
     * Lists all supported packet core control planes versions.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/providers/Microsoft.MobileNetwork/packetCoreControlPlaneVersions/{versionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, versionName],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec = {
    path: "/providers/Microsoft.MobileNetwork/packetCoreControlPlaneVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$7
};
const getBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MobileNetwork/packetCoreControlPlaneVersions/{versionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersion
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        versionName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MobileNetwork/packetCoreControlPlaneVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreControlPlaneVersionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCoreDataPlanes operations. */
class PacketCoreDataPlanesImpl {
    /**
     * Initialize a new instance of the class PacketCoreDataPlanes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the packet core data planes associated with a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        const iter = this.listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings);
            }
        };
    }
    listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByPacketCoreControlPlanePagingAll(resourceGroupName, packetCoreControlPlaneName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByPacketCoreControlPlanePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByPacketCoreControlPlanePagingPage(resourceGroupName, packetCoreControlPlaneName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCoreDataPlaneName,
                    options
                },
                spec: deleteOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified packet core data plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param options The options parameters.
     */
    get(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            options
        }, getOperationSpec$6);
    }
    /**
     * Creates or updates a packet core data plane. Must be created in the same location as its parent
     * packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param parameters Parameters supplied to the create or update packet core data plane operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    packetCoreControlPlaneName,
                    packetCoreDataPlaneName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a packet core data plane. Must be created in the same location as its parent
     * packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param parameters Parameters supplied to the create or update packet core data plane operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates packet core data planes tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param packetCoreDataPlaneName The name of the packet core data plane.
     * @param parameters Parameters supplied to update packet core data plane tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, packetCoreControlPlaneName, packetCoreDataPlaneName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            packetCoreControlPlaneName,
            packetCoreDataPlaneName,
            parameters,
            options
        }, updateTagsOperationSpec$5);
    }
    /**
     * Lists all the packet core data planes associated with a packet core control plane.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlane(resourceGroupName, packetCoreControlPlaneName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, options }, listByPacketCoreControlPlaneOperationSpec);
    }
    /**
     * ListByPacketCoreControlPlaneNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param packetCoreControlPlaneName The name of the packet core control plane.
     * @param nextLink The nextLink from the previous successful call to the ListByPacketCoreControlPlane
     *                 method.
     * @param options The options parameters.
     */
    _listByPacketCoreControlPlaneNext(resourceGroupName, packetCoreControlPlaneName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, packetCoreControlPlaneName, nextLink, options }, listByPacketCoreControlPlaneNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreDataPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PacketCoreDataPlane
        },
        201: {
            bodyMapper: PacketCoreDataPlane
        },
        202: {
            bodyMapper: PacketCoreDataPlane
        },
        204: {
            bodyMapper: PacketCoreDataPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateTagsOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes/{packetCoreDataPlaneName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PacketCoreDataPlane
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        packetCoreDataPlaneName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listByPacketCoreControlPlaneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/packetCoreControlPlanes/{packetCoreControlPlaneName}/packetCoreDataPlanes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreDataPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByPacketCoreControlPlaneNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCoreDataPlaneListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        packetCoreControlPlaneName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Services operations. */
class ServicesImpl {
    /**
     * Initialize a new instance of the class Services class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the services in a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        const iter = this.listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings);
            }
        };
    }
    listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByMobileNetwork(resourceGroupName, mobileNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByMobileNetworkNext(resourceGroupName, mobileNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, serviceName, options },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified service.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, serviceName, options }, getOperationSpec$5);
    }
    /**
     * Creates or updates a service. Must be created in the same location as its parent mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param parameters Parameters supplied to the create or update service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    serviceName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a service. Must be created in the same location as its parent mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param parameters Parameters supplied to the create or update service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates service tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param serviceName The name of the service. You must not use any of the following reserved strings -
     *                    `default`, `requested` or `service`
     * @param parameters Parameters supplied to update service tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, serviceName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            mobileNetworkName,
            serviceName,
            parameters,
            options
        }, updateTagsOperationSpec$4);
    }
    /**
     * Gets all the services in a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    _listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, listByMobileNetworkOperationSpec$3);
    }
    /**
     * ListByMobileNetworkNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param nextLink The nextLink from the previous successful call to the ListByMobileNetwork method.
     * @param options The options parameters.
     */
    _listByMobileNetworkNext(resourceGroupName, mobileNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, nextLink, options }, listByMobileNetworkNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/services/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/services/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Service
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/services/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Service
        },
        201: {
            bodyMapper: Service
        },
        202: {
            bodyMapper: Service
        },
        204: {
            bodyMapper: Service
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const updateTagsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/services/{serviceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Service
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listByMobileNetworkOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/services",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByMobileNetworkNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Sims operations. */
class SimsImpl {
    /**
     * Initialize a new instance of the class Sims class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the SIMs in a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param options The options parameters.
     */
    listByGroup(resourceGroupName, simGroupName, options) {
        const iter = this.listByGroupPagingAll(resourceGroupName, simGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByGroupPagingPage(resourceGroupName, simGroupName, options, settings);
            }
        };
    }
    listByGroupPagingPage(resourceGroupName, simGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByGroup(resourceGroupName, simGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByGroupNext(resourceGroupName, simGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByGroupPagingAll(resourceGroupName, simGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByGroupPagingPage(resourceGroupName, simGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified SIM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param simName The name of the SIM.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, simGroupName, simName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, simName, options },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified SIM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param simName The name of the SIM.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, simGroupName, simName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, simGroupName, simName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified SIM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param simName The name of the SIM.
     * @param options The options parameters.
     */
    get(resourceGroupName, simGroupName, simName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, simGroupName, simName, options }, getOperationSpec$4);
    }
    /**
     * Creates or updates a SIM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param simName The name of the SIM.
     * @param parameters Parameters supplied to the create or update SIM operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, simGroupName, simName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, simName, parameters, options },
                spec: createOrUpdateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a SIM.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param simName The name of the SIM.
     * @param parameters Parameters supplied to the create or update SIM operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, simGroupName, simName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, simGroupName, simName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the SIMs in a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param options The options parameters.
     */
    _listByGroup(resourceGroupName, simGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, simGroupName, options }, listByGroupOperationSpec);
    }
    /**
     * Bulk upload SIMs to a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the bulk SIM upload operation.
     * @param options The options parameters.
     */
    beginBulkUpload(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, parameters, options },
                spec: bulkUploadOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Bulk upload SIMs to a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the bulk SIM upload operation.
     * @param options The options parameters.
     */
    beginBulkUploadAndWait(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBulkUpload(resourceGroupName, simGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Bulk delete SIMs from a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the bulk SIM delete operation.
     * @param options The options parameters.
     */
    beginBulkDelete(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, parameters, options },
                spec: bulkDeleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Bulk delete SIMs from a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the bulk SIM delete operation.
     * @param options The options parameters.
     */
    beginBulkDeleteAndWait(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBulkDelete(resourceGroupName, simGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Bulk upload SIMs in encrypted form to a SIM group. The SIM credentials must be encrypted.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the encrypted SIMs upload operation.
     * @param options The options parameters.
     */
    beginBulkUploadEncrypted(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, parameters, options },
                spec: bulkUploadEncryptedOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Bulk upload SIMs in encrypted form to a SIM group. The SIM credentials must be encrypted.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the encrypted SIMs upload operation.
     * @param options The options parameters.
     */
    beginBulkUploadEncryptedAndWait(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBulkUploadEncrypted(resourceGroupName, simGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param nextLink The nextLink from the previous successful call to the ListByGroup method.
     * @param options The options parameters.
     */
    _listByGroupNext(resourceGroupName, simGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, simGroupName, nextLink, options }, listByGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/sims/{simName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName,
        simName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/sims/{simName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Sim
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName,
        simName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/sims/{simName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Sim
        },
        201: {
            bodyMapper: Sim
        },
        202: {
            bodyMapper: Sim
        },
        204: {
            bodyMapper: Sim
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName,
        simName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listByGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/sims",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const bulkUploadOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/uploadSims",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const bulkDeleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/deleteSims",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const bulkUploadEncryptedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}/uploadEncryptedSims",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AsyncOperationStatus
        },
        201: {
            bodyMapper: AsyncOperationStatus
        },
        202: {
            bodyMapper: AsyncOperationStatus
        },
        204: {
            bodyMapper: AsyncOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listByGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        simGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SimGroups operations. */
class SimGroupsImpl {
    /**
     * Initialize a new instance of the class SimGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the SIM groups in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the SIM groups in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, simGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, simGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, simGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param options The options parameters.
     */
    get(resourceGroupName, simGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, simGroupName, options }, getOperationSpec$3);
    }
    /**
     * Creates or updates a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the create or update SIM group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, simGroupName, parameters, options },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a SIM group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to the create or update SIM group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, simGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, simGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch SIM group resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param simGroupName The name of the SIM Group.
     * @param parameters Parameters supplied to patch SIM group resource.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, simGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, simGroupName, parameters, options }, updateTagsOperationSpec$3);
    }
    /**
     * Gets all the SIM groups in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Gets all the SIM groups in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SimGroup
        },
        201: {
            bodyMapper: SimGroup
        },
        202: {
            bodyMapper: SimGroup
        },
        204: {
            bodyMapper: SimGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateTagsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups/{simGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SimGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        simGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.MobileNetwork/simGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/simGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimGroupListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SimPolicies operations. */
class SimPoliciesImpl {
    /**
     * Initialize a new instance of the class SimPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the SIM policies in a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        const iter = this.listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings);
            }
        };
    }
    listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByMobileNetwork(resourceGroupName, mobileNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByMobileNetworkNext(resourceGroupName, mobileNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified SIM policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, simPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, simPolicyName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified SIM policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, simPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, simPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified SIM policy.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, simPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, simPolicyName, options }, getOperationSpec$2);
    }
    /**
     * Creates or updates a SIM policy. Must be created in the same location as its parent mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param parameters Parameters supplied to the create or update SIM policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, simPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    simPolicyName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a SIM policy. Must be created in the same location as its parent mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param parameters Parameters supplied to the create or update SIM policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, simPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, simPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates SIM policy tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param simPolicyName The name of the SIM policy.
     * @param parameters Parameters supplied to update SIM policy tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, simPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            mobileNetworkName,
            simPolicyName,
            parameters,
            options
        }, updateTagsOperationSpec$2);
    }
    /**
     * Gets all the SIM policies in a mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    _listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, listByMobileNetworkOperationSpec$2);
    }
    /**
     * ListByMobileNetworkNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param nextLink The nextLink from the previous successful call to the ListByMobileNetwork method.
     * @param options The options parameters.
     */
    _listByMobileNetworkNext(resourceGroupName, mobileNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, nextLink, options }, listByMobileNetworkNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/simPolicies/{simPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        simPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/simPolicies/{simPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        simPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/simPolicies/{simPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SimPolicy
        },
        201: {
            bodyMapper: SimPolicy
        },
        202: {
            bodyMapper: SimPolicy
        },
        204: {
            bodyMapper: SimPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        simPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const updateTagsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/simPolicies/{simPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SimPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        simPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listByMobileNetworkOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/simPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimPolicyListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByMobileNetworkNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SimPolicyListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Sites operations. */
class SitesImpl {
    /**
     * Initialize a new instance of the class Sites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all sites in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        const iter = this.listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings);
            }
        };
    }
    listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByMobileNetwork(resourceGroupName, mobileNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByMobileNetworkNext(resourceGroupName, mobileNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified mobile network site. This will also delete any network functions that are a
     * part of this site.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, siteName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified mobile network site. This will also delete any network functions that are a
     * part of this site.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, siteName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified mobile network site.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, siteName, options }, getOperationSpec$1);
    }
    /**
     * Creates or updates a mobile network site. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param parameters Parameters supplied to the create or update mobile network site operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    siteName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a mobile network site. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param parameters Parameters supplied to the create or update mobile network site operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, siteName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates site tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param parameters Parameters supplied to update network site tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, siteName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, siteName, parameters, options }, updateTagsOperationSpec$1);
    }
    /**
     * Lists all sites in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    _listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, listByMobileNetworkOperationSpec$1);
    }
    /**
     * Deletes a packet core under the specified mobile network site.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param parameters Parameters supplied to delete a packet core under a site.
     * @param options The options parameters.
     */
    beginDeletePacketCore(resourceGroupName, mobileNetworkName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    siteName,
                    parameters,
                    options
                },
                spec: deletePacketCoreOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a packet core under the specified mobile network site.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param siteName The name of the mobile network site.
     * @param parameters Parameters supplied to delete a packet core under a site.
     * @param options The options parameters.
     */
    beginDeletePacketCoreAndWait(resourceGroupName, mobileNetworkName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePacketCore(resourceGroupName, mobileNetworkName, siteName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByMobileNetworkNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param nextLink The nextLink from the previous successful call to the ListByMobileNetwork method.
     * @param options The options parameters.
     */
    _listByMobileNetworkNext(resourceGroupName, mobileNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, nextLink, options }, listByMobileNetworkNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites/{siteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites/{siteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites/{siteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Site
        },
        201: {
            bodyMapper: Site
        },
        202: {
            bodyMapper: Site
        },
        204: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        siteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const updateTagsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites/{siteName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Site
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        siteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByMobileNetworkOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deletePacketCoreOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/sites/{siteName}/deletePacketCore",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        siteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByMobileNetworkNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SiteListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Slices operations. */
class SlicesImpl {
    /**
     * Initialize a new instance of the class Slices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all slices in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        const iter = this.listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings);
            }
        };
    }
    listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByMobileNetwork(resourceGroupName, mobileNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByMobileNetworkNext(resourceGroupName, mobileNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByMobileNetworkPagingAll(resourceGroupName, mobileNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByMobileNetworkPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByMobileNetworkPagingPage(resourceGroupName, mobileNetworkName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified network slice.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, mobileNetworkName, sliceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, mobileNetworkName, sliceName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network slice.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, mobileNetworkName, sliceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, mobileNetworkName, sliceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified network slice.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param options The options parameters.
     */
    get(resourceGroupName, mobileNetworkName, sliceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, sliceName, options }, getOperationSpec);
    }
    /**
     * Creates or updates a network slice. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param parameters Parameters supplied to the create or update network slice operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, mobileNetworkName, sliceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    mobileNetworkName,
                    sliceName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a network slice. Must be created in the same location as its parent mobile
     * network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param parameters Parameters supplied to the create or update network slice operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, mobileNetworkName, sliceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, mobileNetworkName, sliceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates slice tags.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param sliceName The name of the network slice.
     * @param parameters Parameters supplied to update network slice tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, mobileNetworkName, sliceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, sliceName, parameters, options }, updateTagsOperationSpec);
    }
    /**
     * Lists all slices in the mobile network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param options The options parameters.
     */
    _listByMobileNetwork(resourceGroupName, mobileNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, options }, listByMobileNetworkOperationSpec);
    }
    /**
     * ListByMobileNetworkNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param mobileNetworkName The name of the mobile network.
     * @param nextLink The nextLink from the previous successful call to the ListByMobileNetwork method.
     * @param options The options parameters.
     */
    _listByMobileNetworkNext(resourceGroupName, mobileNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, mobileNetworkName, nextLink, options }, listByMobileNetworkNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/slices/{sliceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        sliceName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/slices/{sliceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Slice
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        sliceName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/slices/{sliceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Slice
        },
        201: {
            bodyMapper: Slice
        },
        202: {
            bodyMapper: Slice
        },
        204: {
            bodyMapper: Slice
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        sliceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/slices/{sliceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Slice
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName,
        sliceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listByMobileNetworkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.MobileNetwork/mobileNetworks/{mobileNetworkName}/slices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SliceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer
};
const listByMobileNetworkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SliceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        mobileNetworkName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class MobileNetworkManagementClient extends coreClient__namespace.ServiceClient {
    constructor(credentials, subscriptionIdOrOptions, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        let subscriptionId;
        if (typeof subscriptionIdOrOptions === "string") {
            subscriptionId = subscriptionIdOrOptions;
        }
        else if (typeof subscriptionIdOrOptions === "object") {
            options = subscriptionIdOrOptions;
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-mobilenetwork/4.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-09-01";
        this.attachedDataNetworks = new AttachedDataNetworksImpl(this);
        this.dataNetworks = new DataNetworksImpl(this);
        this.diagnosticsPackages = new DiagnosticsPackagesImpl(this);
        this.mobileNetworks = new MobileNetworksImpl(this);
        this.operations = new OperationsImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.packetCoreControlPlanes = new PacketCoreControlPlanesImpl(this);
        this.packetCoreControlPlaneVersions = new PacketCoreControlPlaneVersionsImpl(this);
        this.packetCoreDataPlanes = new PacketCoreDataPlanesImpl(this);
        this.services = new ServicesImpl(this);
        this.sims = new SimsImpl(this);
        this.simGroups = new SimGroupsImpl(this);
        this.simPolicies = new SimPoliciesImpl(this);
        this.sites = new SitesImpl(this);
        this.slices = new SlicesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.MobileNetworkManagementClient = MobileNetworkManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
