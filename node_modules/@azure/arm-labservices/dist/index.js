'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link Origin} that the service accepts. */
exports.KnownOrigin = void 0;
(function (KnownOrigin) {
    /** User */
    KnownOrigin["User"] = "user";
    /** System */
    KnownOrigin["System"] = "system";
    /** UserSystem */
    KnownOrigin["UserSystem"] = "user,system";
})(exports.KnownOrigin || (exports.KnownOrigin = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    /** Internal */
    KnownActionType["Internal"] = "Internal";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link LabServicesSkuTier} that the service accepts. */
exports.KnownLabServicesSkuTier = void 0;
(function (KnownLabServicesSkuTier) {
    /** Standard */
    KnownLabServicesSkuTier["Standard"] = "Standard";
    /** Premium */
    KnownLabServicesSkuTier["Premium"] = "Premium";
})(exports.KnownLabServicesSkuTier || (exports.KnownLabServicesSkuTier = {}));
/** Known values of {@link ScaleType} that the service accepts. */
exports.KnownScaleType = void 0;
(function (KnownScaleType) {
    /** The capacity is not adjustable in any way. */
    KnownScaleType["None"] = "None";
    /** The user must manually scale this SKU in and out. */
    KnownScaleType["Manual"] = "Manual";
    /** The user is permitted to scale this SKU in and out. */
    KnownScaleType["Automatic"] = "Automatic";
})(exports.KnownScaleType || (exports.KnownScaleType = {}));
/** Known values of {@link RestrictionType} that the service accepts. */
exports.KnownRestrictionType = void 0;
(function (KnownRestrictionType) {
    /** Location */
    KnownRestrictionType["Location"] = "Location";
})(exports.KnownRestrictionType || (exports.KnownRestrictionType = {}));
/** Known values of {@link RestrictionReasonCode} that the service accepts. */
exports.KnownRestrictionReasonCode = void 0;
(function (KnownRestrictionReasonCode) {
    /** QuotaId */
    KnownRestrictionReasonCode["QuotaId"] = "QuotaId";
    /** NotAvailableForSubscription */
    KnownRestrictionReasonCode["NotAvailableForSubscription"] = "NotAvailableForSubscription";
})(exports.KnownRestrictionReasonCode || (exports.KnownRestrictionReasonCode = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
exports.KnownUsageUnit = void 0;
(function (KnownUsageUnit) {
    /** Count */
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const PagedImages = {
    type: {
        name: "Composite",
        className: "PagedImages",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Image"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ImageUpdateProperties = {
    type: {
        name: "Composite",
        className: "ImageUpdateProperties",
        modelProperties: {
            enabledState: {
                serializedName: "enabledState",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ImageUpdate = {
    type: {
        name: "Composite",
        className: "ImageUpdate",
        modelProperties: {
            enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }
        }
    }
};
const PagedLabPlans = {
    type: {
        name: "Composite",
        className: "PagedLabPlans",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabPlan"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabPlanUpdateProperties = {
    type: {
        name: "Composite",
        className: "LabPlanUpdateProperties",
        modelProperties: {
            defaultConnectionProfile: {
                serializedName: "defaultConnectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            },
            defaultAutoShutdownProfile: {
                serializedName: "defaultAutoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            },
            defaultNetworkProfile: {
                serializedName: "defaultNetworkProfile",
                type: {
                    name: "Composite",
                    className: "LabPlanNetworkProfile"
                }
            },
            allowedRegions: {
                serializedName: "allowedRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sharedGalleryId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "sharedGalleryId",
                type: {
                    name: "String"
                }
            },
            supportInfo: {
                serializedName: "supportInfo",
                type: {
                    name: "Composite",
                    className: "SupportInfo"
                }
            },
            linkedLmsInstance: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "linkedLmsInstance",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionProfile = {
    type: {
        name: "Composite",
        className: "ConnectionProfile",
        modelProperties: {
            webSshAccess: {
                serializedName: "webSshAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Public", "Private", "None"]
                }
            },
            webRdpAccess: {
                serializedName: "webRdpAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Public", "Private", "None"]
                }
            },
            clientSshAccess: {
                serializedName: "clientSshAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Public", "Private", "None"]
                }
            },
            clientRdpAccess: {
                serializedName: "clientRdpAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Public", "Private", "None"]
                }
            }
        }
    }
};
const AutoShutdownProfile = {
    type: {
        name: "Composite",
        className: "AutoShutdownProfile",
        modelProperties: {
            shutdownOnDisconnect: {
                serializedName: "shutdownOnDisconnect",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            },
            shutdownWhenNotConnected: {
                serializedName: "shutdownWhenNotConnected",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            },
            shutdownOnIdle: {
                serializedName: "shutdownOnIdle",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "UserAbsence", "LowUsage"]
                }
            },
            disconnectDelay: {
                serializedName: "disconnectDelay",
                type: {
                    name: "TimeSpan"
                }
            },
            noConnectDelay: {
                serializedName: "noConnectDelay",
                type: {
                    name: "TimeSpan"
                }
            },
            idleDelay: {
                serializedName: "idleDelay",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const LabPlanNetworkProfile = {
    type: {
        name: "Composite",
        className: "LabPlanNetworkProfile",
        modelProperties: {
            subnetId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SupportInfo = {
    type: {
        name: "Composite",
        className: "SupportInfo",
        modelProperties: {
            url: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 6
                },
                serializedName: "email",
                type: {
                    name: "String"
                }
            },
            phone: {
                constraints: {
                    MaxLength: 31,
                    MinLength: 1
                },
                serializedName: "phone",
                type: {
                    name: "String"
                }
            },
            instructions: {
                serializedName: "instructions",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Identity = {
    type: {
        name: "Composite",
        className: "Identity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "SystemAssigned",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrackedResourceUpdate = {
    type: {
        name: "Composite",
        className: "TrackedResourceUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SaveImageBody = {
    type: {
        name: "Composite",
        className: "SaveImageBody",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            labVirtualMachineId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "labVirtualMachineId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            actionType: {
                serializedName: "actionType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PagedLabs = {
    type: {
        name: "Composite",
        className: "PagedLabs",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Lab"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabNetworkProfile = {
    type: {
        name: "Composite",
        className: "LabNetworkProfile",
        modelProperties: {
            subnetId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "subnetId",
                type: {
                    name: "String"
                }
            },
            loadBalancerId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "loadBalancerId",
                type: {
                    name: "String"
                }
            },
            publicIpId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "publicIpId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabUpdateProperties = {
    type: {
        name: "Composite",
        className: "LabUpdateProperties",
        modelProperties: {
            autoShutdownProfile: {
                serializedName: "autoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            },
            connectionProfile: {
                serializedName: "connectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            },
            virtualMachineProfile: {
                serializedName: "virtualMachineProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineProfile"
                }
            },
            securityProfile: {
                serializedName: "securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            },
            rosterProfile: {
                serializedName: "rosterProfile",
                type: {
                    name: "Composite",
                    className: "RosterProfile"
                }
            },
            labPlanId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "labPlanId",
                type: {
                    name: "String"
                }
            },
            title: {
                constraints: {
                    MaxLength: 120,
                    MinLength: 1
                },
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineProfile",
        modelProperties: {
            createOption: {
                serializedName: "createOption",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Image", "TemplateVM"]
                }
            },
            imageReference: {
                serializedName: "imageReference",
                type: {
                    name: "Composite",
                    className: "ImageReference"
                }
            },
            osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            additionalCapabilities: {
                serializedName: "additionalCapabilities",
                type: {
                    name: "Composite",
                    className: "VirtualMachineAdditionalCapabilities"
                }
            },
            usageQuota: {
                serializedName: "usageQuota",
                required: true,
                type: {
                    name: "TimeSpan"
                }
            },
            useSharedPassword: {
                serializedName: "useSharedPassword",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            },
            adminUser: {
                serializedName: "adminUser",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            },
            nonAdminUser: {
                serializedName: "nonAdminUser",
                type: {
                    name: "Composite",
                    className: "Credentials"
                }
            }
        }
    }
};
const ImageReference = {
    type: {
        name: "Composite",
        className: "ImageReference",
        modelProperties: {
            id: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            offer: {
                serializedName: "offer",
                type: {
                    name: "String"
                }
            },
            publisher: {
                serializedName: "publisher",
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                type: {
                    name: "String"
                }
            },
            exactVersion: {
                serializedName: "exactVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "Enum",
                    allowedValues: ["Free", "Basic", "Standard", "Premium"]
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachineAdditionalCapabilities = {
    type: {
        name: "Composite",
        className: "VirtualMachineAdditionalCapabilities",
        modelProperties: {
            installGpuDrivers: {
                serializedName: "installGpuDrivers",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }
        }
    }
};
const Credentials = {
    type: {
        name: "Composite",
        className: "Credentials",
        modelProperties: {
            username: {
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityProfile = {
    type: {
        name: "Composite",
        className: "SecurityProfile",
        modelProperties: {
            registrationCode: {
                serializedName: "registrationCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            openAccess: {
                serializedName: "openAccess",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }
        }
    }
};
const RosterProfile = {
    type: {
        name: "Composite",
        className: "RosterProfile",
        modelProperties: {
            activeDirectoryGroupId: {
                serializedName: "activeDirectoryGroupId",
                type: {
                    name: "String"
                }
            },
            ltiContextId: {
                serializedName: "ltiContextId",
                type: {
                    name: "String"
                }
            },
            lmsInstance: {
                serializedName: "lmsInstance",
                type: {
                    name: "String"
                }
            },
            ltiClientId: {
                serializedName: "ltiClientId",
                type: {
                    name: "String"
                }
            },
            ltiRosterEndpoint: {
                serializedName: "ltiRosterEndpoint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationResult = {
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "NotStarted",
                        "InProgress",
                        "Succeeded",
                        "Failed",
                        "Canceled"
                    ]
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            percentComplete: {
                serializedName: "percentComplete",
                type: {
                    name: "Number"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const PagedSchedules = {
    type: {
        name: "Composite",
        className: "PagedSchedules",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Schedule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScheduleUpdateProperties = {
    type: {
        name: "Composite",
        className: "ScheduleUpdateProperties",
        modelProperties: {
            startAt: {
                serializedName: "startAt",
                type: {
                    name: "DateTime"
                }
            },
            stopAt: {
                serializedName: "stopAt",
                type: {
                    name: "DateTime"
                }
            },
            recurrencePattern: {
                serializedName: "recurrencePattern",
                type: {
                    name: "Composite",
                    className: "RecurrencePattern"
                }
            },
            timeZoneId: {
                constraints: {
                    MaxLength: 50
                },
                serializedName: "timeZoneId",
                type: {
                    name: "String"
                }
            },
            notes: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RecurrencePattern = {
    type: {
        name: "Composite",
        className: "RecurrencePattern",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Daily", "Weekly"]
                }
            },
            weekDays: {
                serializedName: "weekDays",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: [
                                "Sunday",
                                "Monday",
                                "Tuesday",
                                "Wednesday",
                                "Thursday",
                                "Friday",
                                "Saturday"
                            ]
                        }
                    }
                }
            },
            interval: {
                constraints: {
                    InclusiveMaximum: 365,
                    InclusiveMinimum: 1
                },
                serializedName: "interval",
                type: {
                    name: "Number"
                }
            },
            expirationDate: {
                serializedName: "expirationDate",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ScheduleUpdate = {
    type: {
        name: "Composite",
        className: "ScheduleUpdate",
        modelProperties: {
            startAt: {
                serializedName: "properties.startAt",
                type: {
                    name: "DateTime"
                }
            },
            stopAt: {
                serializedName: "properties.stopAt",
                type: {
                    name: "DateTime"
                }
            },
            recurrencePattern: {
                serializedName: "properties.recurrencePattern",
                type: {
                    name: "Composite",
                    className: "RecurrencePattern"
                }
            },
            timeZoneId: {
                constraints: {
                    MaxLength: 50
                },
                serializedName: "properties.timeZoneId",
                type: {
                    name: "String"
                }
            },
            notes: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PagedLabServicesSkus = {
    type: {
        name: "Composite",
        className: "PagedLabServicesSkus",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabServicesSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabServicesSku = {
    type: {
        name: "Composite",
        className: "LabServicesSku",
        modelProperties: {
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Composite",
                    className: "LabServicesSkuCapacity"
                }
            },
            capabilities: {
                serializedName: "capabilities",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabServicesSkuCapabilities"
                        }
                    }
                }
            },
            locations: {
                serializedName: "locations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            costs: {
                serializedName: "costs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabServicesSkuCost"
                        }
                    }
                }
            },
            restrictions: {
                serializedName: "restrictions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LabServicesSkuRestrictions"
                        }
                    }
                }
            }
        }
    }
};
const LabServicesSkuCapacity = {
    type: {
        name: "Composite",
        className: "LabServicesSkuCapacity",
        modelProperties: {
            default: {
                serializedName: "default",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            minimum: {
                serializedName: "minimum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maximum: {
                serializedName: "maximum",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            scaleType: {
                serializedName: "scaleType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabServicesSkuCapabilities = {
    type: {
        name: "Composite",
        className: "LabServicesSkuCapabilities",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabServicesSkuCost = {
    type: {
        name: "Composite",
        className: "LabServicesSkuCost",
        modelProperties: {
            meterId: {
                serializedName: "meterId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            quantity: {
                serializedName: "quantity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            extendedUnit: {
                serializedName: "extendedUnit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabServicesSkuRestrictions = {
    type: {
        name: "Composite",
        className: "LabServicesSkuRestrictions",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            reasonCode: {
                serializedName: "reasonCode",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListUsagesResult = {
    type: {
        name: "Composite",
        className: "ListUsagesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            currentValue: {
                serializedName: "currentValue",
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                type: {
                    name: "Number"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            },
            skuInstances: {
                serializedName: "skuInstances",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PagedUsers = {
    type: {
        name: "Composite",
        className: "PagedUsers",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "User"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UserUpdateProperties = {
    type: {
        name: "Composite",
        className: "UserUpdateProperties",
        modelProperties: {
            additionalUsageQuota: {
                serializedName: "additionalUsageQuota",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const UserUpdate = {
    type: {
        name: "Composite",
        className: "UserUpdate",
        modelProperties: {
            additionalUsageQuota: {
                serializedName: "properties.additionalUsageQuota",
                type: {
                    name: "TimeSpan"
                }
            }
        }
    }
};
const InviteBody = {
    type: {
        name: "Composite",
        className: "InviteBody",
        modelProperties: {
            text: {
                serializedName: "text",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PagedVirtualMachines = {
    type: {
        name: "Composite",
        className: "PagedVirtualMachines",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineConnectionProfile = {
    type: {
        name: "Composite",
        className: "VirtualMachineConnectionProfile",
        modelProperties: {
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sshAuthority: {
                serializedName: "sshAuthority",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sshInBrowserUrl: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "sshInBrowserUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rdpAuthority: {
                serializedName: "rdpAuthority",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            rdpInBrowserUrl: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "rdpInBrowserUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            adminUsername: {
                serializedName: "adminUsername",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nonAdminUsername: {
                serializedName: "nonAdminUsername",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResetPasswordBody = {
    type: {
        name: "Composite",
        className: "ResetPasswordBody",
        modelProperties: {
            username: {
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageProperties = {
    type: {
        name: "Composite",
        className: "ImageProperties",
        modelProperties: Object.assign(Object.assign({}, ImageUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, iconUrl: {
                serializedName: "iconUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, author: {
                serializedName: "author",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, plan: {
                serializedName: "plan",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, termsStatus: {
                serializedName: "termsStatus",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, offer: {
                serializedName: "offer",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "publisher",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharedGalleryId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "sharedGalleryId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableRegions: {
                serializedName: "availableRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, osState: {
                serializedName: "osState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LabPlanProperties = {
    type: {
        name: "Composite",
        className: "LabPlanProperties",
        modelProperties: Object.assign(Object.assign({}, LabPlanUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            } })
    }
};
const LabPlanUpdate = {
    type: {
        name: "Composite",
        className: "LabPlanUpdate",
        modelProperties: Object.assign(Object.assign({}, TrackedResourceUpdate.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, defaultConnectionProfile: {
                serializedName: "properties.defaultConnectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            }, defaultAutoShutdownProfile: {
                serializedName: "properties.defaultAutoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            }, defaultNetworkProfile: {
                serializedName: "properties.defaultNetworkProfile",
                type: {
                    name: "Composite",
                    className: "LabPlanNetworkProfile"
                }
            }, allowedRegions: {
                serializedName: "properties.allowedRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sharedGalleryId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.sharedGalleryId",
                type: {
                    name: "String"
                }
            }, supportInfo: {
                serializedName: "properties.supportInfo",
                type: {
                    name: "Composite",
                    className: "SupportInfo"
                }
            }, linkedLmsInstance: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.linkedLmsInstance",
                type: {
                    name: "String"
                }
            } })
    }
};
const LabUpdate = {
    type: {
        name: "Composite",
        className: "LabUpdate",
        modelProperties: Object.assign(Object.assign({}, TrackedResourceUpdate.type.modelProperties), { autoShutdownProfile: {
                serializedName: "properties.autoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            }, connectionProfile: {
                serializedName: "properties.connectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            }, virtualMachineProfile: {
                serializedName: "properties.virtualMachineProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineProfile"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            }, rosterProfile: {
                serializedName: "properties.rosterProfile",
                type: {
                    name: "Composite",
                    className: "RosterProfile"
                }
            }, labPlanId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.labPlanId",
                type: {
                    name: "String"
                }
            }, title: {
                constraints: {
                    MaxLength: 120,
                    MinLength: 1
                },
                serializedName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const LabProperties = {
    type: {
        name: "Composite",
        className: "LabProperties",
        modelProperties: Object.assign(Object.assign({}, LabUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "LabNetworkProfile"
                }
            }, state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Draft",
                        "Publishing",
                        "Scaling",
                        "Syncing",
                        "Published"
                    ]
                }
            } })
    }
};
const ScheduleProperties = {
    type: {
        name: "Composite",
        className: "ScheduleProperties",
        modelProperties: Object.assign(Object.assign({}, ScheduleUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            } })
    }
};
const UserProperties = {
    type: {
        name: "Composite",
        className: "UserProperties",
        modelProperties: Object.assign(Object.assign({}, UserUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 6
                },
                serializedName: "email",
                required: true,
                type: {
                    name: "String"
                }
            }, registrationState: {
                serializedName: "registrationState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Registered", "NotRegistered"]
                }
            }, invitationState: {
                serializedName: "invitationState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSent", "Sending", "Sent", "Failed"]
                }
            }, invitationSent: {
                serializedName: "invitationSent",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, totalUsage: {
                serializedName: "totalUsage",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const Image = {
    type: {
        name: "Composite",
        className: "Image",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, enabledState: {
                serializedName: "properties.enabledState",
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, iconUrl: {
                serializedName: "properties.iconUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, author: {
                serializedName: "properties.author",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osType: {
                serializedName: "properties.osType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Windows", "Linux"]
                }
            }, plan: {
                serializedName: "properties.plan",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, termsStatus: {
                serializedName: "properties.termsStatus",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Enabled", "Disabled"]
                }
            }, offer: {
                serializedName: "properties.offer",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publisher: {
                serializedName: "properties.publisher",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "properties.sku",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharedGalleryId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.sharedGalleryId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableRegions: {
                serializedName: "properties.availableRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, osState: {
                serializedName: "properties.osState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Generalized", "Specialized"]
                }
            } })
    }
};
const Schedule = {
    type: {
        name: "Composite",
        className: "Schedule",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, startAt: {
                serializedName: "properties.startAt",
                type: {
                    name: "DateTime"
                }
            }, stopAt: {
                serializedName: "properties.stopAt",
                type: {
                    name: "DateTime"
                }
            }, recurrencePattern: {
                serializedName: "properties.recurrencePattern",
                type: {
                    name: "Composite",
                    className: "RecurrencePattern"
                }
            }, timeZoneId: {
                constraints: {
                    MaxLength: 50
                },
                serializedName: "properties.timeZoneId",
                type: {
                    name: "String"
                }
            }, notes: {
                constraints: {
                    MaxLength: 1000
                },
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            } })
    }
};
const User = {
    type: {
        name: "Composite",
        className: "User",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, additionalUsageQuota: {
                serializedName: "properties.additionalUsageQuota",
                type: {
                    name: "TimeSpan"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, email: {
                constraints: {
                    MaxLength: 254,
                    MinLength: 6
                },
                serializedName: "properties.email",
                required: true,
                type: {
                    name: "String"
                }
            }, registrationState: {
                serializedName: "properties.registrationState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Registered", "NotRegistered"]
                }
            }, invitationState: {
                serializedName: "properties.invitationState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["NotSent", "Sending", "Sent", "Failed"]
                }
            }, invitationSent: {
                serializedName: "properties.invitationSent",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, totalUsage: {
                serializedName: "properties.totalUsage",
                readOnly: true,
                type: {
                    name: "TimeSpan"
                }
            } })
    }
};
const VirtualMachine = {
    type: {
        name: "Composite",
        className: "VirtualMachine",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Stopped",
                        "Starting",
                        "Running",
                        "Stopping",
                        "ResettingPassword",
                        "Reimaging",
                        "Redeploying"
                    ]
                }
            }, connectionProfile: {
                serializedName: "properties.connectionProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineConnectionProfile"
                }
            }, claimedByUserId: {
                serializedName: "properties.claimedByUserId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vmType: {
                serializedName: "properties.vmType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["User", "Template"]
                }
            } })
    }
};
const LabPlan = {
    type: {
        name: "Composite",
        className: "LabPlan",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "Identity"
                }
            }, defaultConnectionProfile: {
                serializedName: "properties.defaultConnectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            }, defaultAutoShutdownProfile: {
                serializedName: "properties.defaultAutoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            }, defaultNetworkProfile: {
                serializedName: "properties.defaultNetworkProfile",
                type: {
                    name: "Composite",
                    className: "LabPlanNetworkProfile"
                }
            }, allowedRegions: {
                serializedName: "properties.allowedRegions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sharedGalleryId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.sharedGalleryId",
                type: {
                    name: "String"
                }
            }, supportInfo: {
                serializedName: "properties.supportInfo",
                type: {
                    name: "Composite",
                    className: "SupportInfo"
                }
            }, linkedLmsInstance: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.linkedLmsInstance",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            } })
    }
};
const Lab = {
    type: {
        name: "Composite",
        className: "Lab",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, autoShutdownProfile: {
                serializedName: "properties.autoShutdownProfile",
                type: {
                    name: "Composite",
                    className: "AutoShutdownProfile"
                }
            }, connectionProfile: {
                serializedName: "properties.connectionProfile",
                type: {
                    name: "Composite",
                    className: "ConnectionProfile"
                }
            }, virtualMachineProfile: {
                serializedName: "properties.virtualMachineProfile",
                type: {
                    name: "Composite",
                    className: "VirtualMachineProfile"
                }
            }, securityProfile: {
                serializedName: "properties.securityProfile",
                type: {
                    name: "Composite",
                    className: "SecurityProfile"
                }
            }, rosterProfile: {
                serializedName: "properties.rosterProfile",
                type: {
                    name: "Composite",
                    className: "RosterProfile"
                }
            }, labPlanId: {
                constraints: {
                    MaxLength: 2000,
                    MinLength: 3
                },
                serializedName: "properties.labPlanId",
                type: {
                    name: "String"
                }
            }, title: {
                constraints: {
                    MaxLength: 120,
                    MinLength: 1
                },
                serializedName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Updating",
                        "Deleting",
                        "Succeeded",
                        "Failed",
                        "Locked"
                    ]
                }
            }, networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "LabNetworkProfile"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Draft",
                        "Publishing",
                        "Scaling",
                        "Syncing",
                        "Published"
                    ]
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    PagedImages: PagedImages,
    SystemData: SystemData,
    ImageUpdateProperties: ImageUpdateProperties,
    Resource: Resource,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ImageUpdate: ImageUpdate,
    PagedLabPlans: PagedLabPlans,
    LabPlanUpdateProperties: LabPlanUpdateProperties,
    ConnectionProfile: ConnectionProfile,
    AutoShutdownProfile: AutoShutdownProfile,
    LabPlanNetworkProfile: LabPlanNetworkProfile,
    SupportInfo: SupportInfo,
    Identity: Identity,
    TrackedResourceUpdate: TrackedResourceUpdate,
    SaveImageBody: SaveImageBody,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    PagedLabs: PagedLabs,
    LabNetworkProfile: LabNetworkProfile,
    LabUpdateProperties: LabUpdateProperties,
    VirtualMachineProfile: VirtualMachineProfile,
    ImageReference: ImageReference,
    Sku: Sku,
    VirtualMachineAdditionalCapabilities: VirtualMachineAdditionalCapabilities,
    Credentials: Credentials,
    SecurityProfile: SecurityProfile,
    RosterProfile: RosterProfile,
    OperationResult: OperationResult,
    PagedSchedules: PagedSchedules,
    ScheduleUpdateProperties: ScheduleUpdateProperties,
    RecurrencePattern: RecurrencePattern,
    ScheduleUpdate: ScheduleUpdate,
    PagedLabServicesSkus: PagedLabServicesSkus,
    LabServicesSku: LabServicesSku,
    LabServicesSkuCapacity: LabServicesSkuCapacity,
    LabServicesSkuCapabilities: LabServicesSkuCapabilities,
    LabServicesSkuCost: LabServicesSkuCost,
    LabServicesSkuRestrictions: LabServicesSkuRestrictions,
    ListUsagesResult: ListUsagesResult,
    Usage: Usage,
    UsageName: UsageName,
    PagedUsers: PagedUsers,
    UserUpdateProperties: UserUpdateProperties,
    UserUpdate: UserUpdate,
    InviteBody: InviteBody,
    PagedVirtualMachines: PagedVirtualMachines,
    VirtualMachineConnectionProfile: VirtualMachineConnectionProfile,
    ResetPasswordBody: ResetPasswordBody,
    ImageProperties: ImageProperties,
    ProxyResource: ProxyResource,
    TrackedResource: TrackedResource,
    LabPlanProperties: LabPlanProperties,
    LabPlanUpdate: LabPlanUpdate,
    LabUpdate: LabUpdate,
    LabProperties: LabProperties,
    ScheduleProperties: ScheduleProperties,
    UserProperties: UserProperties,
    Image: Image,
    Schedule: Schedule,
    User: User,
    VirtualMachine: VirtualMachine,
    LabPlan: LabPlan,
    Lab: Lab
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-08-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const labPlanName = {
    parameterPath: "labPlanName",
    mapper: {
        constraints: {
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "labPlanName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const imageName = {
    parameterPath: "imageName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\\\._\\\\(\\\\)]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "imageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: Image
};
const body1 = {
    parameterPath: "body",
    mapper: ImageUpdate
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const body2 = {
    parameterPath: "body",
    mapper: LabPlan
};
const body3 = {
    parameterPath: "body",
    mapper: LabPlanUpdate
};
const body4 = {
    parameterPath: "body",
    mapper: SaveImageBody
};
const labName = {
    parameterPath: "labName",
    mapper: {
        constraints: {
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "labName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body5 = {
    parameterPath: "body",
    mapper: Lab
};
const body6 = {
    parameterPath: "body",
    mapper: LabUpdate
};
const operationResultId = {
    parameterPath: "operationResultId",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\\\._\\\\(\\\\)]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "operationResultId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scheduleName = {
    parameterPath: "scheduleName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\\\._\\\\(\\\\)]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "scheduleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body7 = {
    parameterPath: "body",
    mapper: Schedule
};
const body8 = {
    parameterPath: "body",
    mapper: ScheduleUpdate
};
const location = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const userName = {
    parameterPath: "userName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\\\._\\\\(\\\\)]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "userName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body9 = {
    parameterPath: "body",
    mapper: User
};
const body10 = {
    parameterPath: "body",
    mapper: UserUpdate
};
const body11 = {
    parameterPath: "body",
    mapper: InviteBody
};
const virtualMachineName = {
    parameterPath: "virtualMachineName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\\\._\\\\(\\\\)]+$"),
            MaxLength: 100,
            MinLength: 1
        },
        serializedName: "virtualMachineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body12 = {
    parameterPath: "body",
    mapper: ResetPasswordBody
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Images operations. */
class ImagesImpl {
    /**
     * Initialize a new instance of the class Images class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all images from galleries attached to a lab plan.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param options The options parameters.
     */
    listByLabPlan(resourceGroupName, labPlanName, options) {
        const iter = this.listByLabPlanPagingAll(resourceGroupName, labPlanName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLabPlanPagingPage(resourceGroupName, labPlanName, options, settings);
            }
        };
    }
    listByLabPlanPagingPage(resourceGroupName, labPlanName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPlanPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLabPlan(resourceGroupName, labPlanName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLabPlanNext(resourceGroupName, labPlanName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLabPlanPagingAll(resourceGroupName, labPlanName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPlanPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLabPlanPagingPage(resourceGroupName, labPlanName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all images from galleries attached to a lab plan.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param options The options parameters.
     */
    _listByLabPlan(resourceGroupName, labPlanName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, options }, listByLabPlanOperationSpec);
    }
    /**
     * Gets an image resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param imageName The image name.
     * @param options The options parameters.
     */
    get(resourceGroupName, labPlanName, imageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, imageName, options }, getOperationSpec$6);
    }
    /**
     * Updates an image resource via PUT. Creating new resources via PUT will not function.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param imageName The image name.
     * @param body The request body.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labPlanName, imageName, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, imageName, body, options }, createOrUpdateOperationSpec$4);
    }
    /**
     * Updates an image resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param imageName The image name.
     * @param body The request body.
     * @param options The options parameters.
     */
    update(resourceGroupName, labPlanName, imageName, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, imageName, body, options }, updateOperationSpec$4);
    }
    /**
     * ListByLabPlanNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param nextLink The nextLink from the previous successful call to the ListByLabPlan method.
     * @param options The options parameters.
     */
    _listByLabPlanNext(resourceGroupName, labPlanName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, nextLink, options }, listByLabPlanNextOperationSpec);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLabPlanOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}/images",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedImages
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}/images/{imageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName,
        imageName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}/images/{imageName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName,
        imageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}/images/{imageName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Image
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName,
        imageName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listByLabPlanNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedImages
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LabPlans operations. */
class LabPlansImpl {
    /**
     * Initialize a new instance of the class LabPlans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all lab plans within a subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all lab plans for a subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns a list of all lab plans within a subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Returns a list of all lab plans for a subscription and resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Retrieves the properties of a Lab Plan.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param options The options parameters.
     */
    get(resourceGroupName, labPlanName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labPlanName, options }, getOperationSpec$5);
    }
    /**
     * Operation to create or update a Lab Plan resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labPlanName, body, options }, createOrUpdateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "original-uri"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to create or update a Lab Plan resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labPlanName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to update a Lab Plan resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labPlanName, body, options }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to update a Lab Plan resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, labPlanName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to delete a Lab Plan resource. Deleting a lab plan does not delete labs associated with a
     * lab plan, nor does it delete shared images added to a gallery via the lab plan permission container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labPlanName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to delete a Lab Plan resource. Deleting a lab plan does not delete labs associated with a
     * lab plan, nor does it delete shared images added to a gallery via the lab plan permission container.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labPlanName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Saves an image from a lab VM to the attached shared image gallery.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginSaveImage(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labPlanName, body, options }, saveImageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Saves an image from a lab VM to the attached shared image gallery.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labPlanName The name of the lab plan that uniquely identifies it within containing resource
     *                    group. Used in resource URIs and in UI.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginSaveImageAndWait(resourceGroupName, labPlanName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSaveImage(resourceGroupName, labPlanName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.LabServices/labPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabPlans
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabPlans
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LabPlan
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LabPlan
        },
        201: {
            bodyMapper: LabPlan
        },
        202: {
            bodyMapper: LabPlan
        },
        204: {
            bodyMapper: LabPlan
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LabPlan
        },
        201: {
            bodyMapper: LabPlan
        },
        202: {
            bodyMapper: LabPlan
        },
        204: {
            bodyMapper: LabPlan
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const saveImageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labPlans/{labPlanName}/saveImage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabPlans
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabPlans
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.LabServices/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Labs operations. */
class LabsImpl {
    /**
     * Initialize a new instance of the class Labs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all labs for a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all labs in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns a list of all labs for a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Returns a list of all labs in a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Returns the properties of a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, getOperationSpec$4);
    }
    /**
     * Operation to create or update a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, body, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "original-uri"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to create or update a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to update a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, labName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, body, options }, updateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to update a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, labName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, labName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to delete a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to delete a lab resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Publish or re-publish a lab. This will create or update all lab resources, such as virtual machines.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginPublish(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, options }, publishOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Publish or re-publish a lab. This will create or update all lab resources, such as virtual machines.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginPublishAndWait(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPublish(resourceGroupName, labName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Action used to manually kick off an AAD group sync job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginSyncGroup(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, options }, syncGroupOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Action used to manually kick off an AAD group sync job.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    beginSyncGroupAndWait(resourceGroupName, labName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSyncGroup(resourceGroupName, labName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.LabServices/labs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabs
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabs
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Lab
        },
        201: {
            bodyMapper: Lab
        },
        202: {
            bodyMapper: Lab
        },
        204: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Lab
        },
        201: {
            bodyMapper: Lab
        },
        202: {
            bodyMapper: Lab
        },
        204: {
            bodyMapper: Lab
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const publishOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/publish",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const syncGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/syncGroup",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabs
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabs
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationResults operations. */
class OperationResultsImpl {
    /**
     * Initialize a new instance of the class OperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns an azure operation result.
     * @param operationResultId The operation result ID / name.
     * @param options The options parameters.
     */
    get(operationResultId, options) {
        return this.client.sendOperationRequest({ operationResultId, options }, getOperationSpec$3);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.LabServices/operationResults/{operationResultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResult
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        operationResultId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Schedules operations. */
class SchedulesImpl {
    /**
     * Initialize a new instance of the class Schedules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all schedules for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    listByLab(resourceGroupName, labName, options) {
        const iter = this.listByLabPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLabPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listByLabPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLab(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLabNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLabPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLabPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all schedules for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    _listByLab(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listByLabOperationSpec$2);
    }
    /**
     * Returns the properties of a lab Schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param scheduleName The name of the schedule that uniquely identifies it within containing lab. Used
     *                     in resource URIs.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, scheduleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, scheduleName, options }, getOperationSpec$2);
    }
    /**
     * Operation to create or update a lab schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param scheduleName The name of the schedule that uniquely identifies it within containing lab. Used
     *                     in resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, labName, scheduleName, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, scheduleName, body, options }, createOrUpdateOperationSpec$1);
    }
    /**
     * Operation to update a lab schedule.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param scheduleName The name of the schedule that uniquely identifies it within containing lab. Used
     *                     in resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    update(resourceGroupName, labName, scheduleName, body, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, scheduleName, body, options }, updateOperationSpec$1);
    }
    /**
     * Operation to delete a schedule resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param scheduleName The name of the schedule that uniquely identifies it within containing lab. Used
     *                     in resource URIs.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, scheduleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, scheduleName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to delete a schedule resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param scheduleName The name of the schedule that uniquely identifies it within containing lab. Used
     *                     in resource URIs.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, scheduleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, scheduleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLabNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param nextLink The nextLink from the previous successful call to the ListByLab method.
     * @param options The options parameters.
     */
    _listByLabNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listByLabNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLabOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/schedules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedSchedules
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/schedules/{scheduleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        scheduleName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/schedules/{scheduleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        201: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        scheduleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/schedules/{scheduleName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Schedule
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        scheduleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/schedules/{scheduleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        scheduleName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByLabNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedSchedules
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Skus operations. */
class SkusImpl {
    /**
     * Initialize a new instance of the class Skus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of Azure Lab Services resource SKUs.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of Azure Lab Services resource SKUs.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.LabServices/skus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabServicesSkus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedLabServicesSkus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of usage per SKU family for the specified subscription in the specified region.
     * @param location The location name.
     * @param options The options parameters.
     */
    listByLocation(location, options) {
        const iter = this.listByLocationPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLocationPagingPage(location, options, settings);
            }
        };
    }
    listByLocationPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLocation(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLocationNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLocationPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLocationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLocationPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of usage per SKU family for the specified subscription in the specified region.
     * @param location The location name.
     * @param options The options parameters.
     */
    _listByLocation(location, options) {
        return this.client.sendOperationRequest({ location, options }, listByLocationOperationSpec);
    }
    /**
     * ListByLocationNext
     * @param location The location name.
     * @param nextLink The nextLink from the previous successful call to the ListByLocation method.
     * @param options The options parameters.
     */
    _listByLocationNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listByLocationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLocationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.LabServices/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByLocationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListUsagesResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Users operations. */
class UsersImpl {
    /**
     * Initialize a new instance of the class Users class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all users for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    listByLab(resourceGroupName, labName, options) {
        const iter = this.listByLabPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLabPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listByLabPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLab(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLabNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLabPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLabPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all users for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    _listByLab(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listByLabOperationSpec$1);
    }
    /**
     * Returns the properties of a lab user.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, userName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, userName, options }, getOperationSpec$1);
    }
    /**
     * Operation to create or update a lab user.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, body, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "original-uri"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to create or update a lab user.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, labName, userName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to update a lab user.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, body, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to update a lab user.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, labName, userName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to delete a user resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, labName, userName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to delete a user resource.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, labName, userName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, labName, userName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Operation to invite a user to a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginInvite(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, userName, body, options }, inviteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Operation to invite a user to a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param userName The name of the user that uniquely identifies it within containing lab. Used in
     *                 resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginInviteAndWait(resourceGroupName, labName, userName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginInvite(resourceGroupName, labName, userName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLabNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param nextLink The nextLink from the previous successful call to the ListByLab method.
     * @param options The options parameters.
     */
    _listByLabNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listByLabNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLabOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedUsers
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users/{userName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: User
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users/{userName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users/{userName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: User
        },
        201: {
            bodyMapper: User
        },
        202: {
            bodyMapper: User
        },
        204: {
            bodyMapper: User
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users/{userName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const inviteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/users/{userName}/invite",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        userName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByLabNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedUsers
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        labName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns a list of all virtual machines for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    listByLab(resourceGroupName, labName, options) {
        const iter = this.listByLabPagingAll(resourceGroupName, labName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByLabPagingPage(resourceGroupName, labName, options, settings);
            }
        };
    }
    listByLabPagingPage(resourceGroupName, labName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByLab(resourceGroupName, labName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByLabNext(resourceGroupName, labName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByLabPagingAll(resourceGroupName, labName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByLabPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByLabPagingPage(resourceGroupName, labName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns a list of all virtual machines for a lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param options The options parameters.
     */
    _listByLab(resourceGroupName, labName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, options }, listByLabOperationSpec);
    }
    /**
     * Returns the properties for a lab virtual machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    get(resourceGroupName, labName, virtualMachineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, virtualMachineName, options }, getOperationSpec);
    }
    /**
     * Action to start a lab virtual machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Action to start a lab virtual machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, labName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Action to stop a lab virtual machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Action to stop a lab virtual machine.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, labName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Re-image a lab virtual machine. The virtual machine will be deleted and recreated using the latest
     * published snapshot of the reference environment of the lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginReimage(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, options }, reimageOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Re-image a lab virtual machine. The virtual machine will be deleted and recreated using the latest
     * published snapshot of the reference environment of the lab.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginReimageAndWait(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReimage(resourceGroupName, labName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Action to redeploy a lab virtual machine to a different compute node. For troubleshooting
     * connectivity.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginRedeploy(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, options }, redeployOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Action to redeploy a lab virtual machine to a different compute node. For troubleshooting
     * connectivity.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param options The options parameters.
     */
    beginRedeployAndWait(resourceGroupName, labName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRedeploy(resourceGroupName, labName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets a lab virtual machine password.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginResetPassword(resourceGroupName, labName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, labName, virtualMachineName, body, options }, resetPasswordOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets a lab virtual machine password.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param virtualMachineName The ID of the virtual machine that uniquely identifies it within the
     *                           containing lab. Used in resource URIs.
     * @param body The request body.
     * @param options The options parameters.
     */
    beginResetPasswordAndWait(resourceGroupName, labName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetPassword(resourceGroupName, labName, virtualMachineName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByLabNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param labName The name of the lab that uniquely identifies it within containing lab plan. Used in
     *                resource URIs.
     * @param nextLink The nextLink from the previous successful call to the ListByLab method.
     * @param options The options parameters.
     */
    _listByLabNext(resourceGroupName, labName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, labName, nextLink, options }, listByLabNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByLabOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedVirtualMachines
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const reimageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}/reimage",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const redeployOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}/redeploy",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const resetPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.LabServices/labs/{labName}/virtualMachines/{virtualMachineName}/resetPassword",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        labName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listByLabNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PagedVirtualMachines
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink,
        labName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LabServicesClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the LabServicesClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-labservices/3.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2022-08-01";
        this.images = new ImagesImpl(this);
        this.labPlans = new LabPlansImpl(this);
        this.operations = new OperationsImpl(this);
        this.labs = new LabsImpl(this);
        this.operationResults = new OperationResultsImpl(this);
        this.schedules = new SchedulesImpl(this);
        this.skus = new SkusImpl(this);
        this.usages = new UsagesImpl(this);
        this.users = new UsersImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.LabServicesClient = LabServicesClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
