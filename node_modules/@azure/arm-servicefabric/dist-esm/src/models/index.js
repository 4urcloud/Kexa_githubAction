/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AddOnFeatures} that the service accepts. */
export var KnownAddOnFeatures;
(function (KnownAddOnFeatures) {
    /** RepairManager */
    KnownAddOnFeatures["RepairManager"] = "RepairManager";
    /** DnsService */
    KnownAddOnFeatures["DnsService"] = "DnsService";
    /** BackupRestoreService */
    KnownAddOnFeatures["BackupRestoreService"] = "BackupRestoreService";
    /** ResourceMonitorService */
    KnownAddOnFeatures["ResourceMonitorService"] = "ResourceMonitorService";
})(KnownAddOnFeatures || (KnownAddOnFeatures = {}));
/** Known values of {@link ClusterEnvironment} that the service accepts. */
export var KnownClusterEnvironment;
(function (KnownClusterEnvironment) {
    /** Windows */
    KnownClusterEnvironment["Windows"] = "Windows";
    /** Linux */
    KnownClusterEnvironment["Linux"] = "Linux";
})(KnownClusterEnvironment || (KnownClusterEnvironment = {}));
/** Known values of {@link StoreName} that the service accepts. */
export var KnownStoreName;
(function (KnownStoreName) {
    /** AddressBook */
    KnownStoreName["AddressBook"] = "AddressBook";
    /** AuthRoot */
    KnownStoreName["AuthRoot"] = "AuthRoot";
    /** CertificateAuthority */
    KnownStoreName["CertificateAuthority"] = "CertificateAuthority";
    /** Disallowed */
    KnownStoreName["Disallowed"] = "Disallowed";
    /** My */
    KnownStoreName["My"] = "My";
    /** Root */
    KnownStoreName["Root"] = "Root";
    /** TrustedPeople */
    KnownStoreName["TrustedPeople"] = "TrustedPeople";
    /** TrustedPublisher */
    KnownStoreName["TrustedPublisher"] = "TrustedPublisher";
})(KnownStoreName || (KnownStoreName = {}));
/** Known values of {@link ClusterState} that the service accepts. */
export var KnownClusterState;
(function (KnownClusterState) {
    /** WaitingForNodes */
    KnownClusterState["WaitingForNodes"] = "WaitingForNodes";
    /** Deploying */
    KnownClusterState["Deploying"] = "Deploying";
    /** BaselineUpgrade */
    KnownClusterState["BaselineUpgrade"] = "BaselineUpgrade";
    /** UpdatingUserConfiguration */
    KnownClusterState["UpdatingUserConfiguration"] = "UpdatingUserConfiguration";
    /** UpdatingUserCertificate */
    KnownClusterState["UpdatingUserCertificate"] = "UpdatingUserCertificate";
    /** UpdatingInfrastructure */
    KnownClusterState["UpdatingInfrastructure"] = "UpdatingInfrastructure";
    /** EnforcingClusterVersion */
    KnownClusterState["EnforcingClusterVersion"] = "EnforcingClusterVersion";
    /** UpgradeServiceUnreachable */
    KnownClusterState["UpgradeServiceUnreachable"] = "UpgradeServiceUnreachable";
    /** AutoScale */
    KnownClusterState["AutoScale"] = "AutoScale";
    /** Ready */
    KnownClusterState["Ready"] = "Ready";
})(KnownClusterState || (KnownClusterState = {}));
/** Known values of {@link DurabilityLevel} that the service accepts. */
export var KnownDurabilityLevel;
(function (KnownDurabilityLevel) {
    /** Bronze */
    KnownDurabilityLevel["Bronze"] = "Bronze";
    /** Silver */
    KnownDurabilityLevel["Silver"] = "Silver";
    /** Gold */
    KnownDurabilityLevel["Gold"] = "Gold";
})(KnownDurabilityLevel || (KnownDurabilityLevel = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
export var KnownProvisioningState;
(function (KnownProvisioningState) {
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
})(KnownProvisioningState || (KnownProvisioningState = {}));
/** Known values of {@link ReliabilityLevel} that the service accepts. */
export var KnownReliabilityLevel;
(function (KnownReliabilityLevel) {
    /** None */
    KnownReliabilityLevel["None"] = "None";
    /** Bronze */
    KnownReliabilityLevel["Bronze"] = "Bronze";
    /** Silver */
    KnownReliabilityLevel["Silver"] = "Silver";
    /** Gold */
    KnownReliabilityLevel["Gold"] = "Gold";
    /** Platinum */
    KnownReliabilityLevel["Platinum"] = "Platinum";
})(KnownReliabilityLevel || (KnownReliabilityLevel = {}));
/** Known values of {@link UpgradeMode} that the service accepts. */
export var KnownUpgradeMode;
(function (KnownUpgradeMode) {
    /** The cluster will be automatically upgraded to the latest Service Fabric runtime version, **upgradeWave** will determine when the upgrade starts after the new version becomes available. */
    KnownUpgradeMode["Automatic"] = "Automatic";
    /** The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource. */
    KnownUpgradeMode["Manual"] = "Manual";
})(KnownUpgradeMode || (KnownUpgradeMode = {}));
/** Known values of {@link SfZonalUpgradeMode} that the service accepts. */
export var KnownSfZonalUpgradeMode;
(function (KnownSfZonalUpgradeMode) {
    /** VMs under the node type are grouped into UDs and ignore the zone info in five UDs. This setting causes UDs across all zones to be upgraded at the same time. This deployment mode is faster for upgrades, we don't recommend it because it goes against the SDP guidelines, which state that the updates should be applied to one zone at a time. */
    KnownSfZonalUpgradeMode["Parallel"] = "Parallel";
    /** If this value is omitted or set to Hierarchical, VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone. This update process is safer for the cluster and the user application. */
    KnownSfZonalUpgradeMode["Hierarchical"] = "Hierarchical";
})(KnownSfZonalUpgradeMode || (KnownSfZonalUpgradeMode = {}));
/** Known values of {@link VmssZonalUpgradeMode} that the service accepts. */
export var KnownVmssZonalUpgradeMode;
(function (KnownVmssZonalUpgradeMode) {
    /** Updates will happen in all Availability Zones at once for the virtual machine scale sets. */
    KnownVmssZonalUpgradeMode["Parallel"] = "Parallel";
    /** VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone. */
    KnownVmssZonalUpgradeMode["Hierarchical"] = "Hierarchical";
})(KnownVmssZonalUpgradeMode || (KnownVmssZonalUpgradeMode = {}));
/** Known values of {@link ClusterUpgradeCadence} that the service accepts. */
export var KnownClusterUpgradeCadence;
(function (KnownClusterUpgradeCadence) {
    /** Cluster upgrade starts immediately after a new version is rolled out. Recommended for Test\/Dev clusters. */
    KnownClusterUpgradeCadence["Wave0"] = "Wave0";
    /** Cluster upgrade starts 7 days after a new version is rolled out. Recommended for Pre-prod clusters. */
    KnownClusterUpgradeCadence["Wave1"] = "Wave1";
    /** Cluster upgrade starts 14 days after a new version is rolled out. Recommended for Production clusters. */
    KnownClusterUpgradeCadence["Wave2"] = "Wave2";
})(KnownClusterUpgradeCadence || (KnownClusterUpgradeCadence = {}));
/** Known values of {@link NotificationCategory} that the service accepts. */
export var KnownNotificationCategory;
(function (KnownNotificationCategory) {
    /** Notification will be regarding wave progress. */
    KnownNotificationCategory["WaveProgress"] = "WaveProgress";
})(KnownNotificationCategory || (KnownNotificationCategory = {}));
/** Known values of {@link NotificationLevel} that the service accepts. */
export var KnownNotificationLevel;
(function (KnownNotificationLevel) {
    /** Receive only critical notifications. */
    KnownNotificationLevel["Critical"] = "Critical";
    /** Receive all notifications. */
    KnownNotificationLevel["All"] = "All";
})(KnownNotificationLevel || (KnownNotificationLevel = {}));
/** Known values of {@link NotificationChannel} that the service accepts. */
export var KnownNotificationChannel;
(function (KnownNotificationChannel) {
    /** For email user receivers. In this case, the parameter receivers should be a list of email addresses that will receive the notifications. */
    KnownNotificationChannel["EmailUser"] = "EmailUser";
    /** For subscription receivers. In this case, the parameter receivers should be a list of roles of the subscription for the cluster (eg. Owner, AccountAdmin, etc) that will receive the notifications. */
    KnownNotificationChannel["EmailSubscription"] = "EmailSubscription";
})(KnownNotificationChannel || (KnownNotificationChannel = {}));
/** Known values of {@link ClusterVersionsEnvironment} that the service accepts. */
export var KnownClusterVersionsEnvironment;
(function (KnownClusterVersionsEnvironment) {
    /** Windows */
    KnownClusterVersionsEnvironment["Windows"] = "Windows";
    /** Linux */
    KnownClusterVersionsEnvironment["Linux"] = "Linux";
})(KnownClusterVersionsEnvironment || (KnownClusterVersionsEnvironment = {}));
/** Known values of {@link ArmUpgradeFailureAction} that the service accepts. */
export var KnownArmUpgradeFailureAction;
(function (KnownArmUpgradeFailureAction) {
    /** Indicates that a rollback of the upgrade will be performed by Service Fabric if the upgrade fails. */
    KnownArmUpgradeFailureAction["Rollback"] = "Rollback";
    /** Indicates that a manual repair will need to be performed by the administrator if the upgrade fails. Service Fabric will not proceed to the next upgrade domain automatically. */
    KnownArmUpgradeFailureAction["Manual"] = "Manual";
})(KnownArmUpgradeFailureAction || (KnownArmUpgradeFailureAction = {}));
/** Known values of {@link RollingUpgradeMode} that the service accepts. */
export var KnownRollingUpgradeMode;
(function (KnownRollingUpgradeMode) {
    /** Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownRollingUpgradeMode["Invalid"] = "Invalid";
    /** The upgrade will proceed automatically without performing any health monitoring. The value is 1 */
    KnownRollingUpgradeMode["UnmonitoredAuto"] = "UnmonitoredAuto";
    /** The upgrade will stop after completing each upgrade domain, giving the opportunity to manually monitor health before proceeding. The value is 2 */
    KnownRollingUpgradeMode["UnmonitoredManual"] = "UnmonitoredManual";
    /** The upgrade will stop after completing each upgrade domain and automatically monitor health before proceeding. The value is 3 */
    KnownRollingUpgradeMode["Monitored"] = "Monitored";
})(KnownRollingUpgradeMode || (KnownRollingUpgradeMode = {}));
/** Known values of {@link ServiceKind} that the service accepts. */
export var KnownServiceKind;
(function (KnownServiceKind) {
    /** Indicates the service kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownServiceKind["Invalid"] = "Invalid";
    /** Does not use Service Fabric to make its state highly available or reliable. The value is 1. */
    KnownServiceKind["Stateless"] = "Stateless";
    /** Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2. */
    KnownServiceKind["Stateful"] = "Stateful";
})(KnownServiceKind || (KnownServiceKind = {}));
/** Known values of {@link PartitionScheme} that the service accepts. */
export var KnownPartitionScheme;
(function (KnownPartitionScheme) {
    /** Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownPartitionScheme["Invalid"] = "Invalid";
    /** Indicates that the partition is based on string names, and is a SingletonPartitionSchemeDescription object, The value is 1. */
    KnownPartitionScheme["Singleton"] = "Singleton";
    /** Indicates that the partition is based on Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription object. The value is 2. */
    KnownPartitionScheme["UniformInt64Range"] = "UniformInt64Range";
    /** Indicates that the partition is based on string names, and is a NamedPartitionSchemeDescription object. The value is 3 */
    KnownPartitionScheme["Named"] = "Named";
})(KnownPartitionScheme || (KnownPartitionScheme = {}));
/** Known values of {@link ArmServicePackageActivationMode} that the service accepts. */
export var KnownArmServicePackageActivationMode;
(function (KnownArmServicePackageActivationMode) {
    /** Indicates the application package activation mode will use shared process. */
    KnownArmServicePackageActivationMode["SharedProcess"] = "SharedProcess";
    /** Indicates the application package activation mode will use exclusive process. */
    KnownArmServicePackageActivationMode["ExclusiveProcess"] = "ExclusiveProcess";
})(KnownArmServicePackageActivationMode || (KnownArmServicePackageActivationMode = {}));
/** Known values of {@link ServiceCorrelationScheme} that the service accepts. */
export var KnownServiceCorrelationScheme;
(function (KnownServiceCorrelationScheme) {
    /** An invalid correlation scheme. Cannot be used. The value is zero. */
    KnownServiceCorrelationScheme["Invalid"] = "Invalid";
    /** Indicates that this service has an affinity relationship with another service. Provided for backwards compatibility, consider preferring the Aligned or NonAlignedAffinity options. The value is 1. */
    KnownServiceCorrelationScheme["Affinity"] = "Affinity";
    /** Aligned affinity ensures that the primaries of the partitions of the affinitized services are collocated on the same nodes. This is the default and is the same as selecting the Affinity scheme. The value is 2. */
    KnownServiceCorrelationScheme["AlignedAffinity"] = "AlignedAffinity";
    /** Non-Aligned affinity guarantees that all replicas of each service will be placed on the same nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will be collocated. The value is 3. */
    KnownServiceCorrelationScheme["NonAlignedAffinity"] = "NonAlignedAffinity";
})(KnownServiceCorrelationScheme || (KnownServiceCorrelationScheme = {}));
/** Known values of {@link ServiceLoadMetricWeight} that the service accepts. */
export var KnownServiceLoadMetricWeight;
(function (KnownServiceLoadMetricWeight) {
    /** Disables resource balancing for this metric. This value is zero. */
    KnownServiceLoadMetricWeight["Zero"] = "Zero";
    /** Specifies the metric weight of the service load as Low. The value is 1. */
    KnownServiceLoadMetricWeight["Low"] = "Low";
    /** Specifies the metric weight of the service load as Medium. The value is 2. */
    KnownServiceLoadMetricWeight["Medium"] = "Medium";
    /** Specifies the metric weight of the service load as High. The value is 3. */
    KnownServiceLoadMetricWeight["High"] = "High";
})(KnownServiceLoadMetricWeight || (KnownServiceLoadMetricWeight = {}));
/** Known values of {@link ServicePlacementPolicyType} that the service accepts. */
export var KnownServicePlacementPolicyType;
(function (KnownServicePlacementPolicyType) {
    /** Indicates the type of the placement policy is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownServicePlacementPolicyType["Invalid"] = "Invalid";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or upgrade domain cannot be used for placement of this service. The value is 1. */
    KnownServicePlacementPolicyType["InvalidDomain"] = "InvalidDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the service must be placed in a specific domain. The value is 2. */
    KnownServicePlacementPolicyType["RequiredDomain"] = "RequiredDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the Primary replica for the partitions of the service should be located in a particular domain as an optimization. The value is 3. */
    KnownServicePlacementPolicyType["PreferredPrimaryDomain"] = "PreferredPrimaryDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will disallow placement of any two replicas from the same partition in the same domain at any time. The value is 4. */
    KnownServicePlacementPolicyType["RequiredDomainDistribution"] = "RequiredDomainDistribution";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all replicas of a particular partition of the service should be placed atomically. The value is 5. */
    KnownServicePlacementPolicyType["NonPartiallyPlaceService"] = "NonPartiallyPlaceService";
})(KnownServicePlacementPolicyType || (KnownServicePlacementPolicyType = {}));
/** Known values of {@link MoveCost} that the service accepts. */
export var KnownMoveCost;
(function (KnownMoveCost) {
    /** Zero move cost. This value is zero. */
    KnownMoveCost["Zero"] = "Zero";
    /** Specifies the move cost of the service as Low. The value is 1. */
    KnownMoveCost["Low"] = "Low";
    /** Specifies the move cost of the service as Medium. The value is 2. */
    KnownMoveCost["Medium"] = "Medium";
    /** Specifies the move cost of the service as High. The value is 3. */
    KnownMoveCost["High"] = "High";
})(KnownMoveCost || (KnownMoveCost = {}));
//# sourceMappingURL=index.js.map