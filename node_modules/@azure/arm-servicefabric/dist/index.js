'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link AddOnFeatures} that the service accepts. */
exports.KnownAddOnFeatures = void 0;
(function (KnownAddOnFeatures) {
    /** RepairManager */
    KnownAddOnFeatures["RepairManager"] = "RepairManager";
    /** DnsService */
    KnownAddOnFeatures["DnsService"] = "DnsService";
    /** BackupRestoreService */
    KnownAddOnFeatures["BackupRestoreService"] = "BackupRestoreService";
    /** ResourceMonitorService */
    KnownAddOnFeatures["ResourceMonitorService"] = "ResourceMonitorService";
})(exports.KnownAddOnFeatures || (exports.KnownAddOnFeatures = {}));
/** Known values of {@link ClusterEnvironment} that the service accepts. */
exports.KnownClusterEnvironment = void 0;
(function (KnownClusterEnvironment) {
    /** Windows */
    KnownClusterEnvironment["Windows"] = "Windows";
    /** Linux */
    KnownClusterEnvironment["Linux"] = "Linux";
})(exports.KnownClusterEnvironment || (exports.KnownClusterEnvironment = {}));
/** Known values of {@link StoreName} that the service accepts. */
exports.KnownStoreName = void 0;
(function (KnownStoreName) {
    /** AddressBook */
    KnownStoreName["AddressBook"] = "AddressBook";
    /** AuthRoot */
    KnownStoreName["AuthRoot"] = "AuthRoot";
    /** CertificateAuthority */
    KnownStoreName["CertificateAuthority"] = "CertificateAuthority";
    /** Disallowed */
    KnownStoreName["Disallowed"] = "Disallowed";
    /** My */
    KnownStoreName["My"] = "My";
    /** Root */
    KnownStoreName["Root"] = "Root";
    /** TrustedPeople */
    KnownStoreName["TrustedPeople"] = "TrustedPeople";
    /** TrustedPublisher */
    KnownStoreName["TrustedPublisher"] = "TrustedPublisher";
})(exports.KnownStoreName || (exports.KnownStoreName = {}));
/** Known values of {@link ClusterState} that the service accepts. */
exports.KnownClusterState = void 0;
(function (KnownClusterState) {
    /** WaitingForNodes */
    KnownClusterState["WaitingForNodes"] = "WaitingForNodes";
    /** Deploying */
    KnownClusterState["Deploying"] = "Deploying";
    /** BaselineUpgrade */
    KnownClusterState["BaselineUpgrade"] = "BaselineUpgrade";
    /** UpdatingUserConfiguration */
    KnownClusterState["UpdatingUserConfiguration"] = "UpdatingUserConfiguration";
    /** UpdatingUserCertificate */
    KnownClusterState["UpdatingUserCertificate"] = "UpdatingUserCertificate";
    /** UpdatingInfrastructure */
    KnownClusterState["UpdatingInfrastructure"] = "UpdatingInfrastructure";
    /** EnforcingClusterVersion */
    KnownClusterState["EnforcingClusterVersion"] = "EnforcingClusterVersion";
    /** UpgradeServiceUnreachable */
    KnownClusterState["UpgradeServiceUnreachable"] = "UpgradeServiceUnreachable";
    /** AutoScale */
    KnownClusterState["AutoScale"] = "AutoScale";
    /** Ready */
    KnownClusterState["Ready"] = "Ready";
})(exports.KnownClusterState || (exports.KnownClusterState = {}));
/** Known values of {@link DurabilityLevel} that the service accepts. */
exports.KnownDurabilityLevel = void 0;
(function (KnownDurabilityLevel) {
    /** Bronze */
    KnownDurabilityLevel["Bronze"] = "Bronze";
    /** Silver */
    KnownDurabilityLevel["Silver"] = "Silver";
    /** Gold */
    KnownDurabilityLevel["Gold"] = "Gold";
})(exports.KnownDurabilityLevel || (exports.KnownDurabilityLevel = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link ReliabilityLevel} that the service accepts. */
exports.KnownReliabilityLevel = void 0;
(function (KnownReliabilityLevel) {
    /** None */
    KnownReliabilityLevel["None"] = "None";
    /** Bronze */
    KnownReliabilityLevel["Bronze"] = "Bronze";
    /** Silver */
    KnownReliabilityLevel["Silver"] = "Silver";
    /** Gold */
    KnownReliabilityLevel["Gold"] = "Gold";
    /** Platinum */
    KnownReliabilityLevel["Platinum"] = "Platinum";
})(exports.KnownReliabilityLevel || (exports.KnownReliabilityLevel = {}));
/** Known values of {@link UpgradeMode} that the service accepts. */
exports.KnownUpgradeMode = void 0;
(function (KnownUpgradeMode) {
    /** The cluster will be automatically upgraded to the latest Service Fabric runtime version, **upgradeWave** will determine when the upgrade starts after the new version becomes available. */
    KnownUpgradeMode["Automatic"] = "Automatic";
    /** The cluster will not be automatically upgraded to the latest Service Fabric runtime version. The cluster is upgraded by setting the **clusterCodeVersion** property in the cluster resource. */
    KnownUpgradeMode["Manual"] = "Manual";
})(exports.KnownUpgradeMode || (exports.KnownUpgradeMode = {}));
/** Known values of {@link SfZonalUpgradeMode} that the service accepts. */
exports.KnownSfZonalUpgradeMode = void 0;
(function (KnownSfZonalUpgradeMode) {
    /** VMs under the node type are grouped into UDs and ignore the zone info in five UDs. This setting causes UDs across all zones to be upgraded at the same time. This deployment mode is faster for upgrades, we don't recommend it because it goes against the SDP guidelines, which state that the updates should be applied to one zone at a time. */
    KnownSfZonalUpgradeMode["Parallel"] = "Parallel";
    /** If this value is omitted or set to Hierarchical, VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone. This update process is safer for the cluster and the user application. */
    KnownSfZonalUpgradeMode["Hierarchical"] = "Hierarchical";
})(exports.KnownSfZonalUpgradeMode || (exports.KnownSfZonalUpgradeMode = {}));
/** Known values of {@link VmssZonalUpgradeMode} that the service accepts. */
exports.KnownVmssZonalUpgradeMode = void 0;
(function (KnownVmssZonalUpgradeMode) {
    /** Updates will happen in all Availability Zones at once for the virtual machine scale sets. */
    KnownVmssZonalUpgradeMode["Parallel"] = "Parallel";
    /** VMs are grouped to reflect the zonal distribution in up to 15 UDs. Each of the three zones has five UDs. This ensures that the zones are updated one at a time, moving to next zone only after completing five UDs within the first zone. */
    KnownVmssZonalUpgradeMode["Hierarchical"] = "Hierarchical";
})(exports.KnownVmssZonalUpgradeMode || (exports.KnownVmssZonalUpgradeMode = {}));
/** Known values of {@link ClusterUpgradeCadence} that the service accepts. */
exports.KnownClusterUpgradeCadence = void 0;
(function (KnownClusterUpgradeCadence) {
    /** Cluster upgrade starts immediately after a new version is rolled out. Recommended for Test\/Dev clusters. */
    KnownClusterUpgradeCadence["Wave0"] = "Wave0";
    /** Cluster upgrade starts 7 days after a new version is rolled out. Recommended for Pre-prod clusters. */
    KnownClusterUpgradeCadence["Wave1"] = "Wave1";
    /** Cluster upgrade starts 14 days after a new version is rolled out. Recommended for Production clusters. */
    KnownClusterUpgradeCadence["Wave2"] = "Wave2";
})(exports.KnownClusterUpgradeCadence || (exports.KnownClusterUpgradeCadence = {}));
/** Known values of {@link NotificationCategory} that the service accepts. */
exports.KnownNotificationCategory = void 0;
(function (KnownNotificationCategory) {
    /** Notification will be regarding wave progress. */
    KnownNotificationCategory["WaveProgress"] = "WaveProgress";
})(exports.KnownNotificationCategory || (exports.KnownNotificationCategory = {}));
/** Known values of {@link NotificationLevel} that the service accepts. */
exports.KnownNotificationLevel = void 0;
(function (KnownNotificationLevel) {
    /** Receive only critical notifications. */
    KnownNotificationLevel["Critical"] = "Critical";
    /** Receive all notifications. */
    KnownNotificationLevel["All"] = "All";
})(exports.KnownNotificationLevel || (exports.KnownNotificationLevel = {}));
/** Known values of {@link NotificationChannel} that the service accepts. */
exports.KnownNotificationChannel = void 0;
(function (KnownNotificationChannel) {
    /** For email user receivers. In this case, the parameter receivers should be a list of email addresses that will receive the notifications. */
    KnownNotificationChannel["EmailUser"] = "EmailUser";
    /** For subscription receivers. In this case, the parameter receivers should be a list of roles of the subscription for the cluster (eg. Owner, AccountAdmin, etc) that will receive the notifications. */
    KnownNotificationChannel["EmailSubscription"] = "EmailSubscription";
})(exports.KnownNotificationChannel || (exports.KnownNotificationChannel = {}));
/** Known values of {@link ClusterVersionsEnvironment} that the service accepts. */
exports.KnownClusterVersionsEnvironment = void 0;
(function (KnownClusterVersionsEnvironment) {
    /** Windows */
    KnownClusterVersionsEnvironment["Windows"] = "Windows";
    /** Linux */
    KnownClusterVersionsEnvironment["Linux"] = "Linux";
})(exports.KnownClusterVersionsEnvironment || (exports.KnownClusterVersionsEnvironment = {}));
/** Known values of {@link ArmUpgradeFailureAction} that the service accepts. */
exports.KnownArmUpgradeFailureAction = void 0;
(function (KnownArmUpgradeFailureAction) {
    /** Indicates that a rollback of the upgrade will be performed by Service Fabric if the upgrade fails. */
    KnownArmUpgradeFailureAction["Rollback"] = "Rollback";
    /** Indicates that a manual repair will need to be performed by the administrator if the upgrade fails. Service Fabric will not proceed to the next upgrade domain automatically. */
    KnownArmUpgradeFailureAction["Manual"] = "Manual";
})(exports.KnownArmUpgradeFailureAction || (exports.KnownArmUpgradeFailureAction = {}));
/** Known values of {@link RollingUpgradeMode} that the service accepts. */
exports.KnownRollingUpgradeMode = void 0;
(function (KnownRollingUpgradeMode) {
    /** Indicates the upgrade mode is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownRollingUpgradeMode["Invalid"] = "Invalid";
    /** The upgrade will proceed automatically without performing any health monitoring. The value is 1 */
    KnownRollingUpgradeMode["UnmonitoredAuto"] = "UnmonitoredAuto";
    /** The upgrade will stop after completing each upgrade domain, giving the opportunity to manually monitor health before proceeding. The value is 2 */
    KnownRollingUpgradeMode["UnmonitoredManual"] = "UnmonitoredManual";
    /** The upgrade will stop after completing each upgrade domain and automatically monitor health before proceeding. The value is 3 */
    KnownRollingUpgradeMode["Monitored"] = "Monitored";
})(exports.KnownRollingUpgradeMode || (exports.KnownRollingUpgradeMode = {}));
/** Known values of {@link ServiceKind} that the service accepts. */
exports.KnownServiceKind = void 0;
(function (KnownServiceKind) {
    /** Indicates the service kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownServiceKind["Invalid"] = "Invalid";
    /** Does not use Service Fabric to make its state highly available or reliable. The value is 1. */
    KnownServiceKind["Stateless"] = "Stateless";
    /** Uses Service Fabric to make its state or part of its state highly available and reliable. The value is 2. */
    KnownServiceKind["Stateful"] = "Stateful";
})(exports.KnownServiceKind || (exports.KnownServiceKind = {}));
/** Known values of {@link PartitionScheme} that the service accepts. */
exports.KnownPartitionScheme = void 0;
(function (KnownPartitionScheme) {
    /** Indicates the partition kind is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownPartitionScheme["Invalid"] = "Invalid";
    /** Indicates that the partition is based on string names, and is a SingletonPartitionSchemeDescription object, The value is 1. */
    KnownPartitionScheme["Singleton"] = "Singleton";
    /** Indicates that the partition is based on Int64 key ranges, and is a UniformInt64RangePartitionSchemeDescription object. The value is 2. */
    KnownPartitionScheme["UniformInt64Range"] = "UniformInt64Range";
    /** Indicates that the partition is based on string names, and is a NamedPartitionSchemeDescription object. The value is 3 */
    KnownPartitionScheme["Named"] = "Named";
})(exports.KnownPartitionScheme || (exports.KnownPartitionScheme = {}));
/** Known values of {@link ArmServicePackageActivationMode} that the service accepts. */
exports.KnownArmServicePackageActivationMode = void 0;
(function (KnownArmServicePackageActivationMode) {
    /** Indicates the application package activation mode will use shared process. */
    KnownArmServicePackageActivationMode["SharedProcess"] = "SharedProcess";
    /** Indicates the application package activation mode will use exclusive process. */
    KnownArmServicePackageActivationMode["ExclusiveProcess"] = "ExclusiveProcess";
})(exports.KnownArmServicePackageActivationMode || (exports.KnownArmServicePackageActivationMode = {}));
/** Known values of {@link ServiceCorrelationScheme} that the service accepts. */
exports.KnownServiceCorrelationScheme = void 0;
(function (KnownServiceCorrelationScheme) {
    /** An invalid correlation scheme. Cannot be used. The value is zero. */
    KnownServiceCorrelationScheme["Invalid"] = "Invalid";
    /** Indicates that this service has an affinity relationship with another service. Provided for backwards compatibility, consider preferring the Aligned or NonAlignedAffinity options. The value is 1. */
    KnownServiceCorrelationScheme["Affinity"] = "Affinity";
    /** Aligned affinity ensures that the primaries of the partitions of the affinitized services are collocated on the same nodes. This is the default and is the same as selecting the Affinity scheme. The value is 2. */
    KnownServiceCorrelationScheme["AlignedAffinity"] = "AlignedAffinity";
    /** Non-Aligned affinity guarantees that all replicas of each service will be placed on the same nodes. Unlike Aligned Affinity, this does not guarantee that replicas of particular role will be collocated. The value is 3. */
    KnownServiceCorrelationScheme["NonAlignedAffinity"] = "NonAlignedAffinity";
})(exports.KnownServiceCorrelationScheme || (exports.KnownServiceCorrelationScheme = {}));
/** Known values of {@link ServiceLoadMetricWeight} that the service accepts. */
exports.KnownServiceLoadMetricWeight = void 0;
(function (KnownServiceLoadMetricWeight) {
    /** Disables resource balancing for this metric. This value is zero. */
    KnownServiceLoadMetricWeight["Zero"] = "Zero";
    /** Specifies the metric weight of the service load as Low. The value is 1. */
    KnownServiceLoadMetricWeight["Low"] = "Low";
    /** Specifies the metric weight of the service load as Medium. The value is 2. */
    KnownServiceLoadMetricWeight["Medium"] = "Medium";
    /** Specifies the metric weight of the service load as High. The value is 3. */
    KnownServiceLoadMetricWeight["High"] = "High";
})(exports.KnownServiceLoadMetricWeight || (exports.KnownServiceLoadMetricWeight = {}));
/** Known values of {@link ServicePlacementPolicyType} that the service accepts. */
exports.KnownServicePlacementPolicyType = void 0;
(function (KnownServicePlacementPolicyType) {
    /** Indicates the type of the placement policy is invalid. All Service Fabric enumerations have the invalid type. The value is zero. */
    KnownServicePlacementPolicyType["Invalid"] = "Invalid";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementInvalidDomainPolicyDescription, which indicates that a particular fault or upgrade domain cannot be used for placement of this service. The value is 1. */
    KnownServicePlacementPolicyType["InvalidDomain"] = "InvalidDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription indicating that the replicas of the service must be placed in a specific domain. The value is 2. */
    KnownServicePlacementPolicyType["RequiredDomain"] = "RequiredDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementPreferPrimaryDomainPolicyDescription, which indicates that if possible the Primary replica for the partitions of the service should be located in a particular domain as an optimization. The value is 3. */
    KnownServicePlacementPolicyType["PreferredPrimaryDomain"] = "PreferredPrimaryDomain";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementRequireDomainDistributionPolicyDescription, indicating that the system will disallow placement of any two replicas from the same partition in the same domain at any time. The value is 4. */
    KnownServicePlacementPolicyType["RequiredDomainDistribution"] = "RequiredDomainDistribution";
    /** Indicates that the ServicePlacementPolicyDescription is of type ServicePlacementNonPartiallyPlaceServicePolicyDescription, which indicates that if possible all replicas of a particular partition of the service should be placed atomically. The value is 5. */
    KnownServicePlacementPolicyType["NonPartiallyPlaceService"] = "NonPartiallyPlaceService";
})(exports.KnownServicePlacementPolicyType || (exports.KnownServicePlacementPolicyType = {}));
/** Known values of {@link MoveCost} that the service accepts. */
exports.KnownMoveCost = void 0;
(function (KnownMoveCost) {
    /** Zero move cost. This value is zero. */
    KnownMoveCost["Zero"] = "Zero";
    /** Specifies the move cost of the service as Low. The value is 1. */
    KnownMoveCost["Low"] = "Low";
    /** Specifies the move cost of the service as Medium. The value is 2. */
    KnownMoveCost["Medium"] = "Medium";
    /** Specifies the move cost of the service as High. The value is 3. */
    KnownMoveCost["High"] = "High";
})(exports.KnownMoveCost || (exports.KnownMoveCost = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ClusterVersionDetails = {
    type: {
        name: "Composite",
        className: "ClusterVersionDetails",
        modelProperties: {
            codeVersion: {
                serializedName: "codeVersion",
                type: {
                    name: "String"
                }
            },
            supportExpiryUtc: {
                serializedName: "supportExpiryUtc",
                type: {
                    name: "String"
                }
            },
            environment: {
                serializedName: "environment",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureActiveDirectory = {
    type: {
        name: "Composite",
        className: "AzureActiveDirectory",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                type: {
                    name: "String"
                }
            },
            clusterApplication: {
                serializedName: "clusterApplication",
                type: {
                    name: "String"
                }
            },
            clientApplication: {
                serializedName: "clientApplication",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateDescription = {
    type: {
        name: "Composite",
        className: "CertificateDescription",
        modelProperties: {
            thumbprint: {
                serializedName: "thumbprint",
                required: true,
                type: {
                    name: "String"
                }
            },
            thumbprintSecondary: {
                serializedName: "thumbprintSecondary",
                type: {
                    name: "String"
                }
            },
            x509StoreName: {
                serializedName: "x509StoreName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerCertificateCommonNames = {
    type: {
        name: "Composite",
        className: "ServerCertificateCommonNames",
        modelProperties: {
            commonNames: {
                serializedName: "commonNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServerCertificateCommonName"
                        }
                    }
                }
            },
            x509StoreName: {
                serializedName: "x509StoreName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServerCertificateCommonName = {
    type: {
        name: "Composite",
        className: "ServerCertificateCommonName",
        modelProperties: {
            certificateCommonName: {
                serializedName: "certificateCommonName",
                required: true,
                type: {
                    name: "String"
                }
            },
            certificateIssuerThumbprint: {
                serializedName: "certificateIssuerThumbprint",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientCertificateCommonName = {
    type: {
        name: "Composite",
        className: "ClientCertificateCommonName",
        modelProperties: {
            isAdmin: {
                serializedName: "isAdmin",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            certificateCommonName: {
                serializedName: "certificateCommonName",
                required: true,
                type: {
                    name: "String"
                }
            },
            certificateIssuerThumbprint: {
                serializedName: "certificateIssuerThumbprint",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClientCertificateThumbprint = {
    type: {
        name: "Composite",
        className: "ClientCertificateThumbprint",
        modelProperties: {
            isAdmin: {
                serializedName: "isAdmin",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            certificateThumbprint: {
                serializedName: "certificateThumbprint",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsStorageAccountConfig = {
    type: {
        name: "Composite",
        className: "DiagnosticsStorageAccountConfig",
        modelProperties: {
            storageAccountName: {
                serializedName: "storageAccountName",
                required: true,
                type: {
                    name: "String"
                }
            },
            protectedAccountKeyName: {
                serializedName: "protectedAccountKeyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            protectedAccountKeyName2: {
                serializedName: "protectedAccountKeyName2",
                type: {
                    name: "String"
                }
            },
            blobEndpoint: {
                serializedName: "blobEndpoint",
                required: true,
                type: {
                    name: "String"
                }
            },
            queueEndpoint: {
                serializedName: "queueEndpoint",
                required: true,
                type: {
                    name: "String"
                }
            },
            tableEndpoint: {
                serializedName: "tableEndpoint",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SettingsSectionDescription = {
    type: {
        name: "Composite",
        className: "SettingsSectionDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SettingsParameterDescription"
                        }
                    }
                }
            }
        }
    }
};
const SettingsParameterDescription = {
    type: {
        name: "Composite",
        className: "SettingsParameterDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeTypeDescription = {
    type: {
        name: "Composite",
        className: "NodeTypeDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            placementProperties: {
                serializedName: "placementProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            capacities: {
                serializedName: "capacities",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            clientConnectionEndpointPort: {
                serializedName: "clientConnectionEndpointPort",
                required: true,
                type: {
                    name: "Number"
                }
            },
            httpGatewayEndpointPort: {
                serializedName: "httpGatewayEndpointPort",
                required: true,
                type: {
                    name: "Number"
                }
            },
            durabilityLevel: {
                serializedName: "durabilityLevel",
                type: {
                    name: "String"
                }
            },
            applicationPorts: {
                serializedName: "applicationPorts",
                type: {
                    name: "Composite",
                    className: "EndpointRangeDescription"
                }
            },
            ephemeralPorts: {
                serializedName: "ephemeralPorts",
                type: {
                    name: "Composite",
                    className: "EndpointRangeDescription"
                }
            },
            isPrimary: {
                serializedName: "isPrimary",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            vmInstanceCount: {
                constraints: {
                    InclusiveMaximum: 2147483647,
                    InclusiveMinimum: 0
                },
                serializedName: "vmInstanceCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            reverseProxyEndpointPort: {
                serializedName: "reverseProxyEndpointPort",
                type: {
                    name: "Number"
                }
            },
            isStateless: {
                serializedName: "isStateless",
                type: {
                    name: "Boolean"
                }
            },
            multipleAvailabilityZones: {
                serializedName: "multipleAvailabilityZones",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const EndpointRangeDescription = {
    type: {
        name: "Composite",
        className: "EndpointRangeDescription",
        modelProperties: {
            startPort: {
                serializedName: "startPort",
                required: true,
                type: {
                    name: "Number"
                }
            },
            endPort: {
                serializedName: "endPort",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClusterUpgradePolicy = {
    type: {
        name: "Composite",
        className: "ClusterUpgradePolicy",
        modelProperties: {
            forceRestart: {
                serializedName: "forceRestart",
                type: {
                    name: "Boolean"
                }
            },
            upgradeReplicaSetCheckTimeout: {
                serializedName: "upgradeReplicaSetCheckTimeout",
                required: true,
                type: {
                    name: "String"
                }
            },
            healthCheckWaitDuration: {
                serializedName: "healthCheckWaitDuration",
                required: true,
                type: {
                    name: "String"
                }
            },
            healthCheckStableDuration: {
                serializedName: "healthCheckStableDuration",
                required: true,
                type: {
                    name: "String"
                }
            },
            healthCheckRetryTimeout: {
                serializedName: "healthCheckRetryTimeout",
                required: true,
                type: {
                    name: "String"
                }
            },
            upgradeTimeout: {
                serializedName: "upgradeTimeout",
                required: true,
                type: {
                    name: "String"
                }
            },
            upgradeDomainTimeout: {
                serializedName: "upgradeDomainTimeout",
                required: true,
                type: {
                    name: "String"
                }
            },
            healthPolicy: {
                serializedName: "healthPolicy",
                type: {
                    name: "Composite",
                    className: "ClusterHealthPolicy"
                }
            },
            deltaHealthPolicy: {
                serializedName: "deltaHealthPolicy",
                type: {
                    name: "Composite",
                    className: "ClusterUpgradeDeltaHealthPolicy"
                }
            }
        }
    }
};
const ClusterHealthPolicy = {
    type: {
        name: "Composite",
        className: "ClusterHealthPolicy",
        modelProperties: {
            maxPercentUnhealthyNodes: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyNodes",
                type: {
                    name: "Number"
                }
            },
            maxPercentUnhealthyApplications: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyApplications",
                type: {
                    name: "Number"
                }
            },
            applicationHealthPolicies: {
                serializedName: "applicationHealthPolicies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ApplicationHealthPolicy" }
                    }
                }
            }
        }
    }
};
const ApplicationHealthPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationHealthPolicy",
        modelProperties: {
            defaultServiceTypeHealthPolicy: {
                serializedName: "defaultServiceTypeHealthPolicy",
                type: {
                    name: "Composite",
                    className: "ServiceTypeHealthPolicy"
                }
            },
            serviceTypeHealthPolicies: {
                serializedName: "serviceTypeHealthPolicies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ServiceTypeHealthPolicy" }
                    }
                }
            }
        }
    }
};
const ServiceTypeHealthPolicy = {
    type: {
        name: "Composite",
        className: "ServiceTypeHealthPolicy",
        modelProperties: {
            maxPercentUnhealthyServices: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyServices",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ClusterUpgradeDeltaHealthPolicy = {
    type: {
        name: "Composite",
        className: "ClusterUpgradeDeltaHealthPolicy",
        modelProperties: {
            maxPercentDeltaUnhealthyNodes: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentDeltaUnhealthyNodes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maxPercentUpgradeDomainDeltaUnhealthyNodes: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUpgradeDomainDeltaUnhealthyNodes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maxPercentDeltaUnhealthyApplications: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentDeltaUnhealthyApplications",
                required: true,
                type: {
                    name: "Number"
                }
            },
            applicationDeltaHealthPolicies: {
                serializedName: "applicationDeltaHealthPolicies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ApplicationDeltaHealthPolicy"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationDeltaHealthPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationDeltaHealthPolicy",
        modelProperties: {
            defaultServiceTypeDeltaHealthPolicy: {
                serializedName: "defaultServiceTypeDeltaHealthPolicy",
                type: {
                    name: "Composite",
                    className: "ServiceTypeDeltaHealthPolicy"
                }
            },
            serviceTypeDeltaHealthPolicies: {
                serializedName: "serviceTypeDeltaHealthPolicies",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "ServiceTypeDeltaHealthPolicy"
                        }
                    }
                }
            }
        }
    }
};
const ServiceTypeDeltaHealthPolicy = {
    type: {
        name: "Composite",
        className: "ServiceTypeDeltaHealthPolicy",
        modelProperties: {
            maxPercentDeltaUnhealthyServices: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentDeltaUnhealthyServices",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationTypeVersionsCleanupPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationTypeVersionsCleanupPolicy",
        modelProperties: {
            maxUnusedVersionsToKeep: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "maxUnusedVersionsToKeep",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Notification = {
    type: {
        name: "Composite",
        className: "Notification",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            notificationCategory: {
                serializedName: "notificationCategory",
                required: true,
                type: {
                    name: "String"
                }
            },
            notificationLevel: {
                serializedName: "notificationLevel",
                required: true,
                type: {
                    name: "String"
                }
            },
            notificationTargets: {
                serializedName: "notificationTargets",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NotificationTarget"
                        }
                    }
                }
            }
        }
    }
};
const NotificationTarget = {
    type: {
        name: "Composite",
        className: "NotificationTarget",
        modelProperties: {
            notificationChannel: {
                serializedName: "notificationChannel",
                required: true,
                type: {
                    name: "String"
                }
            },
            receivers: {
                serializedName: "receivers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModelError"
                }
            }
        }
    }
};
const ErrorModelError = {
    type: {
        name: "Composite",
        className: "ErrorModelError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterUpdateParameters = {
    type: {
        name: "Composite",
        className: "ClusterUpdateParameters",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            addOnFeatures: {
                serializedName: "properties.addOnFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            certificate: {
                serializedName: "properties.certificate",
                type: {
                    name: "Composite",
                    className: "CertificateDescription"
                }
            },
            certificateCommonNames: {
                serializedName: "properties.certificateCommonNames",
                type: {
                    name: "Composite",
                    className: "ServerCertificateCommonNames"
                }
            },
            clientCertificateCommonNames: {
                serializedName: "properties.clientCertificateCommonNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientCertificateCommonName"
                        }
                    }
                }
            },
            clientCertificateThumbprints: {
                serializedName: "properties.clientCertificateThumbprints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientCertificateThumbprint"
                        }
                    }
                }
            },
            clusterCodeVersion: {
                serializedName: "properties.clusterCodeVersion",
                type: {
                    name: "String"
                }
            },
            eventStoreServiceEnabled: {
                serializedName: "properties.eventStoreServiceEnabled",
                type: {
                    name: "Boolean"
                }
            },
            fabricSettings: {
                serializedName: "properties.fabricSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SettingsSectionDescription"
                        }
                    }
                }
            },
            nodeTypes: {
                serializedName: "properties.nodeTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NodeTypeDescription"
                        }
                    }
                }
            },
            reliabilityLevel: {
                serializedName: "properties.reliabilityLevel",
                type: {
                    name: "String"
                }
            },
            reverseProxyCertificate: {
                serializedName: "properties.reverseProxyCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDescription"
                }
            },
            upgradeDescription: {
                serializedName: "properties.upgradeDescription",
                type: {
                    name: "Composite",
                    className: "ClusterUpgradePolicy"
                }
            },
            applicationTypeVersionsCleanupPolicy: {
                serializedName: "properties.applicationTypeVersionsCleanupPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationTypeVersionsCleanupPolicy"
                }
            },
            upgradeMode: {
                defaultValue: "Automatic",
                serializedName: "properties.upgradeMode",
                type: {
                    name: "String"
                }
            },
            sfZonalUpgradeMode: {
                serializedName: "properties.sfZonalUpgradeMode",
                type: {
                    name: "String"
                }
            },
            vmssZonalUpgradeMode: {
                serializedName: "properties.vmssZonalUpgradeMode",
                type: {
                    name: "String"
                }
            },
            infrastructureServiceManager: {
                serializedName: "properties.infrastructureServiceManager",
                type: {
                    name: "Boolean"
                }
            },
            upgradeWave: {
                serializedName: "properties.upgradeWave",
                type: {
                    name: "String"
                }
            },
            upgradePauseStartTimestampUtc: {
                serializedName: "properties.upgradePauseStartTimestampUtc",
                type: {
                    name: "DateTime"
                }
            },
            upgradePauseEndTimestampUtc: {
                serializedName: "properties.upgradePauseEndTimestampUtc",
                type: {
                    name: "DateTime"
                }
            },
            waveUpgradePaused: {
                serializedName: "properties.waveUpgradePaused",
                type: {
                    name: "Boolean"
                }
            },
            notifications: {
                serializedName: "properties.notifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Notification"
                        }
                    }
                }
            }
        }
    }
};
const ClusterListResult = {
    type: {
        name: "Composite",
        className: "ClusterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cluster"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterCodeVersionsListResult = {
    type: {
        name: "Composite",
        className: "ClusterCodeVersionsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterCodeVersionsResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterCodeVersionsResult = {
    type: {
        name: "Composite",
        className: "ClusterCodeVersionsResult",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            codeVersion: {
                serializedName: "properties.codeVersion",
                type: {
                    name: "String"
                }
            },
            supportExpiryUtc: {
                serializedName: "properties.supportExpiryUtc",
                type: {
                    name: "String"
                }
            },
            environment: {
                serializedName: "properties.environment",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpgradableVersionsDescription = {
    type: {
        name: "Composite",
        className: "UpgradableVersionsDescription",
        modelProperties: {
            targetVersion: {
                serializedName: "targetVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UpgradableVersionPathResult = {
    type: {
        name: "Composite",
        className: "UpgradableVersionPathResult",
        modelProperties: {
            supportedPath: {
                serializedName: "supportedPath",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OperationResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationResult = {
    type: {
        name: "Composite",
        className: "OperationResult",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "AvailableOperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableOperationDisplay = {
    type: {
        name: "Composite",
        className: "AvailableOperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const ApplicationTypeResourceList = {
    type: {
        name: "Composite",
        className: "ApplicationTypeResourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationTypeResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationTypeVersionResourceList = {
    type: {
        name: "Composite",
        className: "ApplicationTypeVersionResourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationTypeVersionResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedIdentity = {
    type: {
        name: "Composite",
        className: "ManagedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationResourceUpdateProperties = {
    type: {
        name: "Composite",
        className: "ApplicationResourceUpdateProperties",
        modelProperties: {
            typeVersion: {
                serializedName: "typeVersion",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            upgradePolicy: {
                serializedName: "upgradePolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationUpgradePolicy"
                }
            },
            minimumNodes: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "minimumNodes",
                type: {
                    name: "Number"
                }
            },
            maximumNodes: {
                defaultValue: 0,
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "maximumNodes",
                type: {
                    name: "Number"
                }
            },
            removeApplicationCapacity: {
                serializedName: "removeApplicationCapacity",
                type: {
                    name: "Boolean"
                }
            },
            metrics: {
                serializedName: "metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationMetricDescription"
                        }
                    }
                }
            },
            managedIdentities: {
                serializedName: "managedIdentities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationUserAssignedIdentity"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationUpgradePolicy = {
    type: {
        name: "Composite",
        className: "ApplicationUpgradePolicy",
        modelProperties: {
            upgradeReplicaSetCheckTimeout: {
                serializedName: "upgradeReplicaSetCheckTimeout",
                type: {
                    name: "String"
                }
            },
            forceRestart: {
                defaultValue: false,
                serializedName: "forceRestart",
                type: {
                    name: "Boolean"
                }
            },
            rollingUpgradeMonitoringPolicy: {
                serializedName: "rollingUpgradeMonitoringPolicy",
                type: {
                    name: "Composite",
                    className: "ArmRollingUpgradeMonitoringPolicy"
                }
            },
            applicationHealthPolicy: {
                serializedName: "applicationHealthPolicy",
                type: {
                    name: "Composite",
                    className: "ArmApplicationHealthPolicy"
                }
            },
            upgradeMode: {
                defaultValue: "Monitored",
                serializedName: "upgradeMode",
                type: {
                    name: "String"
                }
            },
            recreateApplication: {
                serializedName: "recreateApplication",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArmRollingUpgradeMonitoringPolicy = {
    type: {
        name: "Composite",
        className: "ArmRollingUpgradeMonitoringPolicy",
        modelProperties: {
            failureAction: {
                serializedName: "failureAction",
                type: {
                    name: "String"
                }
            },
            healthCheckWaitDuration: {
                defaultValue: "0",
                serializedName: "healthCheckWaitDuration",
                type: {
                    name: "String"
                }
            },
            healthCheckStableDuration: {
                defaultValue: "PT0H2M0S",
                serializedName: "healthCheckStableDuration",
                type: {
                    name: "String"
                }
            },
            healthCheckRetryTimeout: {
                defaultValue: "PT0H10M0S",
                serializedName: "healthCheckRetryTimeout",
                type: {
                    name: "String"
                }
            },
            upgradeTimeout: {
                defaultValue: "P10675199DT02H48M05.4775807S",
                serializedName: "upgradeTimeout",
                type: {
                    name: "String"
                }
            },
            upgradeDomainTimeout: {
                defaultValue: "P10675199DT02H48M05.4775807S",
                serializedName: "upgradeDomainTimeout",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ArmApplicationHealthPolicy = {
    type: {
        name: "Composite",
        className: "ArmApplicationHealthPolicy",
        modelProperties: {
            considerWarningAsError: {
                defaultValue: false,
                serializedName: "considerWarningAsError",
                type: {
                    name: "Boolean"
                }
            },
            maxPercentUnhealthyDeployedApplications: {
                defaultValue: 0,
                serializedName: "maxPercentUnhealthyDeployedApplications",
                type: {
                    name: "Number"
                }
            },
            defaultServiceTypeHealthPolicy: {
                serializedName: "defaultServiceTypeHealthPolicy",
                type: {
                    name: "Composite",
                    className: "ArmServiceTypeHealthPolicy"
                }
            },
            serviceTypeHealthPolicyMap: {
                serializedName: "serviceTypeHealthPolicyMap",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "ArmServiceTypeHealthPolicy" }
                    }
                }
            }
        }
    }
};
const ArmServiceTypeHealthPolicy = {
    type: {
        name: "Composite",
        className: "ArmServiceTypeHealthPolicy",
        modelProperties: {
            maxPercentUnhealthyServices: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyServices",
                type: {
                    name: "Number"
                }
            },
            maxPercentUnhealthyPartitionsPerService: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyPartitionsPerService",
                type: {
                    name: "Number"
                }
            },
            maxPercentUnhealthyReplicasPerPartition: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 0
                },
                serializedName: "maxPercentUnhealthyReplicasPerPartition",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationMetricDescription = {
    type: {
        name: "Composite",
        className: "ApplicationMetricDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            maximumCapacity: {
                serializedName: "maximumCapacity",
                type: {
                    name: "Number"
                }
            },
            reservationCapacity: {
                serializedName: "reservationCapacity",
                type: {
                    name: "Number"
                }
            },
            totalApplicationCapacity: {
                serializedName: "totalApplicationCapacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationUserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "ApplicationUserAssignedIdentity",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            principalId: {
                serializedName: "principalId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationResourceList = {
    type: {
        name: "Composite",
        className: "ApplicationResourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartitionSchemeDescription = {
    type: {
        name: "Composite",
        className: "PartitionSchemeDescription",
        uberParent: "PartitionSchemeDescription",
        polymorphicDiscriminator: {
            serializedName: "partitionScheme",
            clientName: "partitionScheme"
        },
        modelProperties: {
            partitionScheme: {
                serializedName: "partitionScheme",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceResourcePropertiesBase = {
    type: {
        name: "Composite",
        className: "ServiceResourcePropertiesBase",
        modelProperties: {
            placementConstraints: {
                serializedName: "placementConstraints",
                type: {
                    name: "String"
                }
            },
            correlationScheme: {
                serializedName: "correlationScheme",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceCorrelationDescription"
                        }
                    }
                }
            },
            serviceLoadMetrics: {
                serializedName: "serviceLoadMetrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceLoadMetricDescription"
                        }
                    }
                }
            },
            servicePlacementPolicies: {
                serializedName: "servicePlacementPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServicePlacementPolicyDescription"
                        }
                    }
                }
            },
            defaultMoveCost: {
                serializedName: "defaultMoveCost",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceCorrelationDescription = {
    type: {
        name: "Composite",
        className: "ServiceCorrelationDescription",
        modelProperties: {
            scheme: {
                serializedName: "scheme",
                required: true,
                type: {
                    name: "String"
                }
            },
            serviceName: {
                serializedName: "serviceName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceLoadMetricDescription = {
    type: {
        name: "Composite",
        className: "ServiceLoadMetricDescription",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                type: {
                    name: "String"
                }
            },
            primaryDefaultLoad: {
                serializedName: "primaryDefaultLoad",
                type: {
                    name: "Number"
                }
            },
            secondaryDefaultLoad: {
                serializedName: "secondaryDefaultLoad",
                type: {
                    name: "Number"
                }
            },
            defaultLoad: {
                serializedName: "defaultLoad",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServicePlacementPolicyDescription = {
    serializedName: "ServicePlacementPolicyDescription",
    type: {
        name: "Composite",
        className: "ServicePlacementPolicyDescription",
        uberParent: "ServicePlacementPolicyDescription",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceResourceList = {
    type: {
        name: "Composite",
        className: "ServiceResourceList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Cluster = {
    type: {
        name: "Composite",
        className: "Cluster",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { addOnFeatures: {
                serializedName: "properties.addOnFeatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availableClusterVersions: {
                serializedName: "properties.availableClusterVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterVersionDetails"
                        }
                    }
                }
            }, azureActiveDirectory: {
                serializedName: "properties.azureActiveDirectory",
                type: {
                    name: "Composite",
                    className: "AzureActiveDirectory"
                }
            }, certificate: {
                serializedName: "properties.certificate",
                type: {
                    name: "Composite",
                    className: "CertificateDescription"
                }
            }, certificateCommonNames: {
                serializedName: "properties.certificateCommonNames",
                type: {
                    name: "Composite",
                    className: "ServerCertificateCommonNames"
                }
            }, clientCertificateCommonNames: {
                serializedName: "properties.clientCertificateCommonNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientCertificateCommonName"
                        }
                    }
                }
            }, clientCertificateThumbprints: {
                serializedName: "properties.clientCertificateThumbprints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClientCertificateThumbprint"
                        }
                    }
                }
            }, clusterCodeVersion: {
                serializedName: "properties.clusterCodeVersion",
                type: {
                    name: "String"
                }
            }, clusterEndpoint: {
                serializedName: "properties.clusterEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clusterId: {
                serializedName: "properties.clusterId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clusterState: {
                serializedName: "properties.clusterState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, diagnosticsStorageAccountConfig: {
                serializedName: "properties.diagnosticsStorageAccountConfig",
                type: {
                    name: "Composite",
                    className: "DiagnosticsStorageAccountConfig"
                }
            }, eventStoreServiceEnabled: {
                serializedName: "properties.eventStoreServiceEnabled",
                type: {
                    name: "Boolean"
                }
            }, fabricSettings: {
                serializedName: "properties.fabricSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SettingsSectionDescription"
                        }
                    }
                }
            }, managementEndpoint: {
                serializedName: "properties.managementEndpoint",
                type: {
                    name: "String"
                }
            }, nodeTypes: {
                serializedName: "properties.nodeTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NodeTypeDescription"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, reliabilityLevel: {
                serializedName: "properties.reliabilityLevel",
                type: {
                    name: "String"
                }
            }, reverseProxyCertificate: {
                serializedName: "properties.reverseProxyCertificate",
                type: {
                    name: "Composite",
                    className: "CertificateDescription"
                }
            }, reverseProxyCertificateCommonNames: {
                serializedName: "properties.reverseProxyCertificateCommonNames",
                type: {
                    name: "Composite",
                    className: "ServerCertificateCommonNames"
                }
            }, upgradeDescription: {
                serializedName: "properties.upgradeDescription",
                type: {
                    name: "Composite",
                    className: "ClusterUpgradePolicy"
                }
            }, upgradeMode: {
                defaultValue: "Automatic",
                serializedName: "properties.upgradeMode",
                type: {
                    name: "String"
                }
            }, applicationTypeVersionsCleanupPolicy: {
                serializedName: "properties.applicationTypeVersionsCleanupPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationTypeVersionsCleanupPolicy"
                }
            }, vmImage: {
                serializedName: "properties.vmImage",
                type: {
                    name: "String"
                }
            }, sfZonalUpgradeMode: {
                serializedName: "properties.sfZonalUpgradeMode",
                type: {
                    name: "String"
                }
            }, vmssZonalUpgradeMode: {
                serializedName: "properties.vmssZonalUpgradeMode",
                type: {
                    name: "String"
                }
            }, infrastructureServiceManager: {
                serializedName: "properties.infrastructureServiceManager",
                type: {
                    name: "Boolean"
                }
            }, upgradeWave: {
                serializedName: "properties.upgradeWave",
                type: {
                    name: "String"
                }
            }, upgradePauseStartTimestampUtc: {
                serializedName: "properties.upgradePauseStartTimestampUtc",
                type: {
                    name: "DateTime"
                }
            }, upgradePauseEndTimestampUtc: {
                serializedName: "properties.upgradePauseEndTimestampUtc",
                type: {
                    name: "DateTime"
                }
            }, waveUpgradePaused: {
                serializedName: "properties.waveUpgradePaused",
                type: {
                    name: "Boolean"
                }
            }, notifications: {
                serializedName: "properties.notifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Notification"
                        }
                    }
                }
            } })
    }
};
const ApplicationTypeResource = {
    type: {
        name: "Composite",
        className: "ApplicationTypeResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationTypeVersionResource = {
    type: {
        name: "Composite",
        className: "ApplicationTypeVersionResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, appPackageUrl: {
                serializedName: "properties.appPackageUrl",
                type: {
                    name: "String"
                }
            }, defaultParameterList: {
                serializedName: "properties.defaultParameterList",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const ApplicationResource = {
    type: {
        name: "Composite",
        className: "ApplicationResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentity"
                }
            }, typeVersion: {
                serializedName: "properties.typeVersion",
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, upgradePolicy: {
                serializedName: "properties.upgradePolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationUpgradePolicy"
                }
            }, minimumNodes: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.minimumNodes",
                type: {
                    name: "Number"
                }
            }, maximumNodes: {
                defaultValue: 0,
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.maximumNodes",
                type: {
                    name: "Number"
                }
            }, removeApplicationCapacity: {
                serializedName: "properties.removeApplicationCapacity",
                type: {
                    name: "Boolean"
                }
            }, metrics: {
                serializedName: "properties.metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationMetricDescription"
                        }
                    }
                }
            }, managedIdentities: {
                serializedName: "properties.managedIdentities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationUserAssignedIdentity"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typeName: {
                serializedName: "properties.typeName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationResourceUpdate = {
    type: {
        name: "Composite",
        className: "ApplicationResourceUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { typeVersion: {
                serializedName: "properties.typeVersion",
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, upgradePolicy: {
                serializedName: "properties.upgradePolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationUpgradePolicy"
                }
            }, minimumNodes: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.minimumNodes",
                type: {
                    name: "Number"
                }
            }, maximumNodes: {
                defaultValue: 0,
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "properties.maximumNodes",
                type: {
                    name: "Number"
                }
            }, removeApplicationCapacity: {
                serializedName: "properties.removeApplicationCapacity",
                type: {
                    name: "Boolean"
                }
            }, metrics: {
                serializedName: "properties.metrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationMetricDescription"
                        }
                    }
                }
            }, managedIdentities: {
                serializedName: "properties.managedIdentities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationUserAssignedIdentity"
                        }
                    }
                }
            } })
    }
};
const ServiceResource = {
    type: {
        name: "Composite",
        className: "ServiceResource",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { placementConstraints: {
                serializedName: "properties.placementConstraints",
                type: {
                    name: "String"
                }
            }, correlationScheme: {
                serializedName: "properties.correlationScheme",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceCorrelationDescription"
                        }
                    }
                }
            }, serviceLoadMetrics: {
                serializedName: "properties.serviceLoadMetrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceLoadMetricDescription"
                        }
                    }
                }
            }, servicePlacementPolicies: {
                serializedName: "properties.servicePlacementPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServicePlacementPolicyDescription"
                        }
                    }
                }
            }, defaultMoveCost: {
                serializedName: "properties.defaultMoveCost",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceKind: {
                serializedName: "properties.serviceKind",
                type: {
                    name: "String"
                }
            }, serviceTypeName: {
                serializedName: "properties.serviceTypeName",
                type: {
                    name: "String"
                }
            }, partitionDescription: {
                serializedName: "properties.partitionDescription",
                type: {
                    name: "Composite",
                    className: "PartitionSchemeDescription"
                }
            }, servicePackageActivationMode: {
                serializedName: "properties.servicePackageActivationMode",
                type: {
                    name: "String"
                }
            }, serviceDnsName: {
                serializedName: "properties.serviceDnsName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceResourceUpdate = {
    type: {
        name: "Composite",
        className: "ServiceResourceUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { placementConstraints: {
                serializedName: "properties.placementConstraints",
                type: {
                    name: "String"
                }
            }, correlationScheme: {
                serializedName: "properties.correlationScheme",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceCorrelationDescription"
                        }
                    }
                }
            }, serviceLoadMetrics: {
                serializedName: "properties.serviceLoadMetrics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceLoadMetricDescription"
                        }
                    }
                }
            }, servicePlacementPolicies: {
                serializedName: "properties.servicePlacementPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServicePlacementPolicyDescription"
                        }
                    }
                }
            }, defaultMoveCost: {
                serializedName: "properties.defaultMoveCost",
                type: {
                    name: "String"
                }
            }, serviceKind: {
                serializedName: "properties.serviceKind",
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationResourceProperties = {
    type: {
        name: "Composite",
        className: "ApplicationResourceProperties",
        modelProperties: Object.assign(Object.assign({}, ApplicationResourceUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typeName: {
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            } })
    }
};
const NamedPartitionSchemeDescription = {
    serializedName: "Named",
    type: {
        name: "Composite",
        className: "NamedPartitionSchemeDescription",
        uberParent: "PartitionSchemeDescription",
        polymorphicDiscriminator: PartitionSchemeDescription.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, PartitionSchemeDescription.type.modelProperties), { count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            }, names: {
                serializedName: "names",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SingletonPartitionSchemeDescription = {
    serializedName: "Singleton",
    type: {
        name: "Composite",
        className: "SingletonPartitionSchemeDescription",
        uberParent: "PartitionSchemeDescription",
        polymorphicDiscriminator: PartitionSchemeDescription.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, PartitionSchemeDescription.type.modelProperties)
    }
};
const UniformInt64RangePartitionSchemeDescription = {
    serializedName: "UniformInt64Range",
    type: {
        name: "Composite",
        className: "UniformInt64RangePartitionSchemeDescription",
        uberParent: "PartitionSchemeDescription",
        polymorphicDiscriminator: PartitionSchemeDescription.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, PartitionSchemeDescription.type.modelProperties), { count: {
                serializedName: "count",
                required: true,
                type: {
                    name: "Number"
                }
            }, lowKey: {
                serializedName: "lowKey",
                required: true,
                type: {
                    name: "String"
                }
            }, highKey: {
                serializedName: "highKey",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceResourceProperties = {
    serializedName: "ServiceResourceProperties",
    type: {
        name: "Composite",
        className: "ServiceResourceProperties",
        uberParent: "ServiceResourcePropertiesBase",
        polymorphicDiscriminator: {
            serializedName: "serviceKind",
            clientName: "serviceKind"
        },
        modelProperties: Object.assign(Object.assign({}, ServiceResourcePropertiesBase.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceKind: {
                serializedName: "serviceKind",
                required: true,
                type: {
                    name: "String"
                }
            }, serviceTypeName: {
                serializedName: "serviceTypeName",
                type: {
                    name: "String"
                }
            }, partitionDescription: {
                serializedName: "partitionDescription",
                type: {
                    name: "Composite",
                    className: "PartitionSchemeDescription"
                }
            }, servicePackageActivationMode: {
                serializedName: "servicePackageActivationMode",
                type: {
                    name: "String"
                }
            }, serviceDnsName: {
                serializedName: "serviceDnsName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceResourceUpdateProperties = {
    serializedName: "ServiceResourceUpdateProperties",
    type: {
        name: "Composite",
        className: "ServiceResourceUpdateProperties",
        uberParent: "ServiceResourcePropertiesBase",
        polymorphicDiscriminator: {
            serializedName: "serviceKind",
            clientName: "serviceKind"
        },
        modelProperties: Object.assign(Object.assign({}, ServiceResourcePropertiesBase.type.modelProperties), { serviceKind: {
                serializedName: "serviceKind",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const StatefulServiceProperties = {
    serializedName: "Stateful",
    type: {
        name: "Composite",
        className: "StatefulServiceProperties",
        uberParent: "ServiceResourceProperties",
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { hasPersistedState: {
                serializedName: "hasPersistedState",
                type: {
                    name: "Boolean"
                }
            }, targetReplicaSetSize: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "targetReplicaSetSize",
                type: {
                    name: "Number"
                }
            }, minReplicaSetSize: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "minReplicaSetSize",
                type: {
                    name: "Number"
                }
            }, replicaRestartWaitDuration: {
                serializedName: "replicaRestartWaitDuration",
                type: {
                    name: "DateTime"
                }
            }, quorumLossWaitDuration: {
                serializedName: "quorumLossWaitDuration",
                type: {
                    name: "DateTime"
                }
            }, standByReplicaKeepDuration: {
                serializedName: "standByReplicaKeepDuration",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const StatelessServiceProperties = {
    serializedName: "Stateless",
    type: {
        name: "Composite",
        className: "StatelessServiceProperties",
        uberParent: "ServiceResourceProperties",
        polymorphicDiscriminator: ServiceResourceProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceProperties.type.modelProperties), { instanceCount: {
                constraints: {
                    InclusiveMinimum: -1
                },
                serializedName: "instanceCount",
                type: {
                    name: "Number"
                }
            }, instanceCloseDelayDuration: {
                serializedName: "instanceCloseDelayDuration",
                type: {
                    name: "String"
                }
            } })
    }
};
const StatefulServiceUpdateProperties = {
    serializedName: "Stateful",
    type: {
        name: "Composite",
        className: "StatefulServiceUpdateProperties",
        uberParent: "ServiceResourceUpdateProperties",
        polymorphicDiscriminator: ServiceResourceUpdateProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceUpdateProperties.type.modelProperties), { targetReplicaSetSize: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "targetReplicaSetSize",
                type: {
                    name: "Number"
                }
            }, minReplicaSetSize: {
                constraints: {
                    InclusiveMinimum: 1
                },
                serializedName: "minReplicaSetSize",
                type: {
                    name: "Number"
                }
            }, replicaRestartWaitDuration: {
                serializedName: "replicaRestartWaitDuration",
                type: {
                    name: "DateTime"
                }
            }, quorumLossWaitDuration: {
                serializedName: "quorumLossWaitDuration",
                type: {
                    name: "DateTime"
                }
            }, standByReplicaKeepDuration: {
                serializedName: "standByReplicaKeepDuration",
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const StatelessServiceUpdateProperties = {
    serializedName: "Stateless",
    type: {
        name: "Composite",
        className: "StatelessServiceUpdateProperties",
        uberParent: "ServiceResourceUpdateProperties",
        polymorphicDiscriminator: ServiceResourceUpdateProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ServiceResourceUpdateProperties.type.modelProperties), { instanceCount: {
                constraints: {
                    InclusiveMinimum: -1
                },
                serializedName: "instanceCount",
                type: {
                    name: "Number"
                }
            }, instanceCloseDelayDuration: {
                serializedName: "instanceCloseDelayDuration",
                type: {
                    name: "String"
                }
            } })
    }
};
let discriminators = {
    PartitionSchemeDescription: PartitionSchemeDescription,
    "ServicePlacementPolicyDescription.ServicePlacementPolicyDescription": ServicePlacementPolicyDescription,
    "PartitionSchemeDescription.Named": NamedPartitionSchemeDescription,
    "PartitionSchemeDescription.Singleton": SingletonPartitionSchemeDescription,
    "PartitionSchemeDescription.UniformInt64Range": UniformInt64RangePartitionSchemeDescription,
    "ServiceResourcePropertiesBase.ServiceResourceProperties": ServiceResourceProperties,
    "ServiceResourcePropertiesBase.ServiceResourceUpdateProperties": ServiceResourceUpdateProperties,
    "ServiceResourceProperties.Stateful": StatefulServiceProperties,
    "ServiceResourceProperties.Stateless": StatelessServiceProperties,
    "ServiceResourceUpdateProperties.Stateful": StatefulServiceUpdateProperties,
    "ServiceResourceUpdateProperties.Stateless": StatelessServiceUpdateProperties
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ApplicationDeltaHealthPolicy: ApplicationDeltaHealthPolicy,
    ApplicationHealthPolicy: ApplicationHealthPolicy,
    ApplicationMetricDescription: ApplicationMetricDescription,
    ApplicationResource: ApplicationResource,
    ApplicationResourceList: ApplicationResourceList,
    ApplicationResourceProperties: ApplicationResourceProperties,
    ApplicationResourceUpdate: ApplicationResourceUpdate,
    ApplicationResourceUpdateProperties: ApplicationResourceUpdateProperties,
    ApplicationTypeResource: ApplicationTypeResource,
    ApplicationTypeResourceList: ApplicationTypeResourceList,
    ApplicationTypeVersionResource: ApplicationTypeVersionResource,
    ApplicationTypeVersionResourceList: ApplicationTypeVersionResourceList,
    ApplicationTypeVersionsCleanupPolicy: ApplicationTypeVersionsCleanupPolicy,
    ApplicationUpgradePolicy: ApplicationUpgradePolicy,
    ApplicationUserAssignedIdentity: ApplicationUserAssignedIdentity,
    ArmApplicationHealthPolicy: ArmApplicationHealthPolicy,
    ArmRollingUpgradeMonitoringPolicy: ArmRollingUpgradeMonitoringPolicy,
    ArmServiceTypeHealthPolicy: ArmServiceTypeHealthPolicy,
    AvailableOperationDisplay: AvailableOperationDisplay,
    AzureActiveDirectory: AzureActiveDirectory,
    CertificateDescription: CertificateDescription,
    ClientCertificateCommonName: ClientCertificateCommonName,
    ClientCertificateThumbprint: ClientCertificateThumbprint,
    Cluster: Cluster,
    ClusterCodeVersionsListResult: ClusterCodeVersionsListResult,
    ClusterCodeVersionsResult: ClusterCodeVersionsResult,
    ClusterHealthPolicy: ClusterHealthPolicy,
    ClusterListResult: ClusterListResult,
    ClusterUpdateParameters: ClusterUpdateParameters,
    ClusterUpgradeDeltaHealthPolicy: ClusterUpgradeDeltaHealthPolicy,
    ClusterUpgradePolicy: ClusterUpgradePolicy,
    ClusterVersionDetails: ClusterVersionDetails,
    DiagnosticsStorageAccountConfig: DiagnosticsStorageAccountConfig,
    EndpointRangeDescription: EndpointRangeDescription,
    ErrorModel: ErrorModel,
    ErrorModelError: ErrorModelError,
    ManagedIdentity: ManagedIdentity,
    NamedPartitionSchemeDescription: NamedPartitionSchemeDescription,
    NodeTypeDescription: NodeTypeDescription,
    Notification: Notification,
    NotificationTarget: NotificationTarget,
    OperationListResult: OperationListResult,
    OperationResult: OperationResult,
    PartitionSchemeDescription: PartitionSchemeDescription,
    ProxyResource: ProxyResource,
    Resource: Resource,
    ServerCertificateCommonName: ServerCertificateCommonName,
    ServerCertificateCommonNames: ServerCertificateCommonNames,
    ServiceCorrelationDescription: ServiceCorrelationDescription,
    ServiceLoadMetricDescription: ServiceLoadMetricDescription,
    ServicePlacementPolicyDescription: ServicePlacementPolicyDescription,
    ServiceResource: ServiceResource,
    ServiceResourceList: ServiceResourceList,
    ServiceResourceProperties: ServiceResourceProperties,
    ServiceResourcePropertiesBase: ServiceResourcePropertiesBase,
    ServiceResourceUpdate: ServiceResourceUpdate,
    ServiceResourceUpdateProperties: ServiceResourceUpdateProperties,
    ServiceTypeDeltaHealthPolicy: ServiceTypeDeltaHealthPolicy,
    ServiceTypeHealthPolicy: ServiceTypeHealthPolicy,
    SettingsParameterDescription: SettingsParameterDescription,
    SettingsSectionDescription: SettingsSectionDescription,
    SingletonPartitionSchemeDescription: SingletonPartitionSchemeDescription,
    StatefulServiceProperties: StatefulServiceProperties,
    StatefulServiceUpdateProperties: StatefulServiceUpdateProperties,
    StatelessServiceProperties: StatelessServiceProperties,
    StatelessServiceUpdateProperties: StatelessServiceUpdateProperties,
    SystemData: SystemData,
    UniformInt64RangePartitionSchemeDescription: UniformInt64RangePartitionSchemeDescription,
    UpgradableVersionPathResult: UpgradableVersionPathResult,
    UpgradableVersionsDescription: UpgradableVersionsDescription,
    UserAssignedIdentity: UserAssignedIdentity,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clusterName = {
    parameterPath: "clusterName",
    mapper: {
        serializedName: "clusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-06-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Cluster
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ClusterUpdateParameters
};
const versionsDescription = {
    parameterPath: ["options", "versionsDescription"],
    mapper: UpgradableVersionsDescription
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clusterVersion = {
    parameterPath: "clusterVersion",
    mapper: {
        serializedName: "clusterVersion",
        required: true,
        type: {
            name: "String"
        }
    }
};
const environment = {
    parameterPath: "environment",
    mapper: {
        serializedName: "environment",
        required: true,
        type: {
            name: "String"
        }
    }
};
const applicationTypeName = {
    parameterPath: "applicationTypeName",
    mapper: {
        serializedName: "applicationTypeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ApplicationTypeResource
};
const version = {
    parameterPath: "version",
    mapper: {
        serializedName: "version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ApplicationTypeVersionResource
};
const applicationName = {
    parameterPath: "applicationName",
    mapper: {
        serializedName: "applicationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: ApplicationResource
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: ApplicationResourceUpdate
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        serializedName: "serviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: ServiceResource
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ServiceResourceUpdate
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Clusters operations. */
class ClustersImpl {
    /**
     * Initialize a new instance of the class Clusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all Service Fabric cluster resources created or in the process of being created in the resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all Service Fabric cluster resources created or in the process of being created in the
     * subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get a Service Fabric cluster resource created or in the process of being created in the specified
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, getOperationSpec$5);
    }
    /**
     * Create or update a Service Fabric cluster resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param parameters The cluster resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, parameters, options },
                spec: createOrUpdateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Service Fabric cluster resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param parameters The cluster resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update the configuration of a Service Fabric cluster resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param parameters The parameters which contains the property value and property name which used to
     *                   update the cluster configuration.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, parameters, options },
                spec: updateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the configuration of a Service Fabric cluster resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param parameters The parameters which contains the property value and property name which used to
     *                   update the cluster configuration.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Service Fabric cluster resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    delete(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, deleteOperationSpec$4);
    }
    /**
     * Gets all Service Fabric cluster resources created or in the process of being created in the resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets all Service Fabric cluster resources created or in the process of being created in the
     * subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$6);
    }
    /**
     * If a target is not provided, it will get the minimum and maximum versions available from the current
     * cluster version. If a target is given, it will provide the required path to get from the current
     * cluster version to the target version.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    listUpgradableVersions(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listUpgradableVersionsOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listUpgradableVersionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/listUpgradableVersions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: UpgradableVersionPathResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: versionsDescription,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ClusterVersions operations. */
class ClusterVersionsImpl {
    /**
     * Initialize a new instance of the class ClusterVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about an available Service Fabric cluster code version.
     * @param location The location for the cluster code versions. This is different from cluster location.
     * @param clusterVersion The cluster code version.
     * @param options The options parameters.
     */
    get(location, clusterVersion, options) {
        return this.client.sendOperationRequest({ location, clusterVersion, options }, getOperationSpec$4);
    }
    /**
     * Gets information about an available Service Fabric cluster code version by environment.
     * @param location The location for the cluster code versions. This is different from cluster location.
     * @param environment The operating system of the cluster. The default means all.
     * @param clusterVersion The cluster code version.
     * @param options The options parameters.
     */
    getByEnvironment(location, environment, clusterVersion, options) {
        return this.client.sendOperationRequest({ location, environment, clusterVersion, options }, getByEnvironmentOperationSpec);
    }
    /**
     * Gets all available code versions for Service Fabric cluster resources by location.
     * @param location The location for the cluster code versions. This is different from cluster location.
     * @param options The options parameters.
     */
    list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$5);
    }
    /**
     * Gets all available code versions for Service Fabric cluster resources by environment.
     * @param location The location for the cluster code versions. This is different from cluster location.
     * @param environment The operating system of the cluster. The default means all.
     * @param options The options parameters.
     */
    listByEnvironment(location, environment, options) {
        return this.client.sendOperationRequest({ location, environment, options }, listByEnvironmentOperationSpec);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/clusterVersions/{clusterVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterCodeVersionsListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        clusterVersion
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getByEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/environments/{environment}/clusterVersions/{clusterVersion}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterCodeVersionsListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        clusterVersion,
        environment
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/clusterVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterCodeVersionsListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByEnvironmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ServiceFabric/locations/{location}/environments/{environment}/clusterVersions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterCodeVersionsListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location,
        environment
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the list of available Service Fabric resource provider API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get the list of available Service Fabric resource provider API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/providers/Microsoft.ServiceFabric/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationTypes operations. */
class ApplicationTypesImpl {
    /**
     * Initialize a new instance of the class ApplicationTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all application type name resources created or in the process of being created in the Service
     * Fabric cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Service Fabric application type name resource created or in the process of being created in
     * the Service Fabric cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, applicationTypeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationTypeName, options }, getOperationSpec$3);
    }
    /**
     * Create or update a Service Fabric application type name resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param parameters The application type name resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, clusterName, applicationTypeName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            clusterName,
            applicationTypeName,
            parameters,
            options
        }, createOrUpdateOperationSpec$3);
    }
    /**
     * Delete a Service Fabric application type name resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, applicationTypeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, applicationTypeName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Service Fabric application type name resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, applicationTypeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, applicationTypeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all application type name resources created or in the process of being created in the Service
     * Fabric cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationTypeResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationTypeVersions operations. */
class ApplicationTypeVersionsImpl {
    /**
     * Initialize a new instance of the class ApplicationTypeVersions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all application type version resources created or in the process of being created in the
     * Service Fabric application type name resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, applicationTypeName, options) {
        const iter = this.listPagingAll(resourceGroupName, clusterName, applicationTypeName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, clusterName, applicationTypeName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, clusterName, applicationTypeName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, clusterName, applicationTypeName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, clusterName, applicationTypeName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, clusterName, applicationTypeName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, clusterName, applicationTypeName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Service Fabric application type version resource created or in the process of being created in
     * the Service Fabric application type name resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param version The application type version.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, applicationTypeName, version, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationTypeName, version, options }, getOperationSpec$2);
    }
    /**
     * Create or update a Service Fabric application type version resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param version The application type version.
     * @param parameters The application type version resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, applicationTypeName, version, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationTypeName,
                    version,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Service Fabric application type version resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param version The application type version.
     * @param parameters The application type version resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, applicationTypeName, version, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, applicationTypeName, version, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Service Fabric application type version resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param version The application type version.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, applicationTypeName, version, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationTypeName,
                    version,
                    options
                },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Service Fabric application type version resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param version The application type version.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, applicationTypeName, version, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, applicationTypeName, version, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all application type version resources created or in the process of being created in the
     * Service Fabric application type name resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, clusterName, applicationTypeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationTypeName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationTypeName The name of the application type name resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, clusterName, applicationTypeName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            clusterName,
            applicationTypeName,
            nextLink,
            options
        }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeVersionResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationTypeVersionResource
        },
        201: {
            bodyMapper: ApplicationTypeVersionResource
        },
        202: {
            bodyMapper: ApplicationTypeVersionResource
        },
        204: {
            bodyMapper: ApplicationTypeVersionResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName,
        version
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions/{version}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName,
        version
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applicationTypes/{applicationTypeName}/versions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeVersionResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationTypeVersionResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        nextLink,
        applicationTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Applications operations. */
class ApplicationsImpl {
    /**
     * Initialize a new instance of the class Applications class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all application resources created or in the process of being created in the Service Fabric
     * cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Service Fabric application resource created or in the process of being created in the Service
     * Fabric cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, options }, getOperationSpec$1);
    }
    /**
     * Create or update a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param parameters The application resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param parameters The application resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, applicationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param parameters The application resource for patch operations.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationName,
                    parameters,
                    options
                },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param parameters The application resource for patch operations.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, applicationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, applicationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, applicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, clusterName, applicationName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Service Fabric application resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, applicationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, applicationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all application resources created or in the process of being created in the Service Fabric
     * cluster resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationResource
        },
        201: {
            bodyMapper: ApplicationResource
        },
        202: {
            bodyMapper: ApplicationResource
        },
        204: {
            bodyMapper: ApplicationResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApplicationResource
        },
        201: {
            bodyMapper: ApplicationResource
        },
        202: {
            bodyMapper: ApplicationResource
        },
        204: {
            bodyMapper: ApplicationResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Services operations. */
class ServicesImpl {
    /**
     * Initialize a new instance of the class Services class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all service resources created or in the process of being created in the Service Fabric
     * application resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, clusterName, applicationName, options) {
        const iter = this.listPagingAll(resourceGroupName, clusterName, applicationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, clusterName, applicationName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, clusterName, applicationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, clusterName, applicationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, clusterName, applicationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, clusterName, applicationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, clusterName, applicationName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get a Service Fabric service resource created or in the process of being created in the Service
     * Fabric application resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param options The options parameters.
     */
    get(resourceGroupName, clusterName, applicationName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, serviceName, options }, getOperationSpec);
    }
    /**
     * Create or update a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param parameters The service resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, clusterName, applicationName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationName,
                    serviceName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param parameters The service resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, clusterName, applicationName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, clusterName, applicationName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param parameters The service resource for patch operations.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, clusterName, applicationName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationName,
                    serviceName,
                    parameters,
                    options
                },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param parameters The service resource for patch operations.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, clusterName, applicationName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, clusterName, applicationName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, clusterName, applicationName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    clusterName,
                    applicationName,
                    serviceName,
                    options
                },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Service Fabric service resource with the specified name.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param serviceName The name of the service resource in the format of
     *                    {applicationName}~{serviceName}.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, clusterName, applicationName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, clusterName, applicationName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all service resources created or in the process of being created in the Service Fabric
     * application resource.
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, clusterName, applicationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param clusterName The name of the cluster resource.
     * @param applicationName The name of the application resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, clusterName, applicationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, clusterName, applicationName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName,
        serviceName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceResource
        },
        201: {
            bodyMapper: ServiceResource
        },
        202: {
            bodyMapper: ServiceResource
        },
        204: {
            bodyMapper: ServiceResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ServiceResource
        },
        201: {
            bodyMapper: ServiceResource
        },
        202: {
            bodyMapper: ServiceResource
        },
        204: {
            bodyMapper: ServiceResource
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName,
        serviceName
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ServiceFabric/clusters/{clusterName}/applications/{applicationName}/services",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        applicationName
    ],
    headerParameters: [accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceResourceList
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        clusterName,
        subscriptionId,
        nextLink,
        applicationName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ServiceFabricManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the ServiceFabricManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The customer subscription identifier.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-servicefabric/3.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-06-01";
        this.clusters = new ClustersImpl(this);
        this.clusterVersions = new ClusterVersionsImpl(this);
        this.operations = new OperationsImpl(this);
        this.applicationTypes = new ApplicationTypesImpl(this);
        this.applicationTypeVersions = new ApplicationTypeVersionsImpl(this);
        this.applications = new ApplicationsImpl(this);
        this.services = new ServicesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.ServiceFabricManagementClient = ServiceFabricManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
