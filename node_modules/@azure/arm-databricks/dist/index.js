'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespaceDefault(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespaceDefault(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CustomParameterType} that the service accepts. */
exports.KnownCustomParameterType = void 0;
(function (KnownCustomParameterType) {
    /** Bool */
    KnownCustomParameterType["Bool"] = "Bool";
    /** Object */
    KnownCustomParameterType["Object"] = "Object";
    /** String */
    KnownCustomParameterType["String"] = "String";
})(exports.KnownCustomParameterType || (exports.KnownCustomParameterType = {}));
/** Known values of {@link KeySource} that the service accepts. */
exports.KnownKeySource = void 0;
(function (KnownKeySource) {
    /** Default */
    KnownKeySource["Default"] = "Default";
    /** MicrosoftKeyvault */
    KnownKeySource["MicrosoftKeyvault"] = "Microsoft.Keyvault";
})(exports.KnownKeySource || (exports.KnownKeySource = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Accepted */
    KnownProvisioningState["Accepted"] = "Accepted";
    /** Running */
    KnownProvisioningState["Running"] = "Running";
    /** Ready */
    KnownProvisioningState["Ready"] = "Ready";
    /** Creating */
    KnownProvisioningState["Creating"] = "Creating";
    /** Created */
    KnownProvisioningState["Created"] = "Created";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Deleted */
    KnownProvisioningState["Deleted"] = "Deleted";
    /** Canceled */
    KnownProvisioningState["Canceled"] = "Canceled";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link EncryptionKeySource} that the service accepts. */
exports.KnownEncryptionKeySource = void 0;
(function (KnownEncryptionKeySource) {
    /** MicrosoftKeyvault */
    KnownEncryptionKeySource["MicrosoftKeyvault"] = "Microsoft.Keyvault";
})(exports.KnownEncryptionKeySource || (exports.KnownEncryptionKeySource = {}));
/** Known values of {@link PrivateLinkServiceConnectionStatus} that the service accepts. */
exports.KnownPrivateLinkServiceConnectionStatus = void 0;
(function (KnownPrivateLinkServiceConnectionStatus) {
    /** Pending */
    KnownPrivateLinkServiceConnectionStatus["Pending"] = "Pending";
    /** Approved */
    KnownPrivateLinkServiceConnectionStatus["Approved"] = "Approved";
    /** Rejected */
    KnownPrivateLinkServiceConnectionStatus["Rejected"] = "Rejected";
    /** Disconnected */
    KnownPrivateLinkServiceConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownPrivateLinkServiceConnectionStatus || (exports.KnownPrivateLinkServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
exports.KnownPrivateEndpointConnectionProvisioningState = void 0;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    /** Succeeded */
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Creating */
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownPrivateEndpointConnectionProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
exports.KnownPublicNetworkAccess = void 0;
(function (KnownPublicNetworkAccess) {
    /** Enabled */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Disabled */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
/** Known values of {@link RequiredNsgRules} that the service accepts. */
exports.KnownRequiredNsgRules = void 0;
(function (KnownRequiredNsgRules) {
    /** AllRules */
    KnownRequiredNsgRules["AllRules"] = "AllRules";
    /** NoAzureDatabricksRules */
    KnownRequiredNsgRules["NoAzureDatabricksRules"] = "NoAzureDatabricksRules";
    /** NoAzureServiceRules */
    KnownRequiredNsgRules["NoAzureServiceRules"] = "NoAzureServiceRules";
})(exports.KnownRequiredNsgRules || (exports.KnownRequiredNsgRules = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link PeeringState} that the service accepts. */
exports.KnownPeeringState = void 0;
(function (KnownPeeringState) {
    /** Initiated */
    KnownPeeringState["Initiated"] = "Initiated";
    /** Connected */
    KnownPeeringState["Connected"] = "Connected";
    /** Disconnected */
    KnownPeeringState["Disconnected"] = "Disconnected";
})(exports.KnownPeeringState || (exports.KnownPeeringState = {}));
/** Known values of {@link PeeringProvisioningState} that the service accepts. */
exports.KnownPeeringProvisioningState = void 0;
(function (KnownPeeringProvisioningState) {
    /** Succeeded */
    KnownPeeringProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownPeeringProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownPeeringProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownPeeringProvisioningState["Failed"] = "Failed";
})(exports.KnownPeeringProvisioningState || (exports.KnownPeeringProvisioningState = {}));
/** Known values of {@link ManagedServiceIdentityType} that the service accepts. */
exports.KnownManagedServiceIdentityType = void 0;
(function (KnownManagedServiceIdentityType) {
    /** None */
    KnownManagedServiceIdentityType["None"] = "None";
    /** SystemAssigned */
    KnownManagedServiceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** UserAssigned */
    KnownManagedServiceIdentityType["UserAssigned"] = "UserAssigned";
    /** SystemAssignedUserAssigned */
    KnownManagedServiceIdentityType["SystemAssignedUserAssigned"] = "SystemAssigned,UserAssigned";
})(exports.KnownManagedServiceIdentityType || (exports.KnownManagedServiceIdentityType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const WorkspaceCustomParameters = {
    type: {
        name: "Composite",
        className: "WorkspaceCustomParameters",
        modelProperties: {
            amlWorkspaceId: {
                serializedName: "amlWorkspaceId",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            customVirtualNetworkId: {
                serializedName: "customVirtualNetworkId",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            customPublicSubnetName: {
                serializedName: "customPublicSubnetName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            customPrivateSubnetName: {
                serializedName: "customPrivateSubnetName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            enableNoPublicIp: {
                serializedName: "enableNoPublicIp",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomBooleanParameter"
                }
            },
            loadBalancerBackendPoolName: {
                serializedName: "loadBalancerBackendPoolName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            loadBalancerId: {
                serializedName: "loadBalancerId",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            natGatewayName: {
                serializedName: "natGatewayName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            publicIpName: {
                serializedName: "publicIpName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            prepareEncryption: {
                serializedName: "prepareEncryption",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomBooleanParameter"
                }
            },
            encryption: {
                serializedName: "encryption",
                type: {
                    name: "Composite",
                    className: "WorkspaceEncryptionParameter"
                }
            },
            requireInfrastructureEncryption: {
                serializedName: "requireInfrastructureEncryption",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomBooleanParameter"
                }
            },
            storageAccountName: {
                serializedName: "storageAccountName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            storageAccountSkuName: {
                serializedName: "storageAccountSkuName",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            vnetAddressPrefix: {
                serializedName: "vnetAddressPrefix",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomStringParameter"
                }
            },
            resourceTags: {
                serializedName: "resourceTags",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomObjectParameter"
                }
            }
        }
    }
};
const WorkspaceCustomStringParameter = {
    type: {
        name: "Composite",
        className: "WorkspaceCustomStringParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceCustomBooleanParameter = {
    type: {
        name: "Composite",
        className: "WorkspaceCustomBooleanParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const WorkspaceEncryptionParameter = {
    type: {
        name: "Composite",
        className: "WorkspaceEncryptionParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }
        }
    }
};
const Encryption = {
    type: {
        name: "Composite",
        className: "Encryption",
        modelProperties: {
            keySource: {
                defaultValue: "Default",
                serializedName: "keySource",
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "KeyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyversion",
                type: {
                    name: "String"
                }
            },
            keyVaultUri: {
                serializedName: "keyvaulturi",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceCustomObjectParameter = {
    type: {
        name: "Composite",
        className: "WorkspaceCustomObjectParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const WorkspaceProviderAuthorization = {
    type: {
        name: "Composite",
        className: "WorkspaceProviderAuthorization",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            roleDefinitionId: {
                serializedName: "roleDefinitionId",
                required: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const CreatedBy = {
    type: {
        name: "Composite",
        className: "CreatedBy",
        modelProperties: {
            oid: {
                serializedName: "oid",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            puid: {
                serializedName: "puid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            applicationId: {
                serializedName: "applicationId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const ManagedIdentityConfiguration = {
    type: {
        name: "Composite",
        className: "ManagedIdentityConfiguration",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspacePropertiesEncryption = {
    type: {
        name: "Composite",
        className: "WorkspacePropertiesEncryption",
        modelProperties: {
            entities: {
                serializedName: "entities",
                type: {
                    name: "Composite",
                    className: "EncryptionEntitiesDefinition"
                }
            }
        }
    }
};
const EncryptionEntitiesDefinition = {
    type: {
        name: "Composite",
        className: "EncryptionEntitiesDefinition",
        modelProperties: {
            managedServices: {
                serializedName: "managedServices",
                type: {
                    name: "Composite",
                    className: "EncryptionV2"
                }
            },
            managedDisk: {
                serializedName: "managedDisk",
                type: {
                    name: "Composite",
                    className: "ManagedDiskEncryption"
                }
            }
        }
    }
};
const EncryptionV2 = {
    type: {
        name: "Composite",
        className: "EncryptionV2",
        modelProperties: {
            keySource: {
                serializedName: "keySource",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionV2KeyVaultProperties"
                }
            }
        }
    }
};
const EncryptionV2KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "EncryptionV2KeyVaultProperties",
        modelProperties: {
            keyVaultUri: {
                serializedName: "keyVaultUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedDiskEncryption = {
    type: {
        name: "Composite",
        className: "ManagedDiskEncryption",
        modelProperties: {
            keySource: {
                serializedName: "keySource",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "ManagedDiskEncryptionKeyVaultProperties"
                }
            },
            rotationToLatestKeyVersionEnabled: {
                serializedName: "rotationToLatestKeyVersionEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ManagedDiskEncryptionKeyVaultProperties = {
    type: {
        name: "Composite",
        className: "ManagedDiskEncryptionKeyVaultProperties",
        modelProperties: {
            keyVaultUri: {
                serializedName: "keyVaultUri",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyName: {
                serializedName: "keyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PrivateEndpointConnectionProperties"
                }
            }
        }
    }
};
const PrivateEndpointConnectionProperties = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionProperties",
        modelProperties: {
            privateEndpoint: {
                serializedName: "privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            },
            groupIds: {
                serializedName: "groupIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            privateLinkServiceConnectionState: {
                serializedName: "privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorInfo"
                }
            }
        }
    }
};
const ErrorInfo = {
    type: {
        name: "Composite",
        className: "ErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            innererror: {
                serializedName: "innererror",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkspaceUpdate = {
    type: {
        name: "Composite",
        className: "WorkspaceUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const WorkspaceListResult = {
    type: {
        name: "Composite",
        className: "WorkspaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Workspace"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkResourcesList = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourcesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GroupIdInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GroupIdInformationProperties = {
    type: {
        name: "Composite",
        className: "GroupIdInformationProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                type: {
                    name: "String"
                }
            },
            requiredMembers: {
                serializedName: "requiredMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            requiredZoneNames: {
                serializedName: "requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionsList = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OutboundEnvironmentEndpoint = {
    type: {
        name: "Composite",
        className: "OutboundEnvironmentEndpoint",
        modelProperties: {
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDependency"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDependency = {
    type: {
        name: "Composite",
        className: "EndpointDependency",
        modelProperties: {
            domainName: {
                serializedName: "domainName",
                type: {
                    name: "String"
                }
            },
            endpointDetails: {
                serializedName: "endpointDetails",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointDetail"
                        }
                    }
                }
            }
        }
    }
};
const EndpointDetail = {
    type: {
        name: "Composite",
        className: "EndpointDetail",
        modelProperties: {
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            latency: {
                serializedName: "latency",
                type: {
                    name: "Number"
                }
            },
            isAccessible: {
                serializedName: "isAccessible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualNetworkPeering = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeering",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            allowVirtualNetworkAccess: {
                serializedName: "properties.allowVirtualNetworkAccess",
                type: {
                    name: "Boolean"
                }
            },
            allowForwardedTraffic: {
                serializedName: "properties.allowForwardedTraffic",
                type: {
                    name: "Boolean"
                }
            },
            allowGatewayTransit: {
                serializedName: "properties.allowGatewayTransit",
                type: {
                    name: "Boolean"
                }
            },
            useRemoteGateways: {
                serializedName: "properties.useRemoteGateways",
                type: {
                    name: "Boolean"
                }
            },
            databricksVirtualNetwork: {
                serializedName: "properties.databricksVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkPeeringPropertiesFormatDatabricksVirtualNetwork"
                }
            },
            databricksAddressSpace: {
                serializedName: "properties.databricksAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            },
            remoteVirtualNetwork: {
                serializedName: "properties.remoteVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkPeeringPropertiesFormatRemoteVirtualNetwork"
                }
            },
            remoteAddressSpace: {
                serializedName: "properties.remoteAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            },
            peeringState: {
                serializedName: "properties.peeringState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkPeeringPropertiesFormatDatabricksVirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeeringPropertiesFormatDatabricksVirtualNetwork",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddressSpace = {
    type: {
        name: "Composite",
        className: "AddressSpace",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualNetworkPeeringPropertiesFormatRemoteVirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeeringPropertiesFormatRemoteVirtualNetwork",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkPeeringList = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeeringList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Composite", className: "UserAssignedIdentity" }
                    }
                }
            }
        }
    }
};
const UserAssignedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const AccessConnectorProperties = {
    type: {
        name: "Composite",
        className: "AccessConnectorProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccessConnectorUpdate = {
    type: {
        name: "Composite",
        className: "AccessConnectorUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }
        }
    }
};
const AccessConnectorListResult = {
    type: {
        name: "Composite",
        className: "AccessConnectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessConnector"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const GroupIdInformation = {
    type: {
        name: "Composite",
        className: "GroupIdInformation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "GroupIdInformationProperties"
                }
            } })
    }
};
const Workspace = {
    type: {
        name: "Composite",
        className: "Workspace",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, managedResourceGroupId: {
                serializedName: "properties.managedResourceGroupId",
                required: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Composite",
                    className: "WorkspaceCustomParameters"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uiDefinitionUri: {
                serializedName: "properties.uiDefinitionUri",
                type: {
                    name: "String"
                }
            }, authorizations: {
                serializedName: "properties.authorizations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkspaceProviderAuthorization"
                        }
                    }
                }
            }, createdBy: {
                serializedName: "properties.createdBy",
                type: {
                    name: "Composite",
                    className: "CreatedBy"
                }
            }, updatedBy: {
                serializedName: "properties.updatedBy",
                type: {
                    name: "Composite",
                    className: "CreatedBy"
                }
            }, createdDateTime: {
                serializedName: "properties.createdDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, workspaceId: {
                serializedName: "properties.workspaceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workspaceUrl: {
                serializedName: "properties.workspaceUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageAccountIdentity: {
                serializedName: "properties.storageAccountIdentity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentityConfiguration"
                }
            }, managedDiskIdentity: {
                serializedName: "properties.managedDiskIdentity",
                type: {
                    name: "Composite",
                    className: "ManagedIdentityConfiguration"
                }
            }, diskEncryptionSetId: {
                serializedName: "properties.diskEncryptionSetId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "WorkspacePropertiesEncryption"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, requiredNsgRules: {
                serializedName: "properties.requiredNsgRules",
                type: {
                    name: "String"
                }
            } })
    }
};
const AccessConnector = {
    type: {
        name: "Composite",
        className: "AccessConnector",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AccessConnectorProperties"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AccessConnector: AccessConnector,
    AccessConnectorListResult: AccessConnectorListResult,
    AccessConnectorProperties: AccessConnectorProperties,
    AccessConnectorUpdate: AccessConnectorUpdate,
    AddressSpace: AddressSpace,
    CreatedBy: CreatedBy,
    Encryption: Encryption,
    EncryptionEntitiesDefinition: EncryptionEntitiesDefinition,
    EncryptionV2: EncryptionV2,
    EncryptionV2KeyVaultProperties: EncryptionV2KeyVaultProperties,
    EndpointDependency: EndpointDependency,
    EndpointDetail: EndpointDetail,
    ErrorDetail: ErrorDetail,
    ErrorInfo: ErrorInfo,
    ErrorResponse: ErrorResponse,
    GroupIdInformation: GroupIdInformation,
    GroupIdInformationProperties: GroupIdInformationProperties,
    ManagedDiskEncryption: ManagedDiskEncryption,
    ManagedDiskEncryptionKeyVaultProperties: ManagedDiskEncryptionKeyVaultProperties,
    ManagedIdentityConfiguration: ManagedIdentityConfiguration,
    ManagedServiceIdentity: ManagedServiceIdentity,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationListResult: OperationListResult,
    OutboundEnvironmentEndpoint: OutboundEnvironmentEndpoint,
    PrivateEndpoint: PrivateEndpoint,
    PrivateEndpointConnection: PrivateEndpointConnection,
    PrivateEndpointConnectionProperties: PrivateEndpointConnectionProperties,
    PrivateEndpointConnectionsList: PrivateEndpointConnectionsList,
    PrivateLinkResourcesList: PrivateLinkResourcesList,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    Resource: Resource,
    Sku: Sku,
    SystemData: SystemData,
    TrackedResource: TrackedResource,
    UserAssignedIdentity: UserAssignedIdentity,
    VirtualNetworkPeering: VirtualNetworkPeering,
    VirtualNetworkPeeringList: VirtualNetworkPeeringList,
    VirtualNetworkPeeringPropertiesFormatDatabricksVirtualNetwork: VirtualNetworkPeeringPropertiesFormatDatabricksVirtualNetwork,
    VirtualNetworkPeeringPropertiesFormatRemoteVirtualNetwork: VirtualNetworkPeeringPropertiesFormatRemoteVirtualNetwork,
    Workspace: Workspace,
    WorkspaceCustomBooleanParameter: WorkspaceCustomBooleanParameter,
    WorkspaceCustomObjectParameter: WorkspaceCustomObjectParameter,
    WorkspaceCustomParameters: WorkspaceCustomParameters,
    WorkspaceCustomStringParameter: WorkspaceCustomStringParameter,
    WorkspaceEncryptionParameter: WorkspaceEncryptionParameter,
    WorkspaceListResult: WorkspaceListResult,
    WorkspacePropertiesEncryption: WorkspacePropertiesEncryption,
    WorkspaceProviderAuthorization: WorkspaceProviderAuthorization,
    WorkspaceUpdate: WorkspaceUpdate
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._\\(\\)]+$"),
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workspaceName = {
    parameterPath: "workspaceName",
    mapper: {
        constraints: {
            MaxLength: 64,
            MinLength: 3
        },
        serializedName: "workspaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-02-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Workspace
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: WorkspaceUpdate
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const groupId = {
    parameterPath: "groupId",
    mapper: {
        serializedName: "groupId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnectionName = {
    parameterPath: "privateEndpointConnectionName",
    mapper: {
        serializedName: "privateEndpointConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointConnection = {
    parameterPath: "privateEndpointConnection",
    mapper: PrivateEndpointConnection
};
const peeringName = {
    parameterPath: "peeringName",
    mapper: {
        serializedName: "peeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetworkPeeringParameters = {
    parameterPath: "virtualNetworkPeeringParameters",
    mapper: VirtualNetworkPeering
};
const connectorName = {
    parameterPath: "connectorName",
    mapper: {
        constraints: {
            MaxLength: 64,
            MinLength: 3
        },
        serializedName: "connectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-05-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: AccessConnector
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: AccessConnectorUpdate
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Workspaces operations. */
class WorkspacesImpl {
    /**
     * Initialize a new instance of the class Workspaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the workspaces within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the workspaces within a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, getOperationSpec$4);
    }
    /**
     * Deletes the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, workspaceName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates a new workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param parameters Parameters supplied to the create or update a workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, workspaceName, parameters, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a new workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param parameters Parameters supplied to the create or update a workspace.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param parameters The update to the workspace.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, workspaceName, parameters, options },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param parameters The update to the workspace.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, workspaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, workspaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the workspaces within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Gets all the workspaces within a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Workspace
        },
        201: {
            bodyMapper: Workspace
        },
        202: {
            bodyMapper: Workspace
        },
        204: {
            bodyMapper: Workspace
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Databricks/workspaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkspaceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available RP operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available RP operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/providers/Microsoft.Databricks/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List private link resources for a given workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List private link resources for a given workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$2);
    }
    /**
     * Get the specified private link resource for the given group id (sub-resource)
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param groupId The name of the private link resource
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, groupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, groupId, options }, getOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateLinkResources/{groupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GroupIdInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        groupId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourcesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List private endpoint connections of the workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, workspaceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List private endpoint connections of the workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec$1);
    }
    /**
     * Get a private endpoint connection properties for a workspace
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            workspaceName,
            privateEndpointConnectionName,
            options
        }, getOperationSpec$2);
    }
    /**
     * Update the status of a private endpoint connection with the specified name
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection
     * @param privateEndpointConnection The private endpoint connection with updated properties
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, workspaceName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    workspaceName,
                    privateEndpointConnectionName,
                    privateEndpointConnection,
                    options
                },
                spec: createOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the status of a private endpoint connection with the specified name
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection
     * @param privateEndpointConnection The private endpoint connection with updated properties
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, workspaceName, privateEndpointConnectionName, privateEndpointConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, workspaceName, privateEndpointConnectionName, privateEndpointConnection, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Remove private endpoint connection with the specified name
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    workspaceName,
                    privateEndpointConnectionName,
                    options
                },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Remove private endpoint connection with the specified name
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param privateEndpointConnectionName The name of the private endpoint connection
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, privateEndpointConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, privateEndpointConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        201: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {
            bodyMapper: PrivateEndpointConnection
        },
        204: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateEndpointConnection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/privateEndpointConnections/{privateEndpointConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        privateEndpointConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OutboundNetworkDependenciesEndpoints operations. */
class OutboundNetworkDependenciesEndpointsImpl {
    /**
     * Initialize a new instance of the class OutboundNetworkDependenciesEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the list of endpoints that VNET Injected Workspace calls Azure Databricks Control Plane. You
     * must configure outbound access with these endpoints. For more information, see
     * https://docs.microsoft.com/azure/databricks/administration-guide/cloud-configurations/azure/udr
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    list(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/outboundNetworkDependenciesEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundEnvironmentEndpoint"
                        }
                    }
                }
            }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VNetPeering operations. */
class VNetPeeringImpl {
    /**
     * Initialize a new instance of the class VNetPeering class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the workspace vNet Peerings.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    listByWorkspace(resourceGroupName, workspaceName, options) {
        const iter = this.listByWorkspacePagingAll(resourceGroupName, workspaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options, settings);
            }
        };
    }
    listByWorkspacePagingPage(resourceGroupName, workspaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByWorkspace(resourceGroupName, workspaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByWorkspaceNext(resourceGroupName, workspaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByWorkspacePagingAll(resourceGroupName, workspaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByWorkspacePagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByWorkspacePagingPage(resourceGroupName, workspaceName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the workspace vNet Peering.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param peeringName The name of the workspace vNet peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, workspaceName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, peeringName, options }, getOperationSpec$1);
    }
    /**
     * Deletes the workspace vNetPeering.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param peeringName The name of the workspace vNet peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, workspaceName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, workspaceName, peeringName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the workspace vNetPeering.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param peeringName The name of the workspace vNet peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, workspaceName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, workspaceName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates vNet Peering for workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param peeringName The name of the workspace vNet peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create workspace vNet Peering.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, workspaceName, peeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    workspaceName,
                    peeringName,
                    virtualNetworkPeeringParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates vNet Peering for workspace.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param peeringName The name of the workspace vNet peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create workspace vNet Peering.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, workspaceName, peeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, workspaceName, peeringName, virtualNetworkPeeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the workspace vNet Peerings.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param options The options parameters.
     */
    _listByWorkspace(resourceGroupName, workspaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, options }, listByWorkspaceOperationSpec);
    }
    /**
     * ListByWorkspaceNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param workspaceName The name of the workspace.
     * @param nextLink The nextLink from the previous successful call to the ListByWorkspace method.
     * @param options The options parameters.
     */
    _listByWorkspaceNext(resourceGroupName, workspaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, workspaceName, nextLink, options }, listByWorkspaceNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/virtualNetworkPeerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/virtualNetworkPeerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/virtualNetworkPeerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        201: {
            bodyMapper: VirtualNetworkPeering
        },
        202: {
            bodyMapper: VirtualNetworkPeering
        },
        204: {
            bodyMapper: VirtualNetworkPeering
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: virtualNetworkPeeringParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByWorkspaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}/virtualNetworkPeerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByWorkspaceNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        workspaceName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AccessConnectors operations. */
class AccessConnectorsImpl {
    /**
     * Initialize a new instance of the class AccessConnectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the azure databricks accessConnectors within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the azure databricks accessConnectors within a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const page = _c;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets an azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param options The options parameters.
     */
    get(resourceGroupName, connectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, connectorName, options }, getOperationSpec);
    }
    /**
     * Deletes the azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, connectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, connectorName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, connectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, connectorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates or updates azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param parameters Parameters supplied to the create or update an azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, connectorName, parameters, options },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param parameters Parameters supplied to the create or update an azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, connectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param parameters The update to the azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, connectorName, parameters, options },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates an azure databricks accessConnector.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param connectorName The name of the azure databricks accessConnector.
     * @param parameters The update to the azure databricks accessConnector.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, connectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the azure databricks accessConnectors within a resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets all the azure databricks accessConnectors within a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/accessConnectors/{connectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessConnector
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/accessConnectors/{connectorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/accessConnectors/{connectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AccessConnector
        },
        201: {
            bodyMapper: AccessConnector
        },
        202: {
            bodyMapper: AccessConnector
        },
        204: {
            bodyMapper: AccessConnector
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/accessConnectors/{connectorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AccessConnector
        },
        201: {
            bodyMapper: AccessConnector
        },
        202: {
            bodyMapper: AccessConnector
        },
        204: {
            bodyMapper: AccessConnector
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/accessConnectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessConnectorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Databricks/accessConnectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessConnectorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessConnectorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessConnectorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class AzureDatabricksManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AzureDatabricksManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-databricks/3.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.workspaces = new WorkspacesImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.outboundNetworkDependenciesEndpoints = new OutboundNetworkDependenciesEndpointsImpl(this);
        this.vNetPeering = new VNetPeeringImpl(this);
        this.accessConnectors = new AccessConnectorsImpl(this);
    }
}

exports.AzureDatabricksManagementClient = AzureDatabricksManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
