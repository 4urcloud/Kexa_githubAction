'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var coreClient = require('@azure/core-client');
var tslib = require('tslib');
var coreLro = require('@azure/core-lro');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
(function (KnownParameterType) {
    /** The parameter's value is a string. */
    KnownParameterType["String"] = "String";
    /** The parameter's value is a string that holds sensitive information. */
    KnownParameterType["SecretString"] = "SecretString";
    /** The parameter's value is a 32-bit signed integer. */
    KnownParameterType["Int"] = "Int";
    /** The parameter's value is a 64-bit double-precision floating point. */
    KnownParameterType["Double"] = "Double";
    /** The parameter's value is a boolean value that is either true or false. */
    KnownParameterType["Bool"] = "Bool";
})(exports.KnownParameterType || (exports.KnownParameterType = {}));
(function (KnownKind) {
    /** Live pipeline topology resource. */
    KnownKind["Live"] = "Live";
    /** Batch pipeline topology resource. */
    KnownKind["Batch"] = "Batch";
})(exports.KnownKind || (exports.KnownKind = {}));
(function (KnownSkuName) {
    /** Represents the Live S1 SKU name. Using this SKU you can create live pipelines to capture, record, and stream live video from RTSP-capable cameras at bitrate settings from 0.5 Kbps to 3000 Kbps. */
    KnownSkuName["LiveS1"] = "Live_S1";
    /** Represents the Batch S1 SKU name. Using this SKU you can create pipeline jobs to process recorded content. */
    KnownSkuName["BatchS1"] = "Batch_S1";
})(exports.KnownSkuName || (exports.KnownSkuName = {}));
(function (KnownSkuTier) {
    /** Standard tier. */
    KnownSkuTier["Standard"] = "Standard";
})(exports.KnownSkuTier || (exports.KnownSkuTier = {}));
(function (KnownLivePipelineState) {
    /** The live pipeline is idle and not processing media. */
    KnownLivePipelineState["Inactive"] = "Inactive";
    /** The live pipeline is transitioning into the active state. */
    KnownLivePipelineState["Activating"] = "Activating";
    /** The live pipeline is active and able to process media. If your data source is not available, for instance, if your RTSP camera is powered off or unreachable, the pipeline will still be active and periodically retrying the connection. Your Azure subscription will be billed for the duration in which the live pipeline is in the active state. */
    KnownLivePipelineState["Active"] = "Active";
    /** The live pipeline is transitioning into the inactive state. */
    KnownLivePipelineState["Deactivating"] = "Deactivating";
})(exports.KnownLivePipelineState || (exports.KnownLivePipelineState = {}));
(function (KnownPipelineJobState) {
    /** Pipeline job is processing. */
    KnownPipelineJobState["Processing"] = "Processing";
    /** Pipeline job is canceled. */
    KnownPipelineJobState["Canceled"] = "Canceled";
    /** Pipeline job completed. */
    KnownPipelineJobState["Completed"] = "Completed";
    /** Pipeline job failed. */
    KnownPipelineJobState["Failed"] = "Failed";
})(exports.KnownPipelineJobState || (exports.KnownPipelineJobState = {}));
(function (KnownMetricUnit) {
    /** The number of bytes. */
    KnownMetricUnit["Bytes"] = "Bytes";
    /** The count. */
    KnownMetricUnit["Count"] = "Count";
    /** The number of milliseconds. */
    KnownMetricUnit["Milliseconds"] = "Milliseconds";
})(exports.KnownMetricUnit || (exports.KnownMetricUnit = {}));
(function (KnownMetricAggregationType) {
    /** The average. */
    KnownMetricAggregationType["Average"] = "Average";
    /** The count of a number of items, usually requests. */
    KnownMetricAggregationType["Count"] = "Count";
    /** The sum. */
    KnownMetricAggregationType["Total"] = "Total";
})(exports.KnownMetricAggregationType || (exports.KnownMetricAggregationType = {}));
(function (KnownActionType) {
    /** An internal action. */
    KnownActionType["Internal"] = "Internal";
})(exports.KnownActionType || (exports.KnownActionType = {}));
(function (KnownVideoAnalyzerEndpointType) {
    /** The client API endpoint. */
    KnownVideoAnalyzerEndpointType["ClientApi"] = "ClientApi";
})(exports.KnownVideoAnalyzerEndpointType || (exports.KnownVideoAnalyzerEndpointType = {}));
(function (KnownAccountEncryptionKeyType) {
    /** The Account Key is encrypted with a System Key. */
    KnownAccountEncryptionKeyType["SystemKey"] = "SystemKey";
    /** The Account Key is encrypted with a Customer Key. */
    KnownAccountEncryptionKeyType["CustomerKey"] = "CustomerKey";
})(exports.KnownAccountEncryptionKeyType || (exports.KnownAccountEncryptionKeyType = {}));
(function (KnownPublicNetworkAccess) {
    /** Public network access is enabled. */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Public network access is disabled. */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(exports.KnownPublicNetworkAccess || (exports.KnownPublicNetworkAccess = {}));
(function (KnownProvisioningState) {
    /** Provisioning state failed. */
    KnownProvisioningState["Failed"] = "Failed";
    /** Provisioning state in progress. */
    KnownProvisioningState["InProgress"] = "InProgress";
    /** Provisioning state succeeded. */
    KnownProvisioningState["Succeeded"] = "Succeeded";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownPrivateEndpointServiceConnectionStatus) {
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(exports.KnownPrivateEndpointServiceConnectionStatus || (exports.KnownPrivateEndpointServiceConnectionStatus = {}));
(function (KnownPrivateEndpointConnectionProvisioningState) {
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(exports.KnownPrivateEndpointConnectionProvisioningState || (exports.KnownPrivateEndpointConnectionProvisioningState = {}));
(function (KnownCheckNameAvailabilityReason) {
    KnownCheckNameAvailabilityReason["Invalid"] = "Invalid";
    KnownCheckNameAvailabilityReason["AlreadyExists"] = "AlreadyExists";
})(exports.KnownCheckNameAvailabilityReason || (exports.KnownCheckNameAvailabilityReason = {}));
(function (KnownVideoType) {
    /** Archive is flexible format that represents a video stream associated with wall-clock time. The video archive can either be continuous or discontinuous. An archive is discontinuous when there are gaps in the recording due to various reasons, such as the live pipeline being stopped, camera being disconnected or due to the use of event based recordings through the use of a signal gate. There is no limit to the archive duration and new video data can be appended to the existing archive at any time, as long as the same video codec and codec parameters are being used. Videos of this type are suitable for appending and long term archival. */
    KnownVideoType["Archive"] = "Archive";
    /** File represents a video which is stored as a single media file, such as MP4. Videos of this type are suitable to be downloaded for external consumption. */
    KnownVideoType["File"] = "File";
})(exports.KnownVideoType || (exports.KnownVideoType = {}));
(function (KnownAccessPolicyRole) {
    /** Reader role allows for read-only operations to be performed through the client APIs. */
    KnownAccessPolicyRole["Reader"] = "Reader";
})(exports.KnownAccessPolicyRole || (exports.KnownAccessPolicyRole = {}));
(function (KnownRtspTransport) {
    /** HTTP transport. RTSP messages are exchanged over long running HTTP requests and RTP packets are interleaved within the HTTP channel. */
    KnownRtspTransport["Http"] = "Http";
    /** TCP transport. RTSP is used directly over TCP and RTP packets are interleaved within the TCP channel. */
    KnownRtspTransport["Tcp"] = "Tcp";
})(exports.KnownRtspTransport || (exports.KnownRtspTransport = {}));
(function (KnownEncoderSystemPresetType) {
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 540 pixels, and at a maximum bitrate of 2000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps */
    KnownEncoderSystemPresetType["SingleLayer540PH264AAC"] = "SingleLayer_540p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 720 pixels, and at a maximum bitrate of 3500 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps */
    KnownEncoderSystemPresetType["SingleLayer720PH264AAC"] = "SingleLayer_720p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 1080 pixels, and at a maximum bitrate of 6000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps */
    KnownEncoderSystemPresetType["SingleLayer1080PH264AAC"] = "SingleLayer_1080p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 2160 pixels, and at a maximum bitrate of 16000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps */
    KnownEncoderSystemPresetType["SingleLayer2160PH264AAC"] = "SingleLayer_2160p_H264_AAC";
})(exports.KnownEncoderSystemPresetType || (exports.KnownEncoderSystemPresetType = {}));
(function (KnownVideoScaleMode) {
    /** Pads the video with black horizontal stripes (letterbox) or black vertical stripes (pillar-box) so the video is resized to the specified dimensions while not altering the content aspect ratio. */
    KnownVideoScaleMode["Pad"] = "Pad";
    /** Preserves the same aspect ratio as the input video. If only one video dimension is provided, the second dimension is calculated based on the input video aspect ratio. When 2 dimensions are provided, the video is resized to fit the most constraining dimension, considering the input video size and aspect ratio. */
    KnownVideoScaleMode["PreserveAspectRatio"] = "PreserveAspectRatio";
    /** Stretches the original video so it resized to the specified dimensions. */
    KnownVideoScaleMode["Stretch"] = "Stretch";
})(exports.KnownVideoScaleMode || (exports.KnownVideoScaleMode = {}));
(function (KnownAccessPolicyRsaAlgo) {
    /** RS256 */
    KnownAccessPolicyRsaAlgo["RS256"] = "RS256";
    /** RS384 */
    KnownAccessPolicyRsaAlgo["RS384"] = "RS384";
    /** RS512 */
    KnownAccessPolicyRsaAlgo["RS512"] = "RS512";
})(exports.KnownAccessPolicyRsaAlgo || (exports.KnownAccessPolicyRsaAlgo = {}));
(function (KnownAccessPolicyEccAlgo) {
    /** ES265 */
    KnownAccessPolicyEccAlgo["ES256"] = "ES256";
    /** ES384 */
    KnownAccessPolicyEccAlgo["ES384"] = "ES384";
    /** ES512 */
    KnownAccessPolicyEccAlgo["ES512"] = "ES512";
})(exports.KnownAccessPolicyEccAlgo || (exports.KnownAccessPolicyEccAlgo = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const EdgeModuleEntityCollection = {
    type: {
        name: "Composite",
        className: "EdgeModuleEntityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EdgeModuleEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const ListProvisioningTokenInput = {
    type: {
        name: "Composite",
        className: "ListProvisioningTokenInput",
        modelProperties: {
            expirationDate: {
                serializedName: "expirationDate",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const EdgeModuleProvisioningToken = {
    type: {
        name: "Composite",
        className: "EdgeModuleProvisioningToken",
        modelProperties: {
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            token: {
                serializedName: "token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PipelineTopologyCollection = {
    type: {
        name: "Composite",
        className: "PipelineTopologyCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PipelineTopology"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParameterDeclaration = {
    type: {
        name: "Composite",
        className: "ParameterDeclaration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeBase = {
    type: {
        name: "Composite",
        className: "NodeBase",
        uberParent: "NodeBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NodeInput = {
    type: {
        name: "Composite",
        className: "NodeInput",
        modelProperties: {
            nodeName: {
                serializedName: "nodeName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LivePipelineCollection = {
    type: {
        name: "Composite",
        className: "LivePipelineCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LivePipeline"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParameterDefinition = {
    type: {
        name: "Composite",
        className: "ParameterDefinition",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PipelineJobCollection = {
    type: {
        name: "Composite",
        className: "PipelineJobCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PipelineJob"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PipelineJobError = {
    type: {
        name: "Composite",
        className: "PipelineJobError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LivePipelineOperationStatus = {
    type: {
        name: "Composite",
        className: "LivePipelineOperationStatus",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const PipelineJobOperationStatus = {
    type: {
        name: "Composite",
        className: "PipelineJobOperationStatus",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const OperationCollection = {
    type: {
        name: "Composite",
        className: "OperationCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "Properties"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            actionType: {
                serializedName: "actionType",
                nullable: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Properties = {
    type: {
        name: "Composite",
        className: "Properties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            },
            metricSpecifications: {
                serializedName: "metricSpecifications",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            lockAggregationType: {
                serializedName: "lockAggregationType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            dimensions: {
                serializedName: "dimensions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MetricDimension = {
    type: {
        name: "Composite",
        className: "MetricDimension",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VideoAnalyzerCollection = {
    type: {
        name: "Composite",
        className: "VideoAnalyzerCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VideoAnalyzer"
                        }
                    }
                }
            }
        }
    }
};
const StorageAccount = {
    type: {
        name: "Composite",
        className: "StorageAccount",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceIdentity = {
    type: {
        name: "Composite",
        className: "ResourceIdentity",
        modelProperties: {
            userAssignedIdentity: {
                serializedName: "userAssignedIdentity",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Endpoint = {
    type: {
        name: "Composite",
        className: "Endpoint",
        modelProperties: {
            endpointUrl: {
                serializedName: "endpointUrl",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccountEncryption = {
    type: {
        name: "Composite",
        className: "AccountEncryption",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "KeyVaultProperties"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyVaultProperties = {
    type: {
        name: "Composite",
        className: "KeyVaultProperties",
        modelProperties: {
            keyIdentifier: {
                serializedName: "keyIdentifier",
                required: true,
                type: {
                    name: "String"
                }
            },
            currentKeyIdentifier: {
                serializedName: "currentKeyIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IotHub = {
    type: {
        name: "Composite",
        className: "IotHub",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ResourceIdentity"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkAccessControl = {
    type: {
        name: "Composite",
        className: "NetworkAccessControl",
        modelProperties: {
            integration: {
                serializedName: "integration",
                type: {
                    name: "Composite",
                    className: "GroupLevelAccessControl"
                }
            },
            ingestion: {
                serializedName: "ingestion",
                type: {
                    name: "Composite",
                    className: "GroupLevelAccessControl"
                }
            },
            consumption: {
                serializedName: "consumption",
                type: {
                    name: "Composite",
                    className: "GroupLevelAccessControl"
                }
            }
        }
    }
};
const GroupLevelAccessControl = {
    type: {
        name: "Composite",
        className: "GroupLevelAccessControl",
        modelProperties: {
            publicNetworkAccess: {
                serializedName: "publicNetworkAccess",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoAnalyzerIdentity = {
    type: {
        name: "Composite",
        className: "VideoAnalyzerIdentity",
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "UserAssignedManagedIdentity"
                        }
                    }
                }
            }
        }
    }
};
const UserAssignedManagedIdentity = {
    type: {
        name: "Composite",
        className: "UserAssignedManagedIdentity",
        modelProperties: {
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Uuid"
                }
            },
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                nullable: true,
                type: {
                    name: "Uuid"
                }
            }
        }
    }
};
const VideoAnalyzerUpdate = {
    type: {
        name: "Composite",
        className: "VideoAnalyzerUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VideoAnalyzerIdentity"
                }
            },
            storageAccounts: {
                serializedName: "properties.storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            },
            endpoints: {
                serializedName: "properties.endpoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Endpoint"
                        }
                    }
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "AccountEncryption"
                }
            },
            iotHubs: {
                serializedName: "properties.iotHubs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IotHub"
                        }
                    }
                }
            },
            publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            },
            networkAccessControl: {
                serializedName: "properties.networkAccessControl",
                type: {
                    name: "Composite",
                    className: "NetworkAccessControl"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const PrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkResource"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }
        }
    }
};
const VideoAnalyzerPrivateEndpointConnectionOperationStatus = {
    type: {
        name: "Composite",
        className: "VideoAnalyzerPrivateEndpointConnectionOperationStatus",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const VideoAnalyzerOperationStatus = {
    type: {
        name: "Composite",
        className: "VideoAnalyzerOperationStatus",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "String"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const CheckNameAvailabilityRequest = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityRequest",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckNameAvailabilityResponse = {
    type: {
        name: "Composite",
        className: "CheckNameAvailabilityResponse",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoEntityCollection = {
    type: {
        name: "Composite",
        className: "VideoEntityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VideoEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoFlags = {
    type: {
        name: "Composite",
        className: "VideoFlags",
        modelProperties: {
            canStream: {
                serializedName: "canStream",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            hasData: {
                serializedName: "hasData",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            isInUse: {
                serializedName: "isInUse",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VideoContentUrls = {
    type: {
        name: "Composite",
        className: "VideoContentUrls",
        modelProperties: {
            downloadUrl: {
                serializedName: "downloadUrl",
                type: {
                    name: "String"
                }
            },
            archiveBaseUrl: {
                serializedName: "archiveBaseUrl",
                type: {
                    name: "String"
                }
            },
            rtspTunnelUrl: {
                serializedName: "rtspTunnelUrl",
                type: {
                    name: "String"
                }
            },
            previewImageUrls: {
                serializedName: "previewImageUrls",
                type: {
                    name: "Composite",
                    className: "VideoPreviewImageUrls"
                }
            }
        }
    }
};
const VideoPreviewImageUrls = {
    type: {
        name: "Composite",
        className: "VideoPreviewImageUrls",
        modelProperties: {
            small: {
                serializedName: "small",
                type: {
                    name: "String"
                }
            },
            medium: {
                serializedName: "medium",
                type: {
                    name: "String"
                }
            },
            large: {
                serializedName: "large",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoMediaInfo = {
    type: {
        name: "Composite",
        className: "VideoMediaInfo",
        modelProperties: {
            segmentLength: {
                serializedName: "segmentLength",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoArchival = {
    type: {
        name: "Composite",
        className: "VideoArchival",
        modelProperties: {
            retentionPeriod: {
                serializedName: "retentionPeriod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoContentToken = {
    type: {
        name: "Composite",
        className: "VideoContentToken",
        modelProperties: {
            expirationDate: {
                serializedName: "expirationDate",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            token: {
                serializedName: "token",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AccessPolicyEntityCollection = {
    type: {
        name: "Composite",
        className: "AccessPolicyEntityCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AccessPolicyEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthenticationBase = {
    type: {
        name: "Composite",
        className: "AuthenticationBase",
        uberParent: "AuthenticationBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointBase = {
    type: {
        name: "Composite",
        className: "EndpointBase",
        uberParent: "EndpointBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            },
            credentials: {
                serializedName: "credentials",
                type: {
                    name: "Composite",
                    className: "CredentialsBase"
                }
            },
            url: {
                serializedName: "url",
                required: true,
                type: {
                    name: "String"
                }
            },
            tunnel: {
                serializedName: "tunnel",
                type: {
                    name: "Composite",
                    className: "TunnelBase"
                }
            }
        }
    }
};
const CredentialsBase = {
    type: {
        name: "Composite",
        className: "CredentialsBase",
        uberParent: "CredentialsBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TunnelBase = {
    type: {
        name: "Composite",
        className: "TunnelBase",
        uberParent: "TunnelBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CertificateSource = {
    type: {
        name: "Composite",
        className: "CertificateSource",
        uberParent: "CertificateSource",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TlsValidationOptions = {
    type: {
        name: "Composite",
        className: "TlsValidationOptions",
        modelProperties: {
            ignoreHostname: {
                serializedName: "ignoreHostname",
                type: {
                    name: "String"
                }
            },
            ignoreSignature: {
                serializedName: "ignoreSignature",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TimeSequenceBase = {
    type: {
        name: "Composite",
        className: "TimeSequenceBase",
        uberParent: "TimeSequenceBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EncoderPresetBase = {
    type: {
        name: "Composite",
        className: "EncoderPresetBase",
        uberParent: "EncoderPresetBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AudioEncoderBase = {
    type: {
        name: "Composite",
        className: "AudioEncoderBase",
        uberParent: "AudioEncoderBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            },
            bitrateKbps: {
                serializedName: "bitrateKbps",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoEncoderBase = {
    type: {
        name: "Composite",
        className: "VideoEncoderBase",
        uberParent: "VideoEncoderBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            },
            bitrateKbps: {
                serializedName: "bitrateKbps",
                type: {
                    name: "String"
                }
            },
            frameRate: {
                serializedName: "frameRate",
                type: {
                    name: "String"
                }
            },
            scale: {
                serializedName: "scale",
                type: {
                    name: "Composite",
                    className: "VideoScale"
                }
            }
        }
    }
};
const VideoScale = {
    type: {
        name: "Composite",
        className: "VideoScale",
        modelProperties: {
            height: {
                serializedName: "height",
                type: {
                    name: "String"
                }
            },
            width: {
                serializedName: "width",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoCreationProperties = {
    type: {
        name: "Composite",
        className: "VideoCreationProperties",
        modelProperties: {
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            segmentLength: {
                serializedName: "segmentLength",
                type: {
                    name: "String"
                }
            },
            retentionPeriod: {
                serializedName: "retentionPeriod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoPublishingOptions = {
    type: {
        name: "Composite",
        className: "VideoPublishingOptions",
        modelProperties: {
            disableArchive: {
                serializedName: "disableArchive",
                type: {
                    name: "String"
                }
            },
            disableRtspPublishing: {
                serializedName: "disableRtspPublishing",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenClaim = {
    type: {
        name: "Composite",
        className: "TokenClaim",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TokenKey = {
    type: {
        name: "Composite",
        className: "TokenKey",
        uberParent: "TokenKey",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "@type",
                required: true,
                type: {
                    name: "String"
                }
            },
            kid: {
                serializedName: "kid",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkResource = {
    type: {
        name: "Composite",
        className: "PrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const SourceNodeBase = {
    serializedName: "#Microsoft.VideoAnalyzer.SourceNodeBase",
    type: {
        name: "Composite",
        className: "SourceNodeBase",
        uberParent: "NodeBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: Object.assign({}, NodeBase.type.modelProperties)
    }
};
const ProcessorNodeBase = {
    serializedName: "#Microsoft.VideoAnalyzer.ProcessorNodeBase",
    type: {
        name: "Composite",
        className: "ProcessorNodeBase",
        uberParent: "NodeBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: Object.assign(Object.assign({}, NodeBase.type.modelProperties), { inputs: {
                serializedName: "inputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NodeInput"
                        }
                    }
                }
            } })
    }
};
const SinkNodeBase = {
    serializedName: "#Microsoft.VideoAnalyzer.SinkNodeBase",
    type: {
        name: "Composite",
        className: "SinkNodeBase",
        uberParent: "NodeBase",
        polymorphicDiscriminator: {
            serializedName: "@type",
            clientName: "type"
        },
        modelProperties: Object.assign(Object.assign({}, NodeBase.type.modelProperties), { inputs: {
                serializedName: "inputs",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NodeInput"
                        }
                    }
                }
            } })
    }
};
const JwtAuthentication = {
    serializedName: "#Microsoft.VideoAnalyzer.JwtAuthentication",
    type: {
        name: "Composite",
        className: "JwtAuthentication",
        uberParent: "AuthenticationBase",
        polymorphicDiscriminator: AuthenticationBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AuthenticationBase.type.modelProperties), { issuers: {
                serializedName: "issuers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, audiences: {
                serializedName: "audiences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, claims: {
                serializedName: "claims",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenClaim"
                        }
                    }
                }
            }, keys: {
                serializedName: "keys",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TokenKey"
                        }
                    }
                }
            } })
    }
};
const UnsecuredEndpoint = {
    serializedName: "#Microsoft.VideoAnalyzer.UnsecuredEndpoint",
    type: {
        name: "Composite",
        className: "UnsecuredEndpoint",
        uberParent: "EndpointBase",
        polymorphicDiscriminator: EndpointBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, EndpointBase.type.modelProperties)
    }
};
const TlsEndpoint = {
    serializedName: "#Microsoft.VideoAnalyzer.TlsEndpoint",
    type: {
        name: "Composite",
        className: "TlsEndpoint",
        uberParent: "EndpointBase",
        polymorphicDiscriminator: EndpointBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EndpointBase.type.modelProperties), { trustedCertificates: {
                serializedName: "trustedCertificates",
                type: {
                    name: "Composite",
                    className: "CertificateSource"
                }
            }, validationOptions: {
                serializedName: "validationOptions",
                type: {
                    name: "Composite",
                    className: "TlsValidationOptions"
                }
            } })
    }
};
const UsernamePasswordCredentials = {
    serializedName: "#Microsoft.VideoAnalyzer.UsernamePasswordCredentials",
    type: {
        name: "Composite",
        className: "UsernamePasswordCredentials",
        uberParent: "CredentialsBase",
        polymorphicDiscriminator: CredentialsBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CredentialsBase.type.modelProperties), { username: {
                serializedName: "username",
                required: true,
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "password",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecureIotDeviceRemoteTunnel = {
    serializedName: "#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel",
    type: {
        name: "Composite",
        className: "SecureIotDeviceRemoteTunnel",
        uberParent: "TunnelBase",
        polymorphicDiscriminator: TunnelBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TunnelBase.type.modelProperties), { iotHubName: {
                serializedName: "iotHubName",
                required: true,
                type: {
                    name: "String"
                }
            }, deviceId: {
                serializedName: "deviceId",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PemCertificateList = {
    serializedName: "#Microsoft.VideoAnalyzer.PemCertificateList",
    type: {
        name: "Composite",
        className: "PemCertificateList",
        uberParent: "CertificateSource",
        polymorphicDiscriminator: CertificateSource.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, CertificateSource.type.modelProperties), { certificates: {
                serializedName: "certificates",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const VideoSequenceAbsoluteTimeMarkers = {
    serializedName: "#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers",
    type: {
        name: "Composite",
        className: "VideoSequenceAbsoluteTimeMarkers",
        uberParent: "TimeSequenceBase",
        polymorphicDiscriminator: TimeSequenceBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TimeSequenceBase.type.modelProperties), { ranges: {
                serializedName: "ranges",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EncoderSystemPreset = {
    serializedName: "#Microsoft.VideoAnalyzer.EncoderSystemPreset",
    type: {
        name: "Composite",
        className: "EncoderSystemPreset",
        uberParent: "EncoderPresetBase",
        polymorphicDiscriminator: EncoderPresetBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EncoderPresetBase.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EncoderCustomPreset = {
    serializedName: "#Microsoft.VideoAnalyzer.EncoderCustomPreset",
    type: {
        name: "Composite",
        className: "EncoderCustomPreset",
        uberParent: "EncoderPresetBase",
        polymorphicDiscriminator: EncoderPresetBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EncoderPresetBase.type.modelProperties), { audioEncoder: {
                serializedName: "audioEncoder",
                type: {
                    name: "Composite",
                    className: "AudioEncoderBase"
                }
            }, videoEncoder: {
                serializedName: "videoEncoder",
                type: {
                    name: "Composite",
                    className: "VideoEncoderBase"
                }
            } })
    }
};
const AudioEncoderAac = {
    serializedName: "#Microsoft.VideoAnalyzer.AudioEncoderAac",
    type: {
        name: "Composite",
        className: "AudioEncoderAac",
        uberParent: "AudioEncoderBase",
        polymorphicDiscriminator: AudioEncoderBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, AudioEncoderBase.type.modelProperties)
    }
};
const VideoEncoderH264 = {
    serializedName: "#Microsoft.VideoAnalyzer.VideoEncoderH264",
    type: {
        name: "Composite",
        className: "VideoEncoderH264",
        uberParent: "VideoEncoderBase",
        polymorphicDiscriminator: VideoEncoderBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, VideoEncoderBase.type.modelProperties)
    }
};
const RsaTokenKey = {
    serializedName: "#Microsoft.VideoAnalyzer.RsaTokenKey",
    type: {
        name: "Composite",
        className: "RsaTokenKey",
        uberParent: "TokenKey",
        polymorphicDiscriminator: TokenKey.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenKey.type.modelProperties), { alg: {
                serializedName: "alg",
                required: true,
                type: {
                    name: "String"
                }
            }, n: {
                serializedName: "n",
                required: true,
                type: {
                    name: "String"
                }
            }, e: {
                serializedName: "e",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EccTokenKey = {
    serializedName: "#Microsoft.VideoAnalyzer.EccTokenKey",
    type: {
        name: "Composite",
        className: "EccTokenKey",
        uberParent: "TokenKey",
        polymorphicDiscriminator: TokenKey.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, TokenKey.type.modelProperties), { alg: {
                serializedName: "alg",
                required: true,
                type: {
                    name: "String"
                }
            }, x: {
                serializedName: "x",
                required: true,
                type: {
                    name: "String"
                }
            }, y: {
                serializedName: "y",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EdgeModuleEntity = {
    type: {
        name: "Composite",
        className: "EdgeModuleEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { edgeModuleId: {
                serializedName: "properties.edgeModuleId",
                readOnly: true,
                type: {
                    name: "Uuid"
                }
            } })
    }
};
const PipelineTopology = {
    type: {
        name: "Composite",
        className: "PipelineTopology",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDeclaration"
                        }
                    }
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceNodeBase"
                        }
                    }
                }
            }, processors: {
                serializedName: "properties.processors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessorNodeBase"
                        }
                    }
                }
            }, sinks: {
                serializedName: "properties.sinks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SinkNodeBase"
                        }
                    }
                }
            } })
    }
};
const PipelineTopologyUpdate = {
    type: {
        name: "Composite",
        className: "PipelineTopologyUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDeclaration"
                        }
                    }
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SourceNodeBase"
                        }
                    }
                }
            }, processors: {
                serializedName: "properties.processors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProcessorNodeBase"
                        }
                    }
                }
            }, sinks: {
                serializedName: "properties.sinks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SinkNodeBase"
                        }
                    }
                }
            } })
    }
};
const LivePipeline = {
    type: {
        name: "Composite",
        className: "LivePipeline",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { topologyName: {
                serializedName: "properties.topologyName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, bitrateKbps: {
                serializedName: "properties.bitrateKbps",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDefinition"
                        }
                    }
                }
            } })
    }
};
const LivePipelineUpdate = {
    type: {
        name: "Composite",
        className: "LivePipelineUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { topologyName: {
                serializedName: "properties.topologyName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, bitrateKbps: {
                serializedName: "properties.bitrateKbps",
                type: {
                    name: "Number"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDefinition"
                        }
                    }
                }
            } })
    }
};
const PipelineJob = {
    type: {
        name: "Composite",
        className: "PipelineJob",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { topologyName: {
                serializedName: "properties.topologyName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expiration: {
                serializedName: "properties.expiration",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, error: {
                serializedName: "properties.error",
                type: {
                    name: "Composite",
                    className: "PipelineJobError"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDefinition"
                        }
                    }
                }
            } })
    }
};
const PipelineJobUpdate = {
    type: {
        name: "Composite",
        className: "PipelineJobUpdate",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { topologyName: {
                serializedName: "properties.topologyName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expiration: {
                serializedName: "properties.expiration",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, error: {
                serializedName: "properties.error",
                type: {
                    name: "Composite",
                    className: "PipelineJobError"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParameterDefinition"
                        }
                    }
                }
            } })
    }
};
const VideoEntity = {
    type: {
        name: "Composite",
        className: "VideoEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { title: {
                serializedName: "properties.title",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, flags: {
                serializedName: "properties.flags",
                type: {
                    name: "Composite",
                    className: "VideoFlags"
                }
            }, contentUrls: {
                serializedName: "properties.contentUrls",
                type: {
                    name: "Composite",
                    className: "VideoContentUrls"
                }
            }, mediaInfo: {
                serializedName: "properties.mediaInfo",
                type: {
                    name: "Composite",
                    className: "VideoMediaInfo"
                }
            }, archival: {
                serializedName: "properties.archival",
                type: {
                    name: "Composite",
                    className: "VideoArchival"
                }
            } })
    }
};
const AccessPolicyEntity = {
    type: {
        name: "Composite",
        className: "AccessPolicyEntity",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { role: {
                serializedName: "properties.role",
                nullable: true,
                type: {
                    name: "String"
                }
            }, authentication: {
                serializedName: "properties.authentication",
                type: {
                    name: "Composite",
                    className: "AuthenticationBase"
                }
            } })
    }
};
const VideoAnalyzer = {
    type: {
        name: "Composite",
        className: "VideoAnalyzer",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "VideoAnalyzerIdentity"
                }
            }, storageAccounts: {
                serializedName: "properties.storageAccounts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageAccount"
                        }
                    }
                }
            }, endpoints: {
                serializedName: "properties.endpoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Endpoint"
                        }
                    }
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "AccountEncryption"
                }
            }, iotHubs: {
                serializedName: "properties.iotHubs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IotHub"
                        }
                    }
                }
            }, publicNetworkAccess: {
                serializedName: "properties.publicNetworkAccess",
                type: {
                    name: "String"
                }
            }, networkAccessControl: {
                serializedName: "properties.networkAccessControl",
                type: {
                    name: "Composite",
                    className: "NetworkAccessControl"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            } })
    }
};
const RtspSource = {
    serializedName: "#Microsoft.VideoAnalyzer.RtspSource",
    type: {
        name: "Composite",
        className: "RtspSource",
        uberParent: "NodeBase",
        polymorphicDiscriminator: NodeBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SourceNodeBase.type.modelProperties), { transport: {
                serializedName: "transport",
                type: {
                    name: "String"
                }
            }, endpoint: {
                serializedName: "endpoint",
                type: {
                    name: "Composite",
                    className: "EndpointBase"
                }
            } })
    }
};
const VideoSource = {
    serializedName: "#Microsoft.VideoAnalyzer.VideoSource",
    type: {
        name: "Composite",
        className: "VideoSource",
        uberParent: "NodeBase",
        polymorphicDiscriminator: NodeBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SourceNodeBase.type.modelProperties), { videoName: {
                serializedName: "videoName",
                required: true,
                type: {
                    name: "String"
                }
            }, timeSequences: {
                serializedName: "timeSequences",
                type: {
                    name: "Composite",
                    className: "TimeSequenceBase"
                }
            } })
    }
};
const EncoderProcessor = {
    serializedName: "#Microsoft.VideoAnalyzer.EncoderProcessor",
    type: {
        name: "Composite",
        className: "EncoderProcessor",
        uberParent: "NodeBase",
        polymorphicDiscriminator: NodeBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ProcessorNodeBase.type.modelProperties), { preset: {
                serializedName: "preset",
                type: {
                    name: "Composite",
                    className: "EncoderPresetBase"
                }
            } })
    }
};
const VideoSink = {
    serializedName: "#Microsoft.VideoAnalyzer.VideoSink",
    type: {
        name: "Composite",
        className: "VideoSink",
        uberParent: "NodeBase",
        polymorphicDiscriminator: NodeBase.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, SinkNodeBase.type.modelProperties), { videoName: {
                serializedName: "videoName",
                required: true,
                type: {
                    name: "String"
                }
            }, videoCreationProperties: {
                serializedName: "videoCreationProperties",
                type: {
                    name: "Composite",
                    className: "VideoCreationProperties"
                }
            }, videoPublishingOptions: {
                serializedName: "videoPublishingOptions",
                type: {
                    name: "Composite",
                    className: "VideoPublishingOptions"
                }
            } })
    }
};
const VideoAnalyzersCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "VideoAnalyzersCreateOrUpdateHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VideoAnalyzersUpdateHeaders = {
    type: {
        name: "Composite",
        className: "VideoAnalyzersUpdateHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionsCreateOrUpdateHeaders",
        modelProperties: {
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    NodeBase: NodeBase,
    AuthenticationBase: AuthenticationBase,
    EndpointBase: EndpointBase,
    CredentialsBase: CredentialsBase,
    TunnelBase: TunnelBase,
    CertificateSource: CertificateSource,
    TimeSequenceBase: TimeSequenceBase,
    EncoderPresetBase: EncoderPresetBase,
    AudioEncoderBase: AudioEncoderBase,
    VideoEncoderBase: VideoEncoderBase,
    TokenKey: TokenKey,
    "NodeBase.#Microsoft.VideoAnalyzer.SourceNodeBase": SourceNodeBase,
    "NodeBase.#Microsoft.VideoAnalyzer.ProcessorNodeBase": ProcessorNodeBase,
    "NodeBase.#Microsoft.VideoAnalyzer.SinkNodeBase": SinkNodeBase,
    "AuthenticationBase.#Microsoft.VideoAnalyzer.JwtAuthentication": JwtAuthentication,
    "EndpointBase.#Microsoft.VideoAnalyzer.UnsecuredEndpoint": UnsecuredEndpoint,
    "EndpointBase.#Microsoft.VideoAnalyzer.TlsEndpoint": TlsEndpoint,
    "CredentialsBase.#Microsoft.VideoAnalyzer.UsernamePasswordCredentials": UsernamePasswordCredentials,
    "TunnelBase.#Microsoft.VideoAnalyzer.SecureIotDeviceRemoteTunnel": SecureIotDeviceRemoteTunnel,
    "CertificateSource.#Microsoft.VideoAnalyzer.PemCertificateList": PemCertificateList,
    "TimeSequenceBase.#Microsoft.VideoAnalyzer.VideoSequenceAbsoluteTimeMarkers": VideoSequenceAbsoluteTimeMarkers,
    "EncoderPresetBase.#Microsoft.VideoAnalyzer.EncoderSystemPreset": EncoderSystemPreset,
    "EncoderPresetBase.#Microsoft.VideoAnalyzer.EncoderCustomPreset": EncoderCustomPreset,
    "AudioEncoderBase.#Microsoft.VideoAnalyzer.AudioEncoderAac": AudioEncoderAac,
    "VideoEncoderBase.#Microsoft.VideoAnalyzer.VideoEncoderH264": VideoEncoderH264,
    "TokenKey.#Microsoft.VideoAnalyzer.RsaTokenKey": RsaTokenKey,
    "TokenKey.#Microsoft.VideoAnalyzer.EccTokenKey": EccTokenKey,
    "NodeBase.#Microsoft.VideoAnalyzer.RtspSource": RtspSource,
    "NodeBase.#Microsoft.VideoAnalyzer.VideoSource": VideoSource,
    "NodeBase.#Microsoft.VideoAnalyzer.EncoderProcessor": EncoderProcessor,
    "NodeBase.#Microsoft.VideoAnalyzer.VideoSink": VideoSink
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    EdgeModuleEntityCollection: EdgeModuleEntityCollection,
    Resource: Resource,
    SystemData: SystemData,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    ListProvisioningTokenInput: ListProvisioningTokenInput,
    EdgeModuleProvisioningToken: EdgeModuleProvisioningToken,
    PipelineTopologyCollection: PipelineTopologyCollection,
    ParameterDeclaration: ParameterDeclaration,
    NodeBase: NodeBase,
    NodeInput: NodeInput,
    Sku: Sku,
    LivePipelineCollection: LivePipelineCollection,
    ParameterDefinition: ParameterDefinition,
    PipelineJobCollection: PipelineJobCollection,
    PipelineJobError: PipelineJobError,
    LivePipelineOperationStatus: LivePipelineOperationStatus,
    PipelineJobOperationStatus: PipelineJobOperationStatus,
    OperationCollection: OperationCollection,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    Properties: Properties,
    ServiceSpecification: ServiceSpecification,
    LogSpecification: LogSpecification,
    MetricSpecification: MetricSpecification,
    MetricDimension: MetricDimension,
    VideoAnalyzerCollection: VideoAnalyzerCollection,
    StorageAccount: StorageAccount,
    ResourceIdentity: ResourceIdentity,
    Endpoint: Endpoint,
    AccountEncryption: AccountEncryption,
    KeyVaultProperties: KeyVaultProperties,
    IotHub: IotHub,
    NetworkAccessControl: NetworkAccessControl,
    GroupLevelAccessControl: GroupLevelAccessControl,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    VideoAnalyzerIdentity: VideoAnalyzerIdentity,
    UserAssignedManagedIdentity: UserAssignedManagedIdentity,
    VideoAnalyzerUpdate: VideoAnalyzerUpdate,
    PrivateLinkResourceListResult: PrivateLinkResourceListResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    VideoAnalyzerPrivateEndpointConnectionOperationStatus: VideoAnalyzerPrivateEndpointConnectionOperationStatus,
    VideoAnalyzerOperationStatus: VideoAnalyzerOperationStatus,
    CheckNameAvailabilityRequest: CheckNameAvailabilityRequest,
    CheckNameAvailabilityResponse: CheckNameAvailabilityResponse,
    VideoEntityCollection: VideoEntityCollection,
    VideoFlags: VideoFlags,
    VideoContentUrls: VideoContentUrls,
    VideoPreviewImageUrls: VideoPreviewImageUrls,
    VideoMediaInfo: VideoMediaInfo,
    VideoArchival: VideoArchival,
    VideoContentToken: VideoContentToken,
    AccessPolicyEntityCollection: AccessPolicyEntityCollection,
    AuthenticationBase: AuthenticationBase,
    EndpointBase: EndpointBase,
    CredentialsBase: CredentialsBase,
    TunnelBase: TunnelBase,
    CertificateSource: CertificateSource,
    TlsValidationOptions: TlsValidationOptions,
    TimeSequenceBase: TimeSequenceBase,
    EncoderPresetBase: EncoderPresetBase,
    AudioEncoderBase: AudioEncoderBase,
    VideoEncoderBase: VideoEncoderBase,
    VideoScale: VideoScale,
    VideoCreationProperties: VideoCreationProperties,
    VideoPublishingOptions: VideoPublishingOptions,
    TokenClaim: TokenClaim,
    TokenKey: TokenKey,
    ProxyResource: ProxyResource,
    PrivateEndpointConnection: PrivateEndpointConnection,
    TrackedResource: TrackedResource,
    PrivateLinkResource: PrivateLinkResource,
    SourceNodeBase: SourceNodeBase,
    ProcessorNodeBase: ProcessorNodeBase,
    SinkNodeBase: SinkNodeBase,
    JwtAuthentication: JwtAuthentication,
    UnsecuredEndpoint: UnsecuredEndpoint,
    TlsEndpoint: TlsEndpoint,
    UsernamePasswordCredentials: UsernamePasswordCredentials,
    SecureIotDeviceRemoteTunnel: SecureIotDeviceRemoteTunnel,
    PemCertificateList: PemCertificateList,
    VideoSequenceAbsoluteTimeMarkers: VideoSequenceAbsoluteTimeMarkers,
    EncoderSystemPreset: EncoderSystemPreset,
    EncoderCustomPreset: EncoderCustomPreset,
    AudioEncoderAac: AudioEncoderAac,
    VideoEncoderH264: VideoEncoderH264,
    RsaTokenKey: RsaTokenKey,
    EccTokenKey: EccTokenKey,
    EdgeModuleEntity: EdgeModuleEntity,
    PipelineTopology: PipelineTopology,
    PipelineTopologyUpdate: PipelineTopologyUpdate,
    LivePipeline: LivePipeline,
    LivePipelineUpdate: LivePipelineUpdate,
    PipelineJob: PipelineJob,
    PipelineJobUpdate: PipelineJobUpdate,
    VideoEntity: VideoEntity,
    AccessPolicyEntity: AccessPolicyEntity,
    VideoAnalyzer: VideoAnalyzer,
    RtspSource: RtspSource,
    VideoSource: VideoSource,
    EncoderProcessor: EncoderProcessor,
    VideoSink: VideoSink,
    VideoAnalyzersCreateOrUpdateHeaders: VideoAnalyzersCreateOrUpdateHeaders,
    VideoAnalyzersUpdateHeaders: VideoAnalyzersUpdateHeaders,
    PrivateEndpointConnectionsCreateOrUpdateHeaders: PrivateEndpointConnectionsCreateOrUpdateHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accountName = {
    parameterPath: "accountName",
    mapper: {
        serializedName: "accountName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-11-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const edgeModuleName = {
    parameterPath: "edgeModuleName",
    mapper: {
        serializedName: "edgeModuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: EdgeModuleEntity
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ListProvisioningTokenInput
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const pipelineTopologyName = {
    parameterPath: "pipelineTopologyName",
    mapper: {
        serializedName: "pipelineTopologyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: PipelineTopology
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: PipelineTopologyUpdate
};
const livePipelineName = {
    parameterPath: "livePipelineName",
    mapper: {
        serializedName: "livePipelineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: LivePipeline
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: LivePipelineUpdate
};
const pipelineJobName = {
    parameterPath: "pipelineJobName",
    mapper: {
        serializedName: "pipelineJobName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: PipelineJob
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: PipelineJobUpdate
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: VideoAnalyzer
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: VideoAnalyzerUpdate
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: CheckNameAvailabilityRequest
};
const videoName = {
    parameterPath: "videoName",
    mapper: {
        serializedName: "videoName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: VideoEntity
};
const accessPolicyName = {
    parameterPath: "accessPolicyName",
    mapper: {
        serializedName: "accessPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: AccessPolicyEntity
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing EdgeModules operations. */
class EdgeModulesImpl {
    /**
     * Initialize a new instance of the class EdgeModules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all existing edge module resources, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all existing edge module resources, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec);
    }
    /**
     * Retrieves an existing edge module resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param edgeModuleName The Edge Module name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, edgeModuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, edgeModuleName, options }, getOperationSpec);
    }
    /**
     * Creates a new edge module or updates an existing one. An edge module resource enables a single
     * instance of an Azure Video Analyzer IoT edge module to interact with the Video Analyzer Account.
     * This is used for authorization and also to make sure that the particular edge module instance only
     * has access to the data it requires from the Azure Video Analyzer service. A new edge module resource
     * should be created for every new instance of an Azure Video Analyzer edge module deployed to you
     * Azure IoT edge environment. Edge module resources can be deleted if the specific module is not in
     * use anymore.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param edgeModuleName The Edge Module name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, edgeModuleName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, edgeModuleName, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes an existing edge module resource. Deleting the edge module resource will prevent an Azure
     * Video Analyzer IoT edge module which was previously initiated with the module provisioning token
     * from communicating with the cloud.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param edgeModuleName The Edge Module name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, edgeModuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, edgeModuleName, options }, deleteOperationSpec);
    }
    /**
     * Creates a new provisioning token. A provisioning token allows for a single instance of Azure Video
     * analyzer IoT edge module to be initialized and authorized to the cloud account. The provisioning
     * token itself is short lived and it is only used for the initial handshake between IoT edge module
     * and the cloud. After the initial handshake, the IoT edge module will agree on a set of
     * authentication keys which will be auto-rotated as long as the module is able to periodically connect
     * to the cloud. A new provisioning token can be generated for the same IoT edge module in case the
     * module state lost or reset.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param edgeModuleName The Edge Module name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    listProvisioningToken(resourceGroupName, accountName, edgeModuleName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, edgeModuleName, parameters, options }, listProvisioningTokenOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/edgeModules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EdgeModuleEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/edgeModules/{edgeModuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EdgeModuleEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        edgeModuleName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/edgeModules/{edgeModuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: EdgeModuleEntity
        },
        201: {
            bodyMapper: EdgeModuleEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        edgeModuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/edgeModules/{edgeModuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        edgeModuleName
    ],
    headerParameters: [accept],
    serializer
};
const listProvisioningTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/edgeModules/{edgeModuleName}/listProvisioningToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EdgeModuleProvisioningToken
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        edgeModuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EdgeModuleEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PipelineTopologies operations. */
class PipelineTopologiesImpl {
    /**
     * Initialize a new instance of the class PipelineTopologies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves a list of pipeline topologies that have been added to the account, if any, along with
     * their JSON representation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of pipeline topologies that have been added to the account, if any, along with
     * their JSON representation.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$1);
    }
    /**
     * Retrieves a specific pipeline topology by name. If a topology with that name has been previously
     * created, the call will return the JSON representation of that topology.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineTopologyName Pipeline topology unique identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, pipelineTopologyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineTopologyName, options }, getOperationSpec$1);
    }
    /**
     * Creates a new pipeline topology or updates an existing one, with the given name. A pipeline topology
     * describes the processing steps to be applied when processing content for a particular outcome. The
     * topology should be defined according to the scenario to be achieved and can be reused across many
     * pipeline instances which share the same processing characteristics.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineTopologyName Pipeline topology unique identifier.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, pipelineTopologyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            pipelineTopologyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Deletes a pipeline topology with the given name. This method should be called after all instances of
     * the topology have been stopped and deleted.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineTopologyName Pipeline topology unique identifier.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, pipelineTopologyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineTopologyName, options }, deleteOperationSpec$1);
    }
    /**
     * Updates an existing pipeline topology with the given name. If the associated live pipelines or
     * pipeline jobs are in active or processing state, respectively, then only the description can be
     * updated. Else, the properties that can be updated include: description, parameter declarations,
     * sources, processors, and sinks.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineTopologyName Pipeline topology unique identifier.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, pipelineTopologyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            pipelineTopologyName,
            parameters,
            options
        }, updateOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineTopologies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineTopologyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineTopologies/{pipelineTopologyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineTopology
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineTopologyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineTopologies/{pipelineTopologyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PipelineTopology
        },
        201: {
            bodyMapper: PipelineTopology
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineTopologyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineTopologies/{pipelineTopologyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineTopologyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineTopologies/{pipelineTopologyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PipelineTopology
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineTopologyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineTopologyCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LivePipelines operations. */
class LivePipelinesImpl {
    /**
     * Initialize a new instance of the class LivePipelines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves a list of live pipelines that have been created, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of live pipelines that have been created, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$2);
    }
    /**
     * Retrieves a specific live pipeline by name. If a live pipeline with that name has been previously
     * created, the call will return the JSON representation of that instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, livePipelineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, livePipelineName, options }, getOperationSpec$2);
    }
    /**
     * Creates a new live pipeline or updates an existing one, with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, livePipelineName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, livePipelineName, parameters, options }, createOrUpdateOperationSpec$2);
    }
    /**
     * Deletes a live pipeline with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, livePipelineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, livePipelineName, options }, deleteOperationSpec$2);
    }
    /**
     * Updates an existing live pipeline with the given name. Properties that can be updated include:
     * description, bitrateKbps, and parameter definitions. Only the description can be updated while the
     * live pipeline is active.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, livePipelineName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, livePipelineName, parameters, options }, updateOperationSpec$1);
    }
    /**
     * Activates a live pipeline with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    beginActivate(resourceGroupName, accountName, livePipelineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, accountName, livePipelineName, options }, activateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Activates a live pipeline with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    beginActivateAndWait(resourceGroupName, accountName, livePipelineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginActivate(resourceGroupName, accountName, livePipelineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deactivates a live pipeline with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    beginDeactivate(resourceGroupName, accountName, livePipelineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, accountName, livePipelineName, options }, deactivateOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Deactivates a live pipeline with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param options The options parameters.
     */
    beginDeactivateAndWait(resourceGroupName, accountName, livePipelineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeactivate(resourceGroupName, accountName, livePipelineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LivePipelineCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LivePipeline
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LivePipeline
        },
        201: {
            bodyMapper: LivePipeline
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LivePipeline
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const activateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}/activate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deactivateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}/deactivate",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LivePipelineCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PipelineJobs operations. */
class PipelineJobsImpl {
    /**
     * Initialize a new instance of the class PipelineJobs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves a list of all live pipelines that have been created, along with their JSON
     * representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of all live pipelines that have been created, along with their JSON
     * representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$3);
    }
    /**
     * Retrieves a specific pipeline job by name. If a pipeline job with that name has been previously
     * created, the call will return the JSON representation of that instance.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, pipelineJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineJobName, options }, getOperationSpec$3);
    }
    /**
     * Creates a new pipeline job or updates an existing one, with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, pipelineJobName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineJobName, parameters, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Deletes a pipeline job with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, pipelineJobName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineJobName, options }, deleteOperationSpec$3);
    }
    /**
     * Updates an existing pipeline job with the given name. Properties that can be updated include:
     * description.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, pipelineJobName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineJobName, parameters, options }, updateOperationSpec$2);
    }
    /**
     * Cancels a pipeline job with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param options The options parameters.
     */
    beginCancel(resourceGroupName, accountName, pipelineJobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, accountName, pipelineJobName, options }, cancelOperationSpec);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Cancels a pipeline job with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param options The options parameters.
     */
    beginCancelAndWait(resourceGroupName, accountName, pipelineJobName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCancel(resourceGroupName, accountName, pipelineJobName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineJobCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineJob
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PipelineJob
        },
        201: {
            bodyMapper: PipelineJob
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PipelineJob
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const cancelOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}/cancel",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineJobCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top, filter],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing LivePipelineOperationStatuses operations. */
class LivePipelineOperationStatusesImpl {
    /**
     * Initialize a new instance of the class LivePipelineOperationStatuses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the operation status of a live pipeline.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param livePipelineName Live pipeline unique identifier.
     * @param operationId The operation ID.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, livePipelineName, operationId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            accountName,
            livePipelineName,
            operationId,
            options
        }, getOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/livePipelines/{livePipelineName}/operationStatuses/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LivePipelineOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        livePipelineName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PipelineJobOperationStatuses operations. */
class PipelineJobOperationStatusesImpl {
    /**
     * Initialize a new instance of the class PipelineJobOperationStatuses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get the operation status of a pipeline job with the given operationId.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param pipelineJobName The pipeline job name.
     * @param operationId The operation ID.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, pipelineJobName, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, pipelineJobName, operationId, options }, getOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/pipelineJobs/{pipelineJobName}/operationStatuses/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PipelineJobOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        pipelineJobName,
        operationId
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the Media operations.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$4);
    }
}
// Operation Specifications
const serializer$6 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/providers/Microsoft.Media/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VideoAnalyzers operations. */
class VideoAnalyzersImpl {
    /**
     * Initialize a new instance of the class VideoAnalyzers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the Video Analyzer accounts in the specified resource group.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$5);
    }
    /**
     * Get the details of the specified Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, getOperationSpec$6);
    }
    /**
     * Create or update an instance of a Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, accountName, parameters, options }, createOrUpdateOperationSpec$4);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Create or update an instance of a Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete the specified Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, deleteOperationSpec$4);
    }
    /**
     * Updates an existing instance of Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, accountName, parameters, options }, updateOperationSpec$3);
            return new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
        });
    }
    /**
     * Updates an existing instance of Video Analyzer account
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, accountName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, accountName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List all Video Analyzer accounts in the specified subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VideoAnalyzer
        },
        201: {
            bodyMapper: VideoAnalyzer
        },
        202: {
            bodyMapper: VideoAnalyzer
        },
        204: {
            bodyMapper: VideoAnalyzer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VideoAnalyzer,
            headersMapper: VideoAnalyzersUpdateHeaders
        },
        201: {
            bodyMapper: VideoAnalyzer,
            headersMapper: VideoAnalyzersUpdateHeaders
        },
        202: {
            bodyMapper: VideoAnalyzer,
            headersMapper: VideoAnalyzersUpdateHeaders
        },
        204: {
            bodyMapper: VideoAnalyzer,
            headersMapper: VideoAnalyzersUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Media/videoAnalyzers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzerCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateLinkResources operations. */
class PrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get list of group IDs for video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$6);
    }
    /**
     * Get group ID for video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Name of the private link resource (Group ID).
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, options }, getOperationSpec$7);
    }
}
// Operation Specifications
const serializer$8 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResourceListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateLinkResources/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkResource
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing PrivateEndpointConnections operations. */
class PrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all private endpoint connections under video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$7);
    }
    /**
     * Get private endpoint connection under video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Private endpoint connection name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, options }, getOperationSpec$8);
    }
    /**
     * Update private endpoint connection state under video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Private endpoint connection name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, name, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, parameters, options }, createOrUpdateOperationSpec$5);
    }
    /**
     * Delete private endpoint connection under video analyzer account.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Private endpoint connection name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, name, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, options }, deleteOperationSpec$5);
    }
}
// Operation Specifications
const serializer$9 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections/{name}",
    httpMethod: "PUT",
    responses: {
        201: {
            bodyMapper: PrivateEndpointConnection,
            headersMapper: PrivateEndpointConnectionsCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        name
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections/{name}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationStatuses operations. */
class OperationStatusesImpl {
    /**
     * Initialize a new instance of the class OperationStatuses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get private endpoint connection operation status.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Private endpoint connection name.
     * @param operationId Operation Id.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, operationId, options }, getOperationSpec$9);
    }
}
// Operation Specifications
const serializer$a = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections/{name}/operationStatuses/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzerPrivateEndpointConnectionOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        operationId,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing OperationResults operations. */
class OperationResultsImpl {
    /**
     * Initialize a new instance of the class OperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get private endpoint connection operation result.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Video Analyzer account name.
     * @param name Private endpoint connection name.
     * @param operationId Operation Id.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, name, operationId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, name, operationId, options }, getOperationSpec$a);
    }
}
// Operation Specifications
const serializer$b = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/privateEndpointConnections/{name}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        operationId,
        name
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VideoAnalyzerOperationStatuses operations. */
class VideoAnalyzerOperationStatusesImpl {
    /**
     * Initialize a new instance of the class VideoAnalyzerOperationStatuses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get video analyzer operation status.
     * @param locationName Location name.
     * @param operationId Operation Id.
     * @param options The options parameters.
     */
    get(locationName, operationId, options) {
        return this.client.sendOperationRequest({ locationName, operationId, options }, getOperationSpec$b);
    }
}
// Operation Specifications
const serializer$c = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Media/locations/{locationName}/videoAnalyzerOperationStatuses/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzerOperationStatus
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        operationId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VideoAnalyzerOperationResults operations. */
class VideoAnalyzerOperationResultsImpl {
    /**
     * Initialize a new instance of the class VideoAnalyzerOperationResults class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get video analyzer operation result.
     * @param locationName Location name.
     * @param operationId Operation Id.
     * @param options The options parameters.
     */
    get(locationName, operationId, options) {
        return this.client.sendOperationRequest({ locationName, operationId, options }, getOperationSpec$c);
    }
}
// Operation Specifications
const serializer$d = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Media/locations/{locationName}/videoAnalyzerOperationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoAnalyzer
        },
        202: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        operationId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Locations operations. */
class LocationsImpl {
    /**
     * Initialize a new instance of the class Locations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Checks whether the Video Analyzer resource name is available.
     * @param locationName Location Name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    checkNameAvailability(locationName, parameters, options) {
        return this.client.sendOperationRequest({ locationName, parameters, options }, checkNameAvailabilityOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient.createSerializer(Mappers, /* isXml */ false);
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Media/locations/{locationName}/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: CheckNameAvailabilityResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Videos operations. */
class VideosImpl {
    /**
     * Initialize a new instance of the class Videos class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves a list of video resources that have been created, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves a list of video resources that have been created, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$8);
    }
    /**
     * Retrieves an existing video resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param videoName The Video name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, videoName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, videoName, options }, getOperationSpec$d);
    }
    /**
     * Creates a new video resource or updates an existing video resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param videoName The Video name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, videoName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, videoName, parameters, options }, createOrUpdateOperationSpec$6);
    }
    /**
     * Deletes an existing video resource and its underlying data. This operation is irreversible.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param videoName The Video name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, videoName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, videoName, options }, deleteOperationSpec$6);
    }
    /**
     * Updates individual properties of an existing video resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param videoName The Video name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, videoName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, videoName, parameters, options }, updateOperationSpec$4);
    }
    /**
     * Generates a streaming token which can be used for accessing content from video content URLs, for a
     * video resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param videoName The Video name.
     * @param options The options parameters.
     */
    listContentToken(resourceGroupName, accountName, videoName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, videoName, options }, listContentTokenOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$f = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos/{videoName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        videoName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos/{videoName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VideoEntity
        },
        201: {
            bodyMapper: VideoEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        videoName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos/{videoName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        videoName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos/{videoName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VideoEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        videoName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const listContentTokenOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/videos/{videoName}/listContentToken",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VideoContentToken
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        videoName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VideoEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AccessPolicies operations. */
class AccessPoliciesImpl {
    /**
     * Initialize a new instance of the class AccessPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all existing access policy resources, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    list(resourceGroupName, accountName, options) {
        const iter = this.listPagingAll(resourceGroupName, accountName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(resourceGroupName, accountName, options);
            }
        };
    }
    listPagingPage(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(resourceGroupName, accountName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, accountName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(resourceGroupName, accountName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, accountName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves all existing access policy resources, along with their JSON representations.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param options The options parameters.
     */
    _list(resourceGroupName, accountName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, options }, listOperationSpec$9);
    }
    /**
     * Retrieves an existing access policy resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param accessPolicyName The Access Policy name.
     * @param options The options parameters.
     */
    get(resourceGroupName, accountName, accessPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, accessPolicyName, options }, getOperationSpec$e);
    }
    /**
     * Creates a new access policy resource or updates an existing one with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param accessPolicyName The Access Policy name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, accountName, accessPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, accessPolicyName, parameters, options }, createOrUpdateOperationSpec$7);
    }
    /**
     * Deletes an existing access policy resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param accessPolicyName The Access Policy name.
     * @param options The options parameters.
     */
    delete(resourceGroupName, accountName, accessPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, accessPolicyName, options }, deleteOperationSpec$7);
    }
    /**
     * Updates individual properties of an existing access policy resource with the given name.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param accessPolicyName The Access Policy name.
     * @param parameters The request parameters
     * @param options The options parameters.
     */
    update(resourceGroupName, accountName, accessPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, accessPolicyName, parameters, options }, updateOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param accountName The Azure Video Analyzer account name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, accountName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, accountName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$g = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/accessPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessPolicyEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/accessPolicies/{accessPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessPolicyEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        accessPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/accessPolicies/{accessPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AccessPolicyEntity
        },
        201: {
            bodyMapper: AccessPolicyEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        accessPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/accessPolicies/{accessPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        accessPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Media/videoAnalyzers/{accountName}/accessPolicies/{accessPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AccessPolicyEntity
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        accessPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AccessPolicyEntityCollection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        accountName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class VideoAnalyzerManagementClient extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the VideoAnalyzerManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-videoanalyzer/1.0.0-beta.2`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2021-11-01-preview";
        this.edgeModules = new EdgeModulesImpl(this);
        this.pipelineTopologies = new PipelineTopologiesImpl(this);
        this.livePipelines = new LivePipelinesImpl(this);
        this.pipelineJobs = new PipelineJobsImpl(this);
        this.livePipelineOperationStatuses = new LivePipelineOperationStatusesImpl(this);
        this.pipelineJobOperationStatuses = new PipelineJobOperationStatusesImpl(this);
        this.operations = new OperationsImpl(this);
        this.videoAnalyzers = new VideoAnalyzersImpl(this);
        this.privateLinkResources = new PrivateLinkResourcesImpl(this);
        this.privateEndpointConnections = new PrivateEndpointConnectionsImpl(this);
        this.operationStatuses = new OperationStatusesImpl(this);
        this.operationResults = new OperationResultsImpl(this);
        this.videoAnalyzerOperationStatuses = new VideoAnalyzerOperationStatusesImpl(this);
        this.videoAnalyzerOperationResults = new VideoAnalyzerOperationResultsImpl(this);
        this.locations = new LocationsImpl(this);
        this.videos = new VideosImpl(this);
        this.accessPolicies = new AccessPoliciesImpl(this);
    }
}

exports.VideoAnalyzerManagementClient = VideoAnalyzerManagementClient;
//# sourceMappingURL=index.js.map
