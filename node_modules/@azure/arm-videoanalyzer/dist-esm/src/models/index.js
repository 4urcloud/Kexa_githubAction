/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
export var KnownCreatedByType;
(function (KnownCreatedByType) {
    KnownCreatedByType["User"] = "User";
    KnownCreatedByType["Application"] = "Application";
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    KnownCreatedByType["Key"] = "Key";
})(KnownCreatedByType || (KnownCreatedByType = {}));
/** Known values of {@link ParameterType} that the service accepts. */
export var KnownParameterType;
(function (KnownParameterType) {
    /** The parameter's value is a string. */
    KnownParameterType["String"] = "String";
    /** The parameter's value is a string that holds sensitive information. */
    KnownParameterType["SecretString"] = "SecretString";
    /** The parameter's value is a 32-bit signed integer. */
    KnownParameterType["Int"] = "Int";
    /** The parameter's value is a 64-bit double-precision floating point. */
    KnownParameterType["Double"] = "Double";
    /** The parameter's value is a boolean value that is either true or false. */
    KnownParameterType["Bool"] = "Bool";
})(KnownParameterType || (KnownParameterType = {}));
/** Known values of {@link Kind} that the service accepts. */
export var KnownKind;
(function (KnownKind) {
    /** Live pipeline topology resource. */
    KnownKind["Live"] = "Live";
    /** Batch pipeline topology resource. */
    KnownKind["Batch"] = "Batch";
})(KnownKind || (KnownKind = {}));
/** Known values of {@link SkuName} that the service accepts. */
export var KnownSkuName;
(function (KnownSkuName) {
    /** Represents the Live S1 SKU name. Using this SKU you can create live pipelines to capture, record, and stream live video from RTSP-capable cameras at bitrate settings from 0.5 Kbps to 3000 Kbps. */
    KnownSkuName["LiveS1"] = "Live_S1";
    /** Represents the Batch S1 SKU name. Using this SKU you can create pipeline jobs to process recorded content. */
    KnownSkuName["BatchS1"] = "Batch_S1";
})(KnownSkuName || (KnownSkuName = {}));
/** Known values of {@link SkuTier} that the service accepts. */
export var KnownSkuTier;
(function (KnownSkuTier) {
    /** Standard tier. */
    KnownSkuTier["Standard"] = "Standard";
})(KnownSkuTier || (KnownSkuTier = {}));
/** Known values of {@link LivePipelineState} that the service accepts. */
export var KnownLivePipelineState;
(function (KnownLivePipelineState) {
    /** The live pipeline is idle and not processing media. */
    KnownLivePipelineState["Inactive"] = "Inactive";
    /** The live pipeline is transitioning into the active state. */
    KnownLivePipelineState["Activating"] = "Activating";
    /** The live pipeline is active and able to process media. If your data source is not available, for instance, if your RTSP camera is powered off or unreachable, the pipeline will still be active and periodically retrying the connection. Your Azure subscription will be billed for the duration in which the live pipeline is in the active state. */
    KnownLivePipelineState["Active"] = "Active";
    /** The live pipeline is transitioning into the inactive state. */
    KnownLivePipelineState["Deactivating"] = "Deactivating";
})(KnownLivePipelineState || (KnownLivePipelineState = {}));
/** Known values of {@link PipelineJobState} that the service accepts. */
export var KnownPipelineJobState;
(function (KnownPipelineJobState) {
    /** Pipeline job is processing. */
    KnownPipelineJobState["Processing"] = "Processing";
    /** Pipeline job is canceled. */
    KnownPipelineJobState["Canceled"] = "Canceled";
    /** Pipeline job completed. */
    KnownPipelineJobState["Completed"] = "Completed";
    /** Pipeline job failed. */
    KnownPipelineJobState["Failed"] = "Failed";
})(KnownPipelineJobState || (KnownPipelineJobState = {}));
/** Known values of {@link MetricUnit} that the service accepts. */
export var KnownMetricUnit;
(function (KnownMetricUnit) {
    /** The number of bytes. */
    KnownMetricUnit["Bytes"] = "Bytes";
    /** The count. */
    KnownMetricUnit["Count"] = "Count";
    /** The number of milliseconds. */
    KnownMetricUnit["Milliseconds"] = "Milliseconds";
})(KnownMetricUnit || (KnownMetricUnit = {}));
/** Known values of {@link MetricAggregationType} that the service accepts. */
export var KnownMetricAggregationType;
(function (KnownMetricAggregationType) {
    /** The average. */
    KnownMetricAggregationType["Average"] = "Average";
    /** The count of a number of items, usually requests. */
    KnownMetricAggregationType["Count"] = "Count";
    /** The sum. */
    KnownMetricAggregationType["Total"] = "Total";
})(KnownMetricAggregationType || (KnownMetricAggregationType = {}));
/** Known values of {@link ActionType} that the service accepts. */
export var KnownActionType;
(function (KnownActionType) {
    /** An internal action. */
    KnownActionType["Internal"] = "Internal";
})(KnownActionType || (KnownActionType = {}));
/** Known values of {@link VideoAnalyzerEndpointType} that the service accepts. */
export var KnownVideoAnalyzerEndpointType;
(function (KnownVideoAnalyzerEndpointType) {
    /** The client API endpoint. */
    KnownVideoAnalyzerEndpointType["ClientApi"] = "ClientApi";
})(KnownVideoAnalyzerEndpointType || (KnownVideoAnalyzerEndpointType = {}));
/** Known values of {@link AccountEncryptionKeyType} that the service accepts. */
export var KnownAccountEncryptionKeyType;
(function (KnownAccountEncryptionKeyType) {
    /** The Account Key is encrypted with a System Key. */
    KnownAccountEncryptionKeyType["SystemKey"] = "SystemKey";
    /** The Account Key is encrypted with a Customer Key. */
    KnownAccountEncryptionKeyType["CustomerKey"] = "CustomerKey";
})(KnownAccountEncryptionKeyType || (KnownAccountEncryptionKeyType = {}));
/** Known values of {@link PublicNetworkAccess} that the service accepts. */
export var KnownPublicNetworkAccess;
(function (KnownPublicNetworkAccess) {
    /** Public network access is enabled. */
    KnownPublicNetworkAccess["Enabled"] = "Enabled";
    /** Public network access is disabled. */
    KnownPublicNetworkAccess["Disabled"] = "Disabled";
})(KnownPublicNetworkAccess || (KnownPublicNetworkAccess = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
export var KnownProvisioningState;
(function (KnownProvisioningState) {
    /** Provisioning state failed. */
    KnownProvisioningState["Failed"] = "Failed";
    /** Provisioning state in progress. */
    KnownProvisioningState["InProgress"] = "InProgress";
    /** Provisioning state succeeded. */
    KnownProvisioningState["Succeeded"] = "Succeeded";
})(KnownProvisioningState || (KnownProvisioningState = {}));
/** Known values of {@link PrivateEndpointServiceConnectionStatus} that the service accepts. */
export var KnownPrivateEndpointServiceConnectionStatus;
(function (KnownPrivateEndpointServiceConnectionStatus) {
    KnownPrivateEndpointServiceConnectionStatus["Pending"] = "Pending";
    KnownPrivateEndpointServiceConnectionStatus["Approved"] = "Approved";
    KnownPrivateEndpointServiceConnectionStatus["Rejected"] = "Rejected";
})(KnownPrivateEndpointServiceConnectionStatus || (KnownPrivateEndpointServiceConnectionStatus = {}));
/** Known values of {@link PrivateEndpointConnectionProvisioningState} that the service accepts. */
export var KnownPrivateEndpointConnectionProvisioningState;
(function (KnownPrivateEndpointConnectionProvisioningState) {
    KnownPrivateEndpointConnectionProvisioningState["Succeeded"] = "Succeeded";
    KnownPrivateEndpointConnectionProvisioningState["Creating"] = "Creating";
    KnownPrivateEndpointConnectionProvisioningState["Deleting"] = "Deleting";
    KnownPrivateEndpointConnectionProvisioningState["Failed"] = "Failed";
})(KnownPrivateEndpointConnectionProvisioningState || (KnownPrivateEndpointConnectionProvisioningState = {}));
/** Known values of {@link CheckNameAvailabilityReason} that the service accepts. */
export var KnownCheckNameAvailabilityReason;
(function (KnownCheckNameAvailabilityReason) {
    KnownCheckNameAvailabilityReason["Invalid"] = "Invalid";
    KnownCheckNameAvailabilityReason["AlreadyExists"] = "AlreadyExists";
})(KnownCheckNameAvailabilityReason || (KnownCheckNameAvailabilityReason = {}));
/** Known values of {@link VideoType} that the service accepts. */
export var KnownVideoType;
(function (KnownVideoType) {
    /** Archive is flexible format that represents a video stream associated with wall-clock time. The video archive can either be continuous or discontinuous. An archive is discontinuous when there are gaps in the recording due to various reasons, such as the live pipeline being stopped, camera being disconnected or due to the use of event based recordings through the use of a signal gate. There is no limit to the archive duration and new video data can be appended to the existing archive at any time, as long as the same video codec and codec parameters are being used. Videos of this type are suitable for appending and long term archival. */
    KnownVideoType["Archive"] = "Archive";
    /** File represents a video which is stored as a single media file, such as MP4. Videos of this type are suitable to be downloaded for external consumption. */
    KnownVideoType["File"] = "File";
})(KnownVideoType || (KnownVideoType = {}));
/** Known values of {@link AccessPolicyRole} that the service accepts. */
export var KnownAccessPolicyRole;
(function (KnownAccessPolicyRole) {
    /** Reader role allows for read-only operations to be performed through the client APIs. */
    KnownAccessPolicyRole["Reader"] = "Reader";
})(KnownAccessPolicyRole || (KnownAccessPolicyRole = {}));
/** Known values of {@link RtspTransport} that the service accepts. */
export var KnownRtspTransport;
(function (KnownRtspTransport) {
    /** HTTP transport. RTSP messages are exchanged over long running HTTP requests and RTP packets are interleaved within the HTTP channel. */
    KnownRtspTransport["Http"] = "Http";
    /** TCP transport. RTSP is used directly over TCP and RTP packets are interleaved within the TCP channel. */
    KnownRtspTransport["Tcp"] = "Tcp";
})(KnownRtspTransport || (KnownRtspTransport = {}));
/** Known values of {@link EncoderSystemPresetType} that the service accepts. */
export var KnownEncoderSystemPresetType;
(function (KnownEncoderSystemPresetType) {
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 540 pixels, and at a maximum bitrate of 2000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps */
    KnownEncoderSystemPresetType["SingleLayer540PH264AAC"] = "SingleLayer_540p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 720 pixels, and at a maximum bitrate of 3500 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 96 Kbps */
    KnownEncoderSystemPresetType["SingleLayer720PH264AAC"] = "SingleLayer_720p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 1080 pixels, and at a maximum bitrate of 6000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps */
    KnownEncoderSystemPresetType["SingleLayer1080PH264AAC"] = "SingleLayer_1080p_H264_AAC";
    /** Produces an MP4 file where the video is encoded with H.264 codec at a picture height of 2160 pixels, and at a maximum bitrate of 16000 Kbps. Encoded video has the same average frame rate as the input. The aspect ratio of the input is preserved. If the input content has audio, then it is encoded with AAC-LC codec at 128 Kbps */
    KnownEncoderSystemPresetType["SingleLayer2160PH264AAC"] = "SingleLayer_2160p_H264_AAC";
})(KnownEncoderSystemPresetType || (KnownEncoderSystemPresetType = {}));
/** Known values of {@link VideoScaleMode} that the service accepts. */
export var KnownVideoScaleMode;
(function (KnownVideoScaleMode) {
    /** Pads the video with black horizontal stripes (letterbox) or black vertical stripes (pillar-box) so the video is resized to the specified dimensions while not altering the content aspect ratio. */
    KnownVideoScaleMode["Pad"] = "Pad";
    /** Preserves the same aspect ratio as the input video. If only one video dimension is provided, the second dimension is calculated based on the input video aspect ratio. When 2 dimensions are provided, the video is resized to fit the most constraining dimension, considering the input video size and aspect ratio. */
    KnownVideoScaleMode["PreserveAspectRatio"] = "PreserveAspectRatio";
    /** Stretches the original video so it resized to the specified dimensions. */
    KnownVideoScaleMode["Stretch"] = "Stretch";
})(KnownVideoScaleMode || (KnownVideoScaleMode = {}));
/** Known values of {@link AccessPolicyRsaAlgo} that the service accepts. */
export var KnownAccessPolicyRsaAlgo;
(function (KnownAccessPolicyRsaAlgo) {
    /** RS256 */
    KnownAccessPolicyRsaAlgo["RS256"] = "RS256";
    /** RS384 */
    KnownAccessPolicyRsaAlgo["RS384"] = "RS384";
    /** RS512 */
    KnownAccessPolicyRsaAlgo["RS512"] = "RS512";
})(KnownAccessPolicyRsaAlgo || (KnownAccessPolicyRsaAlgo = {}));
/** Known values of {@link AccessPolicyEccAlgo} that the service accepts. */
export var KnownAccessPolicyEccAlgo;
(function (KnownAccessPolicyEccAlgo) {
    /** ES265 */
    KnownAccessPolicyEccAlgo["ES256"] = "ES256";
    /** ES384 */
    KnownAccessPolicyEccAlgo["ES384"] = "ES384";
    /** ES512 */
    KnownAccessPolicyEccAlgo["ES512"] = "ES512";
})(KnownAccessPolicyEccAlgo || (KnownAccessPolicyEccAlgo = {}));
//# sourceMappingURL=index.js.map