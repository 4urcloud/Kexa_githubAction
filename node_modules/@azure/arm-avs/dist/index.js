'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link TrialStatus} that the service accepts. */
exports.KnownTrialStatus = void 0;
(function (KnownTrialStatus) {
    /** TrialAvailable */
    KnownTrialStatus["TrialAvailable"] = "TrialAvailable";
    /** TrialUsed */
    KnownTrialStatus["TrialUsed"] = "TrialUsed";
    /** TrialDisabled */
    KnownTrialStatus["TrialDisabled"] = "TrialDisabled";
})(exports.KnownTrialStatus || (exports.KnownTrialStatus = {}));
/** Known values of {@link QuotaEnabled} that the service accepts. */
exports.KnownQuotaEnabled = void 0;
(function (KnownQuotaEnabled) {
    /** Enabled */
    KnownQuotaEnabled["Enabled"] = "Enabled";
    /** Disabled */
    KnownQuotaEnabled["Disabled"] = "Disabled";
})(exports.KnownQuotaEnabled || (exports.KnownQuotaEnabled = {}));
/** Known values of {@link PrivateCloudProvisioningState} that the service accepts. */
exports.KnownPrivateCloudProvisioningState = void 0;
(function (KnownPrivateCloudProvisioningState) {
    /** Succeeded */
    KnownPrivateCloudProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownPrivateCloudProvisioningState["Failed"] = "Failed";
    /** Cancelled */
    KnownPrivateCloudProvisioningState["Cancelled"] = "Cancelled";
    /** Pending */
    KnownPrivateCloudProvisioningState["Pending"] = "Pending";
    /** Building */
    KnownPrivateCloudProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownPrivateCloudProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownPrivateCloudProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownPrivateCloudProvisioningState["Canceled"] = "Canceled";
})(exports.KnownPrivateCloudProvisioningState || (exports.KnownPrivateCloudProvisioningState = {}));
/** Known values of {@link NsxPublicIpQuotaRaisedEnum} that the service accepts. */
exports.KnownNsxPublicIpQuotaRaisedEnum = void 0;
(function (KnownNsxPublicIpQuotaRaisedEnum) {
    /** Enabled */
    KnownNsxPublicIpQuotaRaisedEnum["Enabled"] = "Enabled";
    /** Disabled */
    KnownNsxPublicIpQuotaRaisedEnum["Disabled"] = "Disabled";
})(exports.KnownNsxPublicIpQuotaRaisedEnum || (exports.KnownNsxPublicIpQuotaRaisedEnum = {}));
/** Known values of {@link ClusterProvisioningState} that the service accepts. */
exports.KnownClusterProvisioningState = void 0;
(function (KnownClusterProvisioningState) {
    /** Succeeded */
    KnownClusterProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownClusterProvisioningState["Failed"] = "Failed";
    /** Cancelled */
    KnownClusterProvisioningState["Cancelled"] = "Cancelled";
    /** Deleting */
    KnownClusterProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownClusterProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownClusterProvisioningState["Canceled"] = "Canceled";
})(exports.KnownClusterProvisioningState || (exports.KnownClusterProvisioningState = {}));
/** Known values of {@link InternetEnum} that the service accepts. */
exports.KnownInternetEnum = void 0;
(function (KnownInternetEnum) {
    /** Enabled */
    KnownInternetEnum["Enabled"] = "Enabled";
    /** Disabled */
    KnownInternetEnum["Disabled"] = "Disabled";
})(exports.KnownInternetEnum || (exports.KnownInternetEnum = {}));
/** Known values of {@link SslEnum} that the service accepts. */
exports.KnownSslEnum = void 0;
(function (KnownSslEnum) {
    /** Enabled */
    KnownSslEnum["Enabled"] = "Enabled";
    /** Disabled */
    KnownSslEnum["Disabled"] = "Disabled";
})(exports.KnownSslEnum || (exports.KnownSslEnum = {}));
/** Known values of {@link AvailabilityStrategy} that the service accepts. */
exports.KnownAvailabilityStrategy = void 0;
(function (KnownAvailabilityStrategy) {
    /** SingleZone */
    KnownAvailabilityStrategy["SingleZone"] = "SingleZone";
    /** DualZone */
    KnownAvailabilityStrategy["DualZone"] = "DualZone";
})(exports.KnownAvailabilityStrategy || (exports.KnownAvailabilityStrategy = {}));
/** Known values of {@link EncryptionState} that the service accepts. */
exports.KnownEncryptionState = void 0;
(function (KnownEncryptionState) {
    /** Enabled */
    KnownEncryptionState["Enabled"] = "Enabled";
    /** Disabled */
    KnownEncryptionState["Disabled"] = "Disabled";
})(exports.KnownEncryptionState || (exports.KnownEncryptionState = {}));
/** Known values of {@link EncryptionKeyStatus} that the service accepts. */
exports.KnownEncryptionKeyStatus = void 0;
(function (KnownEncryptionKeyStatus) {
    /** Connected */
    KnownEncryptionKeyStatus["Connected"] = "Connected";
    /** AccessDenied */
    KnownEncryptionKeyStatus["AccessDenied"] = "AccessDenied";
})(exports.KnownEncryptionKeyStatus || (exports.KnownEncryptionKeyStatus = {}));
/** Known values of {@link EncryptionVersionType} that the service accepts. */
exports.KnownEncryptionVersionType = void 0;
(function (KnownEncryptionVersionType) {
    /** Fixed */
    KnownEncryptionVersionType["Fixed"] = "Fixed";
    /** AutoDetected */
    KnownEncryptionVersionType["AutoDetected"] = "AutoDetected";
})(exports.KnownEncryptionVersionType || (exports.KnownEncryptionVersionType = {}));
/** Known values of {@link ResourceIdentityType} that the service accepts. */
exports.KnownResourceIdentityType = void 0;
(function (KnownResourceIdentityType) {
    /** SystemAssigned */
    KnownResourceIdentityType["SystemAssigned"] = "SystemAssigned";
    /** None */
    KnownResourceIdentityType["None"] = "None";
})(exports.KnownResourceIdentityType || (exports.KnownResourceIdentityType = {}));
/** Known values of {@link DatastoreProvisioningState} that the service accepts. */
exports.KnownDatastoreProvisioningState = void 0;
(function (KnownDatastoreProvisioningState) {
    /** Succeeded */
    KnownDatastoreProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownDatastoreProvisioningState["Failed"] = "Failed";
    /** Cancelled */
    KnownDatastoreProvisioningState["Cancelled"] = "Cancelled";
    /** Pending */
    KnownDatastoreProvisioningState["Pending"] = "Pending";
    /** Creating */
    KnownDatastoreProvisioningState["Creating"] = "Creating";
    /** Updating */
    KnownDatastoreProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownDatastoreProvisioningState["Deleting"] = "Deleting";
    /** Canceled */
    KnownDatastoreProvisioningState["Canceled"] = "Canceled";
})(exports.KnownDatastoreProvisioningState || (exports.KnownDatastoreProvisioningState = {}));
/** Known values of {@link MountOptionEnum} that the service accepts. */
exports.KnownMountOptionEnum = void 0;
(function (KnownMountOptionEnum) {
    /** Mount */
    KnownMountOptionEnum["Mount"] = "MOUNT";
    /** Attach */
    KnownMountOptionEnum["Attach"] = "ATTACH";
})(exports.KnownMountOptionEnum || (exports.KnownMountOptionEnum = {}));
/** Known values of {@link DatastoreStatus} that the service accepts. */
exports.KnownDatastoreStatus = void 0;
(function (KnownDatastoreStatus) {
    /** Unknown */
    KnownDatastoreStatus["Unknown"] = "Unknown";
    /** Accessible */
    KnownDatastoreStatus["Accessible"] = "Accessible";
    /** Inaccessible */
    KnownDatastoreStatus["Inaccessible"] = "Inaccessible";
    /** Attached */
    KnownDatastoreStatus["Attached"] = "Attached";
    /** Detached */
    KnownDatastoreStatus["Detached"] = "Detached";
    /** LostCommunication */
    KnownDatastoreStatus["LostCommunication"] = "LostCommunication";
    /** DeadOrError */
    KnownDatastoreStatus["DeadOrError"] = "DeadOrError";
})(exports.KnownDatastoreStatus || (exports.KnownDatastoreStatus = {}));
/** Known values of {@link HcxEnterpriseSiteStatus} that the service accepts. */
exports.KnownHcxEnterpriseSiteStatus = void 0;
(function (KnownHcxEnterpriseSiteStatus) {
    /** Available */
    KnownHcxEnterpriseSiteStatus["Available"] = "Available";
    /** Consumed */
    KnownHcxEnterpriseSiteStatus["Consumed"] = "Consumed";
    /** Deactivated */
    KnownHcxEnterpriseSiteStatus["Deactivated"] = "Deactivated";
    /** Deleted */
    KnownHcxEnterpriseSiteStatus["Deleted"] = "Deleted";
})(exports.KnownHcxEnterpriseSiteStatus || (exports.KnownHcxEnterpriseSiteStatus = {}));
/** Known values of {@link ExpressRouteAuthorizationProvisioningState} that the service accepts. */
exports.KnownExpressRouteAuthorizationProvisioningState = void 0;
(function (KnownExpressRouteAuthorizationProvisioningState) {
    /** Succeeded */
    KnownExpressRouteAuthorizationProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownExpressRouteAuthorizationProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownExpressRouteAuthorizationProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownExpressRouteAuthorizationProvisioningState["Canceled"] = "Canceled";
})(exports.KnownExpressRouteAuthorizationProvisioningState || (exports.KnownExpressRouteAuthorizationProvisioningState = {}));
/** Known values of {@link GlobalReachConnectionProvisioningState} that the service accepts. */
exports.KnownGlobalReachConnectionProvisioningState = void 0;
(function (KnownGlobalReachConnectionProvisioningState) {
    /** Succeeded */
    KnownGlobalReachConnectionProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownGlobalReachConnectionProvisioningState["Failed"] = "Failed";
    /** Updating */
    KnownGlobalReachConnectionProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownGlobalReachConnectionProvisioningState["Canceled"] = "Canceled";
})(exports.KnownGlobalReachConnectionProvisioningState || (exports.KnownGlobalReachConnectionProvisioningState = {}));
/** Known values of {@link GlobalReachConnectionStatus} that the service accepts. */
exports.KnownGlobalReachConnectionStatus = void 0;
(function (KnownGlobalReachConnectionStatus) {
    /** Connected */
    KnownGlobalReachConnectionStatus["Connected"] = "Connected";
    /** Connecting */
    KnownGlobalReachConnectionStatus["Connecting"] = "Connecting";
    /** Disconnected */
    KnownGlobalReachConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownGlobalReachConnectionStatus || (exports.KnownGlobalReachConnectionStatus = {}));
/** Known values of {@link WorkloadNetworkName} that the service accepts. */
exports.KnownWorkloadNetworkName = void 0;
(function (KnownWorkloadNetworkName) {
    /** Default */
    KnownWorkloadNetworkName["Default"] = "default";
})(exports.KnownWorkloadNetworkName || (exports.KnownWorkloadNetworkName = {}));
/** Known values of {@link SegmentStatusEnum} that the service accepts. */
exports.KnownSegmentStatusEnum = void 0;
(function (KnownSegmentStatusEnum) {
    /** Success */
    KnownSegmentStatusEnum["Success"] = "SUCCESS";
    /** Failure */
    KnownSegmentStatusEnum["Failure"] = "FAILURE";
})(exports.KnownSegmentStatusEnum || (exports.KnownSegmentStatusEnum = {}));
/** Known values of {@link WorkloadNetworkSegmentProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkSegmentProvisioningState = void 0;
(function (KnownWorkloadNetworkSegmentProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkSegmentProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkSegmentProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkSegmentProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkSegmentProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkSegmentProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkSegmentProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkSegmentProvisioningState || (exports.KnownWorkloadNetworkSegmentProvisioningState = {}));
/** Known values of {@link DhcpTypeEnum} that the service accepts. */
exports.KnownDhcpTypeEnum = void 0;
(function (KnownDhcpTypeEnum) {
    /** Server */
    KnownDhcpTypeEnum["Server"] = "SERVER";
    /** Relay */
    KnownDhcpTypeEnum["Relay"] = "RELAY";
})(exports.KnownDhcpTypeEnum || (exports.KnownDhcpTypeEnum = {}));
/** Known values of {@link WorkloadNetworkDhcpProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkDhcpProvisioningState = void 0;
(function (KnownWorkloadNetworkDhcpProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkDhcpProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkDhcpProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkDhcpProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkDhcpProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkDhcpProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkDhcpProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkDhcpProvisioningState || (exports.KnownWorkloadNetworkDhcpProvisioningState = {}));
/** Known values of {@link PortMirroringDirectionEnum} that the service accepts. */
exports.KnownPortMirroringDirectionEnum = void 0;
(function (KnownPortMirroringDirectionEnum) {
    /** Ingress */
    KnownPortMirroringDirectionEnum["Ingress"] = "INGRESS";
    /** Egress */
    KnownPortMirroringDirectionEnum["Egress"] = "EGRESS";
    /** Bidirectional */
    KnownPortMirroringDirectionEnum["Bidirectional"] = "BIDIRECTIONAL";
})(exports.KnownPortMirroringDirectionEnum || (exports.KnownPortMirroringDirectionEnum = {}));
/** Known values of {@link PortMirroringStatusEnum} that the service accepts. */
exports.KnownPortMirroringStatusEnum = void 0;
(function (KnownPortMirroringStatusEnum) {
    /** Success */
    KnownPortMirroringStatusEnum["Success"] = "SUCCESS";
    /** Failure */
    KnownPortMirroringStatusEnum["Failure"] = "FAILURE";
})(exports.KnownPortMirroringStatusEnum || (exports.KnownPortMirroringStatusEnum = {}));
/** Known values of {@link WorkloadNetworkPortMirroringProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkPortMirroringProvisioningState = void 0;
(function (KnownWorkloadNetworkPortMirroringProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkPortMirroringProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkPortMirroringProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkPortMirroringProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkPortMirroringProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkPortMirroringProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkPortMirroringProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkPortMirroringProvisioningState || (exports.KnownWorkloadNetworkPortMirroringProvisioningState = {}));
/** Known values of {@link VMGroupStatusEnum} that the service accepts. */
exports.KnownVMGroupStatusEnum = void 0;
(function (KnownVMGroupStatusEnum) {
    /** Success */
    KnownVMGroupStatusEnum["Success"] = "SUCCESS";
    /** Failure */
    KnownVMGroupStatusEnum["Failure"] = "FAILURE";
})(exports.KnownVMGroupStatusEnum || (exports.KnownVMGroupStatusEnum = {}));
/** Known values of {@link WorkloadNetworkVMGroupProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkVMGroupProvisioningState = void 0;
(function (KnownWorkloadNetworkVMGroupProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkVMGroupProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkVMGroupProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkVMGroupProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkVMGroupProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkVMGroupProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkVMGroupProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkVMGroupProvisioningState || (exports.KnownWorkloadNetworkVMGroupProvisioningState = {}));
/** Known values of {@link VMTypeEnum} that the service accepts. */
exports.KnownVMTypeEnum = void 0;
(function (KnownVMTypeEnum) {
    /** Regular */
    KnownVMTypeEnum["Regular"] = "REGULAR";
    /** Edge */
    KnownVMTypeEnum["Edge"] = "EDGE";
    /** Service */
    KnownVMTypeEnum["Service"] = "SERVICE";
})(exports.KnownVMTypeEnum || (exports.KnownVMTypeEnum = {}));
/** Known values of {@link DnsServiceLogLevelEnum} that the service accepts. */
exports.KnownDnsServiceLogLevelEnum = void 0;
(function (KnownDnsServiceLogLevelEnum) {
    /** Debug */
    KnownDnsServiceLogLevelEnum["Debug"] = "DEBUG";
    /** Info */
    KnownDnsServiceLogLevelEnum["Info"] = "INFO";
    /** Warning */
    KnownDnsServiceLogLevelEnum["Warning"] = "WARNING";
    /** Error */
    KnownDnsServiceLogLevelEnum["Error"] = "ERROR";
    /** Fatal */
    KnownDnsServiceLogLevelEnum["Fatal"] = "FATAL";
})(exports.KnownDnsServiceLogLevelEnum || (exports.KnownDnsServiceLogLevelEnum = {}));
/** Known values of {@link DnsServiceStatusEnum} that the service accepts. */
exports.KnownDnsServiceStatusEnum = void 0;
(function (KnownDnsServiceStatusEnum) {
    /** Success */
    KnownDnsServiceStatusEnum["Success"] = "SUCCESS";
    /** Failure */
    KnownDnsServiceStatusEnum["Failure"] = "FAILURE";
})(exports.KnownDnsServiceStatusEnum || (exports.KnownDnsServiceStatusEnum = {}));
/** Known values of {@link WorkloadNetworkDnsServiceProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkDnsServiceProvisioningState = void 0;
(function (KnownWorkloadNetworkDnsServiceProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkDnsServiceProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkDnsServiceProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkDnsServiceProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkDnsServiceProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkDnsServiceProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkDnsServiceProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkDnsServiceProvisioningState || (exports.KnownWorkloadNetworkDnsServiceProvisioningState = {}));
/** Known values of {@link WorkloadNetworkDnsZoneProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkDnsZoneProvisioningState = void 0;
(function (KnownWorkloadNetworkDnsZoneProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkDnsZoneProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkDnsZoneProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkDnsZoneProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkDnsZoneProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkDnsZoneProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkDnsZoneProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkDnsZoneProvisioningState || (exports.KnownWorkloadNetworkDnsZoneProvisioningState = {}));
/** Known values of {@link WorkloadNetworkPublicIPProvisioningState} that the service accepts. */
exports.KnownWorkloadNetworkPublicIPProvisioningState = void 0;
(function (KnownWorkloadNetworkPublicIPProvisioningState) {
    /** Succeeded */
    KnownWorkloadNetworkPublicIPProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownWorkloadNetworkPublicIPProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownWorkloadNetworkPublicIPProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownWorkloadNetworkPublicIPProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownWorkloadNetworkPublicIPProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownWorkloadNetworkPublicIPProvisioningState["Canceled"] = "Canceled";
})(exports.KnownWorkloadNetworkPublicIPProvisioningState || (exports.KnownWorkloadNetworkPublicIPProvisioningState = {}));
/** Known values of {@link CloudLinkStatus} that the service accepts. */
exports.KnownCloudLinkStatus = void 0;
(function (KnownCloudLinkStatus) {
    /** Active */
    KnownCloudLinkStatus["Active"] = "Active";
    /** Building */
    KnownCloudLinkStatus["Building"] = "Building";
    /** Deleting */
    KnownCloudLinkStatus["Deleting"] = "Deleting";
    /** Failed */
    KnownCloudLinkStatus["Failed"] = "Failed";
    /** Disconnected */
    KnownCloudLinkStatus["Disconnected"] = "Disconnected";
})(exports.KnownCloudLinkStatus || (exports.KnownCloudLinkStatus = {}));
/** Known values of {@link AddonType} that the service accepts. */
exports.KnownAddonType = void 0;
(function (KnownAddonType) {
    /** SRM */
    KnownAddonType["SRM"] = "SRM";
    /** VR */
    KnownAddonType["VR"] = "VR";
    /** HCX */
    KnownAddonType["HCX"] = "HCX";
    /** Arc */
    KnownAddonType["Arc"] = "Arc";
})(exports.KnownAddonType || (exports.KnownAddonType = {}));
/** Known values of {@link AddonProvisioningState} that the service accepts. */
exports.KnownAddonProvisioningState = void 0;
(function (KnownAddonProvisioningState) {
    /** Succeeded */
    KnownAddonProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownAddonProvisioningState["Failed"] = "Failed";
    /** Cancelled */
    KnownAddonProvisioningState["Cancelled"] = "Cancelled";
    /** Building */
    KnownAddonProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownAddonProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownAddonProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownAddonProvisioningState["Canceled"] = "Canceled";
})(exports.KnownAddonProvisioningState || (exports.KnownAddonProvisioningState = {}));
/** Known values of {@link VirtualMachineRestrictMovementState} that the service accepts. */
exports.KnownVirtualMachineRestrictMovementState = void 0;
(function (KnownVirtualMachineRestrictMovementState) {
    /** Enabled */
    KnownVirtualMachineRestrictMovementState["Enabled"] = "Enabled";
    /** Disabled */
    KnownVirtualMachineRestrictMovementState["Disabled"] = "Disabled";
})(exports.KnownVirtualMachineRestrictMovementState || (exports.KnownVirtualMachineRestrictMovementState = {}));
/** Known values of {@link PlacementPolicyType} that the service accepts. */
exports.KnownPlacementPolicyType = void 0;
(function (KnownPlacementPolicyType) {
    /** VmVm */
    KnownPlacementPolicyType["VmVm"] = "VmVm";
    /** VmHost */
    KnownPlacementPolicyType["VmHost"] = "VmHost";
})(exports.KnownPlacementPolicyType || (exports.KnownPlacementPolicyType = {}));
/** Known values of {@link PlacementPolicyState} that the service accepts. */
exports.KnownPlacementPolicyState = void 0;
(function (KnownPlacementPolicyState) {
    /** Enabled */
    KnownPlacementPolicyState["Enabled"] = "Enabled";
    /** Disabled */
    KnownPlacementPolicyState["Disabled"] = "Disabled";
})(exports.KnownPlacementPolicyState || (exports.KnownPlacementPolicyState = {}));
/** Known values of {@link PlacementPolicyProvisioningState} that the service accepts. */
exports.KnownPlacementPolicyProvisioningState = void 0;
(function (KnownPlacementPolicyProvisioningState) {
    /** Succeeded */
    KnownPlacementPolicyProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownPlacementPolicyProvisioningState["Failed"] = "Failed";
    /** Building */
    KnownPlacementPolicyProvisioningState["Building"] = "Building";
    /** Deleting */
    KnownPlacementPolicyProvisioningState["Deleting"] = "Deleting";
    /** Updating */
    KnownPlacementPolicyProvisioningState["Updating"] = "Updating";
    /** Canceled */
    KnownPlacementPolicyProvisioningState["Canceled"] = "Canceled";
})(exports.KnownPlacementPolicyProvisioningState || (exports.KnownPlacementPolicyProvisioningState = {}));
/** Known values of {@link AffinityStrength} that the service accepts. */
exports.KnownAffinityStrength = void 0;
(function (KnownAffinityStrength) {
    /** Should */
    KnownAffinityStrength["Should"] = "Should";
    /** Must */
    KnownAffinityStrength["Must"] = "Must";
})(exports.KnownAffinityStrength || (exports.KnownAffinityStrength = {}));
/** Known values of {@link AzureHybridBenefitType} that the service accepts. */
exports.KnownAzureHybridBenefitType = void 0;
(function (KnownAzureHybridBenefitType) {
    /** SqlHost */
    KnownAzureHybridBenefitType["SqlHost"] = "SqlHost";
    /** None */
    KnownAzureHybridBenefitType["None"] = "None";
})(exports.KnownAzureHybridBenefitType || (exports.KnownAzureHybridBenefitType = {}));
/** Known values of {@link ScriptParameterTypes} that the service accepts. */
exports.KnownScriptParameterTypes = void 0;
(function (KnownScriptParameterTypes) {
    /** String */
    KnownScriptParameterTypes["String"] = "String";
    /** SecureString */
    KnownScriptParameterTypes["SecureString"] = "SecureString";
    /** Credential */
    KnownScriptParameterTypes["Credential"] = "Credential";
    /** Int */
    KnownScriptParameterTypes["Int"] = "Int";
    /** Bool */
    KnownScriptParameterTypes["Bool"] = "Bool";
    /** Float */
    KnownScriptParameterTypes["Float"] = "Float";
})(exports.KnownScriptParameterTypes || (exports.KnownScriptParameterTypes = {}));
/** Known values of {@link VisibilityParameterEnum} that the service accepts. */
exports.KnownVisibilityParameterEnum = void 0;
(function (KnownVisibilityParameterEnum) {
    /** Visible */
    KnownVisibilityParameterEnum["Visible"] = "Visible";
    /** Hidden */
    KnownVisibilityParameterEnum["Hidden"] = "Hidden";
})(exports.KnownVisibilityParameterEnum || (exports.KnownVisibilityParameterEnum = {}));
/** Known values of {@link OptionalParamEnum} that the service accepts. */
exports.KnownOptionalParamEnum = void 0;
(function (KnownOptionalParamEnum) {
    /** Optional */
    KnownOptionalParamEnum["Optional"] = "Optional";
    /** Required */
    KnownOptionalParamEnum["Required"] = "Required";
})(exports.KnownOptionalParamEnum || (exports.KnownOptionalParamEnum = {}));
/** Known values of {@link ScriptExecutionParameterType} that the service accepts. */
exports.KnownScriptExecutionParameterType = void 0;
(function (KnownScriptExecutionParameterType) {
    /** Value */
    KnownScriptExecutionParameterType["Value"] = "Value";
    /** SecureValue */
    KnownScriptExecutionParameterType["SecureValue"] = "SecureValue";
    /** Credential */
    KnownScriptExecutionParameterType["Credential"] = "Credential";
})(exports.KnownScriptExecutionParameterType || (exports.KnownScriptExecutionParameterType = {}));
/** Known values of {@link ScriptExecutionProvisioningState} that the service accepts. */
exports.KnownScriptExecutionProvisioningState = void 0;
(function (KnownScriptExecutionProvisioningState) {
    /** Pending */
    KnownScriptExecutionProvisioningState["Pending"] = "Pending";
    /** Running */
    KnownScriptExecutionProvisioningState["Running"] = "Running";
    /** Succeeded */
    KnownScriptExecutionProvisioningState["Succeeded"] = "Succeeded";
    /** Failed */
    KnownScriptExecutionProvisioningState["Failed"] = "Failed";
    /** Cancelling */
    KnownScriptExecutionProvisioningState["Cancelling"] = "Cancelling";
    /** Cancelled */
    KnownScriptExecutionProvisioningState["Cancelled"] = "Cancelled";
    /** Deleting */
    KnownScriptExecutionProvisioningState["Deleting"] = "Deleting";
    /** Canceled */
    KnownScriptExecutionProvisioningState["Canceled"] = "Canceled";
})(exports.KnownScriptExecutionProvisioningState || (exports.KnownScriptExecutionProvisioningState = {}));
/** Known values of {@link ScriptOutputStreamType} that the service accepts. */
exports.KnownScriptOutputStreamType = void 0;
(function (KnownScriptOutputStreamType) {
    /** Information */
    KnownScriptOutputStreamType["Information"] = "Information";
    /** Warning */
    KnownScriptOutputStreamType["Warning"] = "Warning";
    /** Output */
    KnownScriptOutputStreamType["Output"] = "Output";
    /** Error */
    KnownScriptOutputStreamType["Error"] = "Error";
})(exports.KnownScriptOutputStreamType || (exports.KnownScriptOutputStreamType = {}));
/** Known values of {@link AffinityType} that the service accepts. */
exports.KnownAffinityType = void 0;
(function (KnownAffinityType) {
    /** Affinity */
    KnownAffinityType["Affinity"] = "Affinity";
    /** AntiAffinity */
    KnownAffinityType["AntiAffinity"] = "AntiAffinity";
})(exports.KnownAffinityType || (exports.KnownAffinityType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationList = {
    type: {
        name: "Composite",
        className: "OperationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "OperationProperties"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationProperties = {
    type: {
        name: "Composite",
        className: "OperationProperties",
        modelProperties: {
            serviceSpecification: {
                serializedName: "serviceSpecification",
                type: {
                    name: "Composite",
                    className: "ServiceSpecification"
                }
            }
        }
    }
};
const ServiceSpecification = {
    type: {
        name: "Composite",
        className: "ServiceSpecification",
        modelProperties: {
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            },
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            category: {
                serializedName: "category",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            supportedAggregationTypes: {
                serializedName: "supportedAggregationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            supportedTimeGrainTypes: {
                serializedName: "supportedTimeGrainTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricDimension"
                        }
                    }
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetricDimension = {
    type: {
        name: "Composite",
        className: "MetricDimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            },
            toBeExportedForShoebox: {
                serializedName: "toBeExportedForShoebox",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetail"
                }
            }
        }
    }
};
const ErrorDetail = {
    type: {
        name: "Composite",
        className: "ErrorDetail",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetail"
                        }
                    }
                }
            },
            additionalInfo: {
                serializedName: "additionalInfo",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorAdditionalInfo"
                        }
                    }
                }
            }
        }
    }
};
const ErrorAdditionalInfo = {
    type: {
        name: "Composite",
        className: "ErrorAdditionalInfo",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            info: {
                serializedName: "info",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Trial = {
    type: {
        name: "Composite",
        className: "Trial",
        modelProperties: {
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availableHosts: {
                serializedName: "availableHosts",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Quota = {
    type: {
        name: "Composite",
        className: "Quota",
        modelProperties: {
            hostsRemaining: {
                serializedName: "hostsRemaining",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "Number" } }
                }
            },
            quotaEnabled: {
                serializedName: "quotaEnabled",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudList = {
    type: {
        name: "Composite",
        className: "PrivateCloudList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateCloud"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Circuit = {
    type: {
        name: "Composite",
        className: "Circuit",
        modelProperties: {
            primarySubnet: {
                serializedName: "primarySubnet",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            secondarySubnet: {
                serializedName: "secondarySubnet",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expressRouteID: {
                serializedName: "expressRouteID",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            expressRoutePrivatePeeringID: {
                serializedName: "expressRoutePrivatePeeringID",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Endpoints = {
    type: {
        name: "Composite",
        className: "Endpoints",
        modelProperties: {
            nsxtManager: {
                serializedName: "nsxtManager",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vcsa: {
                serializedName: "vcsa",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            hcxCloudManager: {
                serializedName: "hcxCloudManager",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudUpdateProperties = {
    type: {
        name: "Composite",
        className: "PrivateCloudUpdateProperties",
        modelProperties: {
            managementCluster: {
                serializedName: "managementCluster",
                type: {
                    name: "Composite",
                    className: "ManagementCluster"
                }
            },
            internet: {
                defaultValue: "Disabled",
                serializedName: "internet",
                type: {
                    name: "String"
                }
            },
            identitySources: {
                serializedName: "identitySources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IdentitySource"
                        }
                    }
                }
            },
            availability: {
                serializedName: "availability",
                type: {
                    name: "Composite",
                    className: "AvailabilityProperties"
                }
            },
            encryption: {
                serializedName: "encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            extendedNetworkBlocks: {
                serializedName: "extendedNetworkBlocks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const CommonClusterProperties = {
    type: {
        name: "Composite",
        className: "CommonClusterProperties",
        modelProperties: {
            clusterSize: {
                serializedName: "clusterSize",
                type: {
                    name: "Number"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clusterId: {
                serializedName: "clusterId",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            hosts: {
                serializedName: "hosts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const IdentitySource = {
    type: {
        name: "Composite",
        className: "IdentitySource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            alias: {
                serializedName: "alias",
                type: {
                    name: "String"
                }
            },
            domain: {
                serializedName: "domain",
                type: {
                    name: "String"
                }
            },
            baseUserDN: {
                serializedName: "baseUserDN",
                type: {
                    name: "String"
                }
            },
            baseGroupDN: {
                serializedName: "baseGroupDN",
                type: {
                    name: "String"
                }
            },
            primaryServer: {
                serializedName: "primaryServer",
                type: {
                    name: "String"
                }
            },
            secondaryServer: {
                serializedName: "secondaryServer",
                type: {
                    name: "String"
                }
            },
            ssl: {
                serializedName: "ssl",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilityProperties = {
    type: {
        name: "Composite",
        className: "AvailabilityProperties",
        modelProperties: {
            strategy: {
                serializedName: "strategy",
                type: {
                    name: "String"
                }
            },
            zone: {
                serializedName: "zone",
                type: {
                    name: "Number"
                }
            },
            secondaryZone: {
                serializedName: "secondaryZone",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Encryption = {
    type: {
        name: "Composite",
        className: "Encryption",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            keyVaultProperties: {
                serializedName: "keyVaultProperties",
                type: {
                    name: "Composite",
                    className: "EncryptionKeyVaultProperties"
                }
            }
        }
    }
};
const EncryptionKeyVaultProperties = {
    type: {
        name: "Composite",
        className: "EncryptionKeyVaultProperties",
        modelProperties: {
            keyName: {
                serializedName: "keyName",
                type: {
                    name: "String"
                }
            },
            keyVersion: {
                serializedName: "keyVersion",
                type: {
                    name: "String"
                }
            },
            autoDetectedKeyVersion: {
                serializedName: "autoDetectedKeyVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            keyVaultUrl: {
                serializedName: "keyVaultUrl",
                type: {
                    name: "String"
                }
            },
            keyState: {
                serializedName: "keyState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            versionType: {
                serializedName: "versionType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudIdentity = {
    type: {
        name: "Composite",
        className: "PrivateCloudIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudUpdate = {
    type: {
        name: "Composite",
        className: "PrivateCloudUpdate",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "PrivateCloudIdentity"
                }
            },
            managementCluster: {
                serializedName: "properties.managementCluster",
                type: {
                    name: "Composite",
                    className: "ManagementCluster"
                }
            },
            internet: {
                defaultValue: "Disabled",
                serializedName: "properties.internet",
                type: {
                    name: "String"
                }
            },
            identitySources: {
                serializedName: "properties.identitySources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IdentitySource"
                        }
                    }
                }
            },
            availability: {
                serializedName: "properties.availability",
                type: {
                    name: "Composite",
                    className: "AvailabilityProperties"
                }
            },
            encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            },
            extendedNetworkBlocks: {
                serializedName: "properties.extendedNetworkBlocks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ClusterList = {
    type: {
        name: "Composite",
        className: "ClusterList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cluster"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ClusterUpdate = {
    type: {
        name: "Composite",
        className: "ClusterUpdate",
        modelProperties: {
            clusterSize: {
                serializedName: "properties.clusterSize",
                type: {
                    name: "Number"
                }
            },
            hosts: {
                serializedName: "properties.hosts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ClusterZoneList = {
    type: {
        name: "Composite",
        className: "ClusterZoneList",
        modelProperties: {
            zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ClusterZone"
                        }
                    }
                }
            }
        }
    }
};
const ClusterZone = {
    type: {
        name: "Composite",
        className: "ClusterZone",
        modelProperties: {
            hosts: {
                serializedName: "hosts",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            zone: {
                serializedName: "zone",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DatastoreList = {
    type: {
        name: "Composite",
        className: "DatastoreList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Datastore"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetAppVolume = {
    type: {
        name: "Composite",
        className: "NetAppVolume",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiskPoolVolume = {
    type: {
        name: "Composite",
        className: "DiskPoolVolume",
        modelProperties: {
            targetId: {
                serializedName: "targetId",
                required: true,
                type: {
                    name: "String"
                }
            },
            lunName: {
                serializedName: "lunName",
                required: true,
                type: {
                    name: "String"
                }
            },
            mountOption: {
                defaultValue: "MOUNT",
                serializedName: "mountOption",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdminCredentials = {
    type: {
        name: "Composite",
        className: "AdminCredentials",
        modelProperties: {
            nsxtUsername: {
                serializedName: "nsxtUsername",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nsxtPassword: {
                serializedName: "nsxtPassword",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vcenterUsername: {
                serializedName: "vcenterUsername",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vcenterPassword: {
                serializedName: "vcenterPassword",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HcxEnterpriseSiteList = {
    type: {
        name: "Composite",
        className: "HcxEnterpriseSiteList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HcxEnterpriseSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteAuthorizationList = {
    type: {
        name: "Composite",
        className: "ExpressRouteAuthorizationList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteAuthorization"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GlobalReachConnectionList = {
    type: {
        name: "Composite",
        className: "GlobalReachConnectionList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GlobalReachConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkSegmentsList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkSegmentsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkSegment"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkSegmentSubnet = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkSegmentSubnet",
        modelProperties: {
            dhcpRanges: {
                serializedName: "dhcpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            gatewayAddress: {
                serializedName: "gatewayAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkSegmentPortVif = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkSegmentPortVif",
        modelProperties: {
            portName: {
                serializedName: "portName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkDhcpList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDhcpList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkDhcp"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkDhcpEntity = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDhcpEntity",
        uberParent: "WorkloadNetworkDhcpEntity",
        polymorphicDiscriminator: {
            serializedName: "dhcpType",
            clientName: "dhcpType"
        },
        modelProperties: {
            dhcpType: {
                serializedName: "dhcpType",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            segments: {
                serializedName: "segments",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            revision: {
                serializedName: "revision",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const WorkloadNetworkGatewayList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkGatewayList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkPortMirroringList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkPortMirroringList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkPortMirroring"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkVMGroupsList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkVMGroupsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkVMGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkVirtualMachinesList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkVirtualMachinesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkVirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkDnsServicesList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDnsServicesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkDnsService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkDnsZonesList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDnsZonesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkDnsZone"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WorkloadNetworkPublicIPsList = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkPublicIPsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkPublicIP"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudLinkList = {
    type: {
        name: "Composite",
        className: "CloudLinkList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddonList = {
    type: {
        name: "Composite",
        className: "AddonList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Addon"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddonProperties = {
    type: {
        name: "Composite",
        className: "AddonProperties",
        uberParent: "AddonProperties",
        polymorphicDiscriminator: {
            serializedName: "addonType",
            clientName: "addonType"
        },
        modelProperties: {
            addonType: {
                serializedName: "addonType",
                required: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinesList = {
    type: {
        name: "Composite",
        className: "VirtualMachinesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineRestrictMovement = {
    type: {
        name: "Composite",
        className: "VirtualMachineRestrictMovement",
        modelProperties: {
            restrictMovement: {
                serializedName: "restrictMovement",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlacementPoliciesList = {
    type: {
        name: "Composite",
        className: "PlacementPoliciesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PlacementPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlacementPolicyProperties = {
    type: {
        name: "Composite",
        className: "PlacementPolicyProperties",
        uberParent: "PlacementPolicyProperties",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PlacementPolicyUpdate = {
    type: {
        name: "Composite",
        className: "PlacementPolicyUpdate",
        modelProperties: {
            state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            },
            vmMembers: {
                serializedName: "properties.vmMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            hostMembers: {
                serializedName: "properties.hostMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            affinityStrength: {
                serializedName: "properties.affinityStrength",
                type: {
                    name: "String"
                }
            },
            azureHybridBenefitType: {
                serializedName: "properties.azureHybridBenefitType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptPackagesList = {
    type: {
        name: "Composite",
        className: "ScriptPackagesList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptPackage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptCmdletsList = {
    type: {
        name: "Composite",
        className: "ScriptCmdletsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptCmdlet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptParameter = {
    type: {
        name: "Composite",
        className: "ScriptParameter",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            visibility: {
                serializedName: "visibility",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            optional: {
                serializedName: "optional",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptExecutionsList = {
    type: {
        name: "Composite",
        className: "ScriptExecutionsList",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptExecution"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScriptExecutionParameter = {
    type: {
        name: "Composite",
        className: "ScriptExecutionParameter",
        uberParent: "ScriptExecutionParameter",
        polymorphicDiscriminator: {
            serializedName: "type",
            clientName: "type"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudProperties = {
    type: {
        name: "Composite",
        className: "PrivateCloudProperties",
        modelProperties: Object.assign(Object.assign({}, PrivateCloudUpdateProperties.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, circuit: {
                serializedName: "circuit",
                type: {
                    name: "Composite",
                    className: "Circuit"
                }
            }, endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Composite",
                    className: "Endpoints"
                }
            }, networkBlock: {
                serializedName: "networkBlock",
                required: true,
                type: {
                    name: "String"
                }
            }, managementNetwork: {
                serializedName: "managementNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningNetwork: {
                serializedName: "provisioningNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vmotionNetwork: {
                serializedName: "vmotionNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vcenterPassword: {
                serializedName: "vcenterPassword",
                type: {
                    name: "String"
                }
            }, nsxtPassword: {
                serializedName: "nsxtPassword",
                type: {
                    name: "String"
                }
            }, vcenterCertificateThumbprint: {
                serializedName: "vcenterCertificateThumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nsxtCertificateThumbprint: {
                serializedName: "nsxtCertificateThumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, externalCloudLinks: {
                serializedName: "externalCloudLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, secondaryCircuit: {
                serializedName: "secondaryCircuit",
                type: {
                    name: "Composite",
                    className: "Circuit"
                }
            }, nsxPublicIpQuotaRaised: {
                serializedName: "nsxPublicIpQuotaRaised",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ManagementCluster = {
    type: {
        name: "Composite",
        className: "ManagementCluster",
        modelProperties: Object.assign({}, CommonClusterProperties.type.modelProperties)
    }
};
const ClusterProperties = {
    type: {
        name: "Composite",
        className: "ClusterProperties",
        modelProperties: Object.assign({}, CommonClusterProperties.type.modelProperties)
    }
};
const TrackedResource = {
    type: {
        name: "Composite",
        className: "TrackedResource",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const Cluster = {
    type: {
        name: "Composite",
        className: "Cluster",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, clusterSize: {
                serializedName: "properties.clusterSize",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clusterId: {
                serializedName: "properties.clusterId",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, hosts: {
                serializedName: "properties.hosts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Datastore = {
    type: {
        name: "Composite",
        className: "Datastore",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, netAppVolume: {
                serializedName: "properties.netAppVolume",
                type: {
                    name: "Composite",
                    className: "NetAppVolume"
                }
            }, diskPoolVolume: {
                serializedName: "properties.diskPoolVolume",
                type: {
                    name: "Composite",
                    className: "DiskPoolVolume"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HcxEnterpriseSite = {
    type: {
        name: "Composite",
        className: "HcxEnterpriseSite",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { activationKey: {
                serializedName: "properties.activationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteAuthorization = {
    type: {
        name: "Composite",
        className: "ExpressRouteAuthorization",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteAuthorizationId: {
                serializedName: "properties.expressRouteAuthorizationId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteAuthorizationKey: {
                serializedName: "properties.expressRouteAuthorizationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteId: {
                serializedName: "properties.expressRouteId",
                type: {
                    name: "String"
                }
            } })
    }
};
const GlobalReachConnection = {
    type: {
        name: "Composite",
        className: "GlobalReachConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, circuitConnectionStatus: {
                serializedName: "properties.circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerExpressRouteCircuit: {
                serializedName: "properties.peerExpressRouteCircuit",
                type: {
                    name: "String"
                }
            }, expressRouteId: {
                serializedName: "properties.expressRouteId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const CloudLink = {
    type: {
        name: "Composite",
        className: "CloudLink",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkedCloud: {
                serializedName: "properties.linkedCloud",
                type: {
                    name: "String"
                }
            } })
    }
};
const Addon = {
    type: {
        name: "Composite",
        className: "Addon",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "AddonProperties"
                }
            } })
    }
};
const PlacementPolicy = {
    type: {
        name: "Composite",
        className: "PlacementPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "PlacementPolicyProperties"
                }
            } })
    }
};
const WorkloadNetworkDhcpServer = {
    serializedName: "SERVER",
    type: {
        name: "Composite",
        className: "WorkloadNetworkDhcpServer",
        uberParent: "WorkloadNetworkDhcpEntity",
        polymorphicDiscriminator: WorkloadNetworkDhcpEntity.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkloadNetworkDhcpEntity.type.modelProperties), { serverAddress: {
                serializedName: "serverAddress",
                type: {
                    name: "String"
                }
            }, leaseTime: {
                serializedName: "leaseTime",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkDhcpRelay = {
    serializedName: "RELAY",
    type: {
        name: "Composite",
        className: "WorkloadNetworkDhcpRelay",
        uberParent: "WorkloadNetworkDhcpEntity",
        polymorphicDiscriminator: WorkloadNetworkDhcpEntity.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, WorkloadNetworkDhcpEntity.type.modelProperties), { serverAddresses: {
                constraints: {
                    MinItems: 1,
                    MaxItems: 3
                },
                serializedName: "serverAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AddonSrmProperties = {
    serializedName: "SRM",
    type: {
        name: "Composite",
        className: "AddonSrmProperties",
        uberParent: "AddonProperties",
        polymorphicDiscriminator: AddonProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AddonProperties.type.modelProperties), { licenseKey: {
                serializedName: "licenseKey",
                type: {
                    name: "String"
                }
            } })
    }
};
const AddonVrProperties = {
    serializedName: "VR",
    type: {
        name: "Composite",
        className: "AddonVrProperties",
        uberParent: "AddonProperties",
        polymorphicDiscriminator: AddonProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AddonProperties.type.modelProperties), { vrsCount: {
                serializedName: "vrsCount",
                required: true,
                type: {
                    name: "Number"
                }
            } })
    }
};
const AddonHcxProperties = {
    serializedName: "HCX",
    type: {
        name: "Composite",
        className: "AddonHcxProperties",
        uberParent: "AddonProperties",
        polymorphicDiscriminator: AddonProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AddonProperties.type.modelProperties), { offer: {
                serializedName: "offer",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AddonArcProperties = {
    serializedName: "Arc",
    type: {
        name: "Composite",
        className: "AddonArcProperties",
        uberParent: "AddonProperties",
        polymorphicDiscriminator: AddonProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, AddonProperties.type.modelProperties), { vCenter: {
                serializedName: "vCenter",
                type: {
                    name: "String"
                }
            } })
    }
};
const VmPlacementPolicyProperties = {
    serializedName: "VmVm",
    type: {
        name: "Composite",
        className: "VmPlacementPolicyProperties",
        uberParent: "PlacementPolicyProperties",
        polymorphicDiscriminator: PlacementPolicyProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, PlacementPolicyProperties.type.modelProperties), { vmMembers: {
                serializedName: "vmMembers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, affinityType: {
                serializedName: "affinityType",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VmHostPlacementPolicyProperties = {
    serializedName: "VmHost",
    type: {
        name: "Composite",
        className: "VmHostPlacementPolicyProperties",
        uberParent: "PlacementPolicyProperties",
        polymorphicDiscriminator: PlacementPolicyProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, PlacementPolicyProperties.type.modelProperties), { vmMembers: {
                serializedName: "vmMembers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hostMembers: {
                serializedName: "hostMembers",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, affinityType: {
                serializedName: "affinityType",
                required: true,
                type: {
                    name: "String"
                }
            }, affinityStrength: {
                serializedName: "affinityStrength",
                type: {
                    name: "String"
                }
            }, azureHybridBenefitType: {
                serializedName: "azureHybridBenefitType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ScriptSecureStringExecutionParameter = {
    serializedName: "SecureValue",
    type: {
        name: "Composite",
        className: "ScriptSecureStringExecutionParameter",
        uberParent: "ScriptExecutionParameter",
        polymorphicDiscriminator: ScriptExecutionParameter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScriptExecutionParameter.type.modelProperties), { secureValue: {
                serializedName: "secureValue",
                type: {
                    name: "String"
                }
            } })
    }
};
const ScriptStringExecutionParameter = {
    serializedName: "Value",
    type: {
        name: "Composite",
        className: "ScriptStringExecutionParameter",
        uberParent: "ScriptExecutionParameter",
        polymorphicDiscriminator: ScriptExecutionParameter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScriptExecutionParameter.type.modelProperties), { value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            } })
    }
};
const PSCredentialExecutionParameter = {
    serializedName: "Credential",
    type: {
        name: "Composite",
        className: "PSCredentialExecutionParameter",
        uberParent: "ScriptExecutionParameter",
        polymorphicDiscriminator: ScriptExecutionParameter.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ScriptExecutionParameter.type.modelProperties), { username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateCloud = {
    type: {
        name: "Composite",
        className: "PrivateCloud",
        modelProperties: Object.assign(Object.assign({}, TrackedResource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "PrivateCloudIdentity"
                }
            }, managementCluster: {
                serializedName: "properties.managementCluster",
                type: {
                    name: "Composite",
                    className: "ManagementCluster"
                }
            }, internet: {
                defaultValue: "Disabled",
                serializedName: "properties.internet",
                type: {
                    name: "String"
                }
            }, identitySources: {
                serializedName: "properties.identitySources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IdentitySource"
                        }
                    }
                }
            }, availability: {
                serializedName: "properties.availability",
                type: {
                    name: "Composite",
                    className: "AvailabilityProperties"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "Encryption"
                }
            }, extendedNetworkBlocks: {
                serializedName: "properties.extendedNetworkBlocks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, circuit: {
                serializedName: "properties.circuit",
                type: {
                    name: "Composite",
                    className: "Circuit"
                }
            }, endpoints: {
                serializedName: "properties.endpoints",
                type: {
                    name: "Composite",
                    className: "Endpoints"
                }
            }, networkBlock: {
                serializedName: "properties.networkBlock",
                type: {
                    name: "String"
                }
            }, managementNetwork: {
                serializedName: "properties.managementNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningNetwork: {
                serializedName: "properties.provisioningNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vmotionNetwork: {
                serializedName: "properties.vmotionNetwork",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vcenterPassword: {
                serializedName: "properties.vcenterPassword",
                type: {
                    name: "String"
                }
            }, nsxtPassword: {
                serializedName: "properties.nsxtPassword",
                type: {
                    name: "String"
                }
            }, vcenterCertificateThumbprint: {
                serializedName: "properties.vcenterCertificateThumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nsxtCertificateThumbprint: {
                serializedName: "properties.nsxtCertificateThumbprint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, externalCloudLinks: {
                serializedName: "properties.externalCloudLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, secondaryCircuit: {
                serializedName: "properties.secondaryCircuit",
                type: {
                    name: "Composite",
                    className: "Circuit"
                }
            }, nsxPublicIpQuotaRaised: {
                serializedName: "properties.nsxPublicIpQuotaRaised",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadNetwork = {
    type: {
        name: "Composite",
        className: "WorkloadNetwork",
        modelProperties: Object.assign({}, ProxyResource.type.modelProperties)
    }
};
const WorkloadNetworkSegment = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkSegment",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, connectedGateway: {
                serializedName: "properties.connectedGateway",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "WorkloadNetworkSegmentSubnet"
                }
            }, portVif: {
                serializedName: "properties.portVif",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WorkloadNetworkSegmentPortVif"
                        }
                    }
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revision: {
                serializedName: "properties.revision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkDhcp = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDhcp",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "WorkloadNetworkDhcpEntity"
                }
            } })
    }
};
const WorkloadNetworkGateway = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkGateway",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "properties.path",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadNetworkPortMirroring = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkPortMirroring",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, source: {
                serializedName: "properties.source",
                type: {
                    name: "String"
                }
            }, destination: {
                serializedName: "properties.destination",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revision: {
                serializedName: "properties.revision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkVMGroup = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkVMGroup",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, members: {
                serializedName: "properties.members",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revision: {
                serializedName: "properties.revision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkVirtualMachine = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkVirtualMachine",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, vmType: {
                serializedName: "properties.vmType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const WorkloadNetworkDnsService = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDnsService",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, dnsServiceIp: {
                serializedName: "properties.dnsServiceIp",
                type: {
                    name: "String"
                }
            }, defaultDnsZone: {
                serializedName: "properties.defaultDnsZone",
                type: {
                    name: "String"
                }
            }, fqdnZones: {
                serializedName: "properties.fqdnZones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, logLevel: {
                serializedName: "properties.logLevel",
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revision: {
                serializedName: "properties.revision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkDnsZone = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkDnsZone",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, domain: {
                serializedName: "properties.domain",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, dnsServerIps: {
                serializedName: "properties.dnsServerIps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceIp: {
                serializedName: "properties.sourceIp",
                type: {
                    name: "String"
                }
            }, dnsServices: {
                serializedName: "properties.dnsServices",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, revision: {
                serializedName: "properties.revision",
                type: {
                    name: "Number"
                }
            } })
    }
};
const WorkloadNetworkPublicIP = {
    type: {
        name: "Composite",
        className: "WorkloadNetworkPublicIP",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, numberOfPublicIPs: {
                serializedName: "properties.numberOfPublicIPs",
                type: {
                    name: "Number"
                }
            }, publicIPBlock: {
                serializedName: "properties.publicIPBlock",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachine = {
    type: {
        name: "Composite",
        className: "VirtualMachine",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, moRefId: {
                serializedName: "properties.moRefId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, folderPath: {
                serializedName: "properties.folderPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, restrictMovement: {
                serializedName: "properties.restrictMovement",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ScriptPackage = {
    type: {
        name: "Composite",
        className: "ScriptPackage",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, company: {
                serializedName: "properties.company",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uri: {
                serializedName: "properties.uri",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ScriptCmdlet = {
    type: {
        name: "Composite",
        className: "ScriptCmdlet",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "properties.timeout",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptParameter"
                        }
                    }
                }
            } })
    }
};
const ScriptExecution = {
    type: {
        name: "Composite",
        className: "ScriptExecution",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { scriptCmdletId: {
                serializedName: "properties.scriptCmdletId",
                type: {
                    name: "String"
                }
            }, parameters: {
                serializedName: "properties.parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptExecutionParameter"
                        }
                    }
                }
            }, hiddenParameters: {
                serializedName: "properties.hiddenParameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScriptExecutionParameter"
                        }
                    }
                }
            }, failureReason: {
                serializedName: "properties.failureReason",
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "properties.timeout",
                type: {
                    name: "String"
                }
            }, retention: {
                serializedName: "properties.retention",
                type: {
                    name: "String"
                }
            }, submittedAt: {
                serializedName: "properties.submittedAt",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, startedAt: {
                serializedName: "properties.startedAt",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, finishedAt: {
                serializedName: "properties.finishedAt",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, output: {
                serializedName: "properties.output",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, namedOutputs: {
                serializedName: "properties.namedOutputs",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }, information: {
                serializedName: "properties.information",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, warnings: {
                serializedName: "properties.warnings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, errors: {
                serializedName: "properties.errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
let discriminators = {
    WorkloadNetworkDhcpEntity: WorkloadNetworkDhcpEntity,
    AddonProperties: AddonProperties,
    PlacementPolicyProperties: PlacementPolicyProperties,
    ScriptExecutionParameter: ScriptExecutionParameter,
    "WorkloadNetworkDhcpEntity.SERVER": WorkloadNetworkDhcpServer,
    "WorkloadNetworkDhcpEntity.RELAY": WorkloadNetworkDhcpRelay,
    "AddonProperties.SRM": AddonSrmProperties,
    "AddonProperties.VR": AddonVrProperties,
    "AddonProperties.HCX": AddonHcxProperties,
    "AddonProperties.Arc": AddonArcProperties,
    "PlacementPolicyProperties.VmVm": VmPlacementPolicyProperties,
    "PlacementPolicyProperties.VmHost": VmHostPlacementPolicyProperties,
    "ScriptExecutionParameter.SecureValue": ScriptSecureStringExecutionParameter,
    "ScriptExecutionParameter.Value": ScriptStringExecutionParameter,
    "ScriptExecutionParameter.Credential": PSCredentialExecutionParameter
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationList: OperationList,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationProperties: OperationProperties,
    ServiceSpecification: ServiceSpecification,
    LogSpecification: LogSpecification,
    MetricSpecification: MetricSpecification,
    MetricDimension: MetricDimension,
    ErrorResponse: ErrorResponse,
    ErrorDetail: ErrorDetail,
    ErrorAdditionalInfo: ErrorAdditionalInfo,
    Sku: Sku,
    Trial: Trial,
    Quota: Quota,
    PrivateCloudList: PrivateCloudList,
    Circuit: Circuit,
    Endpoints: Endpoints,
    PrivateCloudUpdateProperties: PrivateCloudUpdateProperties,
    CommonClusterProperties: CommonClusterProperties,
    IdentitySource: IdentitySource,
    AvailabilityProperties: AvailabilityProperties,
    Encryption: Encryption,
    EncryptionKeyVaultProperties: EncryptionKeyVaultProperties,
    PrivateCloudIdentity: PrivateCloudIdentity,
    Resource: Resource,
    PrivateCloudUpdate: PrivateCloudUpdate,
    ClusterList: ClusterList,
    ClusterUpdate: ClusterUpdate,
    ClusterZoneList: ClusterZoneList,
    ClusterZone: ClusterZone,
    DatastoreList: DatastoreList,
    NetAppVolume: NetAppVolume,
    DiskPoolVolume: DiskPoolVolume,
    AdminCredentials: AdminCredentials,
    HcxEnterpriseSiteList: HcxEnterpriseSiteList,
    ExpressRouteAuthorizationList: ExpressRouteAuthorizationList,
    GlobalReachConnectionList: GlobalReachConnectionList,
    WorkloadNetworkList: WorkloadNetworkList,
    WorkloadNetworkSegmentsList: WorkloadNetworkSegmentsList,
    WorkloadNetworkSegmentSubnet: WorkloadNetworkSegmentSubnet,
    WorkloadNetworkSegmentPortVif: WorkloadNetworkSegmentPortVif,
    WorkloadNetworkDhcpList: WorkloadNetworkDhcpList,
    WorkloadNetworkDhcpEntity: WorkloadNetworkDhcpEntity,
    WorkloadNetworkGatewayList: WorkloadNetworkGatewayList,
    WorkloadNetworkPortMirroringList: WorkloadNetworkPortMirroringList,
    WorkloadNetworkVMGroupsList: WorkloadNetworkVMGroupsList,
    WorkloadNetworkVirtualMachinesList: WorkloadNetworkVirtualMachinesList,
    WorkloadNetworkDnsServicesList: WorkloadNetworkDnsServicesList,
    WorkloadNetworkDnsZonesList: WorkloadNetworkDnsZonesList,
    WorkloadNetworkPublicIPsList: WorkloadNetworkPublicIPsList,
    CloudLinkList: CloudLinkList,
    AddonList: AddonList,
    AddonProperties: AddonProperties,
    VirtualMachinesList: VirtualMachinesList,
    VirtualMachineRestrictMovement: VirtualMachineRestrictMovement,
    PlacementPoliciesList: PlacementPoliciesList,
    PlacementPolicyProperties: PlacementPolicyProperties,
    PlacementPolicyUpdate: PlacementPolicyUpdate,
    ScriptPackagesList: ScriptPackagesList,
    ScriptCmdletsList: ScriptCmdletsList,
    ScriptParameter: ScriptParameter,
    ScriptExecutionsList: ScriptExecutionsList,
    ScriptExecutionParameter: ScriptExecutionParameter,
    PrivateCloudProperties: PrivateCloudProperties,
    ManagementCluster: ManagementCluster,
    ClusterProperties: ClusterProperties,
    TrackedResource: TrackedResource,
    Cluster: Cluster,
    Datastore: Datastore,
    HcxEnterpriseSite: HcxEnterpriseSite,
    ExpressRouteAuthorization: ExpressRouteAuthorization,
    GlobalReachConnection: GlobalReachConnection,
    ProxyResource: ProxyResource,
    CloudLink: CloudLink,
    Addon: Addon,
    PlacementPolicy: PlacementPolicy,
    WorkloadNetworkDhcpServer: WorkloadNetworkDhcpServer,
    WorkloadNetworkDhcpRelay: WorkloadNetworkDhcpRelay,
    AddonSrmProperties: AddonSrmProperties,
    AddonVrProperties: AddonVrProperties,
    AddonHcxProperties: AddonHcxProperties,
    AddonArcProperties: AddonArcProperties,
    VmPlacementPolicyProperties: VmPlacementPolicyProperties,
    VmHostPlacementPolicyProperties: VmHostPlacementPolicyProperties,
    ScriptSecureStringExecutionParameter: ScriptSecureStringExecutionParameter,
    ScriptStringExecutionParameter: ScriptStringExecutionParameter,
    PSCredentialExecutionParameter: PSCredentialExecutionParameter,
    PrivateCloud: PrivateCloud,
    WorkloadNetwork: WorkloadNetwork,
    WorkloadNetworkSegment: WorkloadNetworkSegment,
    WorkloadNetworkDhcp: WorkloadNetworkDhcp,
    WorkloadNetworkGateway: WorkloadNetworkGateway,
    WorkloadNetworkPortMirroring: WorkloadNetworkPortMirroring,
    WorkloadNetworkVMGroup: WorkloadNetworkVMGroup,
    WorkloadNetworkVirtualMachine: WorkloadNetworkVirtualMachine,
    WorkloadNetworkDnsService: WorkloadNetworkDnsService,
    WorkloadNetworkDnsZone: WorkloadNetworkDnsZone,
    WorkloadNetworkPublicIP: WorkloadNetworkPublicIP,
    VirtualMachine: VirtualMachine,
    ScriptPackage: ScriptPackage,
    ScriptCmdlet: ScriptCmdlet,
    ScriptExecution: ScriptExecution,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2023-03-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const sku = {
    parameterPath: ["options", "sku"],
    mapper: Sku
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 90,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateCloudName = {
    parameterPath: "privateCloudName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "privateCloudName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateCloud = {
    parameterPath: "privateCloud",
    mapper: PrivateCloud
};
const privateCloudUpdate = {
    parameterPath: "privateCloudUpdate",
    mapper: PrivateCloudUpdate
};
const clusterName = {
    parameterPath: "clusterName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "clusterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cluster = {
    parameterPath: "cluster",
    mapper: Cluster
};
const privateCloudName1 = {
    parameterPath: "privateCloudName",
    mapper: {
        serializedName: "privateCloudName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const clusterUpdate = {
    parameterPath: "clusterUpdate",
    mapper: ClusterUpdate
};
const datastoreName = {
    parameterPath: "datastoreName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "datastoreName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const datastore = {
    parameterPath: "datastore",
    mapper: Datastore
};
const hcxEnterpriseSiteName = {
    parameterPath: "hcxEnterpriseSiteName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "hcxEnterpriseSiteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const hcxEnterpriseSite = {
    parameterPath: "hcxEnterpriseSite",
    mapper: HcxEnterpriseSite
};
const authorizationName = {
    parameterPath: "authorizationName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "authorizationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorization = {
    parameterPath: "authorization",
    mapper: ExpressRouteAuthorization
};
const globalReachConnectionName = {
    parameterPath: "globalReachConnectionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "globalReachConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const globalReachConnection = {
    parameterPath: "globalReachConnection",
    mapper: GlobalReachConnection
};
const workloadNetworkName = {
    parameterPath: "workloadNetworkName",
    mapper: {
        serializedName: "workloadNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const segmentId = {
    parameterPath: "segmentId",
    mapper: {
        serializedName: "segmentId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkSegment = {
    parameterPath: "workloadNetworkSegment",
    mapper: WorkloadNetworkSegment
};
const dhcpId = {
    parameterPath: "dhcpId",
    mapper: {
        serializedName: "dhcpId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkDhcp = {
    parameterPath: "workloadNetworkDhcp",
    mapper: WorkloadNetworkDhcp
};
const gatewayId = {
    parameterPath: "gatewayId",
    mapper: {
        serializedName: "gatewayId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const portMirroringId = {
    parameterPath: "portMirroringId",
    mapper: {
        serializedName: "portMirroringId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkPortMirroring = {
    parameterPath: "workloadNetworkPortMirroring",
    mapper: WorkloadNetworkPortMirroring
};
const vmGroupId = {
    parameterPath: "vmGroupId",
    mapper: {
        serializedName: "vmGroupId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkVMGroup = {
    parameterPath: "workloadNetworkVMGroup",
    mapper: WorkloadNetworkVMGroup
};
const virtualMachineId = {
    parameterPath: "virtualMachineId",
    mapper: {
        serializedName: "virtualMachineId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dnsServiceId = {
    parameterPath: "dnsServiceId",
    mapper: {
        serializedName: "dnsServiceId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkDnsService = {
    parameterPath: "workloadNetworkDnsService",
    mapper: WorkloadNetworkDnsService
};
const dnsZoneId = {
    parameterPath: "dnsZoneId",
    mapper: {
        serializedName: "dnsZoneId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkDnsZone = {
    parameterPath: "workloadNetworkDnsZone",
    mapper: WorkloadNetworkDnsZone
};
const publicIPId = {
    parameterPath: "publicIPId",
    mapper: {
        serializedName: "publicIPId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const workloadNetworkPublicIP = {
    parameterPath: "workloadNetworkPublicIP",
    mapper: WorkloadNetworkPublicIP
};
const cloudLinkName = {
    parameterPath: "cloudLinkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "cloudLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const cloudLink = {
    parameterPath: "cloudLink",
    mapper: CloudLink
};
const addonName = {
    parameterPath: "addonName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "addonName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const addon = {
    parameterPath: "addon",
    mapper: Addon
};
const restrictMovement = {
    parameterPath: "restrictMovement",
    mapper: VirtualMachineRestrictMovement
};
const placementPolicyName = {
    parameterPath: "placementPolicyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "placementPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const placementPolicy = {
    parameterPath: "placementPolicy",
    mapper: PlacementPolicy
};
const placementPolicyUpdate = {
    parameterPath: "placementPolicyUpdate",
    mapper: PlacementPolicyUpdate
};
const scriptPackageName = {
    parameterPath: "scriptPackageName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._@]+$")
        },
        serializedName: "scriptPackageName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scriptCmdletName = {
    parameterPath: "scriptCmdletName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "scriptCmdletName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scriptExecutionName = {
    parameterPath: "scriptExecutionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._]+$")
        },
        serializedName: "scriptExecutionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const scriptExecution = {
    parameterPath: "scriptExecution",
    mapper: ScriptExecution
};
const scriptOutputStreamType = {
    parameterPath: ["options", "scriptOutputStreamType"],
    mapper: {
        serializedName: "scriptOutputStreamType",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available operations
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available operations
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$e = {
    path: "/providers/Microsoft.AVS/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Locations operations. */
class LocationsImpl {
    /**
     * Initialize a new instance of the class Locations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return trial status for subscription by region
     * @param location Azure region
     * @param options The options parameters.
     */
    checkTrialAvailability(location, options) {
        return this.client.sendOperationRequest({ location, options }, checkTrialAvailabilityOperationSpec);
    }
    /**
     * Return quota for subscription by region
     * @param location Azure region
     * @param options The options parameters.
     */
    checkQuotaAvailability(location, options) {
        return this.client.sendOperationRequest({ location, options }, checkQuotaAvailabilityOperationSpec);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkTrialAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.AVS/locations/{location}/checkTrialAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Trial
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: sku,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const checkQuotaAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.AVS/locations/{location}/checkQuotaAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Quota
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateClouds operations. */
class PrivateCloudsImpl {
    /**
     * Initialize a new instance of the class PrivateClouds class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List private clouds in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List private clouds in a subscription
     * @param options The options parameters.
     */
    listInSubscription(options) {
        const iter = this.listInSubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listInSubscriptionPagingPage(options, settings);
            }
        };
    }
    listInSubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listInSubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listInSubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listInSubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listInSubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listInSubscriptionPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listInSubscriptionPagingPage(options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List private clouds in a resource group
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$d);
    }
    /**
     * List private clouds in a subscription
     * @param options The options parameters.
     */
    _listInSubscription(options) {
        return this.client.sendOperationRequest({ options }, listInSubscriptionOperationSpec);
    }
    /**
     * Get a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, getOperationSpec$d);
    }
    /**
     * Create or update a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param privateCloud The private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, privateCloud, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, privateCloud, options },
                spec: createOrUpdateOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param privateCloud The private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, privateCloud, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, privateCloud, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param privateCloudUpdate The private cloud properties to be updated
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, privateCloudName, privateCloudUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    privateCloudUpdate,
                    options
                },
                spec: updateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param privateCloudUpdate The private cloud properties to be updated
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, privateCloudName, privateCloudUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, privateCloudName, privateCloudUpdate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, options },
                spec: deleteOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Rotate the vCenter password
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginRotateVcenterPassword(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, options },
                spec: rotateVcenterPasswordOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Rotate the vCenter password
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginRotateVcenterPasswordAndWait(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRotateVcenterPassword(resourceGroupName, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Rotate the NSX-T Manager password
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginRotateNsxtPassword(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, options },
                spec: rotateNsxtPasswordOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Rotate the NSX-T Manager password
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginRotateNsxtPasswordAndWait(resourceGroupName, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRotateNsxtPassword(resourceGroupName, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List the admin credentials for the private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listAdminCredentials(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listAdminCredentialsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$d);
    }
    /**
     * ListInSubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListInSubscription method.
     * @param options The options parameters.
     */
    _listInSubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listInSubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listInSubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.AVS/privateClouds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$d
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateCloud
        },
        201: {
            bodyMapper: PrivateCloud
        },
        202: {
            bodyMapper: PrivateCloud
        },
        204: {
            bodyMapper: PrivateCloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateCloud,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PrivateCloud
        },
        201: {
            bodyMapper: PrivateCloud
        },
        202: {
            bodyMapper: PrivateCloud
        },
        204: {
            bodyMapper: PrivateCloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: privateCloudUpdate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const rotateVcenterPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/rotateVcenterPassword",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const rotateNsxtPasswordOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/rotateNsxtPassword",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listAdminCredentialsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/listAdminCredentials",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AdminCredentials
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listInSubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Clusters operations. */
class ClustersImpl {
    /**
     * Initialize a new instance of the class Clusters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List clusters in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List clusters in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$c);
    }
    /**
     * Get a cluster by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, options }, getOperationSpec$c);
    }
    /**
     * Create or update a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param clusterName Name of the cluster in the private cloud
     * @param cluster A cluster in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    cluster,
                    options
                },
                spec: createOrUpdateOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param clusterName Name of the cluster in the private cloud
     * @param cluster A cluster in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, clusterName, cluster, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, cluster, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param clusterUpdate The cluster properties to be updated
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, privateCloudName, clusterName, clusterUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    clusterUpdate,
                    options
                },
                spec: updateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param clusterUpdate The cluster properties to be updated
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, privateCloudName, clusterName, clusterUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, privateCloudName, clusterName, clusterUpdate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, clusterName, options },
                spec: deleteOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a cluster in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, clusterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, clusterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List hosts by zone in a cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    listZones(resourceGroupName, privateCloudName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, options }, listZonesOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: cluster,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        clusterName,
        privateCloudName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cluster
        },
        201: {
            bodyMapper: Cluster
        },
        202: {
            bodyMapper: Cluster
        },
        204: {
            bodyMapper: Cluster
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: clusterUpdate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listZonesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/listZones",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ClusterZoneList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ClusterList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Datastores operations. */
class DatastoresImpl {
    /**
     * Initialize a new instance of the class Datastores class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List datastores in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List datastores in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, options }, listOperationSpec$b);
    }
    /**
     * Get a datastore in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param datastoreName Name of the datastore in the private cloud cluster
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, clusterName, datastoreName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            clusterName,
            datastoreName,
            options
        }, getOperationSpec$b);
    }
    /**
     * Create or update a datastore in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param datastoreName Name of the datastore in the private cloud cluster
     * @param datastore A datastore in a private cloud cluster
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, datastoreName, datastore, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    datastoreName,
                    datastore,
                    options
                },
                spec: createOrUpdateOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a datastore in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param datastoreName Name of the datastore in the private cloud cluster
     * @param datastore A datastore in a private cloud cluster
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, clusterName, datastoreName, datastore, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, datastoreName, datastore, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a datastore in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param datastoreName Name of the datastore in the private cloud cluster
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, clusterName, datastoreName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    datastoreName,
                    options
                },
                spec: deleteOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a datastore in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param datastoreName Name of the datastore in the private cloud cluster
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, clusterName, datastoreName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, clusterName, datastoreName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/datastores",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatastoreList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/datastores/{datastoreName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Datastore
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        datastoreName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/datastores/{datastoreName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Datastore
        },
        201: {
            bodyMapper: Datastore
        },
        202: {
            bodyMapper: Datastore
        },
        204: {
            bodyMapper: Datastore
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: datastore,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        datastoreName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/datastores/{datastoreName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        datastoreName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DatastoreList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing HcxEnterpriseSites operations. */
class HcxEnterpriseSitesImpl {
    /**
     * Initialize a new instance of the class HcxEnterpriseSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List HCX on-premises key in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List HCX on-premises key in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$a);
    }
    /**
     * Get an HCX on-premises key by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param hcxEnterpriseSiteName Name of the HCX Enterprise Site in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, hcxEnterpriseSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, hcxEnterpriseSiteName, options }, getOperationSpec$a);
    }
    /**
     * Create or update an activation key for on-premises HCX site
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param hcxEnterpriseSiteName Name of the HCX Enterprise Site in the private cloud
     * @param hcxEnterpriseSite The HCX Enterprise Site
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, privateCloudName, hcxEnterpriseSiteName, hcxEnterpriseSite, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            hcxEnterpriseSiteName,
            hcxEnterpriseSite,
            options
        }, createOrUpdateOperationSpec$6);
    }
    /**
     * Delete HCX on-premises key in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param hcxEnterpriseSiteName Name of the HCX Enterprise Site in the private cloud
     * @param options The options parameters.
     */
    delete(resourceGroupName, privateCloudName, hcxEnterpriseSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, hcxEnterpriseSiteName, options }, deleteOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/hcxEnterpriseSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HcxEnterpriseSiteList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/hcxEnterpriseSites/{hcxEnterpriseSiteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HcxEnterpriseSite
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        hcxEnterpriseSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/hcxEnterpriseSites/{hcxEnterpriseSiteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HcxEnterpriseSite
        },
        201: {
            bodyMapper: HcxEnterpriseSite
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: hcxEnterpriseSite,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        hcxEnterpriseSiteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/hcxEnterpriseSites/{hcxEnterpriseSiteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        hcxEnterpriseSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HcxEnterpriseSiteList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Authorizations operations. */
class AuthorizationsImpl {
    /**
     * Initialize a new instance of the class Authorizations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List ExpressRoute Circuit Authorizations in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List ExpressRoute Circuit Authorizations in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$9);
    }
    /**
     * Get an ExpressRoute Circuit Authorization by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param authorizationName Name of the ExpressRoute Circuit Authorization in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, authorizationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, authorizationName, options }, getOperationSpec$9);
    }
    /**
     * Create or update an ExpressRoute Circuit Authorization in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param authorizationName Name of the ExpressRoute Circuit Authorization in the private cloud
     * @param authorization An ExpressRoute Circuit Authorization
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, authorizationName, authorization, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    authorizationName,
                    authorization,
                    options
                },
                spec: createOrUpdateOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update an ExpressRoute Circuit Authorization in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param authorizationName Name of the ExpressRoute Circuit Authorization in the private cloud
     * @param authorization An ExpressRoute Circuit Authorization
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, authorizationName, authorization, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, authorizationName, authorization, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an ExpressRoute Circuit Authorization in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param authorizationName Name of the ExpressRoute Circuit Authorization in the private cloud
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, authorizationName, options },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete an ExpressRoute Circuit Authorization in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param authorizationName Name of the ExpressRoute Circuit Authorization in the private cloud
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, authorizationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/authorizations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteAuthorizationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/authorizations/{authorizationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteAuthorization
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/authorizations/{authorizationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteAuthorization
        },
        201: {
            bodyMapper: ExpressRouteAuthorization
        },
        202: {
            bodyMapper: ExpressRouteAuthorization
        },
        204: {
            bodyMapper: ExpressRouteAuthorization
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: authorization,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        authorizationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/authorizations/{authorizationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteAuthorizationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing GlobalReachConnections operations. */
class GlobalReachConnectionsImpl {
    /**
     * Initialize a new instance of the class GlobalReachConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List global reach connections in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List global reach connections in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$8);
    }
    /**
     * Get a global reach connection by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param globalReachConnectionName Name of the global reach connection in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, globalReachConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            globalReachConnectionName,
            options
        }, getOperationSpec$8);
    }
    /**
     * Create or update a global reach connection in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param globalReachConnectionName Name of the global reach connection in the private cloud
     * @param globalReachConnection A global reach connection in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, globalReachConnectionName, globalReachConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    globalReachConnectionName,
                    globalReachConnection,
                    options
                },
                spec: createOrUpdateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a global reach connection in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param globalReachConnectionName Name of the global reach connection in the private cloud
     * @param globalReachConnection A global reach connection in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, globalReachConnectionName, globalReachConnection, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, globalReachConnectionName, globalReachConnection, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a global reach connection in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param globalReachConnectionName Name of the global reach connection in the private cloud
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, globalReachConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    globalReachConnectionName,
                    options
                },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a global reach connection in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param globalReachConnectionName Name of the global reach connection in the private cloud
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, globalReachConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, globalReachConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/globalReachConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GlobalReachConnectionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/globalReachConnections/{globalReachConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GlobalReachConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        globalReachConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/globalReachConnections/{globalReachConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: GlobalReachConnection
        },
        201: {
            bodyMapper: GlobalReachConnection
        },
        202: {
            bodyMapper: GlobalReachConnection
        },
        204: {
            bodyMapper: GlobalReachConnection
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: globalReachConnection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        globalReachConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/globalReachConnections/{globalReachConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        globalReachConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: GlobalReachConnectionList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadNetworks operations. */
class WorkloadNetworksImpl {
    /**
     * Initialize a new instance of the class WorkloadNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of workload networks in a private cloud.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of segments in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listSegments(resourceGroupName, privateCloudName, options) {
        const iter = this.listSegmentsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSegmentsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listSegmentsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listSegmentsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listSegments(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listSegmentsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listSegmentsPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listSegmentsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listSegmentsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List dhcp in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDhcp(resourceGroupName, privateCloudName, options) {
        const iter = this.listDhcpPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDhcpPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDhcpPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDhcpPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDhcp(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDhcpNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDhcpPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDhcpPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDhcpPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List of gateways in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listGateways(resourceGroupName, privateCloudName, options) {
        const iter = this.listGatewaysPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGatewaysPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listGatewaysPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listGatewaysPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listGateways(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listGatewaysNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listGatewaysPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listGatewaysPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listGatewaysPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * List of port mirroring profiles in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listPortMirroring(resourceGroupName, privateCloudName, options) {
        const iter = this.listPortMirroringPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPortMirroringPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPortMirroringPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPortMirroringPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPortMirroring(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPortMirroringNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPortMirroringPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPortMirroringPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPortMirroringPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * List of vm groups in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listVMGroups(resourceGroupName, privateCloudName, options) {
        const iter = this.listVMGroupsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVMGroupsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listVMGroupsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVMGroupsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVMGroups(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVMGroupsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVMGroupsPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVMGroupsPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listVMGroupsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * List of virtual machines in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listVirtualMachines(resourceGroupName, privateCloudName, options) {
        const iter = this.listVirtualMachinesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachinesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachines(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachinesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachinesPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachinesPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * List of DNS services in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDnsServices(resourceGroupName, privateCloudName, options) {
        const iter = this.listDnsServicesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDnsServicesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDnsServicesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDnsServicesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDnsServices(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDnsServicesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDnsServicesPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDnsServicesPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDnsServicesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * List of DNS zones in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDnsZones(resourceGroupName, privateCloudName, options) {
        const iter = this.listDnsZonesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDnsZonesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDnsZonesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDnsZonesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listDnsZones(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDnsZonesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDnsZonesPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDnsZonesPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listDnsZonesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * List of Public IP Blocks in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listPublicIPs(resourceGroupName, privateCloudName, options) {
        const iter = this.listPublicIPsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPublicIPsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPublicIPsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicIPsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPublicIPs(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPublicIPsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPublicIPsPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPublicIPsPagingAll_1() {
            var _a, e_10, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPublicIPsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Get a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param workloadNetworkName Name for the workload network in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, workloadNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, workloadNetworkName, options }, getOperationSpec$7);
    }
    /**
     * List of workload networks in a private cloud.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$7);
    }
    /**
     * List of segments in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listSegments(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listSegmentsOperationSpec);
    }
    /**
     * Get a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    getSegment(resourceGroupName, privateCloudName, segmentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, segmentId, options }, getSegmentOperationSpec);
    }
    /**
     * Create a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginCreateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    segmentId,
                    workloadNetworkSegment,
                    options
                },
                spec: createSegmentsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginCreateSegmentsAndWait(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginUpdateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    segmentId,
                    workloadNetworkSegment,
                    options
                },
                spec: updateSegmentsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginUpdateSegmentsAndWait(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    beginDeleteSegment(resourceGroupName, privateCloudName, segmentId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, segmentId, options },
                spec: deleteSegmentOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    beginDeleteSegmentAndWait(resourceGroupName, privateCloudName, segmentId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSegment(resourceGroupName, privateCloudName, segmentId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List dhcp in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDhcp(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDhcpOperationSpec);
    }
    /**
     * Get dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    getDhcp(resourceGroupName, dhcpId, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dhcpId, privateCloudName, options }, getDhcpOperationSpec);
    }
    /**
     * Create dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginCreateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dhcpId,
                    workloadNetworkDhcp,
                    options
                },
                spec: createDhcpOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginCreateDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginUpdateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dhcpId,
                    workloadNetworkDhcp,
                    options
                },
                spec: updateDhcpOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginUpdateDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param options The options parameters.
     */
    beginDeleteDhcp(resourceGroupName, privateCloudName, dhcpId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, dhcpId, options },
                spec: deleteDhcpOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param options The options parameters.
     */
    beginDeleteDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDhcp(resourceGroupName, privateCloudName, dhcpId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of gateways in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listGateways(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listGatewaysOperationSpec);
    }
    /**
     * Get a gateway by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param gatewayId NSX Gateway identifier. Generally the same as the Gateway's display name
     * @param options The options parameters.
     */
    getGateway(resourceGroupName, privateCloudName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, gatewayId, options }, getGatewayOperationSpec);
    }
    /**
     * List of port mirroring profiles in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listPortMirroring(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listPortMirroringOperationSpec);
    }
    /**
     * Get a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param options The options parameters.
     */
    getPortMirroring(resourceGroupName, privateCloudName, portMirroringId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, portMirroringId, options }, getPortMirroringOperationSpec);
    }
    /**
     * Create a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginCreatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    portMirroringId,
                    workloadNetworkPortMirroring,
                    options
                },
                spec: createPortMirroringOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginCreatePortMirroringAndWait(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginUpdatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    portMirroringId,
                    workloadNetworkPortMirroring,
                    options
                },
                spec: updatePortMirroringOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginUpdatePortMirroringAndWait(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePortMirroring(resourceGroupName, portMirroringId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, portMirroringId, privateCloudName, options },
                spec: deletePortMirroringOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePortMirroringAndWait(resourceGroupName, portMirroringId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePortMirroring(resourceGroupName, portMirroringId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of vm groups in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listVMGroups(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listVMGroupsOperationSpec);
    }
    /**
     * Get a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param options The options parameters.
     */
    getVMGroup(resourceGroupName, privateCloudName, vmGroupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, vmGroupId, options }, getVMGroupOperationSpec);
    }
    /**
     * Create a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginCreateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    vmGroupId,
                    workloadNetworkVMGroup,
                    options
                },
                spec: createVMGroupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginCreateVMGroupAndWait(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginUpdateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    vmGroupId,
                    workloadNetworkVMGroup,
                    options
                },
                spec: updateVMGroupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginUpdateVMGroupAndWait(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteVMGroup(resourceGroupName, vmGroupId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vmGroupId, privateCloudName, options },
                spec: deleteVMGroupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteVMGroupAndWait(resourceGroupName, vmGroupId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteVMGroup(resourceGroupName, vmGroupId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of virtual machines in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listVirtualMachines(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listVirtualMachinesOperationSpec);
    }
    /**
     * Get a virtual machine by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param virtualMachineId Virtual Machine identifier
     * @param options The options parameters.
     */
    getVirtualMachine(resourceGroupName, privateCloudName, virtualMachineId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, virtualMachineId, options }, getVirtualMachineOperationSpec);
    }
    /**
     * List of DNS services in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDnsServices(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDnsServicesOperationSpec);
    }
    /**
     * Get a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param options The options parameters.
     */
    getDnsService(resourceGroupName, privateCloudName, dnsServiceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, dnsServiceId, options }, getDnsServiceOperationSpec);
    }
    /**
     * Create a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginCreateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsServiceId,
                    workloadNetworkDnsService,
                    options
                },
                spec: createDnsServiceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginCreateDnsServiceAndWait(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginUpdateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsServiceId,
                    workloadNetworkDnsService,
                    options
                },
                spec: updateDnsServiceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginUpdateDnsServiceAndWait(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsService(resourceGroupName, dnsServiceId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dnsServiceId, privateCloudName, options },
                spec: deleteDnsServiceOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsServiceAndWait(resourceGroupName, dnsServiceId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDnsService(resourceGroupName, dnsServiceId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of DNS zones in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDnsZones(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDnsZonesOperationSpec);
    }
    /**
     * Get a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param options The options parameters.
     */
    getDnsZone(resourceGroupName, privateCloudName, dnsZoneId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, dnsZoneId, options }, getDnsZoneOperationSpec);
    }
    /**
     * Create a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginCreateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsZoneId,
                    workloadNetworkDnsZone,
                    options
                },
                spec: createDnsZoneOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginCreateDnsZoneAndWait(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginUpdateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsZoneId,
                    workloadNetworkDnsZone,
                    options
                },
                spec: updateDnsZoneOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginUpdateDnsZoneAndWait(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsZone(resourceGroupName, dnsZoneId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dnsZoneId, privateCloudName, options },
                spec: deleteDnsZoneOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsZoneAndWait(resourceGroupName, dnsZoneId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDnsZone(resourceGroupName, dnsZoneId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of Public IP Blocks in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listPublicIPs(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listPublicIPsOperationSpec);
    }
    /**
     * Get a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param options The options parameters.
     */
    getPublicIP(resourceGroupName, privateCloudName, publicIPId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, publicIPId, options }, getPublicIPOperationSpec);
    }
    /**
     * Create a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param workloadNetworkPublicIP NSX Public IP Block
     * @param options The options parameters.
     */
    beginCreatePublicIP(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    publicIPId,
                    workloadNetworkPublicIP,
                    options
                },
                spec: createPublicIPOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param workloadNetworkPublicIP NSX Public IP Block
     * @param options The options parameters.
     */
    beginCreatePublicIPAndWait(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreatePublicIP(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePublicIP(resourceGroupName, publicIPId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIPId, privateCloudName, options },
                spec: deletePublicIPOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePublicIPAndWait(resourceGroupName, publicIPId, privateCloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePublicIP(resourceGroupName, publicIPId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$7);
    }
    /**
     * ListSegmentsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListSegments method.
     * @param options The options parameters.
     */
    _listSegmentsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listSegmentsNextOperationSpec);
    }
    /**
     * ListDhcpNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDhcp method.
     * @param options The options parameters.
     */
    _listDhcpNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDhcpNextOperationSpec);
    }
    /**
     * ListGatewaysNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListGateways method.
     * @param options The options parameters.
     */
    _listGatewaysNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listGatewaysNextOperationSpec);
    }
    /**
     * ListPortMirroringNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListPortMirroring method.
     * @param options The options parameters.
     */
    _listPortMirroringNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listPortMirroringNextOperationSpec);
    }
    /**
     * ListVMGroupsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListVMGroups method.
     * @param options The options parameters.
     */
    _listVMGroupsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listVMGroupsNextOperationSpec);
    }
    /**
     * ListVirtualMachinesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListVirtualMachines method.
     * @param options The options parameters.
     */
    _listVirtualMachinesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listVirtualMachinesNextOperationSpec);
    }
    /**
     * ListDnsServicesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDnsServices method.
     * @param options The options parameters.
     */
    _listDnsServicesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDnsServicesNextOperationSpec);
    }
    /**
     * ListDnsZonesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDnsZones method.
     * @param options The options parameters.
     */
    _listDnsZonesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDnsZonesNextOperationSpec);
    }
    /**
     * ListPublicIPsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListPublicIPs method.
     * @param options The options parameters.
     */
    _listPublicIPsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listPublicIPsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/{workloadNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        workloadNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkSegmentsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getSegmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkSegment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        segmentId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkSegment
        },
        201: {
            bodyMapper: WorkloadNetworkSegment
        },
        202: {
            bodyMapper: WorkloadNetworkSegment
        },
        204: {
            bodyMapper: WorkloadNetworkSegment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkSegment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        segmentId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkSegment
        },
        201: {
            bodyMapper: WorkloadNetworkSegment
        },
        202: {
            bodyMapper: WorkloadNetworkSegment
        },
        204: {
            bodyMapper: WorkloadNetworkSegment
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkSegment,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        segmentId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteSegmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        segmentId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDhcpList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dhcpId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDhcp
        },
        201: {
            bodyMapper: WorkloadNetworkDhcp
        },
        202: {
            bodyMapper: WorkloadNetworkDhcp
        },
        204: {
            bodyMapper: WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDhcp,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dhcpId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDhcp
        },
        201: {
            bodyMapper: WorkloadNetworkDhcp
        },
        202: {
            bodyMapper: WorkloadNetworkDhcp
        },
        204: {
            bodyMapper: WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDhcp,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dhcpId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dhcpId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listGatewaysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkGatewayList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkGateway
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        gatewayId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPortMirroringList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        portMirroringId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        201: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        202: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        204: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkPortMirroring,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        portMirroringId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updatePortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        201: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        202: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        204: {
            bodyMapper: WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkPortMirroring,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        portMirroringId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deletePortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        portMirroringId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listVMGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVMGroupsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        vmGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        201: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        202: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        204: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkVMGroup,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        vmGroupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        201: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        202: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        204: {
            bodyMapper: WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkVMGroup,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        vmGroupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        vmGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listVirtualMachinesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVirtualMachinesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getVirtualMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        virtualMachineId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDnsServicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsServicesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsServiceId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsService
        },
        201: {
            bodyMapper: WorkloadNetworkDnsService
        },
        202: {
            bodyMapper: WorkloadNetworkDnsService
        },
        204: {
            bodyMapper: WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDnsService,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsServiceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsService
        },
        201: {
            bodyMapper: WorkloadNetworkDnsService
        },
        202: {
            bodyMapper: WorkloadNetworkDnsService
        },
        204: {
            bodyMapper: WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDnsService,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsServiceId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsServiceId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDnsZonesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsZonesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsZoneId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        201: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        202: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        204: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDnsZone,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsZoneId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const updateDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        201: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        202: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        204: {
            bodyMapper: WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkDnsZone,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsZoneId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        dnsZoneId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listPublicIPsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPublicIPsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const getPublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPublicIP
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        publicIPId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createPublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPublicIP
        },
        201: {
            bodyMapper: WorkloadNetworkPublicIP
        },
        202: {
            bodyMapper: WorkloadNetworkPublicIP
        },
        204: {
            bodyMapper: WorkloadNetworkPublicIP
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: workloadNetworkPublicIP,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        publicIPId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deletePublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        publicIPId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listSegmentsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkSegmentsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDhcpNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDhcpList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listGatewaysNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkGatewayList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listPortMirroringNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPortMirroringList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listVMGroupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVMGroupsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listVirtualMachinesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkVirtualMachinesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDnsServicesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsServicesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listDnsZonesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkDnsZonesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listPublicIPsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WorkloadNetworkPublicIPsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CloudLinks operations. */
class CloudLinksImpl {
    /**
     * Initialize a new instance of the class CloudLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$6);
    }
    /**
     * Get an cloud link by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param cloudLinkName Name of the cloud link resource
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, cloudLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, cloudLinkName, options }, getOperationSpec$6);
    }
    /**
     * Create or update a cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param cloudLinkName Name of the cloud link resource
     * @param cloudLink A cloud link in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, cloudLinkName, cloudLink, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    cloudLinkName,
                    cloudLink,
                    options
                },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param cloudLinkName Name of the cloud link resource
     * @param cloudLink A cloud link in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, cloudLinkName, cloudLink, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, cloudLinkName, cloudLink, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param cloudLinkName Name of the cloud link resource
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, cloudLinkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, cloudLinkName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a cloud link in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param cloudLinkName Name of the cloud link resource
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, cloudLinkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, cloudLinkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/cloudLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudLinkList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/cloudLinks/{cloudLinkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudLink
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        cloudLinkName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/cloudLinks/{cloudLinkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CloudLink
        },
        201: {
            bodyMapper: CloudLink
        },
        202: {
            bodyMapper: CloudLink
        },
        204: {
            bodyMapper: CloudLink
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: cloudLink,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        cloudLinkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/cloudLinks/{cloudLinkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        cloudLinkName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudLinkList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Addons operations. */
class AddonsImpl {
    /**
     * Initialize a new instance of the class Addons class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List addons in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List addons in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$5);
    }
    /**
     * Get an addon by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param addonName Name of the addon for the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, addonName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, addonName, options }, getOperationSpec$5);
    }
    /**
     * Create or update a addon in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param addonName Name of the addon for the private cloud
     * @param addon A addon in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, addonName, addon, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, addonName, addon, options },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a addon in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param addonName Name of the addon for the private cloud
     * @param addon A addon in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, addonName, addon, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, addonName, addon, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a addon in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param addonName Name of the addon for the private cloud
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, addonName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, addonName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a addon in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param addonName Name of the addon for the private cloud
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, addonName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, addonName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/addons",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddonList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/addons/{addonName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Addon
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        addonName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/addons/{addonName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Addon
        },
        201: {
            bodyMapper: Addon
        },
        202: {
            bodyMapper: Addon
        },
        204: {
            bodyMapper: Addon
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: addon,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        addonName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/addons/{addonName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        addonName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AddonList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of virtual machines in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of virtual machines in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, options }, listOperationSpec$4);
    }
    /**
     * Get a virtual machine by id in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param virtualMachineId Virtual Machine identifier
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, clusterName, virtualMachineId, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            clusterName,
            virtualMachineId,
            options
        }, getOperationSpec$4);
    }
    /**
     * Enable or disable DRS-driven VM movement restriction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param virtualMachineId Virtual Machine identifier
     * @param restrictMovement Whether VM DRS-driven movement is restricted (Enabled) or not (Disabled)
     * @param options The options parameters.
     */
    beginRestrictMovement(resourceGroupName, privateCloudName, clusterName, virtualMachineId, restrictMovement, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    virtualMachineId,
                    restrictMovement,
                    options
                },
                spec: restrictMovementOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Enable or disable DRS-driven VM movement restriction
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param virtualMachineId Virtual Machine identifier
     * @param restrictMovement Whether VM DRS-driven movement is restricted (Enabled) or not (Disabled)
     * @param options The options parameters.
     */
    beginRestrictMovementAndWait(resourceGroupName, privateCloudName, clusterName, virtualMachineId, restrictMovement, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestrictMovement(resourceGroupName, privateCloudName, clusterName, virtualMachineId, restrictMovement, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachinesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/virtualMachines/{virtualMachineId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        virtualMachineId
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const restrictMovementOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/virtualMachines/{virtualMachineId}/restrictMovement",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: restrictMovement,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        virtualMachineId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachinesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PlacementPolicies operations. */
class PlacementPoliciesImpl {
    /**
     * Initialize a new instance of the class PlacementPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List placement policies in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, clusterName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, clusterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, clusterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, clusterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, clusterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, clusterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, clusterName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List placement policies in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, clusterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, options }, listOperationSpec$3);
    }
    /**
     * Get a placement policy by name in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, clusterName, placementPolicyName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            clusterName,
            placementPolicyName,
            options
        }, getOperationSpec$3);
    }
    /**
     * Create or update a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param placementPolicy A placement policy in the private cloud cluster
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    placementPolicyName,
                    placementPolicy,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param placementPolicy A placement policy in the private cloud cluster
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicy, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicy, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param placementPolicyUpdate The placement policy properties that may be updated
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicyUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    placementPolicyName,
                    placementPolicyUpdate,
                    options
                },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param placementPolicyUpdate The placement policy properties that may be updated
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicyUpdate, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, privateCloudName, clusterName, placementPolicyName, placementPolicyUpdate, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, clusterName, placementPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    clusterName,
                    placementPolicyName,
                    options
                },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a placement policy in a private cloud cluster
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param placementPolicyName Name of the VMware vSphere Distributed Resource Scheduler (DRS) placement
     *                            policy
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, clusterName, placementPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, clusterName, placementPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param clusterName Name of the cluster in the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, clusterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, clusterName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/placementPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PlacementPoliciesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/placementPolicies/{placementPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PlacementPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        placementPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/placementPolicies/{placementPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PlacementPolicy
        },
        201: {
            bodyMapper: PlacementPolicy
        },
        202: {
            bodyMapper: PlacementPolicy
        },
        204: {
            bodyMapper: PlacementPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: placementPolicy,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        placementPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/placementPolicies/{placementPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PlacementPolicy
        },
        201: {
            bodyMapper: PlacementPolicy
        },
        202: {
            bodyMapper: PlacementPolicy
        },
        204: {
            bodyMapper: PlacementPolicy
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: placementPolicyUpdate,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        placementPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/clusters/{clusterName}/placementPolicies/{placementPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName,
        placementPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PlacementPoliciesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        clusterName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScriptPackages operations. */
class ScriptPackagesImpl {
    /**
     * Initialize a new instance of the class ScriptPackages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List script packages available to run on the private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List script packages available to run on the private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec$2);
    }
    /**
     * Get a script package available to run on a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptPackageName Name of the script package in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, scriptPackageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, scriptPackageName, options }, getOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptPackages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptPackagesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptPackages/{scriptPackageName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptPackage
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptPackagesList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScriptCmdlets operations. */
class ScriptCmdletsImpl {
    /**
     * Initialize a new instance of the class ScriptCmdlets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List script cmdlet resources available for a private cloud to create a script execution resource on
     * a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptPackageName Name of the script package in the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, scriptPackageName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, scriptPackageName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, scriptPackageName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, scriptPackageName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, scriptPackageName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, scriptPackageName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, scriptPackageName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, scriptPackageName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List script cmdlet resources available for a private cloud to create a script execution resource on
     * a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptPackageName Name of the script package in the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, scriptPackageName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, scriptPackageName, options }, listOperationSpec$1);
    }
    /**
     * Return information about a script cmdlet resource in a specific package on a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptPackageName Name of the script package in the private cloud
     * @param scriptCmdletName Name of the script cmdlet resource in the script package in the private
     *                         cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, scriptPackageName, scriptCmdletName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            scriptPackageName,
            scriptCmdletName,
            options
        }, getOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptPackageName Name of the script package in the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, scriptPackageName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateCloudName,
            scriptPackageName,
            nextLink,
            options
        }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptPackages/{scriptPackageName}/scriptCmdlets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptCmdletsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptPackages/{scriptPackageName}/scriptCmdlets/{scriptCmdletName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptCmdlet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptPackageName,
        scriptCmdletName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptCmdletsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptPackageName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScriptExecutions operations. */
class ScriptExecutionsImpl {
    /**
     * Initialize a new instance of the class ScriptExecutions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List script executions in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List script executions in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec);
    }
    /**
     * Get an script execution by name in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, scriptExecutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, scriptExecutionName, options }, getOperationSpec);
    }
    /**
     * Create or update a script execution in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param scriptExecution A script running in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateCloudName, scriptExecutionName, scriptExecution, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    scriptExecutionName,
                    scriptExecution,
                    options
                },
                spec: createOrUpdateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a script execution in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName The name of the private cloud.
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param scriptExecution A script running in the private cloud
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateCloudName, scriptExecutionName, scriptExecution, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateCloudName, scriptExecutionName, scriptExecution, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Cancel a ScriptExecution in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateCloudName, scriptExecutionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    scriptExecutionName,
                    options
                },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Cancel a ScriptExecution in a private cloud
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateCloudName, scriptExecutionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateCloudName, scriptExecutionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Return the logs for a script execution resource
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param scriptExecutionName Name of the user-invoked script execution resource
     * @param options The options parameters.
     */
    getExecutionLogs(resourceGroupName, privateCloudName, scriptExecutionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, scriptExecutionName, options }, getExecutionLogsOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptExecutions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptExecutionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptExecutions/{scriptExecutionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptExecution
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptExecutionName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptExecutions/{scriptExecutionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ScriptExecution
        },
        201: {
            bodyMapper: ScriptExecution
        },
        202: {
            bodyMapper: ScriptExecution
        },
        204: {
            bodyMapper: ScriptExecution
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: scriptExecution,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName1,
        scriptExecutionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptExecutions/{scriptExecutionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptExecutionName
    ],
    headerParameters: [accept],
    serializer
};
const getExecutionLogsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/scriptExecutions/{scriptExecutionName}/getExecutionLogs",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ScriptExecution
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: scriptOutputStreamType,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        privateCloudName,
        scriptExecutionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScriptExecutionsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        nextLink,
        subscriptionId,
        resourceGroupName,
        privateCloudName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class AzureVMwareSolutionAPI extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the AzureVMwareSolutionAPI class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The ID of the target subscription.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-avs/4.0.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2023-03-01";
        this.operations = new OperationsImpl(this);
        this.locations = new LocationsImpl(this);
        this.privateClouds = new PrivateCloudsImpl(this);
        this.clusters = new ClustersImpl(this);
        this.datastores = new DatastoresImpl(this);
        this.hcxEnterpriseSites = new HcxEnterpriseSitesImpl(this);
        this.authorizations = new AuthorizationsImpl(this);
        this.globalReachConnections = new GlobalReachConnectionsImpl(this);
        this.workloadNetworks = new WorkloadNetworksImpl(this);
        this.cloudLinks = new CloudLinksImpl(this);
        this.addons = new AddonsImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.placementPolicies = new PlacementPoliciesImpl(this);
        this.scriptPackages = new ScriptPackagesImpl(this);
        this.scriptCmdlets = new ScriptCmdletsImpl(this);
        this.scriptExecutions = new ScriptExecutionsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.AzureVMwareSolutionAPI = AzureVMwareSolutionAPI;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
