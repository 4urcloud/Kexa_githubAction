/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
import { setContinuationToken } from "../pagingHelper";
import * as coreClient from "@azure/core-client";
import * as Mappers from "../models/mappers";
import * as Parameters from "../models/parameters";
import { createHttpPoller } from "@azure/core-lro";
import { createLroSpec } from "../lroImpl";
/// <reference lib="esnext.asynciterable" />
/** Class containing WorkloadNetworks operations. */
export class WorkloadNetworksImpl {
    /**
     * Initialize a new instance of the class WorkloadNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of workload networks in a private cloud.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    list(resourceGroupName, privateCloudName, options) {
        const iter = this.listPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._list(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listPagingAll_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of segments in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listSegments(resourceGroupName, privateCloudName, options) {
        const iter = this.listSegmentsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listSegmentsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listSegmentsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listSegmentsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listSegments(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listSegmentsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listSegmentsPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listSegmentsPagingAll_1() {
            var _a, e_2, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listSegmentsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * List dhcp in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDhcp(resourceGroupName, privateCloudName, options) {
        const iter = this.listDhcpPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDhcpPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDhcpPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listDhcpPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listDhcp(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listDhcpNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listDhcpPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listDhcpPagingAll_1() {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listDhcpPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * List of gateways in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listGateways(resourceGroupName, privateCloudName, options) {
        const iter = this.listGatewaysPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listGatewaysPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listGatewaysPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listGatewaysPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listGateways(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listGatewaysNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listGatewaysPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listGatewaysPagingAll_1() {
            var _a, e_4, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listGatewaysPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * List of port mirroring profiles in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listPortMirroring(resourceGroupName, privateCloudName, options) {
        const iter = this.listPortMirroringPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPortMirroringPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPortMirroringPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listPortMirroringPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listPortMirroring(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listPortMirroringNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listPortMirroringPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listPortMirroringPagingAll_1() {
            var _a, e_5, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listPortMirroringPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * List of vm groups in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listVMGroups(resourceGroupName, privateCloudName, options) {
        const iter = this.listVMGroupsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVMGroupsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listVMGroupsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listVMGroupsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listVMGroups(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listVMGroupsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listVMGroupsPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listVMGroupsPagingAll_1() {
            var _a, e_6, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listVMGroupsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * List of virtual machines in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listVirtualMachines(resourceGroupName, privateCloudName, options) {
        const iter = this.listVirtualMachinesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listVirtualMachinesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listVirtualMachines(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listVirtualMachinesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listVirtualMachinesPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listVirtualMachinesPagingAll_1() {
            var _a, e_7, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listVirtualMachinesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * List of DNS services in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDnsServices(resourceGroupName, privateCloudName, options) {
        const iter = this.listDnsServicesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDnsServicesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDnsServicesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listDnsServicesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listDnsServices(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listDnsServicesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listDnsServicesPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listDnsServicesPagingAll_1() {
            var _a, e_8, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listDnsServicesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_8) throw e_8.error; }
            }
        });
    }
    /**
     * List of DNS zones in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listDnsZones(resourceGroupName, privateCloudName, options) {
        const iter = this.listDnsZonesPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDnsZonesPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listDnsZonesPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listDnsZonesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listDnsZones(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listDnsZonesNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listDnsZonesPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listDnsZonesPagingAll_1() {
            var _a, e_9, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listDnsZonesPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_9) throw e_9.error; }
            }
        });
    }
    /**
     * List of Public IP Blocks in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    listPublicIPs(resourceGroupName, privateCloudName, options) {
        const iter = this.listPublicIPsPagingAll(resourceGroupName, privateCloudName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPublicIPsPagingPage(resourceGroupName, privateCloudName, options, settings);
            }
        };
    }
    listPublicIPsPagingPage(resourceGroupName, privateCloudName, options, settings) {
        return __asyncGenerator(this, arguments, function* listPublicIPsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield __await(this._listPublicIPs(resourceGroupName, privateCloudName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
            while (continuationToken) {
                result = yield __await(this._listPublicIPsNext(resourceGroupName, privateCloudName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield __await(page);
            }
        });
    }
    listPublicIPsPagingAll(resourceGroupName, privateCloudName, options) {
        return __asyncGenerator(this, arguments, function* listPublicIPsPagingAll_1() {
            var _a, e_10, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(this.listPublicIPsPagingPage(resourceGroupName, privateCloudName, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_10) throw e_10.error; }
            }
        });
    }
    /**
     * Get a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param workloadNetworkName Name for the workload network in the private cloud
     * @param options The options parameters.
     */
    get(resourceGroupName, privateCloudName, workloadNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, workloadNetworkName, options }, getOperationSpec);
    }
    /**
     * List of workload networks in a private cloud.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _list(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listOperationSpec);
    }
    /**
     * List of segments in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listSegments(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listSegmentsOperationSpec);
    }
    /**
     * Get a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    getSegment(resourceGroupName, privateCloudName, segmentId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, segmentId, options }, getSegmentOperationSpec);
    }
    /**
     * Create a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginCreateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    segmentId,
                    workloadNetworkSegment,
                    options
                },
                spec: createSegmentsOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginCreateSegmentsAndWait(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginUpdateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    segmentId,
                    workloadNetworkSegment,
                    options
                },
                spec: updateSegmentsOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param workloadNetworkSegment NSX Segment
     * @param options The options parameters.
     */
    beginUpdateSegmentsAndWait(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateSegments(resourceGroupName, privateCloudName, segmentId, workloadNetworkSegment, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    beginDeleteSegment(resourceGroupName, privateCloudName, segmentId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, segmentId, options },
                spec: deleteSegmentOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a segment by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param segmentId NSX Segment identifier. Generally the same as the Segment's display name
     * @param options The options parameters.
     */
    beginDeleteSegmentAndWait(resourceGroupName, privateCloudName, segmentId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteSegment(resourceGroupName, privateCloudName, segmentId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List dhcp in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDhcp(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDhcpOperationSpec);
    }
    /**
     * Get dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    getDhcp(resourceGroupName, dhcpId, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dhcpId, privateCloudName, options }, getDhcpOperationSpec);
    }
    /**
     * Create dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginCreateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dhcpId,
                    workloadNetworkDhcp,
                    options
                },
                spec: createDhcpOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginCreateDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginUpdateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dhcpId,
                    workloadNetworkDhcp,
                    options
                },
                spec: updateDhcpOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param workloadNetworkDhcp NSX DHCP
     * @param options The options parameters.
     */
    beginUpdateDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDhcp(resourceGroupName, privateCloudName, dhcpId, workloadNetworkDhcp, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param options The options parameters.
     */
    beginDeleteDhcp(resourceGroupName, privateCloudName, dhcpId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateCloudName, dhcpId, options },
                spec: deleteDhcpOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete dhcp by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dhcpId NSX DHCP identifier. Generally the same as the DHCP display name
     * @param options The options parameters.
     */
    beginDeleteDhcpAndWait(resourceGroupName, privateCloudName, dhcpId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDhcp(resourceGroupName, privateCloudName, dhcpId, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of gateways in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listGateways(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listGatewaysOperationSpec);
    }
    /**
     * Get a gateway by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param gatewayId NSX Gateway identifier. Generally the same as the Gateway's display name
     * @param options The options parameters.
     */
    getGateway(resourceGroupName, privateCloudName, gatewayId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, gatewayId, options }, getGatewayOperationSpec);
    }
    /**
     * List of port mirroring profiles in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listPortMirroring(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listPortMirroringOperationSpec);
    }
    /**
     * Get a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param options The options parameters.
     */
    getPortMirroring(resourceGroupName, privateCloudName, portMirroringId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, portMirroringId, options }, getPortMirroringOperationSpec);
    }
    /**
     * Create a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginCreatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    portMirroringId,
                    workloadNetworkPortMirroring,
                    options
                },
                spec: createPortMirroringOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginCreatePortMirroringAndWait(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginUpdatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    portMirroringId,
                    workloadNetworkPortMirroring,
                    options
                },
                spec: updatePortMirroringOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param workloadNetworkPortMirroring NSX port mirroring
     * @param options The options parameters.
     */
    beginUpdatePortMirroringAndWait(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdatePortMirroring(resourceGroupName, privateCloudName, portMirroringId, workloadNetworkPortMirroring, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePortMirroring(resourceGroupName, portMirroringId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, portMirroringId, privateCloudName, options },
                spec: deletePortMirroringOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a port mirroring profile by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param portMirroringId NSX Port Mirroring identifier. Generally the same as the Port Mirroring
     *                        display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePortMirroringAndWait(resourceGroupName, portMirroringId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePortMirroring(resourceGroupName, portMirroringId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of vm groups in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listVMGroups(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listVMGroupsOperationSpec);
    }
    /**
     * Get a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param options The options parameters.
     */
    getVMGroup(resourceGroupName, privateCloudName, vmGroupId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, vmGroupId, options }, getVMGroupOperationSpec);
    }
    /**
     * Create a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginCreateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    vmGroupId,
                    workloadNetworkVMGroup,
                    options
                },
                spec: createVMGroupOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginCreateVMGroupAndWait(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginUpdateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    vmGroupId,
                    workloadNetworkVMGroup,
                    options
                },
                spec: updateVMGroupOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param workloadNetworkVMGroup NSX VM Group
     * @param options The options parameters.
     */
    beginUpdateVMGroupAndWait(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateVMGroup(resourceGroupName, privateCloudName, vmGroupId, workloadNetworkVMGroup, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteVMGroup(resourceGroupName, vmGroupId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vmGroupId, privateCloudName, options },
                spec: deleteVMGroupOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a vm group by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param vmGroupId NSX VM Group identifier. Generally the same as the VM Group's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteVMGroupAndWait(resourceGroupName, vmGroupId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteVMGroup(resourceGroupName, vmGroupId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of virtual machines in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listVirtualMachines(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listVirtualMachinesOperationSpec);
    }
    /**
     * Get a virtual machine by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param virtualMachineId Virtual Machine identifier
     * @param options The options parameters.
     */
    getVirtualMachine(resourceGroupName, privateCloudName, virtualMachineId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, virtualMachineId, options }, getVirtualMachineOperationSpec);
    }
    /**
     * List of DNS services in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDnsServices(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDnsServicesOperationSpec);
    }
    /**
     * Get a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param options The options parameters.
     */
    getDnsService(resourceGroupName, privateCloudName, dnsServiceId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, dnsServiceId, options }, getDnsServiceOperationSpec);
    }
    /**
     * Create a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginCreateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsServiceId,
                    workloadNetworkDnsService,
                    options
                },
                spec: createDnsServiceOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginCreateDnsServiceAndWait(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginUpdateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsServiceId,
                    workloadNetworkDnsService,
                    options
                },
                spec: updateDnsServiceOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param workloadNetworkDnsService NSX DNS Service
     * @param options The options parameters.
     */
    beginUpdateDnsServiceAndWait(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDnsService(resourceGroupName, privateCloudName, dnsServiceId, workloadNetworkDnsService, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsService(resourceGroupName, dnsServiceId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dnsServiceId, privateCloudName, options },
                spec: deleteDnsServiceOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a DNS service by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsServiceId NSX DNS Service identifier. Generally the same as the DNS Service's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsServiceAndWait(resourceGroupName, dnsServiceId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDnsService(resourceGroupName, dnsServiceId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of DNS zones in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listDnsZones(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listDnsZonesOperationSpec);
    }
    /**
     * Get a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param options The options parameters.
     */
    getDnsZone(resourceGroupName, privateCloudName, dnsZoneId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, dnsZoneId, options }, getDnsZoneOperationSpec);
    }
    /**
     * Create a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginCreateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsZoneId,
                    workloadNetworkDnsZone,
                    options
                },
                spec: createDnsZoneOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginCreateDnsZoneAndWait(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Create or update a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginUpdateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    dnsZoneId,
                    workloadNetworkDnsZone,
                    options
                },
                spec: updateDnsZoneOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param workloadNetworkDnsZone NSX DNS Zone
     * @param options The options parameters.
     */
    beginUpdateDnsZoneAndWait(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateDnsZone(resourceGroupName, privateCloudName, dnsZoneId, workloadNetworkDnsZone, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsZone(resourceGroupName, dnsZoneId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dnsZoneId, privateCloudName, options },
                spec: deleteDnsZoneOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a DNS zone by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param dnsZoneId NSX DNS Zone identifier. Generally the same as the DNS Zone's display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeleteDnsZoneAndWait(resourceGroupName, dnsZoneId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteDnsZone(resourceGroupName, dnsZoneId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of Public IP Blocks in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    _listPublicIPs(resourceGroupName, privateCloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, options }, listPublicIPsOperationSpec);
    }
    /**
     * Get a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param options The options parameters.
     */
    getPublicIP(resourceGroupName, privateCloudName, publicIPId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, publicIPId, options }, getPublicIPOperationSpec);
    }
    /**
     * Create a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param workloadNetworkPublicIP NSX Public IP Block
     * @param options The options parameters.
     */
    beginCreatePublicIP(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateCloudName,
                    publicIPId,
                    workloadNetworkPublicIP,
                    options
                },
                spec: createPublicIPOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param workloadNetworkPublicIP NSX Public IP Block
     * @param options The options parameters.
     */
    beginCreatePublicIPAndWait(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreatePublicIP(resourceGroupName, privateCloudName, publicIPId, workloadNetworkPublicIP, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePublicIP(resourceGroupName, publicIPId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIPId, privateCloudName, options },
                spec: deletePublicIPOperationSpec
            });
            const poller = yield createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete a Public IP Block by id in a private cloud workload network.
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param publicIPId NSX Public IP Block identifier. Generally the same as the Public IP Block's
     *                   display name
     * @param privateCloudName Name of the private cloud
     * @param options The options parameters.
     */
    beginDeletePublicIPAndWait(resourceGroupName, publicIPId, privateCloudName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePublicIP(resourceGroupName, publicIPId, privateCloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListSegmentsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListSegments method.
     * @param options The options parameters.
     */
    _listSegmentsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listSegmentsNextOperationSpec);
    }
    /**
     * ListDhcpNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDhcp method.
     * @param options The options parameters.
     */
    _listDhcpNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDhcpNextOperationSpec);
    }
    /**
     * ListGatewaysNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListGateways method.
     * @param options The options parameters.
     */
    _listGatewaysNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listGatewaysNextOperationSpec);
    }
    /**
     * ListPortMirroringNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListPortMirroring method.
     * @param options The options parameters.
     */
    _listPortMirroringNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listPortMirroringNextOperationSpec);
    }
    /**
     * ListVMGroupsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListVMGroups method.
     * @param options The options parameters.
     */
    _listVMGroupsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listVMGroupsNextOperationSpec);
    }
    /**
     * ListVirtualMachinesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListVirtualMachines method.
     * @param options The options parameters.
     */
    _listVirtualMachinesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listVirtualMachinesNextOperationSpec);
    }
    /**
     * ListDnsServicesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDnsServices method.
     * @param options The options parameters.
     */
    _listDnsServicesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDnsServicesNextOperationSpec);
    }
    /**
     * ListDnsZonesNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListDnsZones method.
     * @param options The options parameters.
     */
    _listDnsZonesNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listDnsZonesNextOperationSpec);
    }
    /**
     * ListPublicIPsNext
     * @param resourceGroupName The name of the resource group. The name is case insensitive.
     * @param privateCloudName Name of the private cloud
     * @param nextLink The nextLink from the previous successful call to the ListPublicIPs method.
     * @param options The options parameters.
     */
    _listPublicIPsNext(resourceGroupName, privateCloudName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateCloudName, nextLink, options }, listPublicIPsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/{workloadNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetwork
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.workloadNetworkName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkSegmentsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getSegmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.segmentId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkSegment,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.segmentId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updateSegmentsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkSegment
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkSegment,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.segmentId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteSegmentOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/segments/{segmentId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.segmentId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDhcpList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dhcpId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDhcp,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dhcpId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updateDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDhcp
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDhcp,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dhcpId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteDhcpOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dhcpConfigurations/{dhcpId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dhcpId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listGatewaysOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkGatewayList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/gateways/{gatewayId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkGateway
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.gatewayId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroringList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.portMirroringId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createPortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkPortMirroring,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.portMirroringId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updatePortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroring
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkPortMirroring,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.portMirroringId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deletePortMirroringOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/portMirroringProfiles/{portMirroringId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.portMirroringId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listVMGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVMGroupsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.vmGroupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkVMGroup,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.vmGroupId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updateVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkVMGroup
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkVMGroup,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.vmGroupId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteVMGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/vmGroups/{vmGroupId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.vmGroupId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listVirtualMachinesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getVirtualMachineOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/virtualMachines/{virtualMachineId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVirtualMachine
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.virtualMachineId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDnsServicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsServicesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsServiceId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDnsService,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsServiceId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updateDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDnsService
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDnsService,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsServiceId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteDnsServiceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsServices/{dnsServiceId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsServiceId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDnsZonesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsZonesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsZoneId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDnsZone,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsZoneId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const updateDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkDnsZone
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkDnsZone,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsZoneId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deleteDnsZoneOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/dnsZones/{dnsZoneId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.dnsZoneId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listPublicIPsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPublicIPsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const getPublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPublicIP
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.publicIPId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const createPublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPublicIP
        },
        201: {
            bodyMapper: Mappers.WorkloadNetworkPublicIP
        },
        202: {
            bodyMapper: Mappers.WorkloadNetworkPublicIP
        },
        204: {
            bodyMapper: Mappers.WorkloadNetworkPublicIP
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    requestBody: Parameters.workloadNetworkPublicIP,
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.publicIPId
    ],
    headerParameters: [Parameters.accept, Parameters.contentType],
    mediaType: "json",
    serializer
};
const deletePublicIPOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.AVS/privateClouds/{privateCloudName}/workloadNetworks/default/publicIPs/{publicIPId}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    queryParameters: [Parameters.apiVersion],
    urlParameters: [
        Parameters.$host,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName,
        Parameters.publicIPId
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listSegmentsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkSegmentsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDhcpNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDhcpList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listGatewaysNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkGatewayList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listPortMirroringNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPortMirroringList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listVMGroupsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVMGroupsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listVirtualMachinesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkVirtualMachinesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDnsServicesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsServicesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listDnsZonesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkDnsZonesList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
const listPublicIPsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Mappers.WorkloadNetworkPublicIPsList
        },
        default: {
            bodyMapper: Mappers.ErrorResponse
        }
    },
    urlParameters: [
        Parameters.$host,
        Parameters.nextLink,
        Parameters.subscriptionId,
        Parameters.resourceGroupName,
        Parameters.privateCloudName
    ],
    headerParameters: [Parameters.accept],
    serializer
};
//# sourceMappingURL=workloadNetworks.js.map