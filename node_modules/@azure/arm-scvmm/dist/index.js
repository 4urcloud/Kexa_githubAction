'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link OsType} that the service accepts. */
exports.KnownOsType = void 0;
(function (KnownOsType) {
    /** Windows */
    KnownOsType["Windows"] = "Windows";
    /** Linux */
    KnownOsType["Linux"] = "Linux";
    /** Other */
    KnownOsType["Other"] = "Other";
})(exports.KnownOsType || (exports.KnownOsType = {}));
/** Known values of {@link LimitCpuForMigration} that the service accepts. */
exports.KnownLimitCpuForMigration = void 0;
(function (KnownLimitCpuForMigration) {
    /** False */
    KnownLimitCpuForMigration["False"] = "false";
    /** True */
    KnownLimitCpuForMigration["True"] = "true";
})(exports.KnownLimitCpuForMigration || (exports.KnownLimitCpuForMigration = {}));
/** Known values of {@link DynamicMemoryEnabled} that the service accepts. */
exports.KnownDynamicMemoryEnabled = void 0;
(function (KnownDynamicMemoryEnabled) {
    /** False */
    KnownDynamicMemoryEnabled["False"] = "false";
    /** True */
    KnownDynamicMemoryEnabled["True"] = "true";
})(exports.KnownDynamicMemoryEnabled || (exports.KnownDynamicMemoryEnabled = {}));
/** Known values of {@link AllocationMethod} that the service accepts. */
exports.KnownAllocationMethod = void 0;
(function (KnownAllocationMethod) {
    /** Dynamic */
    KnownAllocationMethod["Dynamic"] = "Dynamic";
    /** Static */
    KnownAllocationMethod["Static"] = "Static";
})(exports.KnownAllocationMethod || (exports.KnownAllocationMethod = {}));
/** Known values of {@link CreateDiffDisk} that the service accepts. */
exports.KnownCreateDiffDisk = void 0;
(function (KnownCreateDiffDisk) {
    /** False */
    KnownCreateDiffDisk["False"] = "false";
    /** True */
    KnownCreateDiffDisk["True"] = "true";
})(exports.KnownCreateDiffDisk || (exports.KnownCreateDiffDisk = {}));
/** Known values of {@link IsCustomizable} that the service accepts. */
exports.KnownIsCustomizable = void 0;
(function (KnownIsCustomizable) {
    /** False */
    KnownIsCustomizable["False"] = "false";
    /** True */
    KnownIsCustomizable["True"] = "true";
})(exports.KnownIsCustomizable || (exports.KnownIsCustomizable = {}));
/** Known values of {@link InventoryType} that the service accepts. */
exports.KnownInventoryType = void 0;
(function (KnownInventoryType) {
    /** Cloud */
    KnownInventoryType["Cloud"] = "Cloud";
    /** VirtualNetwork */
    KnownInventoryType["VirtualNetwork"] = "VirtualNetwork";
    /** VirtualMachineTemplate */
    KnownInventoryType["VirtualMachineTemplate"] = "VirtualMachineTemplate";
    /** VirtualMachine */
    KnownInventoryType["VirtualMachine"] = "VirtualMachine";
})(exports.KnownInventoryType || (exports.KnownInventoryType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const VMMServer = {
    type: {
        name: "Composite",
        className: "VMMServer",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            credentials: {
                serializedName: "properties.credentials",
                type: {
                    name: "Composite",
                    className: "VMMServerPropertiesCredentials"
                }
            },
            fqdn: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.fqdn",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            },
            connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "properties.errorMessage",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uuid: {
                serializedName: "properties.uuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "properties.version",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VMMServerPropertiesCredentials = {
    type: {
        name: "Composite",
        className: "VMMServerPropertiesCredentials",
        modelProperties: {
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDefinition"
                }
            }
        }
    }
};
const ErrorDefinition = {
    type: {
        name: "Composite",
        className: "ErrorDefinition",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDefinition"
                        }
                    }
                }
            }
        }
    }
};
const ResourcePatch = {
    type: {
        name: "Composite",
        className: "ResourcePatch",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VMMServerListResult = {
    type: {
        name: "Composite",
        className: "VMMServerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VMMServer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceProviderOperationList = {
    type: {
        name: "Composite",
        className: "ResourceProviderOperationList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceProviderOperation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceProviderOperation = {
    type: {
        name: "Composite",
        className: "ResourceProviderOperation",
        modelProperties: {
            isDataAction: {
                serializedName: "isDataAction",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "ResourceProviderOperationDisplay"
                }
            }
        }
    }
};
const ResourceProviderOperationDisplay = {
    type: {
        name: "Composite",
        className: "ResourceProviderOperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Cloud = {
    type: {
        name: "Composite",
        className: "Cloud",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            inventoryItemId: {
                serializedName: "properties.inventoryItemId",
                type: {
                    name: "String"
                }
            },
            uuid: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.uuid",
                type: {
                    name: "String"
                }
            },
            vmmServerId: {
                serializedName: "properties.vmmServerId",
                type: {
                    name: "String"
                }
            },
            cloudName: {
                serializedName: "properties.cloudName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cloudCapacity: {
                serializedName: "properties.cloudCapacity",
                type: {
                    name: "Composite",
                    className: "CloudCapacity"
                }
            },
            storageQoSPolicies: {
                serializedName: "properties.storageQoSPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StorageQoSPolicy"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudCapacity = {
    type: {
        name: "Composite",
        className: "CloudCapacity",
        modelProperties: {
            cpuCount: {
                serializedName: "cpuCount",
                type: {
                    name: "Number"
                }
            },
            memoryMB: {
                serializedName: "memoryMB",
                type: {
                    name: "Number"
                }
            },
            vmCount: {
                serializedName: "vmCount",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const StorageQoSPolicy = {
    type: {
        name: "Composite",
        className: "StorageQoSPolicy",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            iopsMaximum: {
                serializedName: "iopsMaximum",
                type: {
                    name: "Number"
                }
            },
            iopsMinimum: {
                serializedName: "iopsMinimum",
                type: {
                    name: "Number"
                }
            },
            bandwidthLimit: {
                serializedName: "bandwidthLimit",
                type: {
                    name: "Number"
                }
            },
            policyId: {
                serializedName: "policyId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudListResult = {
    type: {
        name: "Composite",
        className: "CloudListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Cloud"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetwork",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            inventoryItemId: {
                serializedName: "properties.inventoryItemId",
                type: {
                    name: "String"
                }
            },
            uuid: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.uuid",
                type: {
                    name: "String"
                }
            },
            vmmServerId: {
                serializedName: "properties.vmmServerId",
                type: {
                    name: "String"
                }
            },
            networkName: {
                serializedName: "properties.networkName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachine = {
    type: {
        name: "Composite",
        className: "VirtualMachine",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            inventoryItemId: {
                serializedName: "properties.inventoryItemId",
                type: {
                    name: "String"
                }
            },
            vmmServerId: {
                serializedName: "properties.vmmServerId",
                type: {
                    name: "String"
                }
            },
            cloudId: {
                serializedName: "properties.cloudId",
                type: {
                    name: "String"
                }
            },
            templateId: {
                serializedName: "properties.templateId",
                type: {
                    name: "String"
                }
            },
            checkpointType: {
                serializedName: "properties.checkpointType",
                type: {
                    name: "String"
                }
            },
            checkpoints: {
                serializedName: "properties.checkpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Checkpoint"
                        }
                    }
                }
            },
            availabilitySets: {
                serializedName: "properties.availabilitySets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailabilitySetListItem"
                        }
                    }
                }
            },
            osProfile: {
                serializedName: "properties.osProfile",
                type: {
                    name: "Composite",
                    className: "OsProfile"
                }
            },
            hardwareProfile: {
                serializedName: "properties.hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfile"
                }
            },
            networkProfile: {
                serializedName: "properties.networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfile"
                }
            },
            storageProfile: {
                serializedName: "properties.storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfile"
                }
            },
            vmName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.vmName",
                type: {
                    name: "String"
                }
            },
            uuid: {
                serializedName: "properties.uuid",
                type: {
                    name: "String"
                }
            },
            generation: {
                serializedName: "properties.generation",
                type: {
                    name: "Number"
                }
            },
            powerState: {
                serializedName: "properties.powerState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Checkpoint = {
    type: {
        name: "Composite",
        className: "Checkpoint",
        modelProperties: {
            parentCheckpointID: {
                serializedName: "parentCheckpointID",
                type: {
                    name: "String"
                }
            },
            checkpointID: {
                serializedName: "checkpointID",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilitySetListItem = {
    type: {
        name: "Composite",
        className: "AvailabilitySetListItem",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OsProfile = {
    type: {
        name: "Composite",
        className: "OsProfile",
        modelProperties: {
            adminPassword: {
                serializedName: "adminPassword",
                type: {
                    name: "String"
                }
            },
            computerName: {
                serializedName: "computerName",
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            osName: {
                serializedName: "osName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HardwareProfile = {
    type: {
        name: "Composite",
        className: "HardwareProfile",
        modelProperties: {
            memoryMB: {
                serializedName: "memoryMB",
                type: {
                    name: "Number"
                }
            },
            cpuCount: {
                serializedName: "cpuCount",
                type: {
                    name: "Number"
                }
            },
            limitCpuForMigration: {
                serializedName: "limitCpuForMigration",
                type: {
                    name: "String"
                }
            },
            dynamicMemoryEnabled: {
                serializedName: "dynamicMemoryEnabled",
                type: {
                    name: "String"
                }
            },
            dynamicMemoryMaxMB: {
                serializedName: "dynamicMemoryMaxMB",
                type: {
                    name: "Number"
                }
            },
            dynamicMemoryMinMB: {
                serializedName: "dynamicMemoryMinMB",
                type: {
                    name: "Number"
                }
            },
            isHighlyAvailable: {
                serializedName: "isHighlyAvailable",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkProfile = {
    type: {
        name: "Composite",
        className: "NetworkProfile",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaces"
                        }
                    }
                }
            }
        }
    }
};
const NetworkInterfaces = {
    type: {
        name: "Composite",
        className: "NetworkInterfaces",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipv4Addresses: {
                serializedName: "ipv4Addresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ipv6Addresses: {
                serializedName: "ipv6Addresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            },
            virtualNetworkId: {
                serializedName: "virtualNetworkId",
                type: {
                    name: "String"
                }
            },
            networkName: {
                serializedName: "networkName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ipv4AddressType: {
                serializedName: "ipv4AddressType",
                type: {
                    name: "String"
                }
            },
            ipv6AddressType: {
                serializedName: "ipv6AddressType",
                type: {
                    name: "String"
                }
            },
            macAddressType: {
                serializedName: "macAddressType",
                type: {
                    name: "String"
                }
            },
            nicId: {
                serializedName: "nicId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageProfile = {
    type: {
        name: "Composite",
        className: "StorageProfile",
        modelProperties: {
            disks: {
                serializedName: "disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDisk"
                        }
                    }
                }
            }
        }
    }
};
const VirtualDisk = {
    type: {
        name: "Composite",
        className: "VirtualDisk",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            diskId: {
                serializedName: "diskId",
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            maxDiskSizeGB: {
                serializedName: "maxDiskSizeGB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            bus: {
                serializedName: "bus",
                type: {
                    name: "Number"
                }
            },
            lun: {
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            },
            busType: {
                serializedName: "busType",
                type: {
                    name: "String"
                }
            },
            vhdType: {
                serializedName: "vhdType",
                type: {
                    name: "String"
                }
            },
            volumeType: {
                serializedName: "volumeType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vhdFormatType: {
                serializedName: "vhdFormatType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            templateDiskId: {
                serializedName: "templateDiskId",
                type: {
                    name: "String"
                }
            },
            storageQoSPolicy: {
                serializedName: "storageQoSPolicy",
                type: {
                    name: "Composite",
                    className: "StorageQoSPolicyDetails"
                }
            },
            createDiffDisk: {
                serializedName: "createDiffDisk",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StorageQoSPolicyDetails = {
    type: {
        name: "Composite",
        className: "StorageQoSPolicyDetails",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineUpdate = {
    type: {
        name: "Composite",
        className: "VirtualMachineUpdate",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "VirtualMachineUpdateProperties"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VirtualMachineUpdateProperties = {
    type: {
        name: "Composite",
        className: "VirtualMachineUpdateProperties",
        modelProperties: {
            hardwareProfile: {
                serializedName: "hardwareProfile",
                type: {
                    name: "Composite",
                    className: "HardwareProfileUpdate"
                }
            },
            storageProfile: {
                serializedName: "storageProfile",
                type: {
                    name: "Composite",
                    className: "StorageProfileUpdate"
                }
            },
            networkProfile: {
                serializedName: "networkProfile",
                type: {
                    name: "Composite",
                    className: "NetworkProfileUpdate"
                }
            },
            availabilitySets: {
                serializedName: "availabilitySets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailabilitySetListItem"
                        }
                    }
                }
            }
        }
    }
};
const HardwareProfileUpdate = {
    type: {
        name: "Composite",
        className: "HardwareProfileUpdate",
        modelProperties: {
            memoryMB: {
                serializedName: "memoryMB",
                type: {
                    name: "Number"
                }
            },
            cpuCount: {
                serializedName: "cpuCount",
                type: {
                    name: "Number"
                }
            },
            limitCpuForMigration: {
                serializedName: "limitCpuForMigration",
                type: {
                    name: "String"
                }
            },
            dynamicMemoryEnabled: {
                serializedName: "dynamicMemoryEnabled",
                type: {
                    name: "String"
                }
            },
            dynamicMemoryMaxMB: {
                serializedName: "dynamicMemoryMaxMB",
                type: {
                    name: "Number"
                }
            },
            dynamicMemoryMinMB: {
                serializedName: "dynamicMemoryMinMB",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const StorageProfileUpdate = {
    type: {
        name: "Composite",
        className: "StorageProfileUpdate",
        modelProperties: {
            disks: {
                serializedName: "disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDiskUpdate"
                        }
                    }
                }
            }
        }
    }
};
const VirtualDiskUpdate = {
    type: {
        name: "Composite",
        className: "VirtualDiskUpdate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            diskId: {
                serializedName: "diskId",
                type: {
                    name: "String"
                }
            },
            diskSizeGB: {
                serializedName: "diskSizeGB",
                type: {
                    name: "Number"
                }
            },
            bus: {
                serializedName: "bus",
                type: {
                    name: "Number"
                }
            },
            lun: {
                serializedName: "lun",
                type: {
                    name: "Number"
                }
            },
            busType: {
                serializedName: "busType",
                type: {
                    name: "String"
                }
            },
            vhdType: {
                serializedName: "vhdType",
                type: {
                    name: "String"
                }
            },
            storageQoSPolicy: {
                serializedName: "storageQoSPolicy",
                type: {
                    name: "Composite",
                    className: "StorageQoSPolicyDetails"
                }
            }
        }
    }
};
const NetworkProfileUpdate = {
    type: {
        name: "Composite",
        className: "NetworkProfileUpdate",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfacesUpdate"
                        }
                    }
                }
            }
        }
    }
};
const NetworkInterfacesUpdate = {
    type: {
        name: "Composite",
        className: "NetworkInterfacesUpdate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            },
            virtualNetworkId: {
                serializedName: "virtualNetworkId",
                type: {
                    name: "String"
                }
            },
            ipv4AddressType: {
                serializedName: "ipv4AddressType",
                type: {
                    name: "String"
                }
            },
            ipv6AddressType: {
                serializedName: "ipv6AddressType",
                type: {
                    name: "String"
                }
            },
            macAddressType: {
                serializedName: "macAddressType",
                type: {
                    name: "String"
                }
            },
            nicId: {
                serializedName: "nicId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StopVirtualMachineOptions = {
    type: {
        name: "Composite",
        className: "StopVirtualMachineOptions",
        modelProperties: {
            skipShutdown: {
                defaultValue: false,
                serializedName: "skipShutdown",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualMachineCreateCheckpoint = {
    type: {
        name: "Composite",
        className: "VirtualMachineCreateCheckpoint",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineDeleteCheckpoint = {
    type: {
        name: "Composite",
        className: "VirtualMachineDeleteCheckpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineRestoreCheckpoint = {
    type: {
        name: "Composite",
        className: "VirtualMachineRestoreCheckpoint",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachine"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineTemplate = {
    type: {
        name: "Composite",
        className: "VirtualMachineTemplate",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            inventoryItemId: {
                serializedName: "properties.inventoryItemId",
                type: {
                    name: "String"
                }
            },
            uuid: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.uuid",
                type: {
                    name: "String"
                }
            },
            vmmServerId: {
                serializedName: "properties.vmmServerId",
                type: {
                    name: "String"
                }
            },
            osType: {
                serializedName: "properties.osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            osName: {
                serializedName: "properties.osName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            computerName: {
                serializedName: "properties.computerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            memoryMB: {
                serializedName: "properties.memoryMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            cpuCount: {
                serializedName: "properties.cpuCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            limitCpuForMigration: {
                serializedName: "properties.limitCpuForMigration",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dynamicMemoryEnabled: {
                serializedName: "properties.dynamicMemoryEnabled",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            isCustomizable: {
                serializedName: "properties.isCustomizable",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dynamicMemoryMaxMB: {
                serializedName: "properties.dynamicMemoryMaxMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            dynamicMemoryMinMB: {
                serializedName: "properties.dynamicMemoryMinMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            isHighlyAvailable: {
                serializedName: "properties.isHighlyAvailable",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            generation: {
                serializedName: "properties.generation",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaces"
                        }
                    }
                }
            },
            disks: {
                serializedName: "properties.disks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDisk"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineTemplateListResult = {
    type: {
        name: "Composite",
        className: "VirtualMachineTemplateListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineTemplate"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilitySet = {
    type: {
        name: "Composite",
        className: "AvailabilitySet",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            },
            extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            },
            availabilitySetName: {
                constraints: {
                    MinLength: 1
                },
                serializedName: "properties.availabilitySetName",
                type: {
                    name: "String"
                }
            },
            vmmServerId: {
                serializedName: "properties.vmmServerId",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilitySetListResult = {
    type: {
        name: "Composite",
        className: "AvailabilitySetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailabilitySet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InventoryItemProperties = {
    type: {
        name: "Composite",
        className: "InventoryItemProperties",
        uberParent: "InventoryItemProperties",
        polymorphicDiscriminator: {
            serializedName: "inventoryType",
            clientName: "inventoryType"
        },
        modelProperties: {
            inventoryType: {
                serializedName: "inventoryType",
                required: true,
                type: {
                    name: "String"
                }
            },
            managedResourceId: {
                serializedName: "managedResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            uuid: {
                serializedName: "uuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            inventoryItemName: {
                serializedName: "inventoryItemName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InventoryItemsList = {
    type: {
        name: "Composite",
        className: "InventoryItemsList",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InventoryItem"
                        }
                    }
                }
            }
        }
    }
};
const InventoryItemDetails = {
    type: {
        name: "Composite",
        className: "InventoryItemDetails",
        modelProperties: {
            inventoryItemId: {
                serializedName: "inventoryItemId",
                type: {
                    name: "String"
                }
            },
            inventoryItemName: {
                serializedName: "inventoryItemName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CloudInventoryItem = {
    serializedName: "Cloud",
    type: {
        name: "Composite",
        className: "CloudInventoryItem",
        uberParent: "InventoryItemProperties",
        polymorphicDiscriminator: InventoryItemProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, InventoryItemProperties.type.modelProperties)
    }
};
const VirtualNetworkInventoryItem = {
    serializedName: "VirtualNetwork",
    type: {
        name: "Composite",
        className: "VirtualNetworkInventoryItem",
        uberParent: "InventoryItemProperties",
        polymorphicDiscriminator: InventoryItemProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign({}, InventoryItemProperties.type.modelProperties)
    }
};
const VirtualMachineTemplateInventoryItem = {
    serializedName: "VirtualMachineTemplate",
    type: {
        name: "Composite",
        className: "VirtualMachineTemplateInventoryItem",
        uberParent: "InventoryItemProperties",
        polymorphicDiscriminator: InventoryItemProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, InventoryItemProperties.type.modelProperties), { cpuCount: {
                serializedName: "cpuCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, memoryMB: {
                serializedName: "memoryMB",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osName: {
                serializedName: "osName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualMachineInventoryItem = {
    serializedName: "VirtualMachine",
    type: {
        name: "Composite",
        className: "VirtualMachineInventoryItem",
        uberParent: "InventoryItemProperties",
        polymorphicDiscriminator: InventoryItemProperties.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, InventoryItemProperties.type.modelProperties), { osType: {
                serializedName: "osType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, osName: {
                serializedName: "osName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, powerState: {
                serializedName: "powerState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, cloud: {
                serializedName: "cloud",
                type: {
                    name: "Composite",
                    className: "InventoryItemDetails"
                }
            } })
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const InventoryItem = {
    type: {
        name: "Composite",
        className: "InventoryItem",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, kind: {
                serializedName: "kind",
                type: {
                    name: "String"
                }
            }, inventoryType: {
                serializedName: "properties.inventoryType",
                required: true,
                type: {
                    name: "String"
                }
            }, managedResourceId: {
                serializedName: "properties.managedResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, uuid: {
                serializedName: "properties.uuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, inventoryItemName: {
                serializedName: "properties.inventoryItemName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AvailabilitySetsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "AvailabilitySetsCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailabilitySetsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "AvailabilitySetsDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    InventoryItemProperties: InventoryItemProperties,
    "InventoryItemProperties.Cloud": CloudInventoryItem,
    "InventoryItemProperties.VirtualNetwork": VirtualNetworkInventoryItem,
    "InventoryItemProperties.VirtualMachineTemplate": VirtualMachineTemplateInventoryItem,
    "InventoryItemProperties.VirtualMachine": VirtualMachineInventoryItem
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VMMServer: VMMServer,
    VMMServerPropertiesCredentials: VMMServerPropertiesCredentials,
    SystemData: SystemData,
    ExtendedLocation: ExtendedLocation,
    ErrorResponse: ErrorResponse,
    ErrorDefinition: ErrorDefinition,
    ResourcePatch: ResourcePatch,
    VMMServerListResult: VMMServerListResult,
    ResourceProviderOperationList: ResourceProviderOperationList,
    ResourceProviderOperation: ResourceProviderOperation,
    ResourceProviderOperationDisplay: ResourceProviderOperationDisplay,
    Cloud: Cloud,
    CloudCapacity: CloudCapacity,
    StorageQoSPolicy: StorageQoSPolicy,
    CloudListResult: CloudListResult,
    VirtualNetwork: VirtualNetwork,
    VirtualNetworkListResult: VirtualNetworkListResult,
    VirtualMachine: VirtualMachine,
    Checkpoint: Checkpoint,
    AvailabilitySetListItem: AvailabilitySetListItem,
    OsProfile: OsProfile,
    HardwareProfile: HardwareProfile,
    NetworkProfile: NetworkProfile,
    NetworkInterfaces: NetworkInterfaces,
    StorageProfile: StorageProfile,
    VirtualDisk: VirtualDisk,
    StorageQoSPolicyDetails: StorageQoSPolicyDetails,
    VirtualMachineUpdate: VirtualMachineUpdate,
    VirtualMachineUpdateProperties: VirtualMachineUpdateProperties,
    HardwareProfileUpdate: HardwareProfileUpdate,
    StorageProfileUpdate: StorageProfileUpdate,
    VirtualDiskUpdate: VirtualDiskUpdate,
    NetworkProfileUpdate: NetworkProfileUpdate,
    NetworkInterfacesUpdate: NetworkInterfacesUpdate,
    StopVirtualMachineOptions: StopVirtualMachineOptions,
    VirtualMachineCreateCheckpoint: VirtualMachineCreateCheckpoint,
    VirtualMachineDeleteCheckpoint: VirtualMachineDeleteCheckpoint,
    VirtualMachineRestoreCheckpoint: VirtualMachineRestoreCheckpoint,
    VirtualMachineListResult: VirtualMachineListResult,
    VirtualMachineTemplate: VirtualMachineTemplate,
    VirtualMachineTemplateListResult: VirtualMachineTemplateListResult,
    AvailabilitySet: AvailabilitySet,
    AvailabilitySetListResult: AvailabilitySetListResult,
    InventoryItemProperties: InventoryItemProperties,
    Resource: Resource,
    InventoryItemsList: InventoryItemsList,
    InventoryItemDetails: InventoryItemDetails,
    CloudInventoryItem: CloudInventoryItem,
    VirtualNetworkInventoryItem: VirtualNetworkInventoryItem,
    VirtualMachineTemplateInventoryItem: VirtualMachineTemplateInventoryItem,
    VirtualMachineInventoryItem: VirtualMachineInventoryItem,
    ProxyResource: ProxyResource,
    InventoryItem: InventoryItem,
    AvailabilitySetsCreateOrUpdateHeaders: AvailabilitySetsCreateOrUpdateHeaders,
    AvailabilitySetsDeleteHeaders: AvailabilitySetsDeleteHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vmmServerName = {
    parameterPath: "vmmServerName",
    mapper: {
        serializedName: "vmmServerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2020-06-05-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: VMMServer
};
const force = {
    parameterPath: ["options", "force"],
    mapper: {
        serializedName: "force",
        type: {
            name: "Boolean"
        }
    }
};
const body1 = {
    parameterPath: "body",
    mapper: ResourcePatch
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const cloudName = {
    parameterPath: "cloudName",
    mapper: {
        serializedName: "cloudName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body2 = {
    parameterPath: "body",
    mapper: Cloud
};
const virtualNetworkName = {
    parameterPath: "virtualNetworkName",
    mapper: {
        serializedName: "virtualNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body3 = {
    parameterPath: "body",
    mapper: VirtualNetwork
};
const virtualMachineName = {
    parameterPath: "virtualMachineName",
    mapper: {
        serializedName: "virtualMachineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body4 = {
    parameterPath: "body",
    mapper: VirtualMachine
};
const retain = {
    parameterPath: ["options", "retain"],
    mapper: {
        serializedName: "retain",
        type: {
            name: "Boolean"
        }
    }
};
const body5 = {
    parameterPath: "body",
    mapper: VirtualMachineUpdate
};
const body6 = {
    parameterPath: ["options", "body"],
    mapper: StopVirtualMachineOptions
};
const body7 = {
    parameterPath: ["options", "body"],
    mapper: VirtualMachineCreateCheckpoint
};
const body8 = {
    parameterPath: ["options", "body"],
    mapper: VirtualMachineDeleteCheckpoint
};
const body9 = {
    parameterPath: ["options", "body"],
    mapper: VirtualMachineRestoreCheckpoint
};
const virtualMachineTemplateName = {
    parameterPath: "virtualMachineTemplateName",
    mapper: {
        serializedName: "virtualMachineTemplateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body10 = {
    parameterPath: "body",
    mapper: VirtualMachineTemplate
};
const availabilitySetName = {
    parameterPath: "availabilitySetName",
    mapper: {
        serializedName: "availabilitySetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const body11 = {
    parameterPath: "body",
    mapper: AvailabilitySet
};
const body12 = {
    parameterPath: ["options", "body"],
    mapper: InventoryItem
};
const inventoryItemName = {
    parameterPath: "inventoryItemName",
    mapper: {
        serializedName: "inventoryItemName",
        required: true,
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VmmServers operations. */
class VmmServersImpl {
    /**
     * Initialize a new instance of the class VmmServers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of VmmServers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of VmmServers in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements VMMServer GET method.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmmServerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, options }, getOperationSpec$6);
    }
    /**
     * Onboards the SCVMM fabric as an Azure VmmServer resource.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vmmServerName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmmServerName, body, options }, createOrUpdateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Onboards the SCVMM fabric as an Azure VmmServer resource.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vmmServerName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vmmServerName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deboards the SCVMM fabric from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vmmServerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmmServerName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deboards the SCVMM fabric from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vmmServerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vmmServerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the VmmServers resource.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param body VmmServers patch payload.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, vmmServerName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, vmmServerName, body, options }, updateOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the VmmServers resource.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param body VmmServers patch payload.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, vmmServerName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, vmmServerName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of VmmServers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * List of VmmServers in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$5);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VMMServer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VMMServer
        },
        201: {
            bodyMapper: VMMServer
        },
        202: {
            bodyMapper: VMMServer
        },
        204: {
            bodyMapper: VMMServer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const updateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VMMServer
        },
        201: {
            bodyMapper: VMMServer
        },
        202: {
            bodyMapper: VMMServer
        },
        204: {
            bodyMapper: VMMServer
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VMMServerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/vmmServers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VMMServerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VMMServerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listBySubscriptionNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VMMServerListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of all operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of all operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/providers/Microsoft.ScVmm/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceProviderOperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceProviderOperationList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Clouds operations. */
class CloudsImpl {
    /**
     * Initialize a new instance of the class Clouds class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of Clouds in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of Clouds in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements Cloud GET method.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param options The options parameters.
     */
    get(resourceGroupName, cloudName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudName, options }, getOperationSpec$5);
    }
    /**
     * Onboards the ScVmm fabric cloud as an Azure cloud resource.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, cloudName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudName, body, options }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Onboards the ScVmm fabric cloud as an Azure cloud resource.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, cloudName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, cloudName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deregisters the ScVmm fabric cloud from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, cloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudName, options }, deleteOperationSpec$5);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deregisters the ScVmm fabric cloud from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, cloudName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, cloudName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the Clouds resource.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param body Clouds patch payload.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, cloudName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, cloudName, body, options }, updateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the Clouds resource.
     * @param resourceGroupName The name of the resource group.
     * @param cloudName Name of the Cloud.
     * @param body Clouds patch payload.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, cloudName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, cloudName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of Clouds in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * List of Clouds in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$4);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Cloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Cloud
        },
        201: {
            bodyMapper: Cloud
        },
        202: {
            bodyMapper: Cloud
        },
        204: {
            bodyMapper: Cloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const updateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds/{cloudName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Cloud
        },
        201: {
            bodyMapper: Cloud
        },
        202: {
            bodyMapper: Cloud
        },
        204: {
            bodyMapper: Cloud
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        cloudName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/clouds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listBySubscriptionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/clouds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$5
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listBySubscriptionNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CloudListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworks operations. */
class VirtualNetworksImpl {
    /**
     * Initialize a new instance of the class VirtualNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of VirtualNetworks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of VirtualNetworks in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements VirtualNetwork GET method.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, getOperationSpec$4);
    }
    /**
     * Onboards the ScVmm virtual network as an Azure virtual network resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, body, options }, createOrUpdateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Onboards the ScVmm virtual network as an Azure virtual network resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deregisters the ScVmm virtual network from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deregisters the ScVmm virtual network from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the VirtualNetworks resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param body VirtualNetworks patch payload.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, virtualNetworkName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualNetworkName, body, options }, updateOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the VirtualNetworks resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName Name of the VirtualNetwork.
     * @param body VirtualNetworks patch payload.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, virtualNetworkName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, virtualNetworkName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of VirtualNetworks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * List of VirtualNetworks in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        201: {
            bodyMapper: VirtualNetwork
        },
        202: {
            bodyMapper: VirtualNetwork
        },
        204: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const updateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        201: {
            bodyMapper: VirtualNetwork
        },
        202: {
            bodyMapper: VirtualNetwork
        },
        204: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of VirtualMachines in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of VirtualMachines in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements VirtualMachine GET method.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualMachineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineName, options }, getOperationSpec$3);
    }
    /**
     * Creates Or Updates virtual machines deployed on scvmm fabric.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, body, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates Or Updates virtual machines deployed on scvmm fabric.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualMachineName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualMachine deployed on ScVmm fabric.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, deleteOperationSpec$3);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualMachine deployed on ScVmm fabric.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the VirtualMachines resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param body VirtualMachines patch payload.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, body, options }, updateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the VirtualMachines resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param body VirtualMachines patch payload.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, virtualMachineName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, virtualMachineName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stop virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stop virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Start virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Start virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restart virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginRestart(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, restartOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restart virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginRestartAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestart(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Creates a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginCreateCheckpoint(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, createCheckpointOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginCreateCheckpointAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateCheckpoint(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginDeleteCheckpoint(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, deleteCheckpointOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginDeleteCheckpointAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteCheckpoint(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Restores to a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginRestoreCheckpoint(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, options }, restoreCheckpointOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Restores to a checkpoint in virtual machine.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineName Name of the VirtualMachine.
     * @param options The options parameters.
     */
    beginRestoreCheckpointAndWait(resourceGroupName, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginRestoreCheckpoint(resourceGroupName, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of VirtualMachines in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * List of VirtualMachines in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        201: {
            bodyMapper: VirtualMachine
        },
        202: {
            bodyMapper: VirtualMachine
        },
        204: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force, retain],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        201: {
            bodyMapper: VirtualMachine
        },
        202: {
            bodyMapper: VirtualMachine
        },
        204: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const restartOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/restart",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const createCheckpointOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/createCheckpoint",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const deleteCheckpointOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/deleteCheckpoint",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const restoreCheckpointOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines/{virtualMachineName}/restoreCheckpoint",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineTemplates operations. */
class VirtualMachineTemplatesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineTemplates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of VirtualMachineTemplates in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of VirtualMachineTemplates in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements VirtualMachineTemplate GET method.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualMachineTemplateName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineTemplateName, options }, getOperationSpec$2);
    }
    /**
     * Onboards the ScVmm VM Template as an Azure VM Template resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualMachineTemplateName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineTemplateName, body, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Onboards the ScVmm VM Template as an Azure VM Template resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualMachineTemplateName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualMachineTemplateName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deregisters the ScVmm VM Template from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualMachineTemplateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineTemplateName, options }, deleteOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deregisters the ScVmm VM Template from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualMachineTemplateName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualMachineTemplateName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the VirtualMachineTemplate resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param body VirtualMachineTemplates patch details.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, virtualMachineTemplateName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineTemplateName, body, options }, updateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the VirtualMachineTemplate resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineTemplateName Name of the VirtualMachineTemplate.
     * @param body VirtualMachineTemplates patch details.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, virtualMachineTemplateName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, virtualMachineTemplateName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of VirtualMachineTemplates in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * List of VirtualMachineTemplates in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplate
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineTemplateName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplate
        },
        201: {
            bodyMapper: VirtualMachineTemplate
        },
        202: {
            bodyMapper: VirtualMachineTemplate
        },
        204: {
            bodyMapper: VirtualMachineTemplate
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineTemplateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineTemplateName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates/{virtualMachineTemplateName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplate
        },
        201: {
            bodyMapper: VirtualMachineTemplate
        },
        202: {
            bodyMapper: VirtualMachineTemplate
        },
        204: {
            bodyMapper: VirtualMachineTemplate
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineTemplateName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/virtualMachineTemplates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/virtualMachineTemplates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$2
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailabilitySets operations. */
class AvailabilitySetsImpl {
    /**
     * Initialize a new instance of the class AvailabilitySets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List of AvailabilitySets in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List of AvailabilitySets in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Implements AvailabilitySet GET method.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param options The options parameters.
     */
    get(resourceGroupName, availabilitySetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, availabilitySetName, options }, getOperationSpec$1);
    }
    /**
     * Onboards the ScVmm availability set as an Azure resource.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, availabilitySetName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, availabilitySetName, body, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Onboards the ScVmm availability set as an Azure resource.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param body Request payload.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, availabilitySetName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, availabilitySetName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deregisters the ScVmm availability set from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, availabilitySetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, availabilitySetName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deregisters the ScVmm availability set from Azure.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, availabilitySetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, availabilitySetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the AvailabilitySets resource.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param body AvailabilitySets patch payload.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, availabilitySetName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, availabilitySetName, body, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                lroResourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the AvailabilitySets resource.
     * @param resourceGroupName The name of the resource group.
     * @param availabilitySetName Name of the AvailabilitySet.
     * @param body AvailabilitySets patch payload.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, availabilitySetName, body, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, availabilitySetName, body, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of AvailabilitySets in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * List of AvailabilitySets in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        201: {
            bodyMapper: AvailabilitySet
        },
        202: {
            bodyMapper: AvailabilitySet
        },
        204: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets/{availabilitySetName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AvailabilitySet
        },
        201: {
            bodyMapper: AvailabilitySet
        },
        202: {
            bodyMapper: AvailabilitySet
        },
        204: {
            bodyMapper: AvailabilitySet
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        availabilitySetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/availabilitySets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.ScVmm/availabilitySets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailabilitySetListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InventoryItems operations. */
class InventoryItemsImpl {
    /**
     * Initialize a new instance of the class InventoryItems class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns the list of inventoryItems in the given VMMServer.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param options The options parameters.
     */
    listByVMMServer(resourceGroupName, vmmServerName, options) {
        const iter = this.listByVMMServerPagingAll(resourceGroupName, vmmServerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVMMServerPagingPage(resourceGroupName, vmmServerName, options, settings);
            }
        };
    }
    listByVMMServerPagingPage(resourceGroupName, vmmServerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVMMServerPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVMMServer(resourceGroupName, vmmServerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVMMServerNext(resourceGroupName, vmmServerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVMMServerPagingAll(resourceGroupName, vmmServerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVMMServerPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVMMServerPagingPage(resourceGroupName, vmmServerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create Or Update InventoryItem.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param inventoryItemName Name of the inventoryItem.
     * @param options The options parameters.
     */
    create(resourceGroupName, vmmServerName, inventoryItemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, inventoryItemName, options }, createOperationSpec);
    }
    /**
     * Shows an inventory item.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param inventoryItemName Name of the inventoryItem.
     * @param options The options parameters.
     */
    get(resourceGroupName, vmmServerName, inventoryItemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, inventoryItemName, options }, getOperationSpec);
    }
    /**
     * Deletes an inventoryItem.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param inventoryItemName Name of the inventoryItem.
     * @param options The options parameters.
     */
    delete(resourceGroupName, vmmServerName, inventoryItemName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, inventoryItemName, options }, deleteOperationSpec);
    }
    /**
     * Returns the list of inventoryItems in the given VMMServer.
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param options The options parameters.
     */
    _listByVMMServer(resourceGroupName, vmmServerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, options }, listByVMMServerOperationSpec);
    }
    /**
     * ListByVMMServerNext
     * @param resourceGroupName The name of the resource group.
     * @param vmmServerName Name of the VMMServer.
     * @param nextLink The nextLink from the previous successful call to the ListByVMMServer method.
     * @param options The options parameters.
     */
    _listByVMMServerNext(resourceGroupName, vmmServerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vmmServerName, nextLink, options }, listByVMMServerNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InventoryItem
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: body12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName,
        inventoryItemName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InventoryItem
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName,
        inventoryItemName
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems/{inventoryItemName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName,
        inventoryItemName
    ],
    headerParameters: [accept],
    serializer
};
const listByVMMServerOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ScVmm/vmmServers/{vmmServerName}/inventoryItems",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InventoryItemsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName
    ],
    headerParameters: [accept],
    serializer
};
const listByVMMServerNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InventoryItemsList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        vmmServerName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class Scvmm extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the Scvmm class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The Azure subscription ID. This is a GUID-formatted string (e.g.
     *                       00000000-0000-0000-0000-000000000000).
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-scvmm/1.0.0-beta.3`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2020-06-05-preview";
        this.vmmServers = new VmmServersImpl(this);
        this.operations = new OperationsImpl(this);
        this.clouds = new CloudsImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.virtualMachineTemplates = new VirtualMachineTemplatesImpl(this);
        this.availabilitySets = new AvailabilitySetsImpl(this);
        this.inventoryItems = new InventoryItemsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.Scvmm = Scvmm;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
