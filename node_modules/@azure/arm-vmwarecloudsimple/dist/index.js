'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link GuestOsnicCustomizationAllocation} that the service accepts. */
exports.KnownGuestOsnicCustomizationAllocation = void 0;
(function (KnownGuestOsnicCustomizationAllocation) {
    /** Static */
    KnownGuestOsnicCustomizationAllocation["Static"] = "static";
    /** Dynamic */
    KnownGuestOsnicCustomizationAllocation["Dynamic"] = "dynamic";
})(exports.KnownGuestOsnicCustomizationAllocation || (exports.KnownGuestOsnicCustomizationAllocation = {}));
/** Known values of {@link CustomizationHostNameType} that the service accepts. */
exports.KnownCustomizationHostNameType = void 0;
(function (KnownCustomizationHostNameType) {
    /** UserDefined */
    KnownCustomizationHostNameType["UserDefined"] = "USER_DEFINED";
    /** PrefixBased */
    KnownCustomizationHostNameType["PrefixBased"] = "PREFIX_BASED";
    /** Fixed */
    KnownCustomizationHostNameType["Fixed"] = "FIXED";
    /** VirtualMachineName */
    KnownCustomizationHostNameType["VirtualMachineName"] = "VIRTUAL_MACHINE_NAME";
    /** CustomName */
    KnownCustomizationHostNameType["CustomName"] = "CUSTOM_NAME";
})(exports.KnownCustomizationHostNameType || (exports.KnownCustomizationHostNameType = {}));
/** Known values of {@link CustomizationIdentityType} that the service accepts. */
exports.KnownCustomizationIdentityType = void 0;
(function (KnownCustomizationIdentityType) {
    /** WindowsText */
    KnownCustomizationIdentityType["WindowsText"] = "WINDOWS_TEXT";
    /** Windows */
    KnownCustomizationIdentityType["Windows"] = "WINDOWS";
    /** Linux */
    KnownCustomizationIdentityType["Linux"] = "LINUX";
})(exports.KnownCustomizationIdentityType || (exports.KnownCustomizationIdentityType = {}));
/** Known values of {@link CustomizationIPAddressType} that the service accepts. */
exports.KnownCustomizationIPAddressType = void 0;
(function (KnownCustomizationIPAddressType) {
    /** Custom */
    KnownCustomizationIPAddressType["Custom"] = "CUSTOM";
    /** DhcpIP */
    KnownCustomizationIPAddressType["DhcpIP"] = "DHCP_IP";
    /** FixedIP */
    KnownCustomizationIPAddressType["FixedIP"] = "FIXED_IP";
    /** UserDefined */
    KnownCustomizationIPAddressType["UserDefined"] = "USER_DEFINED";
})(exports.KnownCustomizationIPAddressType || (exports.KnownCustomizationIPAddressType = {}));
/** Known values of {@link CustomizationPolicyPropertiesType} that the service accepts. */
exports.KnownCustomizationPolicyPropertiesType = void 0;
(function (KnownCustomizationPolicyPropertiesType) {
    /** Linux */
    KnownCustomizationPolicyPropertiesType["Linux"] = "LINUX";
    /** Windows */
    KnownCustomizationPolicyPropertiesType["Windows"] = "WINDOWS";
})(exports.KnownCustomizationPolicyPropertiesType || (exports.KnownCustomizationPolicyPropertiesType = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AvailableOperationsListResponse = {
    type: {
        name: "Composite",
        className: "AvailableOperationsListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableOperation"
                        }
                    }
                }
            }
        }
    }
};
const AvailableOperation = {
    type: {
        name: "Composite",
        className: "AvailableOperation",
        modelProperties: {
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "AvailableOperationDisplay"
                }
            },
            isDataAction: {
                defaultValue: false,
                serializedName: "isDataAction",
                type: {
                    name: "Boolean"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "Enum",
                    allowedValues: ["user", "system", "user,system"]
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "AvailableOperationDisplayPropertyServiceSpecificationMetricsList"
                }
            }
        }
    }
};
const AvailableOperationDisplay = {
    type: {
        name: "Composite",
        className: "AvailableOperationDisplay",
        modelProperties: {
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableOperationDisplayPropertyServiceSpecificationMetricsList = {
    type: {
        name: "Composite",
        className: "AvailableOperationDisplayPropertyServiceSpecificationMetricsList",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableOperationDisplayPropertyServiceSpecificationMetricsItem"
                        }
                    }
                }
            }
        }
    }
};
const AvailableOperationDisplayPropertyServiceSpecificationMetricsItem = {
    type: {
        name: "Composite",
        className: "AvailableOperationDisplayPropertyServiceSpecificationMetricsItem",
        modelProperties: {
            aggregationType: {
                serializedName: "aggregationType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Average", "Total"]
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CsrpError = {
    type: {
        name: "Composite",
        className: "CsrpError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CsrpErrorBody"
                }
            }
        }
    }
};
const CsrpErrorBody = {
    type: {
        name: "Composite",
        className: "CsrpErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CsrpErrorBody"
                        }
                    }
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedCloudNodeListResponse = {
    type: {
        name: "Composite",
        className: "DedicatedCloudNodeListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedCloudNode"
                        }
                    }
                }
            }
        }
    }
};
const DedicatedCloudNode = {
    type: {
        name: "Composite",
        className: "DedicatedCloudNode",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availabilityZoneId: {
                serializedName: "properties.availabilityZoneId",
                type: {
                    name: "String"
                }
            },
            availabilityZoneName: {
                serializedName: "properties.availabilityZoneName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cloudRackName: {
                serializedName: "properties.cloudRackName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            nodesCount: {
                serializedName: "properties.nodesCount",
                type: {
                    name: "Number"
                }
            },
            placementGroupId: {
                serializedName: "properties.placementGroupId",
                type: {
                    name: "String"
                }
            },
            placementGroupName: {
                serializedName: "properties.placementGroupName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateCloudName: {
                serializedName: "properties.privateCloudName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            purchaseId: {
                serializedName: "properties.purchaseId",
                type: {
                    name: "Uuid"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["unused", "used"]
                }
            },
            vmwareClusterName: {
                serializedName: "properties.vmwareClusterName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            idPropertiesSkuDescriptionId: {
                serializedName: "properties.skuDescription.id",
                type: {
                    name: "String"
                }
            },
            namePropertiesSkuDescriptionName: {
                serializedName: "properties.skuDescription.name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedCloudServiceListResponse = {
    type: {
        name: "Composite",
        className: "DedicatedCloudServiceListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DedicatedCloudService"
                        }
                    }
                }
            }
        }
    }
};
const DedicatedCloudService = {
    type: {
        name: "Composite",
        className: "DedicatedCloudService",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            gatewaySubnet: {
                serializedName: "properties.gatewaySubnet",
                type: {
                    name: "String"
                }
            },
            isAccountOnboarded: {
                serializedName: "properties.isAccountOnboarded",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "notOnBoarded",
                        "onBoarded",
                        "onBoardingFailed",
                        "onBoarding"
                    ]
                }
            },
            nodes: {
                serializedName: "properties.nodes",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            serviceURL: {
                serializedName: "properties.serviceURL",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SkuAvailabilityListResponse = {
    type: {
        name: "Composite",
        className: "SkuAvailabilityListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SkuAvailability"
                        }
                    }
                }
            }
        }
    }
};
const SkuAvailability = {
    type: {
        name: "Composite",
        className: "SkuAvailability",
        modelProperties: {
            dedicatedAvailabilityZoneId: {
                serializedName: "dedicatedAvailabilityZoneId",
                type: {
                    name: "String"
                }
            },
            dedicatedAvailabilityZoneName: {
                serializedName: "dedicatedAvailabilityZoneName",
                type: {
                    name: "String"
                }
            },
            dedicatedPlacementGroupId: {
                serializedName: "dedicatedPlacementGroupId",
                type: {
                    name: "String"
                }
            },
            dedicatedPlacementGroupName: {
                serializedName: "dedicatedPlacementGroupName",
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            },
            skuId: {
                serializedName: "skuId",
                type: {
                    name: "String"
                }
            },
            skuName: {
                serializedName: "skuName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationResource = {
    type: {
        name: "Composite",
        className: "OperationResource",
        modelProperties: {
            endTime: {
                serializedName: "endTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "OperationError"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationError = {
    type: {
        name: "Composite",
        className: "OperationError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateCloudList = {
    type: {
        name: "Composite",
        className: "PrivateCloudList",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateCloud"
                        }
                    }
                }
            }
        }
    }
};
const PrivateCloud = {
    type: {
        name: "Composite",
        className: "PrivateCloud",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                defaultValue: "Microsoft.VMwareCloudSimple/privateClouds",
                isConstant: true,
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            availabilityZoneId: {
                serializedName: "properties.availabilityZoneId",
                type: {
                    name: "String"
                }
            },
            availabilityZoneName: {
                serializedName: "properties.availabilityZoneName",
                type: {
                    name: "String"
                }
            },
            clustersNumber: {
                serializedName: "properties.clustersNumber",
                type: {
                    name: "Number"
                }
            },
            createdBy: {
                serializedName: "properties.createdBy",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "properties.createdOn",
                type: {
                    name: "DateTime"
                }
            },
            dnsServers: {
                serializedName: "properties.dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expires: {
                serializedName: "properties.expires",
                type: {
                    name: "String"
                }
            },
            nsxType: {
                serializedName: "properties.nsxType",
                type: {
                    name: "String"
                }
            },
            placementGroupId: {
                serializedName: "properties.placementGroupId",
                type: {
                    name: "String"
                }
            },
            placementGroupName: {
                serializedName: "properties.placementGroupName",
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                type: {
                    name: "Uuid"
                }
            },
            resourcePools: {
                serializedName: "properties.resourcePools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourcePool"
                        }
                    }
                }
            },
            state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            },
            totalCpuCores: {
                serializedName: "properties.totalCpuCores",
                type: {
                    name: "Number"
                }
            },
            totalNodes: {
                serializedName: "properties.totalNodes",
                type: {
                    name: "Number"
                }
            },
            totalRam: {
                serializedName: "properties.totalRam",
                type: {
                    name: "Number"
                }
            },
            totalStorage: {
                serializedName: "properties.totalStorage",
                type: {
                    name: "Number"
                }
            },
            typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            },
            vSphereVersion: {
                serializedName: "properties.vSphereVersion",
                type: {
                    name: "String"
                }
            },
            vcenterFqdn: {
                serializedName: "properties.vcenterFqdn",
                type: {
                    name: "String"
                }
            },
            vcenterRefid: {
                serializedName: "properties.vcenterRefid",
                type: {
                    name: "String"
                }
            },
            virtualMachineTemplates: {
                serializedName: "properties.virtualMachineTemplates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineTemplate"
                        }
                    }
                }
            },
            virtualNetworks: {
                serializedName: "properties.virtualNetworks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            },
            vrOpsEnabled: {
                serializedName: "properties.vrOpsEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ResourcePool = {
    type: {
        name: "Composite",
        className: "ResourcePool",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "privateCloudId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fullName: {
                serializedName: "properties.fullName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineTemplate = {
    type: {
        name: "Composite",
        className: "VirtualMachineTemplate",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amountOfRam: {
                serializedName: "properties.amountOfRam",
                type: {
                    name: "Number"
                }
            },
            controllers: {
                serializedName: "properties.controllers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDiskController"
                        }
                    }
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            disks: {
                serializedName: "properties.disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDisk"
                        }
                    }
                }
            },
            exposeToGuestVM: {
                serializedName: "properties.exposeToGuestVM",
                type: {
                    name: "Boolean"
                }
            },
            guestOS: {
                serializedName: "properties.guestOS",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            guestOSType: {
                serializedName: "properties.guestOSType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nics: {
                serializedName: "properties.nics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNic"
                        }
                    }
                }
            },
            numberOfCores: {
                serializedName: "properties.numberOfCores",
                type: {
                    name: "Number"
                }
            },
            path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                type: {
                    name: "String"
                }
            },
            vSphereNetworks: {
                serializedName: "properties.vSphereNetworks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vSphereTags: {
                serializedName: "properties.vSphereTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vmwaretools: {
                serializedName: "properties.vmwaretools",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualDiskController = {
    type: {
        name: "Composite",
        className: "VirtualDiskController",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            subType: {
                serializedName: "subType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualDisk = {
    type: {
        name: "Composite",
        className: "VirtualDisk",
        modelProperties: {
            controllerId: {
                serializedName: "controllerId",
                required: true,
                type: {
                    name: "String"
                }
            },
            independenceMode: {
                serializedName: "independenceMode",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "persistent",
                        "independent_persistent",
                        "independent_nonpersistent"
                    ]
                }
            },
            totalSize: {
                serializedName: "totalSize",
                required: true,
                type: {
                    name: "Number"
                }
            },
            virtualDiskId: {
                serializedName: "virtualDiskId",
                type: {
                    name: "String"
                }
            },
            virtualDiskName: {
                serializedName: "virtualDiskName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNic = {
    type: {
        name: "Composite",
        className: "VirtualNic",
        modelProperties: {
            customization: {
                serializedName: "customization",
                type: {
                    name: "Composite",
                    className: "GuestOsnicCustomization"
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                type: {
                    name: "Composite",
                    className: "VirtualNetwork"
                }
            },
            nicType: {
                serializedName: "nicType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "E1000",
                        "E1000E",
                        "PCNET32",
                        "VMXNET",
                        "VMXNET2",
                        "VMXNET3"
                    ]
                }
            },
            powerOnBoot: {
                serializedName: "powerOnBoot",
                type: {
                    name: "Boolean"
                }
            },
            virtualNicId: {
                serializedName: "virtualNicId",
                type: {
                    name: "String"
                }
            },
            virtualNicName: {
                serializedName: "virtualNicName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GuestOsnicCustomization = {
    type: {
        name: "Composite",
        className: "GuestOsnicCustomization",
        modelProperties: {
            allocation: {
                serializedName: "allocation",
                type: {
                    name: "String"
                }
            },
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            gateway: {
                serializedName: "gateway",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ipAddress: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            mask: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "mask",
                type: {
                    name: "String"
                }
            },
            primaryWinsServer: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "primaryWinsServer",
                type: {
                    name: "String"
                }
            },
            secondaryWinsServer: {
                constraints: {
                    Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                },
                serializedName: "secondaryWinsServer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetwork",
        modelProperties: {
            assignable: {
                serializedName: "assignable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomizationPoliciesListResponse = {
    type: {
        name: "Composite",
        className: "CustomizationPoliciesListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomizationPolicy"
                        }
                    }
                }
            }
        }
    }
};
const CustomizationPolicy = {
    type: {
        name: "Composite",
        className: "CustomizationPolicy",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                type: {
                    name: "String"
                }
            },
            specification: {
                serializedName: "properties.specification",
                type: {
                    name: "Composite",
                    className: "CustomizationSpecification"
                }
            },
            typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "properties.version",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomizationSpecification = {
    type: {
        name: "Composite",
        className: "CustomizationSpecification",
        modelProperties: {
            identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "CustomizationIdentity"
                }
            },
            nicSettings: {
                serializedName: "nicSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomizationNicSetting"
                        }
                    }
                }
            }
        }
    }
};
const CustomizationIdentity = {
    type: {
        name: "Composite",
        className: "CustomizationIdentity",
        modelProperties: {
            data: {
                serializedName: "data",
                type: {
                    name: "String"
                }
            },
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "Composite",
                    className: "CustomizationHostName"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            userData: {
                serializedName: "userData",
                type: {
                    name: "Composite",
                    className: "CustomizationIdentityUserData"
                }
            }
        }
    }
};
const CustomizationHostName = {
    type: {
        name: "Composite",
        className: "CustomizationHostName",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomizationIdentityUserData = {
    type: {
        name: "Composite",
        className: "CustomizationIdentityUserData",
        modelProperties: {
            isPasswordPredefined: {
                defaultValue: false,
                serializedName: "isPasswordPredefined",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const CustomizationNicSetting = {
    type: {
        name: "Composite",
        className: "CustomizationNicSetting",
        modelProperties: {
            adapter: {
                serializedName: "adapter",
                type: {
                    name: "Composite",
                    className: "CustomizationIPSettings"
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomizationIPSettings = {
    type: {
        name: "Composite",
        className: "CustomizationIPSettings",
        modelProperties: {
            gateway: {
                serializedName: "gateway",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ip: {
                serializedName: "ip",
                type: {
                    name: "Composite",
                    className: "CustomizationIPAddress"
                }
            },
            subnetMask: {
                serializedName: "subnetMask",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomizationIPAddress = {
    type: {
        name: "Composite",
        className: "CustomizationIPAddress",
        modelProperties: {
            argument: {
                serializedName: "argument",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourcePoolsListResponse = {
    type: {
        name: "Composite",
        className: "ResourcePoolsListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourcePool"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachineTemplateListResponse = {
    type: {
        name: "Composite",
        className: "VirtualMachineTemplateListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachineTemplate"
                        }
                    }
                }
            }
        }
    }
};
const VirtualNetworkListResponse = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            }
        }
    }
};
const UsageListResponse = {
    type: {
        name: "Composite",
        className: "UsageListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            currentValue: {
                defaultValue: 0,
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                defaultValue: 0,
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Count",
                        "Bytes",
                        "Seconds",
                        "Percent",
                        "CountPerSecond",
                        "BytesPerSecond"
                    ]
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachineListResponse = {
    type: {
        name: "Composite",
        className: "VirtualMachineListResponse",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualMachine"
                        }
                    }
                }
            }
        }
    }
};
const VirtualMachine = {
    type: {
        name: "Composite",
        className: "VirtualMachine",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            amountOfRam: {
                serializedName: "properties.amountOfRam",
                type: {
                    name: "Number"
                }
            },
            controllers: {
                serializedName: "properties.controllers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDiskController"
                        }
                    }
                }
            },
            customization: {
                serializedName: "properties.customization",
                type: {
                    name: "Composite",
                    className: "GuestOSCustomization"
                }
            },
            disks: {
                serializedName: "properties.disks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualDisk"
                        }
                    }
                }
            },
            dnsname: {
                serializedName: "properties.dnsname",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            exposeToGuestVM: {
                serializedName: "properties.exposeToGuestVM",
                type: {
                    name: "Boolean"
                }
            },
            folder: {
                serializedName: "properties.folder",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            guestOS: {
                serializedName: "properties.guestOS",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            guestOSType: {
                serializedName: "properties.guestOSType",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["linux", "windows", "other"]
                }
            },
            nics: {
                serializedName: "properties.nics",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNic"
                        }
                    }
                }
            },
            numberOfCores: {
                serializedName: "properties.numberOfCores",
                type: {
                    name: "Number"
                }
            },
            password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            },
            privateCloudId: {
                serializedName: "properties.privateCloudId",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIP: {
                serializedName: "properties.publicIP",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourcePool: {
                serializedName: "properties.resourcePool",
                type: {
                    name: "Composite",
                    className: "ResourcePool"
                }
            },
            status: {
                serializedName: "properties.status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "running",
                        "suspended",
                        "poweredoff",
                        "updating",
                        "deallocating",
                        "deleting"
                    ]
                }
            },
            templateId: {
                serializedName: "properties.templateId",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "properties.username",
                type: {
                    name: "String"
                }
            },
            vSphereNetworks: {
                serializedName: "properties.vSphereNetworks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vmId: {
                serializedName: "properties.vmId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vmwaretools: {
                serializedName: "properties.vmwaretools",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GuestOSCustomization = {
    type: {
        name: "Composite",
        className: "GuestOSCustomization",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        constraints: {
                            Pattern: new RegExp("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])[.]){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$")
                        },
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            hostName: {
                serializedName: "hostName",
                type: {
                    name: "String"
                }
            },
            password: {
                serializedName: "password",
                type: {
                    name: "String"
                }
            },
            policyId: {
                serializedName: "policyId",
                type: {
                    name: "String"
                }
            },
            username: {
                serializedName: "username",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PatchPayload = {
    type: {
        name: "Composite",
        className: "PatchPayload",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const VirtualMachineStopMode = {
    type: {
        name: "Composite",
        className: "VirtualMachineStopMode",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "Enum",
                    allowedValues: ["reboot", "suspend", "shutdown", "poweroff"]
                }
            }
        }
    }
};
const OperationsGetHeaders = {
    type: {
        name: "Composite",
        className: "OperationsGetHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const OperationsGetExceptionHeaders = {
    type: {
        name: "Composite",
        className: "OperationsGetExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedCloudNodesCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "DedicatedCloudNodesCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DedicatedCloudNodesDeleteExceptionHeaders = {
    type: {
        name: "Composite",
        className: "DedicatedCloudNodesDeleteExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DedicatedCloudServicesDeleteExceptionHeaders = {
    type: {
        name: "Composite",
        className: "DedicatedCloudServicesDeleteExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinesCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesCreateOrUpdateHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesDeleteHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachinesDeleteExceptionHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesDeleteExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinesStartHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesStartHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachinesStartExceptionHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesStartExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualMachinesStopHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesStopHeaders",
        modelProperties: {
            azureAsyncOperation: {
                serializedName: "azure-asyncoperation",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            retryAfter: {
                serializedName: "retry-after",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VirtualMachinesStopExceptionHeaders = {
    type: {
        name: "Composite",
        className: "VirtualMachinesStopExceptionHeaders",
        modelProperties: {
            contentType: {
                defaultValue: "application/json",
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AvailableOperationsListResponse: AvailableOperationsListResponse,
    AvailableOperation: AvailableOperation,
    AvailableOperationDisplay: AvailableOperationDisplay,
    AvailableOperationDisplayPropertyServiceSpecificationMetricsList: AvailableOperationDisplayPropertyServiceSpecificationMetricsList,
    AvailableOperationDisplayPropertyServiceSpecificationMetricsItem: AvailableOperationDisplayPropertyServiceSpecificationMetricsItem,
    CsrpError: CsrpError,
    CsrpErrorBody: CsrpErrorBody,
    DedicatedCloudNodeListResponse: DedicatedCloudNodeListResponse,
    DedicatedCloudNode: DedicatedCloudNode,
    Sku: Sku,
    DedicatedCloudServiceListResponse: DedicatedCloudServiceListResponse,
    DedicatedCloudService: DedicatedCloudService,
    SkuAvailabilityListResponse: SkuAvailabilityListResponse,
    SkuAvailability: SkuAvailability,
    OperationResource: OperationResource,
    OperationError: OperationError,
    PrivateCloudList: PrivateCloudList,
    PrivateCloud: PrivateCloud,
    ResourcePool: ResourcePool,
    VirtualMachineTemplate: VirtualMachineTemplate,
    VirtualDiskController: VirtualDiskController,
    VirtualDisk: VirtualDisk,
    VirtualNic: VirtualNic,
    GuestOsnicCustomization: GuestOsnicCustomization,
    VirtualNetwork: VirtualNetwork,
    CustomizationPoliciesListResponse: CustomizationPoliciesListResponse,
    CustomizationPolicy: CustomizationPolicy,
    CustomizationSpecification: CustomizationSpecification,
    CustomizationIdentity: CustomizationIdentity,
    CustomizationHostName: CustomizationHostName,
    CustomizationIdentityUserData: CustomizationIdentityUserData,
    CustomizationNicSetting: CustomizationNicSetting,
    CustomizationIPSettings: CustomizationIPSettings,
    CustomizationIPAddress: CustomizationIPAddress,
    ResourcePoolsListResponse: ResourcePoolsListResponse,
    VirtualMachineTemplateListResponse: VirtualMachineTemplateListResponse,
    VirtualNetworkListResponse: VirtualNetworkListResponse,
    UsageListResponse: UsageListResponse,
    Usage: Usage,
    UsageName: UsageName,
    VirtualMachineListResponse: VirtualMachineListResponse,
    VirtualMachine: VirtualMachine,
    GuestOSCustomization: GuestOSCustomization,
    PatchPayload: PatchPayload,
    VirtualMachineStopMode: VirtualMachineStopMode,
    OperationsGetHeaders: OperationsGetHeaders,
    OperationsGetExceptionHeaders: OperationsGetExceptionHeaders,
    DedicatedCloudNodesCreateOrUpdateHeaders: DedicatedCloudNodesCreateOrUpdateHeaders,
    DedicatedCloudNodesDeleteExceptionHeaders: DedicatedCloudNodesDeleteExceptionHeaders,
    DedicatedCloudServicesDeleteExceptionHeaders: DedicatedCloudServicesDeleteExceptionHeaders,
    VirtualMachinesCreateOrUpdateHeaders: VirtualMachinesCreateOrUpdateHeaders,
    VirtualMachinesDeleteHeaders: VirtualMachinesDeleteHeaders,
    VirtualMachinesDeleteExceptionHeaders: VirtualMachinesDeleteExceptionHeaders,
    VirtualMachinesStartHeaders: VirtualMachinesStartHeaders,
    VirtualMachinesStartExceptionHeaders: VirtualMachinesStartExceptionHeaders,
    VirtualMachinesStopHeaders: VirtualMachinesStopHeaders,
    VirtualMachinesStopExceptionHeaders: VirtualMachinesStopExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2019-04-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const regionId = {
    parameterPath: "regionId",
    mapper: {
        serializedName: "regionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const referer = {
    parameterPath: "referer",
    mapper: {
        serializedName: "Referer",
        required: true,
        type: {
            name: "String"
        }
    }
};
const operationId = {
    parameterPath: "operationId",
    mapper: {
        serializedName: "operationId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dedicatedCloudNodeName = {
    parameterPath: "dedicatedCloudNodeName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
        },
        serializedName: "dedicatedCloudNodeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const dedicatedCloudNodeRequest = {
    parameterPath: "dedicatedCloudNodeRequest",
    mapper: DedicatedCloudNode
};
const dedicatedCloudNodeRequest1 = {
    parameterPath: "dedicatedCloudNodeRequest",
    mapper: PatchPayload
};
const dedicatedCloudServiceName = {
    parameterPath: "dedicatedCloudServiceName",
    mapper: {
        serializedName: "dedicatedCloudServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dedicatedCloudServiceRequest = {
    parameterPath: "dedicatedCloudServiceRequest",
    mapper: DedicatedCloudService
};
const dedicatedCloudServiceName1 = {
    parameterPath: "dedicatedCloudServiceName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
        },
        serializedName: "dedicatedCloudServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const dedicatedCloudServiceRequest1 = {
    parameterPath: "dedicatedCloudServiceRequest",
    mapper: PatchPayload
};
const skuId = {
    parameterPath: ["options", "skuId"],
    mapper: {
        serializedName: "skuId",
        type: {
            name: "String"
        }
    }
};
const pcName = {
    parameterPath: "pcName",
    mapper: {
        serializedName: "pcName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const customizationPolicyName = {
    parameterPath: "customizationPolicyName",
    mapper: {
        serializedName: "customizationPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourcePoolName = {
    parameterPath: "resourcePoolName",
    mapper: {
        serializedName: "resourcePoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourcePoolName1 = {
    parameterPath: "resourcePoolName",
    mapper: {
        serializedName: "resourcePoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualMachineTemplateName = {
    parameterPath: "virtualMachineTemplateName",
    mapper: {
        serializedName: "virtualMachineTemplateName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetworkName = {
    parameterPath: "virtualNetworkName",
    mapper: {
        serializedName: "virtualNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualMachineName = {
    parameterPath: "virtualMachineName",
    mapper: {
        serializedName: "virtualMachineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualMachineRequest = {
    parameterPath: "virtualMachineRequest",
    mapper: VirtualMachine
};
const virtualMachineName1 = {
    parameterPath: "virtualMachineName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z0-9]([-_.a-zA-Z0-9]*[a-zA-Z0-9])?$")
        },
        serializedName: "virtualMachineName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualMachineRequest1 = {
    parameterPath: "virtualMachineRequest",
    mapper: PatchPayload
};
const m = {
    parameterPath: ["options", "m"],
    mapper: VirtualMachineStopMode
};
const mode = {
    parameterPath: ["options", "mode"],
    mapper: {
        serializedName: "mode",
        type: {
            name: "Enum",
            allowedValues: ["reboot", "suspend", "shutdown", "poweroff"]
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return list of operations
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return list of operations
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$7);
    }
    /**
     * Return an async operation
     * @param regionId The region Id (westus, eastus)
     * @param referer referer url
     * @param operationId operation id
     * @param options The options parameters.
     */
    get(regionId, referer, operationId, options) {
        return this.client.sendOperationRequest({ regionId, referer, operationId, options }, getOperationSpec$8);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/providers/Microsoft.VMwareCloudSimple/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableOperationsListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$a
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/operationResults/{operationId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationResource
        },
        202: {
            headersMapper: OperationsGetHeaders
        },
        204: {},
        default: {
            bodyMapper: CsrpError,
            headersMapper: OperationsGetExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        operationId
    ],
    headerParameters: [accept, referer],
    serializer: serializer$a
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableOperationsListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DedicatedCloudNodes operations. */
class DedicatedCloudNodesImpl {
    /**
     * Initialize a new instance of the class DedicatedCloudNodes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of dedicate cloud nodes within subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of dedicate cloud nodes within resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns list of dedicate cloud nodes within subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * Returns list of dedicate cloud nodes within resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Returns dedicated cloud node
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudNodeName dedicated cloud node name
     * @param options The options parameters.
     */
    get(resourceGroupName, dedicatedCloudNodeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dedicatedCloudNodeName, options }, getOperationSpec$7);
    }
    /**
     * Returns dedicated cloud node by its name
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param dedicatedCloudNodeName dedicated cloud node name
     * @param dedicatedCloudNodeRequest Create Dedicated Cloud Node request
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, referer, dedicatedCloudNodeName, dedicatedCloudNodeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                referer,
                dedicatedCloudNodeName,
                dedicatedCloudNodeRequest,
                options
            }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns dedicated cloud node by its name
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param dedicatedCloudNodeName dedicated cloud node name
     * @param dedicatedCloudNodeRequest Create Dedicated Cloud Node request
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, referer, dedicatedCloudNodeName, dedicatedCloudNodeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, referer, dedicatedCloudNodeName, dedicatedCloudNodeRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete dedicated cloud node
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudNodeName dedicated cloud node name
     * @param options The options parameters.
     */
    delete(resourceGroupName, dedicatedCloudNodeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dedicatedCloudNodeName, options }, deleteOperationSpec$2);
    }
    /**
     * Patches dedicated node properties
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudNodeName dedicated cloud node name
     * @param dedicatedCloudNodeRequest Patch Dedicated Cloud Node request
     * @param options The options parameters.
     */
    update(resourceGroupName, dedicatedCloudNodeName, dedicatedCloudNodeRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            dedicatedCloudNodeName,
            dedicatedCloudNodeRequest,
            options
        }, updateOperationSpec$2);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNodeListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNodeListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes/{dedicatedCloudNodeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNode
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudNodeName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes/{dedicatedCloudNodeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNode,
            headersMapper: DedicatedCloudNodesCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: DedicatedCloudNode,
            headersMapper: DedicatedCloudNodesCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: DedicatedCloudNode,
            headersMapper: DedicatedCloudNodesCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: DedicatedCloudNode,
            headersMapper: DedicatedCloudNodesCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: dedicatedCloudNodeRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudNodeName
    ],
    headerParameters: [
        accept,
        referer,
        contentType
    ],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes/{dedicatedCloudNodeName}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: CsrpError,
            headersMapper: DedicatedCloudNodesDeleteExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudNodeName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const updateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudNodes/{dedicatedCloudNodeName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNode
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: dedicatedCloudNodeRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudNodeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNodeListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudNodeListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DedicatedCloudServices operations. */
class DedicatedCloudServicesImpl {
    /**
     * Initialize a new instance of the class DedicatedCloudServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of dedicated cloud services within a subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of dedicated cloud services within a resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns list of dedicated cloud services within a subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Returns list of dedicated cloud services within a resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Returns Dedicate Cloud Service
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudServiceName dedicated cloud Service name
     * @param options The options parameters.
     */
    get(resourceGroupName, dedicatedCloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dedicatedCloudServiceName, options }, getOperationSpec$6);
    }
    /**
     * Create dedicate cloud service
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudServiceName dedicated cloud Service name
     * @param dedicatedCloudServiceRequest Create Dedicated Cloud Service request
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, dedicatedCloudServiceName, dedicatedCloudServiceRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            dedicatedCloudServiceName,
            dedicatedCloudServiceRequest,
            options
        }, createOrUpdateOperationSpec$1);
    }
    /**
     * Delete dedicate cloud service
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudServiceName dedicated cloud service name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, dedicatedCloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, dedicatedCloudServiceName, options }, deleteOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete dedicate cloud service
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudServiceName dedicated cloud service name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, dedicatedCloudServiceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, dedicatedCloudServiceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch dedicated cloud service's properties
     * @param resourceGroupName The name of the resource group
     * @param dedicatedCloudServiceName dedicated cloud service name
     * @param dedicatedCloudServiceRequest Patch Dedicated Cloud Service request
     * @param options The options parameters.
     */
    update(resourceGroupName, dedicatedCloudServiceName, dedicatedCloudServiceRequest, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            dedicatedCloudServiceName,
            dedicatedCloudServiceRequest,
            options
        }, updateOperationSpec$1);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudServiceListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudServiceListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices/{dedicatedCloudServiceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudService
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices/{dedicatedCloudServiceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DedicatedCloudService
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: dedicatedCloudServiceRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudServiceName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices/{dedicatedCloudServiceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CsrpError,
            headersMapper: DedicatedCloudServicesDeleteExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const updateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/dedicatedCloudServices/{dedicatedCloudServiceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DedicatedCloudService
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: dedicatedCloudServiceRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        dedicatedCloudServiceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudServiceListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DedicatedCloudServiceListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SkusAvailability operations. */
class SkusAvailabilityImpl {
    /**
     * Initialize a new instance of the class SkusAvailability class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of available resources in region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    list(regionId, options) {
        const iter = this.listPagingAll(regionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, options, settings);
            }
        };
    }
    listPagingPage(regionId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of available resources in region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    _list(regionId, options) {
        return this.client.sendOperationRequest({ regionId, options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/availabilities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuAvailabilityListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion, skuId],
    urlParameters: [
        $host,
        subscriptionId,
        regionId
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SkuAvailabilityListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateClouds operations. */
class PrivateCloudsImpl {
    /**
     * Initialize a new instance of the class PrivateClouds class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of private clouds in particular region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    list(regionId, options) {
        const iter = this.listPagingAll(regionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, options, settings);
            }
        };
    }
    listPagingPage(regionId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of private clouds in particular region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    _list(regionId, options) {
        return this.client.sendOperationRequest({ regionId, options }, listOperationSpec$5);
    }
    /**
     * Returns private cloud by its name
     * @param pcName The private cloud name
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    get(pcName, regionId, options) {
        return this.client.sendOperationRequest({ pcName, regionId, options }, getOperationSpec$5);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloud
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateCloudList
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomizationPolicies operations. */
class CustomizationPoliciesImpl {
    /**
     * Initialize a new instance of the class CustomizationPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of customization policies in region for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param options The options parameters.
     */
    list(regionId, pcName, options) {
        const iter = this.listPagingAll(regionId, pcName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, pcName, options, settings);
            }
        };
    }
    listPagingPage(regionId, pcName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, pcName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, pcName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, pcName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, pcName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of customization policies in region for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param options The options parameters.
     */
    _list(regionId, pcName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, options }, listOperationSpec$4);
    }
    /**
     * Returns customization policy by its name
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param customizationPolicyName customization policy name
     * @param options The options parameters.
     */
    get(regionId, pcName, customizationPolicyName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, customizationPolicyName, options }, getOperationSpec$4);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, pcName, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, pcName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/customizationPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomizationPoliciesListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/customizationPolicies/{customizationPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomizationPolicy
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName,
        customizationPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomizationPoliciesListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ResourcePools operations. */
class ResourcePoolsImpl {
    /**
     * Initialize a new instance of the class ResourcePools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of resource pools in region for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param options The options parameters.
     */
    list(regionId, pcName, options) {
        const iter = this.listPagingAll(regionId, pcName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, pcName, options, settings);
            }
        };
    }
    listPagingPage(regionId, pcName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, pcName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, pcName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, pcName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, pcName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of resource pools in region for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param options The options parameters.
     */
    _list(regionId, pcName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, options }, listOperationSpec$3);
    }
    /**
     * Returns resource pool templates by its name
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param resourcePoolName resource pool id (vsphereId)
     * @param options The options parameters.
     */
    get(regionId, pcName, resourcePoolName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, resourcePoolName, options }, getOperationSpec$3);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, pcName, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, pcName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/resourcePools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourcePoolsListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/resourcePools/{resourcePoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourcePool
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName,
        resourcePoolName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourcePoolsListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachineTemplates operations. */
class VirtualMachineTemplatesImpl {
    /**
     * Initialize a new instance of the class VirtualMachineTemplates class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of virtual machine templates in region for private cloud
     * @param pcName The private cloud name
     * @param regionId The region Id (westus, eastus)
     * @param resourcePoolName Resource pool used to derive vSphere cluster which contains VM templates
     * @param options The options parameters.
     */
    list(pcName, regionId, resourcePoolName, options) {
        const iter = this.listPagingAll(pcName, regionId, resourcePoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(pcName, regionId, resourcePoolName, options, settings);
            }
        };
    }
    listPagingPage(pcName, regionId, resourcePoolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(pcName, regionId, resourcePoolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(pcName, regionId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(pcName, regionId, resourcePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(pcName, regionId, resourcePoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of virtual machine templates in region for private cloud
     * @param pcName The private cloud name
     * @param regionId The region Id (westus, eastus)
     * @param resourcePoolName Resource pool used to derive vSphere cluster which contains VM templates
     * @param options The options parameters.
     */
    _list(pcName, regionId, resourcePoolName, options) {
        return this.client.sendOperationRequest({ pcName, regionId, resourcePoolName, options }, listOperationSpec$2);
    }
    /**
     * Returns virtual machine templates by its name
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param virtualMachineTemplateName virtual machine template id (vsphereId)
     * @param options The options parameters.
     */
    get(regionId, pcName, virtualMachineTemplateName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, virtualMachineTemplateName, options }, getOperationSpec$2);
    }
    /**
     * ListNext
     * @param pcName The private cloud name
     * @param regionId The region Id (westus, eastus)
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(pcName, regionId, nextLink, options) {
        return this.client.sendOperationRequest({ pcName, regionId, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/virtualMachineTemplates",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion, resourcePoolName1],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/virtualMachineTemplates/{virtualMachineTemplateName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplate
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName,
        virtualMachineTemplateName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineTemplateListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworks operations. */
class VirtualNetworksImpl {
    /**
     * Initialize a new instance of the class VirtualNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Return list of virtual networks in location for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param resourcePoolName Resource pool used to derive vSphere cluster which contains virtual networks
     * @param options The options parameters.
     */
    list(regionId, pcName, resourcePoolName, options) {
        const iter = this.listPagingAll(regionId, pcName, resourcePoolName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, pcName, resourcePoolName, options, settings);
            }
        };
    }
    listPagingPage(regionId, pcName, resourcePoolName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, pcName, resourcePoolName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, pcName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, pcName, resourcePoolName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, pcName, resourcePoolName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return list of virtual networks in location for private cloud
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param resourcePoolName Resource pool used to derive vSphere cluster which contains virtual networks
     * @param options The options parameters.
     */
    _list(regionId, pcName, resourcePoolName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, resourcePoolName, options }, listOperationSpec$1);
    }
    /**
     * Return virtual network by its name
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param virtualNetworkName virtual network id (vsphereId)
     * @param options The options parameters.
     */
    get(regionId, pcName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ regionId, pcName, virtualNetworkName, options }, getOperationSpec$1);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param pcName The private cloud name
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, pcName, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, pcName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion, resourcePoolName1],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/privateClouds/{pcName}/virtualNetworks/{virtualNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        pcName,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink,
        pcName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list of usage in region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    list(regionId, options) {
        const iter = this.listPagingAll(regionId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(regionId, options, settings);
            }
        };
    }
    listPagingPage(regionId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(regionId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(regionId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(regionId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(regionId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of usage in region
     * @param regionId The region Id (westus, eastus)
     * @param options The options parameters.
     */
    _list(regionId, options) {
        return this.client.sendOperationRequest({ regionId, options }, listOperationSpec);
    }
    /**
     * ListNext
     * @param regionId The region Id (westus, eastus)
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(regionId, nextLink, options) {
        return this.client.sendOperationRequest({ regionId, nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/locations/{regionId}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [
        $host,
        subscriptionId,
        regionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsageListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        regionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualMachines operations. */
class VirtualMachinesImpl {
    /**
     * Initialize a new instance of the class VirtualMachines class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns list virtual machine within subscription
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns list of virtual machine within resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns list virtual machine within subscription
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Returns list of virtual machine within resource group
     * @param resourceGroupName The name of the resource group
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Get virtual machine
     * @param resourceGroupName The name of the resource group
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualMachineName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineName, options }, getOperationSpec);
    }
    /**
     * Create Or Update Virtual Machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param virtualMachineRequest Create or Update Virtual Machine request
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, referer, virtualMachineName, virtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, {
                resourceGroupName,
                referer,
                virtualMachineName,
                virtualMachineRequest,
                options
            }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create Or Update Virtual Machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param virtualMachineRequest Create or Update Virtual Machine request
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, referer, virtualMachineName, virtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, referer, virtualMachineName, virtualMachineRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete virtual machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, referer, virtualMachineName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete virtual machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, referer, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch virtual machine properties
     * @param resourceGroupName The name of the resource group
     * @param virtualMachineName virtual machine name
     * @param virtualMachineRequest Patch virtual machine request
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, virtualMachineName, virtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, virtualMachineName, virtualMachineRequest, options }, updateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Patch virtual machine properties
     * @param resourceGroupName The name of the resource group
     * @param virtualMachineName virtual machine name
     * @param virtualMachineRequest Patch virtual machine request
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, virtualMachineName, virtualMachineRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, virtualMachineName, virtualMachineRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Power on virtual machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, referer, virtualMachineName, options }, startOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Power on virtual machine
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, referer, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Power off virtual machine, options: shutdown, poweroff, and suspend
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, referer, virtualMachineName, options }, stopOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Power off virtual machine, options: shutdown, poweroff, and suspend
     * @param resourceGroupName The name of the resource group
     * @param referer referer url
     * @param virtualMachineName virtual machine name
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, referer, virtualMachineName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, referer, virtualMachineName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.VMwareCloudSimple/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [
        apiVersion,
        filter,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualMachine,
            headersMapper: VirtualMachinesCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: VirtualMachine,
            headersMapper: VirtualMachinesCreateOrUpdateHeaders
        },
        202: {
            bodyMapper: VirtualMachine,
            headersMapper: VirtualMachinesCreateOrUpdateHeaders
        },
        204: {
            bodyMapper: VirtualMachine,
            headersMapper: VirtualMachinesCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: virtualMachineRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName1
    ],
    headerParameters: [
        accept,
        referer,
        contentType
    ],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            headersMapper: VirtualMachinesDeleteHeaders
        },
        201: {
            headersMapper: VirtualMachinesDeleteHeaders
        },
        202: {
            headersMapper: VirtualMachinesDeleteHeaders
        },
        204: {
            headersMapper: VirtualMachinesDeleteHeaders
        },
        default: {
            bodyMapper: CsrpError,
            headersMapper: VirtualMachinesDeleteExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, referer],
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualMachine
        },
        201: {
            bodyMapper: VirtualMachine
        },
        202: {
            bodyMapper: VirtualMachine
        },
        204: {
            bodyMapper: VirtualMachine
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    requestBody: virtualMachineRequest1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CsrpError,
            headersMapper: VirtualMachinesStartExceptionHeaders
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [accept, referer],
    serializer
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.VMwareCloudSimple/virtualMachines/{virtualMachineName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CsrpError,
            headersMapper: VirtualMachinesStopExceptionHeaders
        }
    },
    requestBody: m,
    queryParameters: [apiVersion, mode],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        virtualMachineName
    ],
    headerParameters: [
        accept,
        referer,
        contentType
    ],
    mediaType: "json",
    serializer
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualMachineListResponse
        },
        default: {
            bodyMapper: CsrpError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class VMwareCloudSimple extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the VMwareCloudSimple class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription ID.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-vmwarecloudsimple/3.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2019-04-01";
        this.operations = new OperationsImpl(this);
        this.dedicatedCloudNodes = new DedicatedCloudNodesImpl(this);
        this.dedicatedCloudServices = new DedicatedCloudServicesImpl(this);
        this.skusAvailability = new SkusAvailabilityImpl(this);
        this.privateClouds = new PrivateCloudsImpl(this);
        this.customizationPolicies = new CustomizationPoliciesImpl(this);
        this.resourcePools = new ResourcePoolsImpl(this);
        this.virtualMachineTemplates = new VirtualMachineTemplatesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualMachines = new VirtualMachinesImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.VMwareCloudSimple = VMwareCloudSimple;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
