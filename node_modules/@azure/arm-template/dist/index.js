'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
require('@azure/core-paging');
var coreClient = require('@azure/core-client');
var coreLro = require('@azure/core-lro');

/** Known values of {@link ProvisioningState} that the service accepts. */
(function (KnownProvisioningState) {
    KnownProvisioningState["Provisioning"] = "Provisioning";
    KnownProvisioningState["Deleting"] = "Deleting";
    KnownProvisioningState["Succeeded"] = "Succeeded";
    KnownProvisioningState["Failed"] = "Failed";
    KnownProvisioningState["Canceled"] = "Canceled";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
(function (KnownIoTSpacesSku) {
    KnownIoTSpacesSku["F1"] = "F1";
    KnownIoTSpacesSku["S1"] = "S1";
    KnownIoTSpacesSku["S2"] = "S2";
    KnownIoTSpacesSku["S3"] = "S3";
})(exports.KnownIoTSpacesSku || (exports.KnownIoTSpacesSku = {}));

const IoTSpacesProperties = {
    type: {
        name: "Composite",
        className: "IoTSpacesProperties",
        modelProperties: {
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            managementApiUrl: {
                serializedName: "managementApiUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            webPortalUrl: {
                serializedName: "webPortalUrl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            storageContainer: {
                serializedName: "storageContainer",
                type: {
                    name: "Composite",
                    className: "StorageContainerProperties"
                }
            }
        }
    }
};
const StorageContainerProperties = {
    type: {
        name: "Composite",
        className: "StorageContainerProperties",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            },
            subscriptionId: {
                serializedName: "subscriptionId",
                type: {
                    name: "String"
                }
            },
            resourceGroup: {
                serializedName: "resourceGroup",
                type: {
                    name: "String"
                }
            },
            containerName: {
                serializedName: "containerName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSpacesSkuInfo = {
    type: {
        name: "Composite",
        className: "IoTSpacesSkuInfo",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                constraints: {
                    Pattern: new RegExp("^(?![0-9]+$)(?!-)[a-zA-Z0-9-]{2,49}[a-zA-Z0-9]$")
                },
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                required: true,
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSpacesPatchDescription = {
    type: {
        name: "Composite",
        className: "IoTSpacesPatchDescription",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "IoTSpacesProperties"
                }
            }
        }
    }
};
const IoTSpacesDescriptionListResult = {
    type: {
        name: "Composite",
        className: "IoTSpacesDescriptionListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IoTSpacesDescription"
                        }
                    }
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationInputs = {
    type: {
        name: "Composite",
        className: "OperationInputs",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSpacesNameAvailabilityInfo = {
    type: {
        name: "Composite",
        className: "IoTSpacesNameAvailabilityInfo",
        modelProperties: {
            nameAvailable: {
                serializedName: "nameAvailable",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            reason: {
                serializedName: "reason",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Invalid", "AlreadyExists"]
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IoTSpacesDescription = {
    type: {
        name: "Composite",
        className: "IoTSpacesDescription",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "IoTSpacesProperties"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "IoTSpacesSkuInfo"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IoTSpacesProperties: IoTSpacesProperties,
    StorageContainerProperties: StorageContainerProperties,
    IoTSpacesSkuInfo: IoTSpacesSkuInfo,
    Resource: Resource,
    ErrorDetails: ErrorDetails,
    IoTSpacesPatchDescription: IoTSpacesPatchDescription,
    IoTSpacesDescriptionListResult: IoTSpacesDescriptionListResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationInputs: OperationInputs,
    IoTSpacesNameAvailabilityInfo: IoTSpacesNameAvailabilityInfo,
    IoTSpacesDescription: IoTSpacesDescription
});

const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2017-10-01-preview",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        constraints: {
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        constraints: {
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const iotSpaceDescription = {
    parameterPath: "iotSpaceDescription",
    mapper: IoTSpacesDescription
};
const iotSpacePatchDescription = {
    parameterPath: "iotSpacePatchDescription",
    mapper: IoTSpacesPatchDescription
};
const operationInputs = {
    parameterPath: "operationInputs",
    mapper: OperationInputs
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

// Copyright (c) Microsoft Corporation.
function getResponseStatus(rawResponse) {
    var _a, _b;
    const { status } = (_a = rawResponse.parsedBody) !== null && _a !== void 0 ? _a : (rawResponse.bodyAsText ? JSON.parse(rawResponse.bodyAsText) : {});
    return (_b = status === null || status === void 0 ? void 0 : status.toLowerCase()) !== null && _b !== void 0 ? _b : "succeeded";
}
function isAzureAsyncPollingDone(rawResponse) {
    const state = getResponseStatus(rawResponse);
    if (failureStates.includes(state)) {
        throw new Error(`Operation status: ${state}`);
    }
    return successStates.includes(state);
}
function processAzureAsyncOperationResult(restrieveResource, resourceLocation, finalStateVia) {
    return (rawResponse, flatResponse) => {
        if (isAzureAsyncPollingDone(rawResponse)) {
            if (resourceLocation === undefined) {
                return { rawResponse, flatResponse, done: true };
            }
            else {
                return {
                    rawResponse,
                    flatResponse,
                    done: false,
                    next: () => tslib.__awaiter(this, void 0, void 0, function* () {
                        function sendFinalRequest() {
                            return tslib.__awaiter(this, void 0, void 0, function* () {
                                switch (finalStateVia) {
                                    case "original-uri":
                                        return restrieveResource();
                                    case "azure-async-operation":
                                        return Promise.resolve(undefined);
                                    case "location":
                                    default:
                                        return restrieveResource(resourceLocation);
                                }
                            });
                        }
                        const finalResponse = yield sendFinalRequest();
                        return Object.assign(Object.assign({}, (finalResponse !== null && finalResponse !== void 0 ? finalResponse : {
                            rawResponse,
                            flatResponse
                        })), { done: true });
                    })
                };
            }
        }
        return {
            rawResponse,
            flatResponse,
            done: false
        };
    };
}

// Copyright (c) Microsoft Corporation.
function getProvisioningState(rawResponse) {
    var _a, _b, _c;
    const { properties, provisioningState } = (_a = rawResponse.parsedBody) !== null && _a !== void 0 ? _a : (rawResponse.bodyAsText ? JSON.parse(rawResponse.bodyAsText) : {});
    const state = (_b = properties === null || properties === void 0 ? void 0 : properties.provisioningState) !== null && _b !== void 0 ? _b : provisioningState;
    return (_c = state === null || state === void 0 ? void 0 : state.toLowerCase()) !== null && _c !== void 0 ? _c : "succeeded";
}
function isBodyPollingDone(rawResponse) {
    const state = getProvisioningState(rawResponse);
    if (failureStates.includes(state)) {
        throw new Error(`Provisioning state: ${state}`);
    }
    return successStates.includes(state);
}
/**
 * Creates a polling strategy based on BodyPolling which uses the provisioning state
 * from the result to determine the current operation state
 */
function processBodyPollingOperationResult(rawResponse, flatResponse) {
    return {
        rawResponse,
        flatResponse,
        done: isBodyPollingDone(rawResponse)
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
function isLocationPollingDone(rawResponse) {
    const code = rawResponse.status;
    if (![202, 200].includes(code)) {
        throw new Error(`Operation failed`);
    }
    return code !== 202;
}
function processLocationPollingOperationResult(rawResponse, flatResponse) {
    return {
        rawResponse,
        flatResponse,
        done: isLocationPollingDone(rawResponse)
    };
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
function processPassthroughOperationResult(rawResponse, flatResponse) {
    return {
        rawResponse,
        flatResponse,
        done: true
    };
}

// Copyright (c) Microsoft Corporation.
function createPollingMethod(sendOperationFn, args, spec, mode) {
    /**
     * Polling calls will always return a status object i.e. {"status": "success"}
     * these intermediate responses are not described in the swagger so we need to
     * pass custom mappers at runtime.
     * This function replaces all the existing mappers to be able to deserialize a status object
     * @param responses Original set of responses defined in the operation
     */
    function getCompositeMappers(responses) {
        return Object.keys(responses).reduce((acc, statusCode) => {
            return Object.assign(Object.assign({}, acc), { [statusCode]: Object.assign(Object.assign({}, responses[statusCode]), { bodyMapper: {
                        type: {
                            name: "Composite",
                            modelProperties: {
                                status: {
                                    serializedName: "status",
                                    type: {
                                        name: "String"
                                    }
                                }
                            }
                        }
                    } }) });
        }, {});
    }
    // Make sure we don't send any body to the get request
    const { requestBody, responses } = spec, restSpec = tslib.__rest(spec, ["requestBody", "responses"]);
    if (mode === "AzureAsync") {
        return (path) => tslib.__awaiter(this, void 0, void 0, function* () {
            return sendOperationFn(args, Object.assign(Object.assign(Object.assign({}, restSpec), { responses: getCompositeMappers(responses), httpMethod: "GET" }), (path && { path })));
        });
    }
    return (path) => tslib.__awaiter(this, void 0, void 0, function* () {
        return sendOperationFn(args, Object.assign(Object.assign(Object.assign({}, restSpec), { responses: responses, httpMethod: "GET" }), (path && { path })));
    });
}
function createRetrieveAzureAsyncResource(sendOperationFn, args, spec) {
    const updatedArgs = Object.assign({}, args);
    if (updatedArgs.options) {
        updatedArgs.options.shouldDeserialize = true;
    }
    return createPollingMethod(sendOperationFn, updatedArgs, spec);
}

// Copyright (c) Microsoft Corporation.
const successStates = ["succeeded"];
const failureStates = ["failed", "canceled", "cancelled"];
/**
 * creates a stepping function that maps an LRO state to another.
 */
function createTransition(sendOperationFn, args, spec, config, finalStateVia) {
    switch (config.mode) {
        case "AzureAsync": {
            return processAzureAsyncOperationResult(createRetrieveAzureAsyncResource(sendOperationFn, args, spec), config.resourceLocation, finalStateVia);
        }
        case "Location": {
            return processLocationPollingOperationResult;
        }
        case "Body": {
            return processBodyPollingOperationResult;
        }
        default: {
            return processPassthroughOperationResult;
        }
    }
}
/**
 * Creates a polling operation that returns a LRO state.
 */
function createGetLROState(sendOperationFn, args, spec, config, finalStateVia) {
    var _a;
    const step = createTransition(sendOperationFn, args, spec, config, finalStateVia);
    const customerCallback = (_a = args === null || args === void 0 ? void 0 : args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
    let response = undefined;
    let retryAfter = undefined;
    const poll = createPollingMethod(sendOperationFn, Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: (rawResponse, flatResponse) => {
                response = step(rawResponse, flatResponse);
                retryAfter = rawResponse.headers.get("Retry-After");
                if (response.done) {
                    customerCallback === null || customerCallback === void 0 ? void 0 : customerCallback(rawResponse, flatResponse);
                }
            } }) }), spec, config.mode);
    return (path, pollerConfig) => tslib.__awaiter(this, void 0, void 0, function* () {
        yield poll(path);
        if (retryAfter !== undefined) {
            const retryAfterInMs = parseInt(retryAfter);
            pollerConfig.intervalInMs = isNaN(retryAfterInMs)
                ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)
                : retryAfterInMs;
        }
        return response;
    });
}
function calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
    }
    return defaultIntervalInMs;
}
/**
 * Creates a callback to be used to initialize the polling operation state.
 * @param state of the polling operation
 * @param operationSpec of the LRO
 * @param callback callback to be called when the operation is done
 * @returns callback that initializes the state of the polling operation
 */
function initializeState(state, operationSpec, callback) {
    return (rawResponse, flatResponse) => {
        state.initialRawResponse = rawResponse;
        state.isStarted = true;
        state.pollingURL = getPollingURL(state.initialRawResponse, getSpecPath(operationSpec));
        state.config = inferLROMode(operationSpec, state.initialRawResponse);
        /** short circuit polling if body polling is done in the initial request */
        if (state.config.mode === undefined ||
            (state.config.mode === "Body" &&
                isBodyPollingDone(state.initialRawResponse))) {
            state.result = flatResponse;
            state.isCompleted = true;
            /**
             * We need to check if the LRO operation is finished inside the
             * call back so that we can call the customer-provided callback
             * on that result.
             */
            callback === null || callback === void 0 ? void 0 : callback(rawResponse, flatResponse);
        }
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Detects where the continuation token is and returns it. Notice that azure-asyncoperation
 * must be checked first before the other location headers because there are scenarios
 * where both azure-asyncoperation and location could be present in the same response but
 * azure-asyncoperation should be the one to use for polling.
 */
function getPollingURL(rawResponse, defaultPath) {
    var _a, _b, _c;
    return ((_c = (_b = (_a = getAzureAsyncoperation(rawResponse)) !== null && _a !== void 0 ? _a : getLocation(rawResponse)) !== null && _b !== void 0 ? _b : getOperationLocation(rawResponse)) !== null && _c !== void 0 ? _c : defaultPath);
}
function getLocation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("location");
}
function getOperationLocation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("operation-location");
}
function getAzureAsyncoperation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("azure-asyncoperation");
}
function inferLROMode(spec, rawResponse) {
    const requestMethod = spec.httpMethod;
    if (getAzureAsyncoperation(rawResponse) !== undefined) {
        return {
            mode: "AzureAsync",
            resourceLocation: requestMethod === "PUT"
                ? spec.path
                : requestMethod === "POST"
                    ? getLocation(rawResponse)
                    : undefined
        };
    }
    else if (getLocation(rawResponse) !== undefined ||
        getOperationLocation(rawResponse) !== undefined) {
        return {
            mode: "Location"
        };
    }
    else if (["PUT", "PATCH"].includes(requestMethod)) {
        return {
            mode: "Body"
        };
    }
    return {};
}
function getSpecPath(spec) {
    if (spec.path) {
        return spec.path;
    }
    else {
        throw Error("Bad spec: request path is not found!");
    }
}

// Copyright (c) Microsoft Corporation.
class GenericPollOperation {
    constructor(state, initialOperationArguments, initialOperationSpec, sendOperation, finalStateVia) {
        this.state = state;
        this.initialOperationArguments = initialOperationArguments;
        this.initialOperationSpec = initialOperationSpec;
        this.sendOperation = sendOperation;
        this.finalStateVia = finalStateVia;
    }
    setPollerConfig(pollerConfig) {
        this.pollerConfig = pollerConfig;
    }
    /**
     * General update function for LROPoller, the general process is as follows
     * 1. Check initial operation result to determine the strategy to use
     *  - Strategies: Location, Azure-AsyncOperation, Original Uri
     * 2. Check if the operation result has a terminal state
     *  - Terminal state will be determined by each strategy
     *  2.1 If it is terminal state Check if a final GET request is required, if so
     *      send final GET request and return result from operation. If no final GET
     *      is required, just return the result from operation.
     *      - Determining what to call for final request is responsibility of each strategy
     *  2.2 If it is not terminal state, call the polling operation and go to step 1
     *      - Determining what to call for polling is responsibility of each strategy
     *      - Strategies will always use the latest URI for polling if provided otherwise
     *        the last known one
     */
    update(options) {
        var _a;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const _b = this.initialOperationArguments.options || {}, { onResponse } = _b, restOptions = tslib.__rest(_b, ["onResponse"]);
            if (!state.isStarted) {
                yield this.sendOperation(Object.assign(Object.assign({}, this.initialOperationArguments), { options: Object.assign(Object.assign({}, restOptions), { onResponse: initializeState(state, this.initialOperationSpec, onResponse) }) }), this.initialOperationSpec);
            }
            if (!state.isCompleted) {
                if (this.getLROState === undefined) {
                    if (state.config === undefined) {
                        throw new Error("Bad state: LRO mode is undefined");
                    }
                    this.getLROState = createGetLROState(this.sendOperation, this.initialOperationArguments, this.initialOperationSpec, state.config, this.finalStateVia);
                }
                if (state.pollingURL === undefined) {
                    throw new Error("Bad state: polling URL is undefined");
                }
                const currentState = yield this.getLROState(state.pollingURL, this.pollerConfig);
                if (currentState.done) {
                    state.result = currentState.flatResponse;
                    state.isCompleted = true;
                }
                else {
                    this.getLROState = (_a = currentState.next) !== null && _a !== void 0 ? _a : this.getLROState;
                    state.pollingURL = getPollingURL(currentState.rawResponse, state.pollingURL);
                }
            }
            if ((options === null || options === void 0 ? void 0 : options.fireProgress) !== undefined) {
                options.fireProgress(state);
            }
            return this;
        });
    }
    cancel() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            this.state.isCancelled = true;
            return this;
        });
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state
        });
    }
}

// Copyright (c) Microsoft Corporation.
class LROPoller extends coreLro.Poller {
    constructor({ intervalInMs = 2000, resumeFrom }, initialOperationArguments, initialOperationSpec, sendOperation, finalStateVia) {
        const state = resumeFrom
            ? JSON.parse(resumeFrom).state
            : {};
        const operation = new GenericPollOperation(state, initialOperationArguments, initialOperationSpec, sendOperation, finalStateVia);
        super(operation);
        this.intervalInMs = intervalInMs;
        operation.setPollerConfig(this);
    }
    /**
     * The method used by the poller to wait before attempting to update its operation.
     */
    delay() {
        return new Promise((resolve) => setTimeout(() => resolve(), this.intervalInMs));
    }
}

/// <reference lib="esnext.asynciterable" />
/** Class representing a IoTSpaces. */
class IoTSpacesImpl {
    /**
     * Initialize a new instance of the class IoTSpaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all the IoTSpaces instances in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all the IoTSpaces instances in a resource group.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listByResourceGroupPagingPage(resourceGroupName, options);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Get the metadata of a IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param options The options parameters.
     */
    get(resourceGroupName, resourceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, resourceName, options }, getOperationSpec);
    }
    /**
     * Create or update the metadata of an IoTSpaces instance. The usual pattern to modify a property is to
     * retrieve the IoTSpaces instance metadata and security metadata, and then combine them with the
     * modified values in a new body to update the IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param iotSpaceDescription The IoTSpaces instance metadata and security metadata.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, resourceName, iotSpaceDescription, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return { flatResponse, rawResponse: currentRawResponse };
            });
            return new LROPoller({ intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs }, { resourceGroupName, resourceName, iotSpaceDescription, options }, createOrUpdateOperationSpec, sendOperation);
        });
    }
    /**
     * Create or update the metadata of an IoTSpaces instance. The usual pattern to modify a property is to
     * retrieve the IoTSpaces instance metadata and security metadata, and then combine them with the
     * modified values in a new body to update the IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param iotSpaceDescription The IoTSpaces instance metadata and security metadata.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, resourceName, iotSpaceDescription, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, resourceName, iotSpaceDescription, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update the metadata of a IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param iotSpacePatchDescription The IoTSpaces instance metadata and security metadata.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, resourceName, iotSpacePatchDescription, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return { flatResponse, rawResponse: currentRawResponse };
            });
            return new LROPoller({ intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs }, { resourceGroupName, resourceName, iotSpacePatchDescription, options }, updateOperationSpec, sendOperation);
        });
    }
    /**
     * Update the metadata of a IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param iotSpacePatchDescription The IoTSpaces instance metadata and security metadata.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, resourceName, iotSpacePatchDescription, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, resourceName, iotSpacePatchDescription, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Delete an IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return { flatResponse, rawResponse: currentRawResponse };
            });
            return new LROPoller({ intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs }, { resourceGroupName, resourceName, options }, deleteOperationSpec, sendOperation);
        });
    }
    /**
     * Delete an IoTSpaces instance.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param resourceName The name of the IoTSpaces instance.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, resourceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, resourceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get all the IoTSpaces instances in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * Get all the IoTSpaces instances in a resource group.
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Check if an IoTSpaces instance name is available.
     * @param operationInputs Set the name parameter in the OperationInputs structure to the name of the
     *                        IoTSpaces instance to check.
     * @param options The options parameters.
     */
    checkNameAvailability(operationInputs, options) {
        return this.client.sendOperationRequest({ operationInputs, options }, checkNameAvailabilityOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group that contains the IoTSpaces instance.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTSpaces/Graph/{resourceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescription
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName
    ],
    headerParameters: [accept],
    serializer
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTSpaces/Graph/{resourceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescription
        },
        201: {
            bodyMapper: IoTSpacesDescription
        },
        202: {
            bodyMapper: IoTSpacesDescription
        },
        204: {
            bodyMapper: IoTSpacesDescription
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    requestBody: iotSpaceDescription,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTSpaces/Graph/{resourceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescription
        },
        201: {
            bodyMapper: IoTSpacesDescription
        },
        202: {
            bodyMapper: IoTSpacesDescription
        },
        204: {
            bodyMapper: IoTSpacesDescription
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    requestBody: iotSpacePatchDescription,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTSpaces/Graph/{resourceName}",
    httpMethod: "DELETE",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescription
        },
        201: {
            bodyMapper: IoTSpacesDescription
        },
        202: {
            bodyMapper: IoTSpacesDescription
        },
        204: {
            bodyMapper: IoTSpacesDescription
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        resourceName
    ],
    headerParameters: [accept],
    serializer
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.IoTSpaces/Graph",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescriptionListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.IoTSpaces/Graph",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescriptionListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName
    ],
    headerParameters: [accept],
    serializer
};
const checkNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.IoTSpaces/checkNameAvailability",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IoTSpacesNameAvailabilityInfo
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    requestBody: operationInputs,
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescriptionListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IoTSpacesDescriptionListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        resourceGroupName,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/// <reference lib="esnext.asynciterable" />
/** Class representing a Operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available IoTSpaces service REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listPagingPage(options);
            }
        };
    }
    listPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result = yield tslib.__await(this._list(options));
            yield yield tslib.__await(result.value || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.value || []);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available IoTSpaces service REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$1 = coreClient.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.IoTSpaces/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: ErrorDetails
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};

class IoTSpacesClientContext extends coreClient.ServiceClient {
    /**
     * Initializes a new instance of the IoTSpacesClientContext class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription identifier.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-iotspaces/1.0.0-beta.1`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        if (!options.credentialScopes) {
            options.credentialScopes = ["https://management.azure.com/.default"];
        }
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, baseUri: options.endpoint || "https://management.azure.com" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2017-10-01-preview";
    }
}

class IoTSpacesClient extends IoTSpacesClientContext {
    /**
     * Initializes a new instance of the IoTSpacesClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription identifier.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        super(credentials, subscriptionId, options);
        this.ioTSpaces = new IoTSpacesImpl(this);
        this.operations = new OperationsImpl(this);
    }
}

exports.IoTSpacesClient = IoTSpacesClient;
exports.IoTSpacesClientContext = IoTSpacesClientContext;
//# sourceMappingURL=index.js.map
