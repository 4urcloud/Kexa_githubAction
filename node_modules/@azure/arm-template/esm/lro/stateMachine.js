// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { processAzureAsyncOperationResult } from "./azureAsyncPolling";
import { isBodyPollingDone, processBodyPollingOperationResult } from "./bodyPolling";
import { processLocationPollingOperationResult } from "./locationPolling";
import { processPassthroughOperationResult } from "./passthrough";
import { createPollingMethod, createRetrieveAzureAsyncResource } from "./pollingMethod";
import { getPollingURL, getSpecPath, inferLROMode } from "./requestUtils";
export const successStates = ["succeeded"];
export const failureStates = ["failed", "canceled", "cancelled"];
export const terminalStates = successStates.concat(failureStates);
/**
 * creates a stepping function that maps an LRO state to another.
 */
function createTransition(sendOperationFn, args, spec, config, finalStateVia) {
    switch (config.mode) {
        case "AzureAsync": {
            return processAzureAsyncOperationResult(createRetrieveAzureAsyncResource(sendOperationFn, args, spec), config.resourceLocation, finalStateVia);
        }
        case "Location": {
            return processLocationPollingOperationResult;
        }
        case "Body": {
            return processBodyPollingOperationResult;
        }
        default: {
            return processPassthroughOperationResult;
        }
    }
}
/**
 * Creates a polling operation that returns a LRO state.
 */
export function createGetLROState(sendOperationFn, args, spec, config, finalStateVia) {
    var _a;
    const step = createTransition(sendOperationFn, args, spec, config, finalStateVia);
    const customerCallback = (_a = args === null || args === void 0 ? void 0 : args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
    let response = undefined;
    let retryAfter = undefined;
    const poll = createPollingMethod(sendOperationFn, Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: (rawResponse, flatResponse) => {
                response = step(rawResponse, flatResponse);
                retryAfter = rawResponse.headers.get("Retry-After");
                if (response.done) {
                    customerCallback === null || customerCallback === void 0 ? void 0 : customerCallback(rawResponse, flatResponse);
                }
            } }) }), spec, config.mode);
    return (path, pollerConfig) => __awaiter(this, void 0, void 0, function* () {
        yield poll(path);
        if (retryAfter !== undefined) {
            const retryAfterInMs = parseInt(retryAfter);
            pollerConfig.intervalInMs = isNaN(retryAfterInMs)
                ? calculatePollingIntervalFromDate(new Date(retryAfter), pollerConfig.intervalInMs)
                : retryAfterInMs;
        }
        return response;
    });
}
function calculatePollingIntervalFromDate(retryAfterDate, defaultIntervalInMs) {
    const timeNow = Math.floor(new Date().getTime());
    const retryAfterTime = retryAfterDate.getTime();
    if (timeNow < retryAfterTime) {
        return retryAfterTime - timeNow;
    }
    return defaultIntervalInMs;
}
/**
 * Creates a callback to be used to initialize the polling operation state.
 * @param state of the polling operation
 * @param operationSpec of the LRO
 * @param callback callback to be called when the operation is done
 * @returns callback that initializes the state of the polling operation
 */
export function initializeState(state, operationSpec, callback) {
    return (rawResponse, flatResponse) => {
        state.initialRawResponse = rawResponse;
        state.isStarted = true;
        state.pollingURL = getPollingURL(state.initialRawResponse, getSpecPath(operationSpec));
        state.config = inferLROMode(operationSpec, state.initialRawResponse);
        /** short circuit polling if body polling is done in the initial request */
        if (state.config.mode === undefined ||
            (state.config.mode === "Body" &&
                isBodyPollingDone(state.initialRawResponse))) {
            state.result = flatResponse;
            state.isCompleted = true;
            /**
             * We need to check if the LRO operation is finished inside the
             * call back so that we can call the customer-provided callback
             * on that result.
             */
            callback === null || callback === void 0 ? void 0 : callback(rawResponse, flatResponse);
        }
    };
}
//# sourceMappingURL=stateMachine.js.map