// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __awaiter, __rest } from "tslib";
import { getPollingURL } from "./requestUtils";
import { createGetLROState, initializeState } from "./stateMachine";
export class GenericPollOperation {
    constructor(state, initialOperationArguments, initialOperationSpec, sendOperation, finalStateVia) {
        this.state = state;
        this.initialOperationArguments = initialOperationArguments;
        this.initialOperationSpec = initialOperationSpec;
        this.sendOperation = sendOperation;
        this.finalStateVia = finalStateVia;
    }
    setPollerConfig(pollerConfig) {
        this.pollerConfig = pollerConfig;
    }
    /**
     * General update function for LROPoller, the general process is as follows
     * 1. Check initial operation result to determine the strategy to use
     *  - Strategies: Location, Azure-AsyncOperation, Original Uri
     * 2. Check if the operation result has a terminal state
     *  - Terminal state will be determined by each strategy
     *  2.1 If it is terminal state Check if a final GET request is required, if so
     *      send final GET request and return result from operation. If no final GET
     *      is required, just return the result from operation.
     *      - Determining what to call for final request is responsibility of each strategy
     *  2.2 If it is not terminal state, call the polling operation and go to step 1
     *      - Determining what to call for polling is responsibility of each strategy
     *      - Strategies will always use the latest URI for polling if provided otherwise
     *        the last known one
     */
    update(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.state;
            const _b = this.initialOperationArguments.options || {}, { onResponse } = _b, restOptions = __rest(_b, ["onResponse"]);
            if (!state.isStarted) {
                yield this.sendOperation(Object.assign(Object.assign({}, this.initialOperationArguments), { options: Object.assign(Object.assign({}, restOptions), { onResponse: initializeState(state, this.initialOperationSpec, onResponse) }) }), this.initialOperationSpec);
            }
            if (!state.isCompleted) {
                if (this.getLROState === undefined) {
                    if (state.config === undefined) {
                        throw new Error("Bad state: LRO mode is undefined");
                    }
                    this.getLROState = createGetLROState(this.sendOperation, this.initialOperationArguments, this.initialOperationSpec, state.config, this.finalStateVia);
                }
                if (state.pollingURL === undefined) {
                    throw new Error("Bad state: polling URL is undefined");
                }
                const currentState = yield this.getLROState(state.pollingURL, this.pollerConfig);
                if (currentState.done) {
                    state.result = currentState.flatResponse;
                    state.isCompleted = true;
                }
                else {
                    this.getLROState = (_a = currentState.next) !== null && _a !== void 0 ? _a : this.getLROState;
                    state.pollingURL = getPollingURL(currentState.rawResponse, state.pollingURL);
                }
            }
            if ((options === null || options === void 0 ? void 0 : options.fireProgress) !== undefined) {
                options.fireProgress(state);
            }
            return this;
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            this.state.isCancelled = true;
            return this;
        });
    }
    /**
     * Serializes the Poller operation.
     */
    toString() {
        return JSON.stringify({
            state: this.state
        });
    }
}
//# sourceMappingURL=operation.js.map