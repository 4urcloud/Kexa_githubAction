// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { terminalStates } from "./stateMachine";
/**
 * We need to selectively deserialize our responses, only deserializing if we
 * are in a final LRO response, not deserializing any polling non-terminal responses
 */
export function shouldDeserializeLRO(finalStateVia) {
    let initialOperationInfo;
    let isInitialRequest = true;
    return (response) => {
        if (response.status < 200 || response.status >= 300) {
            return true;
        }
        if (!initialOperationInfo) {
            initialOperationInfo = getLROData(response);
        }
        else {
            isInitialRequest = false;
        }
        if (initialOperationInfo.azureAsyncOperation ||
            initialOperationInfo.operationLocation) {
            return (!isInitialRequest &&
                isAsyncOperationFinalResponse(response, initialOperationInfo, finalStateVia));
        }
        if (initialOperationInfo.location) {
            return isLocationFinalResponse(response);
        }
        if (initialOperationInfo.requestMethod === "PUT") {
            return isBodyPollingFinalResponse(response);
        }
        return true;
    };
}
function isAsyncOperationFinalResponse(response, initialOperationInfo, finalStateVia) {
    var _a;
    const status = ((_a = response.parsedBody) === null || _a === void 0 ? void 0 : _a.status) || "Succeeded";
    if (!terminalStates.includes(status.toLowerCase())) {
        return false;
    }
    if (initialOperationInfo.requestMethod === "DELETE") {
        return true;
    }
    if (initialOperationInfo.requestMethod === "PUT" &&
        finalStateVia &&
        finalStateVia.toLowerCase() === "azure-asyncoperation") {
        return true;
    }
    if (initialOperationInfo.requestMethod !== "PUT" &&
        !initialOperationInfo.location) {
        return true;
    }
    return false;
}
function isLocationFinalResponse(response) {
    return response.status !== 202;
}
function isBodyPollingFinalResponse(response) {
    var _a, _b;
    const provisioningState = ((_b = (_a = response.parsedBody) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.provisioningState) || "Succeeded";
    if (terminalStates.includes(provisioningState.toLowerCase())) {
        return true;
    }
    return false;
}
function getLROData(result) {
    return {
        azureAsyncOperation: result.headers.get("azure-asyncoperation"),
        operationLocation: result.headers.get("operation-location"),
        location: result.headers.get("location"),
        requestMethod: result.request.method
    };
}
/**
 * Detects where the continuation token is and returns it. Notice that azure-asyncoperation
 * must be checked first before the other location headers because there are scenarios
 * where both azure-asyncoperation and location could be present in the same response but
 * azure-asyncoperation should be the one to use for polling.
 */
export function getPollingURL(rawResponse, defaultPath) {
    var _a, _b, _c;
    return ((_c = (_b = (_a = getAzureAsyncoperation(rawResponse)) !== null && _a !== void 0 ? _a : getLocation(rawResponse)) !== null && _b !== void 0 ? _b : getOperationLocation(rawResponse)) !== null && _c !== void 0 ? _c : defaultPath);
}
function getLocation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("location");
}
function getOperationLocation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("operation-location");
}
function getAzureAsyncoperation(rawResponse) {
    var _a;
    return (_a = rawResponse.headers) === null || _a === void 0 ? void 0 : _a.get("azure-asyncoperation");
}
export function inferLROMode(spec, rawResponse) {
    const requestMethod = spec.httpMethod;
    if (getAzureAsyncoperation(rawResponse) !== undefined) {
        return {
            mode: "AzureAsync",
            resourceLocation: requestMethod === "PUT"
                ? spec.path
                : requestMethod === "POST"
                    ? getLocation(rawResponse)
                    : undefined
        };
    }
    else if (getLocation(rawResponse) !== undefined ||
        getOperationLocation(rawResponse) !== undefined) {
        return {
            mode: "Location"
        };
    }
    else if (["PUT", "PATCH"].includes(requestMethod)) {
        return {
            mode: "Body"
        };
    }
    return {};
}
export function getSpecPath(spec) {
    if (spec.path) {
        return spec.path;
    }
    else {
        throw Error("Bad spec: request path is not found!");
    }
}
//# sourceMappingURL=requestUtils.js.map