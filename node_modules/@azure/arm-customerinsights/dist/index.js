'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given a result page from a pageable operation, returns a
 * continuation token that can be used to begin paging from
 * that point later.
 * @param page A result object from calling .byPage() on a paged operation.
 * @returns The continuation token that can be passed into byPage().
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link DataSourceType} that the service accepts. */
exports.KnownDataSourceType = void 0;
(function (KnownDataSourceType) {
    /** Connector */
    KnownDataSourceType["Connector"] = "Connector";
    /** LinkInteraction */
    KnownDataSourceType["LinkInteraction"] = "LinkInteraction";
    /** SystemDefault */
    KnownDataSourceType["SystemDefault"] = "SystemDefault";
})(exports.KnownDataSourceType || (exports.KnownDataSourceType = {}));
/** Known values of {@link Status} that the service accepts. */
exports.KnownStatus = void 0;
(function (KnownStatus) {
    /** None */
    KnownStatus["None"] = "None";
    /** Active */
    KnownStatus["Active"] = "Active";
    /** Deleted */
    KnownStatus["Deleted"] = "Deleted";
})(exports.KnownStatus || (exports.KnownStatus = {}));
/** Known values of {@link ProvisioningStates} that the service accepts. */
exports.KnownProvisioningStates = void 0;
(function (KnownProvisioningStates) {
    /** Provisioning */
    KnownProvisioningStates["Provisioning"] = "Provisioning";
    /** Succeeded */
    KnownProvisioningStates["Succeeded"] = "Succeeded";
    /** Expiring */
    KnownProvisioningStates["Expiring"] = "Expiring";
    /** Deleting */
    KnownProvisioningStates["Deleting"] = "Deleting";
    /** HumanIntervention */
    KnownProvisioningStates["HumanIntervention"] = "HumanIntervention";
    /** Failed */
    KnownProvisioningStates["Failed"] = "Failed";
})(exports.KnownProvisioningStates || (exports.KnownProvisioningStates = {}));
/** Known values of {@link ConnectorTypes} that the service accepts. */
exports.KnownConnectorTypes = void 0;
(function (KnownConnectorTypes) {
    /** None */
    KnownConnectorTypes["None"] = "None";
    /** CRM */
    KnownConnectorTypes["CRM"] = "CRM";
    /** AzureBlob */
    KnownConnectorTypes["AzureBlob"] = "AzureBlob";
    /** Salesforce */
    KnownConnectorTypes["Salesforce"] = "Salesforce";
    /** ExchangeOnline */
    KnownConnectorTypes["ExchangeOnline"] = "ExchangeOnline";
    /** Outbound */
    KnownConnectorTypes["Outbound"] = "Outbound";
})(exports.KnownConnectorTypes || (exports.KnownConnectorTypes = {}));
/** Known values of {@link CanonicalPropertyValueType} that the service accepts. */
exports.KnownCanonicalPropertyValueType = void 0;
(function (KnownCanonicalPropertyValueType) {
    /** Numeric */
    KnownCanonicalPropertyValueType["Numeric"] = "Numeric";
    /** Categorical */
    KnownCanonicalPropertyValueType["Categorical"] = "Categorical";
    /** DerivedCategorical */
    KnownCanonicalPropertyValueType["DerivedCategorical"] = "DerivedCategorical";
    /** DerivedNumeric */
    KnownCanonicalPropertyValueType["DerivedNumeric"] = "DerivedNumeric";
})(exports.KnownCanonicalPropertyValueType || (exports.KnownCanonicalPropertyValueType = {}));
/** Known values of {@link PredictionModelLifeCycle} that the service accepts. */
exports.KnownPredictionModelLifeCycle = void 0;
(function (KnownPredictionModelLifeCycle) {
    /** New */
    KnownPredictionModelLifeCycle["New"] = "New";
    /** Provisioning */
    KnownPredictionModelLifeCycle["Provisioning"] = "Provisioning";
    /** ProvisioningFailed */
    KnownPredictionModelLifeCycle["ProvisioningFailed"] = "ProvisioningFailed";
    /** PendingDiscovering */
    KnownPredictionModelLifeCycle["PendingDiscovering"] = "PendingDiscovering";
    /** Discovering */
    KnownPredictionModelLifeCycle["Discovering"] = "Discovering";
    /** PendingFeaturing */
    KnownPredictionModelLifeCycle["PendingFeaturing"] = "PendingFeaturing";
    /** Featuring */
    KnownPredictionModelLifeCycle["Featuring"] = "Featuring";
    /** FeaturingFailed */
    KnownPredictionModelLifeCycle["FeaturingFailed"] = "FeaturingFailed";
    /** PendingTraining */
    KnownPredictionModelLifeCycle["PendingTraining"] = "PendingTraining";
    /** Training */
    KnownPredictionModelLifeCycle["Training"] = "Training";
    /** TrainingFailed */
    KnownPredictionModelLifeCycle["TrainingFailed"] = "TrainingFailed";
    /** Evaluating */
    KnownPredictionModelLifeCycle["Evaluating"] = "Evaluating";
    /** EvaluatingFailed */
    KnownPredictionModelLifeCycle["EvaluatingFailed"] = "EvaluatingFailed";
    /** PendingModelConfirmation */
    KnownPredictionModelLifeCycle["PendingModelConfirmation"] = "PendingModelConfirmation";
    /** Active */
    KnownPredictionModelLifeCycle["Active"] = "Active";
    /** Deleted */
    KnownPredictionModelLifeCycle["Deleted"] = "Deleted";
    /** HumanIntervention */
    KnownPredictionModelLifeCycle["HumanIntervention"] = "HumanIntervention";
    /** Failed */
    KnownPredictionModelLifeCycle["Failed"] = "Failed";
})(exports.KnownPredictionModelLifeCycle || (exports.KnownPredictionModelLifeCycle = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HubBillingInfoFormat = {
    type: {
        name: "Composite",
        className: "HubBillingInfoFormat",
        modelProperties: {
            skuName: {
                serializedName: "skuName",
                type: {
                    name: "String"
                }
            },
            minUnits: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 1
                },
                serializedName: "minUnits",
                type: {
                    name: "Number"
                }
            },
            maxUnits: {
                constraints: {
                    InclusiveMaximum: 10,
                    InclusiveMinimum: 1
                },
                serializedName: "maxUnits",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const HubListResult = {
    type: {
        name: "Composite",
        className: "HubListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Hub"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StrongId = {
    type: {
        name: "Composite",
        className: "StrongId",
        modelProperties: {
            keyPropertyNames: {
                serializedName: "keyPropertyNames",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            strongIdName: {
                serializedName: "strongIdName",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PropertyDefinition = {
    type: {
        name: "Composite",
        className: "PropertyDefinition",
        modelProperties: {
            arrayValueSeparator: {
                serializedName: "arrayValueSeparator",
                type: {
                    name: "String"
                }
            },
            enumValidValues: {
                serializedName: "enumValidValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProfileEnumValidValuesFormat"
                        }
                    }
                }
            },
            fieldName: {
                serializedName: "fieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            fieldType: {
                serializedName: "fieldType",
                required: true,
                type: {
                    name: "String"
                }
            },
            isArray: {
                serializedName: "isArray",
                type: {
                    name: "Boolean"
                }
            },
            isEnum: {
                serializedName: "isEnum",
                type: {
                    name: "Boolean"
                }
            },
            isFlagEnum: {
                serializedName: "isFlagEnum",
                type: {
                    name: "Boolean"
                }
            },
            isImage: {
                serializedName: "isImage",
                type: {
                    name: "Boolean"
                }
            },
            isLocalizedString: {
                serializedName: "isLocalizedString",
                type: {
                    name: "Boolean"
                }
            },
            isName: {
                serializedName: "isName",
                type: {
                    name: "Boolean"
                }
            },
            isRequired: {
                serializedName: "isRequired",
                type: {
                    name: "Boolean"
                }
            },
            propertyId: {
                serializedName: "propertyId",
                type: {
                    name: "String"
                }
            },
            schemaItemPropLink: {
                serializedName: "schemaItemPropLink",
                type: {
                    name: "String"
                }
            },
            maxLength: {
                serializedName: "maxLength",
                type: {
                    name: "Number"
                }
            },
            isAvailableInGraph: {
                serializedName: "isAvailableInGraph",
                type: {
                    name: "Boolean"
                }
            },
            dataSourcePrecedenceRules: {
                serializedName: "dataSourcePrecedenceRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataSourcePrecedence"
                        }
                    }
                }
            }
        }
    }
};
const ProfileEnumValidValuesFormat = {
    type: {
        name: "Composite",
        className: "ProfileEnumValidValuesFormat",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Number"
                }
            },
            localizedValueNames: {
                serializedName: "localizedValueNames",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const DataSourcePrecedence = {
    type: {
        name: "Composite",
        className: "DataSourcePrecedence",
        modelProperties: {
            precedence: {
                serializedName: "precedence",
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "dataSource.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            dataSourceType: {
                serializedName: "dataSource.dataSourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "dataSource.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "dataSource.id",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            dataSourceReferenceId: {
                serializedName: "dataSource.dataSourceReferenceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MetadataDefinitionBase = {
    type: {
        name: "Composite",
        className: "MetadataDefinitionBase",
        modelProperties: {
            attributes: {
                serializedName: "attributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            localizedAttributes: {
                serializedName: "localizedAttributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "String" } } }
                    }
                }
            },
            smallImage: {
                serializedName: "smallImage",
                type: {
                    name: "String"
                }
            },
            mediumImage: {
                serializedName: "mediumImage",
                type: {
                    name: "String"
                }
            },
            largeImage: {
                serializedName: "largeImage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProxyResource = {
    type: {
        name: "Composite",
        className: "ProxyResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ProfileListResult = {
    type: {
        name: "Composite",
        className: "ProfileListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ProfileResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KpiDefinition = {
    type: {
        name: "Composite",
        className: "KpiDefinition",
        modelProperties: {
            entityType: {
                serializedName: "entityType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            },
            entityTypeName: {
                serializedName: "entityTypeName",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            kpiName: {
                serializedName: "kpiName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            calculationWindow: {
                serializedName: "calculationWindow",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["Lifetime", "Hour", "Day", "Week", "Month"]
                }
            },
            calculationWindowFieldName: {
                serializedName: "calculationWindowFieldName",
                type: {
                    name: "String"
                }
            },
            function: {
                serializedName: "function",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Sum",
                        "Avg",
                        "Min",
                        "Max",
                        "Last",
                        "Count",
                        "None",
                        "CountDistinct"
                    ]
                }
            },
            expression: {
                serializedName: "expression",
                required: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "String"
                }
            },
            groupBy: {
                serializedName: "groupBy",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            groupByMetadata: {
                serializedName: "groupByMetadata",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiGroupByMetadata"
                        }
                    }
                }
            },
            participantProfilesMetadata: {
                serializedName: "participantProfilesMetadata",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiParticipantProfilesMetadata"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            thresHolds: {
                serializedName: "thresHolds",
                type: {
                    name: "Composite",
                    className: "KpiThresholds"
                }
            },
            aliases: {
                serializedName: "aliases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiAlias"
                        }
                    }
                }
            },
            extracts: {
                serializedName: "extracts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiExtract"
                        }
                    }
                }
            }
        }
    }
};
const KpiGroupByMetadata = {
    type: {
        name: "Composite",
        className: "KpiGroupByMetadata",
        modelProperties: {
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            fieldName: {
                serializedName: "fieldName",
                type: {
                    name: "String"
                }
            },
            fieldType: {
                serializedName: "fieldType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KpiParticipantProfilesMetadata = {
    type: {
        name: "Composite",
        className: "KpiParticipantProfilesMetadata",
        modelProperties: {
            typeName: {
                serializedName: "typeName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KpiThresholds = {
    type: {
        name: "Composite",
        className: "KpiThresholds",
        modelProperties: {
            lowerLimit: {
                serializedName: "lowerLimit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            upperLimit: {
                serializedName: "upperLimit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            increasingKpi: {
                serializedName: "increasingKpi",
                required: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const KpiAlias = {
    type: {
        name: "Composite",
        className: "KpiAlias",
        modelProperties: {
            aliasName: {
                serializedName: "aliasName",
                required: true,
                type: {
                    name: "String"
                }
            },
            expression: {
                serializedName: "expression",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KpiExtract = {
    type: {
        name: "Composite",
        className: "KpiExtract",
        modelProperties: {
            extractName: {
                serializedName: "extractName",
                required: true,
                type: {
                    name: "String"
                }
            },
            expression: {
                serializedName: "expression",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Participant = {
    type: {
        name: "Composite",
        className: "Participant",
        modelProperties: {
            profileTypeName: {
                serializedName: "profileTypeName",
                required: true,
                type: {
                    name: "String"
                }
            },
            participantPropertyReferences: {
                serializedName: "participantPropertyReferences",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantPropertyReference"
                        }
                    }
                }
            },
            participantName: {
                serializedName: "participantName",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            role: {
                serializedName: "role",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParticipantPropertyReference = {
    type: {
        name: "Composite",
        className: "ParticipantPropertyReference",
        modelProperties: {
            sourcePropertyName: {
                serializedName: "sourcePropertyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetPropertyName: {
                serializedName: "targetPropertyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InteractionListResult = {
    type: {
        name: "Composite",
        className: "InteractionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InteractionResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SuggestRelationshipLinksResponse = {
    type: {
        name: "Composite",
        className: "SuggestRelationshipLinksResponse",
        modelProperties: {
            interactionName: {
                serializedName: "interactionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            suggestedRelationships: {
                serializedName: "suggestedRelationships",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipsLookup"
                        }
                    }
                }
            }
        }
    }
};
const RelationshipsLookup = {
    type: {
        name: "Composite",
        className: "RelationshipsLookup",
        modelProperties: {
            profileName: {
                serializedName: "profileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            profilePropertyReferences: {
                serializedName: "profilePropertyReferences",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantProfilePropertyReference"
                        }
                    }
                }
            },
            relatedProfileName: {
                serializedName: "relatedProfileName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            relatedProfilePropertyReferences: {
                serializedName: "relatedProfilePropertyReferences",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantProfilePropertyReference"
                        }
                    }
                }
            },
            existingRelationshipName: {
                serializedName: "existingRelationshipName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ParticipantProfilePropertyReference = {
    type: {
        name: "Composite",
        className: "ParticipantProfilePropertyReference",
        modelProperties: {
            interactionPropertyName: {
                serializedName: "interactionPropertyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            profilePropertyName: {
                serializedName: "profilePropertyName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RelationshipTypeMapping = {
    type: {
        name: "Composite",
        className: "RelationshipTypeMapping",
        modelProperties: {
            fieldMappings: {
                serializedName: "fieldMappings",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipTypeFieldMapping"
                        }
                    }
                }
            }
        }
    }
};
const RelationshipTypeFieldMapping = {
    type: {
        name: "Composite",
        className: "RelationshipTypeFieldMapping",
        modelProperties: {
            profileFieldName: {
                serializedName: "profileFieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            relatedProfileKeyProperty: {
                serializedName: "relatedProfileKeyProperty",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RelationshipListResult = {
    type: {
        name: "Composite",
        className: "RelationshipListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RelationshipLinkFieldMapping = {
    type: {
        name: "Composite",
        className: "RelationshipLinkFieldMapping",
        modelProperties: {
            interactionFieldName: {
                serializedName: "interactionFieldName",
                required: true,
                type: {
                    name: "String"
                }
            },
            linkType: {
                serializedName: "linkType",
                type: {
                    name: "Enum",
                    allowedValues: ["UpdateAlways", "CopyIfNull"]
                }
            },
            relationshipFieldName: {
                serializedName: "relationshipFieldName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RelationshipLinkListResult = {
    type: {
        name: "Composite",
        className: "RelationshipLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipLinkResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationPolicy = {
    type: {
        name: "Composite",
        className: "AuthorizationPolicy",
        modelProperties: {
            policyName: {
                serializedName: "policyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            permissions: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "permissions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["Read", "Write", "Manage"]
                        }
                    }
                }
            },
            primaryKey: {
                serializedName: "primaryKey",
                type: {
                    name: "String"
                }
            },
            secondaryKey: {
                serializedName: "secondaryKey",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationPolicyListResult = {
    type: {
        name: "Composite",
        className: "AuthorizationPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AuthorizationPolicyResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectorListResult = {
    type: {
        name: "Composite",
        className: "ConnectorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectorResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectorMappingProperties = {
    type: {
        name: "Composite",
        className: "ConnectorMappingProperties",
        modelProperties: {
            folderPath: {
                serializedName: "folderPath",
                type: {
                    name: "String"
                }
            },
            fileFilter: {
                serializedName: "fileFilter",
                type: {
                    name: "String"
                }
            },
            hasHeader: {
                serializedName: "hasHeader",
                type: {
                    name: "Boolean"
                }
            },
            errorManagement: {
                serializedName: "errorManagement",
                type: {
                    name: "Composite",
                    className: "ConnectorMappingErrorManagement"
                }
            },
            format: {
                serializedName: "format",
                type: {
                    name: "Composite",
                    className: "ConnectorMappingFormat"
                }
            },
            availability: {
                serializedName: "availability",
                type: {
                    name: "Composite",
                    className: "ConnectorMappingAvailability"
                }
            },
            structure: {
                serializedName: "structure",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectorMappingStructure"
                        }
                    }
                }
            },
            completeOperation: {
                serializedName: "completeOperation",
                type: {
                    name: "Composite",
                    className: "ConnectorMappingCompleteOperation"
                }
            }
        }
    }
};
const ConnectorMappingErrorManagement = {
    type: {
        name: "Composite",
        className: "ConnectorMappingErrorManagement",
        modelProperties: {
            errorManagementType: {
                serializedName: "errorManagementType",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["RejectAndContinue", "StopImport", "RejectUntilLimit"]
                }
            },
            errorLimit: {
                serializedName: "errorLimit",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectorMappingFormat = {
    type: {
        name: "Composite",
        className: "ConnectorMappingFormat",
        modelProperties: {
            formatType: {
                defaultValue: "TextFormat",
                isConstant: true,
                serializedName: "formatType",
                type: {
                    name: "String"
                }
            },
            columnDelimiter: {
                serializedName: "columnDelimiter",
                type: {
                    name: "String"
                }
            },
            acceptLanguage: {
                serializedName: "acceptLanguage",
                type: {
                    name: "String"
                }
            },
            quoteCharacter: {
                serializedName: "quoteCharacter",
                type: {
                    name: "String"
                }
            },
            quoteEscapeCharacter: {
                serializedName: "quoteEscapeCharacter",
                type: {
                    name: "String"
                }
            },
            arraySeparator: {
                serializedName: "arraySeparator",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectorMappingAvailability = {
    type: {
        name: "Composite",
        className: "ConnectorMappingAvailability",
        modelProperties: {
            frequency: {
                serializedName: "frequency",
                type: {
                    name: "Enum",
                    allowedValues: ["Minute", "Hour", "Day", "Week", "Month"]
                }
            },
            interval: {
                serializedName: "interval",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectorMappingStructure = {
    type: {
        name: "Composite",
        className: "ConnectorMappingStructure",
        modelProperties: {
            propertyName: {
                serializedName: "propertyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            columnName: {
                serializedName: "columnName",
                required: true,
                type: {
                    name: "String"
                }
            },
            customFormatSpecifier: {
                serializedName: "customFormatSpecifier",
                type: {
                    name: "String"
                }
            },
            isEncrypted: {
                serializedName: "isEncrypted",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectorMappingCompleteOperation = {
    type: {
        name: "Composite",
        className: "ConnectorMappingCompleteOperation",
        modelProperties: {
            completionOperationType: {
                serializedName: "completionOperationType",
                type: {
                    name: "Enum",
                    allowedValues: ["DoNothing", "DeleteFile", "MoveFile"]
                }
            },
            destinationFolder: {
                serializedName: "destinationFolder",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectorMappingListResult = {
    type: {
        name: "Composite",
        className: "ConnectorMappingListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectorMappingResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KpiListResult = {
    type: {
        name: "Composite",
        className: "KpiListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WidgetTypeListResult = {
    type: {
        name: "Composite",
        className: "WidgetTypeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WidgetTypeResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ViewListResult = {
    type: {
        name: "Composite",
        className: "ViewListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ViewResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TypePropertiesMapping = {
    type: {
        name: "Composite",
        className: "TypePropertiesMapping",
        modelProperties: {
            sourcePropertyName: {
                serializedName: "sourcePropertyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetPropertyName: {
                serializedName: "targetPropertyName",
                required: true,
                type: {
                    name: "String"
                }
            },
            linkType: {
                serializedName: "linkType",
                type: {
                    name: "Enum",
                    allowedValues: ["UpdateAlways", "CopyIfNull"]
                }
            }
        }
    }
};
const LinkListResult = {
    type: {
        name: "Composite",
        className: "LinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LinkResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleListResult = {
    type: {
        name: "Composite",
        className: "RoleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoleAssignmentListResult = {
    type: {
        name: "Composite",
        className: "RoleAssignmentListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoleAssignmentResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AssignmentPrincipal = {
    type: {
        name: "Composite",
        className: "AssignmentPrincipal",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                required: true,
                type: {
                    name: "String"
                }
            },
            principalType: {
                serializedName: "principalType",
                required: true,
                type: {
                    name: "String"
                }
            },
            principalMetadata: {
                serializedName: "principalMetadata",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ResourceSetDescription = {
    type: {
        name: "Composite",
        className: "ResourceSetDescription",
        modelProperties: {
            elements: {
                serializedName: "elements",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            exceptions: {
                serializedName: "exceptions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const GetImageUploadUrlInput = {
    type: {
        name: "Composite",
        className: "GetImageUploadUrlInput",
        modelProperties: {
            entityType: {
                serializedName: "entityType",
                type: {
                    name: "String"
                }
            },
            entityTypeName: {
                serializedName: "entityTypeName",
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ImageDefinition = {
    type: {
        name: "Composite",
        className: "ImageDefinition",
        modelProperties: {
            imageExists: {
                serializedName: "imageExists",
                type: {
                    name: "Boolean"
                }
            },
            contentUrl: {
                serializedName: "contentUrl",
                type: {
                    name: "String"
                }
            },
            relativePath: {
                serializedName: "relativePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PredictionMappings = {
    type: {
        name: "Composite",
        className: "PredictionMappings",
        modelProperties: {
            score: {
                serializedName: "score",
                required: true,
                type: {
                    name: "String"
                }
            },
            grade: {
                serializedName: "grade",
                required: true,
                type: {
                    name: "String"
                }
            },
            reason: {
                serializedName: "reason",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PredictionGradesItem = {
    type: {
        name: "Composite",
        className: "PredictionGradesItem",
        modelProperties: {
            gradeName: {
                serializedName: "gradeName",
                type: {
                    name: "String"
                }
            },
            minScoreThreshold: {
                serializedName: "minScoreThreshold",
                type: {
                    name: "Number"
                }
            },
            maxScoreThreshold: {
                serializedName: "maxScoreThreshold",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PredictionSystemGeneratedEntities = {
    type: {
        name: "Composite",
        className: "PredictionSystemGeneratedEntities",
        modelProperties: {
            generatedInteractionTypes: {
                serializedName: "generatedInteractionTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            generatedLinks: {
                serializedName: "generatedLinks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            generatedKpis: {
                serializedName: "generatedKpis",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const PredictionTrainingResults = {
    type: {
        name: "Composite",
        className: "PredictionTrainingResults",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            scoreName: {
                serializedName: "scoreName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            predictionDistribution: {
                serializedName: "predictionDistribution",
                type: {
                    name: "Composite",
                    className: "PredictionDistributionDefinition"
                }
            },
            canonicalProfiles: {
                serializedName: "canonicalProfiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CanonicalProfileDefinition"
                        }
                    }
                }
            },
            primaryProfileInstanceCount: {
                serializedName: "primaryProfileInstanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const PredictionDistributionDefinition = {
    type: {
        name: "Composite",
        className: "PredictionDistributionDefinition",
        modelProperties: {
            totalPositives: {
                serializedName: "totalPositives",
                type: {
                    name: "Number"
                }
            },
            totalNegatives: {
                serializedName: "totalNegatives",
                type: {
                    name: "Number"
                }
            },
            distributions: {
                serializedName: "distributions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PredictionDistributionDefinitionDistributionsItem"
                        }
                    }
                }
            }
        }
    }
};
const PredictionDistributionDefinitionDistributionsItem = {
    type: {
        name: "Composite",
        className: "PredictionDistributionDefinitionDistributionsItem",
        modelProperties: {
            scoreThreshold: {
                serializedName: "scoreThreshold",
                type: {
                    name: "Number"
                }
            },
            positives: {
                serializedName: "positives",
                type: {
                    name: "Number"
                }
            },
            negatives: {
                serializedName: "negatives",
                type: {
                    name: "Number"
                }
            },
            positivesAboveThreshold: {
                serializedName: "positivesAboveThreshold",
                type: {
                    name: "Number"
                }
            },
            negativesAboveThreshold: {
                serializedName: "negativesAboveThreshold",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const CanonicalProfileDefinition = {
    type: {
        name: "Composite",
        className: "CanonicalProfileDefinition",
        modelProperties: {
            canonicalProfileId: {
                serializedName: "canonicalProfileId",
                type: {
                    name: "Number"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CanonicalProfileDefinitionPropertiesItem"
                        }
                    }
                }
            }
        }
    }
};
const CanonicalProfileDefinitionPropertiesItem = {
    type: {
        name: "Composite",
        className: "CanonicalProfileDefinitionPropertiesItem",
        modelProperties: {
            profileName: {
                serializedName: "profileName",
                type: {
                    name: "String"
                }
            },
            profilePropertyName: {
                serializedName: "profilePropertyName",
                type: {
                    name: "String"
                }
            },
            rank: {
                serializedName: "rank",
                type: {
                    name: "Number"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PredictionModelStatus = {
    type: {
        name: "Composite",
        className: "PredictionModelStatus",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            predictionName: {
                serializedName: "predictionName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            predictionGuidId: {
                serializedName: "predictionGuidId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            trainingSetCount: {
                serializedName: "trainingSetCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            testSetCount: {
                serializedName: "testSetCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            validationSetCount: {
                serializedName: "validationSetCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            trainingAccuracy: {
                serializedName: "trainingAccuracy",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            signalsUsed: {
                serializedName: "signalsUsed",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            modelVersion: {
                serializedName: "modelVersion",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PredictionListResult = {
    type: {
        name: "Composite",
        className: "PredictionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PredictionResourceFormat"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SalesforceDiscoverSetting = {
    type: {
        name: "Composite",
        className: "SalesforceDiscoverSetting",
        modelProperties: {
            salesforceConnectionStringSecretUrl: {
                serializedName: "salesforceConnectionStringSecretUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SalesforceTable = {
    type: {
        name: "Composite",
        className: "SalesforceTable",
        modelProperties: {
            isProfile: {
                serializedName: "isProfile",
                type: {
                    name: "String"
                }
            },
            tableCategory: {
                serializedName: "tableCategory",
                required: true,
                type: {
                    name: "String"
                }
            },
            tableName: {
                serializedName: "tableName",
                required: true,
                type: {
                    name: "String"
                }
            },
            tableRemarks: {
                serializedName: "tableRemarks",
                type: {
                    name: "String"
                }
            },
            tableSchema: {
                serializedName: "tableSchema",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SalesforceConnectorProperties = {
    type: {
        name: "Composite",
        className: "SalesforceConnectorProperties",
        modelProperties: {
            usersetting: {
                serializedName: "usersetting",
                type: {
                    name: "Composite",
                    className: "SalesforceDiscoverSetting"
                }
            },
            salesforcetables: {
                serializedName: "salesforcetables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SalesforceTable"
                        }
                    }
                }
            }
        }
    }
};
const AzureBlobConnectorProperties = {
    type: {
        name: "Composite",
        className: "AzureBlobConnectorProperties",
        modelProperties: {
            connectionKeyVaultUrl: {
                serializedName: "connectionKeyVaultUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CrmConnectorProperties = {
    type: {
        name: "Composite",
        className: "CrmConnectorProperties",
        modelProperties: {
            connectionString: {
                serializedName: "connectionString",
                type: {
                    name: "String"
                }
            },
            organizationId: {
                serializedName: "organizationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            organizationUrl: {
                serializedName: "organizationUrl",
                required: true,
                type: {
                    name: "String"
                }
            },
            entities: {
                serializedName: "entities",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CrmConnectorEntities"
                        }
                    }
                }
            },
            accessToken: {
                serializedName: "accessToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CrmConnectorEntities = {
    type: {
        name: "Composite",
        className: "CrmConnectorEntities",
        modelProperties: {
            logicalName: {
                serializedName: "logicalName",
                required: true,
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            isProfile: {
                serializedName: "isProfile",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const Hub = {
    type: {
        name: "Composite",
        className: "Hub",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { apiEndpoint: {
                serializedName: "properties.apiEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, webEndpoint: {
                serializedName: "properties.webEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tenantFeatures: {
                serializedName: "properties.tenantFeatures",
                type: {
                    name: "Number"
                }
            }, hubBillingInfo: {
                serializedName: "properties.hubBillingInfo",
                type: {
                    name: "Composite",
                    className: "HubBillingInfoFormat"
                }
            } })
    }
};
const EntityTypeDefinition = {
    type: {
        name: "Composite",
        className: "EntityTypeDefinition",
        modelProperties: Object.assign(Object.assign({}, MetadataDefinitionBase.type.modelProperties), { apiEntitySetName: {
                serializedName: "apiEntitySetName",
                type: {
                    name: "String"
                }
            }, entityType: {
                serializedName: "entityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, fields: {
                serializedName: "fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PropertyDefinition"
                        }
                    }
                }
            }, instancesCount: {
                serializedName: "instancesCount",
                type: {
                    name: "Number"
                }
            }, lastChangedUtc: {
                serializedName: "lastChangedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schemaItemTypeLink: {
                serializedName: "schemaItemTypeLink",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timestampFieldName: {
                serializedName: "timestampFieldName",
                type: {
                    name: "String"
                }
            }, typeName: {
                serializedName: "typeName",
                type: {
                    name: "String"
                }
            } })
    }
};
const ProfileResourceFormat = {
    type: {
        name: "Composite",
        className: "ProfileResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { attributes: {
                serializedName: "properties.attributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, localizedAttributes: {
                serializedName: "properties.localizedAttributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "String" } } }
                    }
                }
            }, smallImage: {
                serializedName: "properties.smallImage",
                type: {
                    name: "String"
                }
            }, mediumImage: {
                serializedName: "properties.mediumImage",
                type: {
                    name: "String"
                }
            }, largeImage: {
                serializedName: "properties.largeImage",
                type: {
                    name: "String"
                }
            }, apiEntitySetName: {
                serializedName: "properties.apiEntitySetName",
                type: {
                    name: "String"
                }
            }, entityType: {
                serializedName: "properties.entityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, fields: {
                serializedName: "properties.fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PropertyDefinition"
                        }
                    }
                }
            }, instancesCount: {
                serializedName: "properties.instancesCount",
                type: {
                    name: "Number"
                }
            }, lastChangedUtc: {
                serializedName: "properties.lastChangedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schemaItemTypeLink: {
                serializedName: "properties.schemaItemTypeLink",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timestampFieldName: {
                serializedName: "properties.timestampFieldName",
                type: {
                    name: "String"
                }
            }, typeName: {
                serializedName: "properties.typeName",
                type: {
                    name: "String"
                }
            }, strongIds: {
                serializedName: "properties.strongIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StrongId"
                        }
                    }
                }
            } })
    }
};
const InteractionResourceFormat = {
    type: {
        name: "Composite",
        className: "InteractionResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { attributes: {
                serializedName: "properties.attributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Sequence", element: { type: { name: "String" } } }
                    }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, localizedAttributes: {
                serializedName: "properties.localizedAttributes",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "String" } } }
                    }
                }
            }, smallImage: {
                serializedName: "properties.smallImage",
                type: {
                    name: "String"
                }
            }, mediumImage: {
                serializedName: "properties.mediumImage",
                type: {
                    name: "String"
                }
            }, largeImage: {
                serializedName: "properties.largeImage",
                type: {
                    name: "String"
                }
            }, apiEntitySetName: {
                serializedName: "properties.apiEntitySetName",
                type: {
                    name: "String"
                }
            }, entityType: {
                serializedName: "properties.entityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, fields: {
                serializedName: "properties.fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PropertyDefinition"
                        }
                    }
                }
            }, instancesCount: {
                serializedName: "properties.instancesCount",
                type: {
                    name: "Number"
                }
            }, lastChangedUtc: {
                serializedName: "properties.lastChangedUtc",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, schemaItemTypeLink: {
                serializedName: "properties.schemaItemTypeLink",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, timestampFieldName: {
                serializedName: "properties.timestampFieldName",
                type: {
                    name: "String"
                }
            }, typeName: {
                serializedName: "properties.typeName",
                type: {
                    name: "String"
                }
            }, idPropertyNames: {
                serializedName: "properties.idPropertyNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, participantProfiles: {
                serializedName: "properties.participantProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Participant"
                        }
                    }
                }
            }, primaryParticipantProfilePropertyName: {
                serializedName: "properties.primaryParticipantProfilePropertyName",
                type: {
                    name: "String"
                }
            }, dataSourcePrecedenceRules: {
                serializedName: "properties.dataSourcePrecedenceRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataSourcePrecedence"
                        }
                    }
                }
            }, isActivity: {
                serializedName: "properties.isActivity",
                type: {
                    name: "Boolean"
                }
            }, namePropertiesDefaultDataSourceName: {
                serializedName: "properties.defaultDataSource.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataSourceType: {
                serializedName: "properties.defaultDataSource.dataSourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "properties.defaultDataSource.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, idPropertiesDefaultDataSourceId: {
                serializedName: "properties.defaultDataSource.id",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, dataSourceReferenceId: {
                serializedName: "properties.defaultDataSource.dataSourceReferenceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RelationshipResourceFormat = {
    type: {
        name: "Composite",
        className: "RelationshipResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { cardinality: {
                serializedName: "properties.cardinality",
                type: {
                    name: "Enum",
                    allowedValues: ["OneToOne", "OneToMany", "ManyToMany"]
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, expiryDateTimeUtc: {
                serializedName: "properties.expiryDateTimeUtc",
                type: {
                    name: "DateTime"
                }
            }, fields: {
                serializedName: "properties.fields",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PropertyDefinition"
                        }
                    }
                }
            }, lookupMappings: {
                serializedName: "properties.lookupMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipTypeMapping"
                        }
                    }
                }
            }, profileType: {
                serializedName: "properties.profileType",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, relationshipName: {
                serializedName: "properties.relationshipName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, relatedProfileType: {
                serializedName: "properties.relatedProfileType",
                type: {
                    name: "String"
                }
            }, relationshipGuidId: {
                serializedName: "properties.relationshipGuidId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RelationshipLinkResourceFormat = {
    type: {
        name: "Composite",
        className: "RelationshipLinkResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, interactionType: {
                serializedName: "properties.interactionType",
                type: {
                    name: "String"
                }
            }, linkName: {
                serializedName: "properties.linkName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, mappings: {
                serializedName: "properties.mappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RelationshipLinkFieldMapping"
                        }
                    }
                }
            }, profilePropertyReferences: {
                serializedName: "properties.profilePropertyReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantProfilePropertyReference"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, relatedProfilePropertyReferences: {
                serializedName: "properties.relatedProfilePropertyReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantProfilePropertyReference"
                        }
                    }
                }
            }, relationshipName: {
                serializedName: "properties.relationshipName",
                type: {
                    name: "String"
                }
            }, relationshipGuidId: {
                serializedName: "properties.relationshipGuidId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AuthorizationPolicyResourceFormat = {
    type: {
        name: "Composite",
        className: "AuthorizationPolicyResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { policyName: {
                serializedName: "properties.policyName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, permissions: {
                constraints: {
                    UniqueItems: true
                },
                serializedName: "properties.permissions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Enum",
                            allowedValues: ["Read", "Write", "Manage"]
                        }
                    }
                }
            }, primaryKey: {
                serializedName: "properties.primaryKey",
                type: {
                    name: "String"
                }
            }, secondaryKey: {
                serializedName: "properties.secondaryKey",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectorResourceFormat = {
    type: {
        name: "Composite",
        className: "ConnectorResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { connectorId: {
                serializedName: "properties.connectorId",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, connectorName: {
                serializedName: "properties.connectorName",
                type: {
                    name: "String"
                }
            }, connectorType: {
                serializedName: "properties.connectorType",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, connectorProperties: {
                serializedName: "properties.connectorProperties",
                type: {
                    name: "Dictionary",
                    value: {
                        type: { name: "Dictionary", value: { type: { name: "any" } } }
                    }
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastModified: {
                serializedName: "properties.lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Created",
                        "Ready",
                        "Expiring",
                        "Deleting",
                        "Failed"
                    ]
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isInternal: {
                serializedName: "properties.isInternal",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ConnectorMappingResourceFormat = {
    type: {
        name: "Composite",
        className: "ConnectorMappingResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { connectorName: {
                serializedName: "properties.connectorName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectorType: {
                serializedName: "properties.connectorType",
                type: {
                    name: "String"
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, lastModified: {
                serializedName: "properties.lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, entityType: {
                serializedName: "properties.entityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, entityTypeName: {
                serializedName: "properties.entityTypeName",
                type: {
                    name: "String"
                }
            }, connectorMappingName: {
                serializedName: "properties.connectorMappingName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, dataFormatId: {
                serializedName: "properties.dataFormatId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, mappingProperties: {
                serializedName: "properties.mappingProperties",
                type: {
                    name: "Composite",
                    className: "ConnectorMappingProperties"
                }
            }, nextRunTime: {
                serializedName: "properties.nextRunTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, runId: {
                serializedName: "properties.runId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Creating",
                        "Created",
                        "Failed",
                        "Ready",
                        "Running",
                        "Stopped",
                        "Expiring"
                    ]
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const KpiResourceFormat = {
    type: {
        name: "Composite",
        className: "KpiResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { entityType: {
                serializedName: "properties.entityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, entityTypeName: {
                serializedName: "properties.entityTypeName",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kpiName: {
                serializedName: "properties.kpiName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, calculationWindow: {
                serializedName: "properties.calculationWindow",
                type: {
                    name: "Enum",
                    allowedValues: ["Lifetime", "Hour", "Day", "Week", "Month"]
                }
            }, calculationWindowFieldName: {
                serializedName: "properties.calculationWindowFieldName",
                type: {
                    name: "String"
                }
            }, function: {
                serializedName: "properties.function",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Sum",
                        "Avg",
                        "Min",
                        "Max",
                        "Last",
                        "Count",
                        "None",
                        "CountDistinct"
                    ]
                }
            }, expression: {
                serializedName: "properties.expression",
                type: {
                    name: "String"
                }
            }, unit: {
                serializedName: "properties.unit",
                type: {
                    name: "String"
                }
            }, filter: {
                serializedName: "properties.filter",
                type: {
                    name: "String"
                }
            }, groupBy: {
                serializedName: "properties.groupBy",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, groupByMetadata: {
                serializedName: "properties.groupByMetadata",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiGroupByMetadata"
                        }
                    }
                }
            }, participantProfilesMetadata: {
                serializedName: "properties.participantProfilesMetadata",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiParticipantProfilesMetadata"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thresHolds: {
                serializedName: "properties.thresHolds",
                type: {
                    name: "Composite",
                    className: "KpiThresholds"
                }
            }, aliases: {
                serializedName: "properties.aliases",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiAlias"
                        }
                    }
                }
            }, extracts: {
                serializedName: "properties.extracts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KpiExtract"
                        }
                    }
                }
            } })
    }
};
const WidgetTypeResourceFormat = {
    type: {
        name: "Composite",
        className: "WidgetTypeResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { widgetTypeName: {
                serializedName: "properties.widgetTypeName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, imageUrl: {
                serializedName: "properties.imageUrl",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, widgetVersion: {
                serializedName: "properties.widgetVersion",
                type: {
                    name: "String"
                }
            }, changed: {
                serializedName: "properties.changed",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const ViewResourceFormat = {
    type: {
        name: "Composite",
        className: "ViewResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { viewName: {
                serializedName: "properties.viewName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, userId: {
                serializedName: "properties.userId",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, definition: {
                serializedName: "properties.definition",
                type: {
                    name: "String"
                }
            }, changed: {
                serializedName: "properties.changed",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, created: {
                serializedName: "properties.created",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            } })
    }
};
const LinkResourceFormat = {
    type: {
        name: "Composite",
        className: "LinkResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkName: {
                serializedName: "properties.linkName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sourceEntityType: {
                serializedName: "properties.sourceEntityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, targetEntityType: {
                serializedName: "properties.targetEntityType",
                type: {
                    name: "Enum",
                    allowedValues: ["None", "Profile", "Interaction", "Relationship"]
                }
            }, sourceEntityTypeName: {
                serializedName: "properties.sourceEntityTypeName",
                type: {
                    name: "String"
                }
            }, targetEntityTypeName: {
                serializedName: "properties.targetEntityTypeName",
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, mappings: {
                serializedName: "properties.mappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TypePropertiesMapping"
                        }
                    }
                }
            }, participantPropertyReferences: {
                serializedName: "properties.participantPropertyReferences",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ParticipantPropertyReference"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, referenceOnly: {
                serializedName: "properties.referenceOnly",
                type: {
                    name: "Boolean"
                }
            }, operationType: {
                serializedName: "properties.operationType",
                type: {
                    name: "Enum",
                    allowedValues: ["Upsert", "Delete"]
                }
            } })
    }
};
const RoleResourceFormat = {
    type: {
        name: "Composite",
        className: "RoleResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { roleName: {
                serializedName: "properties.roleName",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const RoleAssignmentResourceFormat = {
    type: {
        name: "Composite",
        className: "RoleAssignmentResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, assignmentName: {
                serializedName: "properties.assignmentName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, role: {
                serializedName: "properties.role",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "Admin",
                        "Reader",
                        "ManageAdmin",
                        "ManageReader",
                        "DataAdmin",
                        "DataReader"
                    ]
                }
            }, principals: {
                serializedName: "properties.principals",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AssignmentPrincipal"
                        }
                    }
                }
            }, profiles: {
                serializedName: "properties.profiles",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, interactions: {
                serializedName: "properties.interactions",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, links: {
                serializedName: "properties.links",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, kpis: {
                serializedName: "properties.kpis",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, sasPolicies: {
                serializedName: "properties.sasPolicies",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, connectors: {
                serializedName: "properties.connectors",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, views: {
                serializedName: "properties.views",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, relationshipLinks: {
                serializedName: "properties.relationshipLinks",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, relationships: {
                serializedName: "properties.relationships",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, widgetTypes: {
                serializedName: "properties.widgetTypes",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, roleAssignments: {
                serializedName: "properties.roleAssignments",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, conflationPolicies: {
                serializedName: "properties.conflationPolicies",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            }, segments: {
                serializedName: "properties.segments",
                type: {
                    name: "Composite",
                    className: "ResourceSetDescription"
                }
            } })
    }
};
const PredictionResourceFormat = {
    type: {
        name: "Composite",
        className: "PredictionResourceFormat",
        modelProperties: Object.assign(Object.assign({}, ProxyResource.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, displayName: {
                serializedName: "properties.displayName",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, involvedInteractionTypes: {
                serializedName: "properties.involvedInteractionTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, involvedKpiTypes: {
                serializedName: "properties.involvedKpiTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, involvedRelationships: {
                serializedName: "properties.involvedRelationships",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, negativeOutcomeExpression: {
                serializedName: "properties.negativeOutcomeExpression",
                type: {
                    name: "String"
                }
            }, positiveOutcomeExpression: {
                serializedName: "properties.positiveOutcomeExpression",
                type: {
                    name: "String"
                }
            }, primaryProfileType: {
                serializedName: "properties.primaryProfileType",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, predictionName: {
                serializedName: "properties.predictionName",
                type: {
                    name: "String"
                }
            }, scopeExpression: {
                serializedName: "properties.scopeExpression",
                type: {
                    name: "String"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoAnalyze: {
                serializedName: "properties.autoAnalyze",
                type: {
                    name: "Boolean"
                }
            }, mappings: {
                serializedName: "properties.mappings",
                type: {
                    name: "Composite",
                    className: "PredictionMappings"
                }
            }, scoreLabel: {
                serializedName: "properties.scoreLabel",
                type: {
                    name: "String"
                }
            }, grades: {
                serializedName: "properties.grades",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PredictionGradesItem"
                        }
                    }
                }
            }, systemGeneratedEntities: {
                serializedName: "properties.systemGeneratedEntities",
                type: {
                    name: "Composite",
                    className: "PredictionSystemGeneratedEntities"
                }
            } })
    }
};
const EnrichingKpi = {
    type: {
        name: "Composite",
        className: "EnrichingKpi",
        modelProperties: Object.assign({}, KpiDefinition.type.modelProperties)
    }
};
const ProfileTypeDefinition = {
    type: {
        name: "Composite",
        className: "ProfileTypeDefinition",
        modelProperties: Object.assign(Object.assign({}, EntityTypeDefinition.type.modelProperties), { strongIds: {
                serializedName: "strongIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StrongId"
                        }
                    }
                }
            } })
    }
};
const InteractionTypeDefinition = {
    type: {
        name: "Composite",
        className: "InteractionTypeDefinition",
        modelProperties: Object.assign(Object.assign({}, EntityTypeDefinition.type.modelProperties), { idPropertyNames: {
                serializedName: "idPropertyNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, participantProfiles: {
                serializedName: "participantProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Participant"
                        }
                    }
                }
            }, primaryParticipantProfilePropertyName: {
                serializedName: "primaryParticipantProfilePropertyName",
                type: {
                    name: "String"
                }
            }, dataSourcePrecedenceRules: {
                serializedName: "dataSourcePrecedenceRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DataSourcePrecedence"
                        }
                    }
                }
            }, isActivity: {
                serializedName: "isActivity",
                type: {
                    name: "Boolean"
                }
            }, name: {
                serializedName: "defaultDataSource.name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, dataSourceType: {
                serializedName: "defaultDataSource.dataSourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, status: {
                serializedName: "defaultDataSource.status",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, id: {
                serializedName: "defaultDataSource.id",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, dataSourceReferenceId: {
                serializedName: "defaultDataSource.dataSourceReferenceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    HubBillingInfoFormat: HubBillingInfoFormat,
    Resource: Resource,
    HubListResult: HubListResult,
    StrongId: StrongId,
    PropertyDefinition: PropertyDefinition,
    ProfileEnumValidValuesFormat: ProfileEnumValidValuesFormat,
    DataSourcePrecedence: DataSourcePrecedence,
    MetadataDefinitionBase: MetadataDefinitionBase,
    ProxyResource: ProxyResource,
    ProfileListResult: ProfileListResult,
    KpiDefinition: KpiDefinition,
    KpiGroupByMetadata: KpiGroupByMetadata,
    KpiParticipantProfilesMetadata: KpiParticipantProfilesMetadata,
    KpiThresholds: KpiThresholds,
    KpiAlias: KpiAlias,
    KpiExtract: KpiExtract,
    Participant: Participant,
    ParticipantPropertyReference: ParticipantPropertyReference,
    InteractionListResult: InteractionListResult,
    SuggestRelationshipLinksResponse: SuggestRelationshipLinksResponse,
    RelationshipsLookup: RelationshipsLookup,
    ParticipantProfilePropertyReference: ParticipantProfilePropertyReference,
    RelationshipTypeMapping: RelationshipTypeMapping,
    RelationshipTypeFieldMapping: RelationshipTypeFieldMapping,
    RelationshipListResult: RelationshipListResult,
    RelationshipLinkFieldMapping: RelationshipLinkFieldMapping,
    RelationshipLinkListResult: RelationshipLinkListResult,
    AuthorizationPolicy: AuthorizationPolicy,
    AuthorizationPolicyListResult: AuthorizationPolicyListResult,
    ConnectorListResult: ConnectorListResult,
    ConnectorMappingProperties: ConnectorMappingProperties,
    ConnectorMappingErrorManagement: ConnectorMappingErrorManagement,
    ConnectorMappingFormat: ConnectorMappingFormat,
    ConnectorMappingAvailability: ConnectorMappingAvailability,
    ConnectorMappingStructure: ConnectorMappingStructure,
    ConnectorMappingCompleteOperation: ConnectorMappingCompleteOperation,
    ConnectorMappingListResult: ConnectorMappingListResult,
    KpiListResult: KpiListResult,
    WidgetTypeListResult: WidgetTypeListResult,
    ViewListResult: ViewListResult,
    TypePropertiesMapping: TypePropertiesMapping,
    LinkListResult: LinkListResult,
    RoleListResult: RoleListResult,
    RoleAssignmentListResult: RoleAssignmentListResult,
    AssignmentPrincipal: AssignmentPrincipal,
    ResourceSetDescription: ResourceSetDescription,
    GetImageUploadUrlInput: GetImageUploadUrlInput,
    ImageDefinition: ImageDefinition,
    PredictionMappings: PredictionMappings,
    PredictionGradesItem: PredictionGradesItem,
    PredictionSystemGeneratedEntities: PredictionSystemGeneratedEntities,
    PredictionTrainingResults: PredictionTrainingResults,
    PredictionDistributionDefinition: PredictionDistributionDefinition,
    PredictionDistributionDefinitionDistributionsItem: PredictionDistributionDefinitionDistributionsItem,
    CanonicalProfileDefinition: CanonicalProfileDefinition,
    CanonicalProfileDefinitionPropertiesItem: CanonicalProfileDefinitionPropertiesItem,
    PredictionModelStatus: PredictionModelStatus,
    PredictionListResult: PredictionListResult,
    SalesforceDiscoverSetting: SalesforceDiscoverSetting,
    SalesforceTable: SalesforceTable,
    SalesforceConnectorProperties: SalesforceConnectorProperties,
    AzureBlobConnectorProperties: AzureBlobConnectorProperties,
    CrmConnectorProperties: CrmConnectorProperties,
    CrmConnectorEntities: CrmConnectorEntities,
    Hub: Hub,
    EntityTypeDefinition: EntityTypeDefinition,
    ProfileResourceFormat: ProfileResourceFormat,
    InteractionResourceFormat: InteractionResourceFormat,
    RelationshipResourceFormat: RelationshipResourceFormat,
    RelationshipLinkResourceFormat: RelationshipLinkResourceFormat,
    AuthorizationPolicyResourceFormat: AuthorizationPolicyResourceFormat,
    ConnectorResourceFormat: ConnectorResourceFormat,
    ConnectorMappingResourceFormat: ConnectorMappingResourceFormat,
    KpiResourceFormat: KpiResourceFormat,
    WidgetTypeResourceFormat: WidgetTypeResourceFormat,
    ViewResourceFormat: ViewResourceFormat,
    LinkResourceFormat: LinkResourceFormat,
    RoleResourceFormat: RoleResourceFormat,
    RoleAssignmentResourceFormat: RoleAssignmentResourceFormat,
    PredictionResourceFormat: PredictionResourceFormat,
    EnrichingKpi: EnrichingKpi,
    ProfileTypeDefinition: ProfileTypeDefinition,
    InteractionTypeDefinition: InteractionTypeDefinition
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2017-04-26",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: Hub
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const hubName = {
    parameterPath: "hubName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9]+$"),
            MaxLength: 64,
            MinLength: 1
        },
        serializedName: "hubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const hubName1 = {
    parameterPath: "hubName",
    mapper: {
        serializedName: "hubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: ProfileResourceFormat
};
const profileName = {
    parameterPath: "profileName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 128,
            MinLength: 1
        },
        serializedName: "profileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const profileName1 = {
    parameterPath: "profileName",
    mapper: {
        serializedName: "profileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const localeCode = {
    parameterPath: ["options", "localeCode"],
    mapper: {
        defaultValue: "en-us",
        serializedName: "locale-code",
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: InteractionResourceFormat
};
const interactionName = {
    parameterPath: "interactionName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 128,
            MinLength: 1
        },
        serializedName: "interactionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const interactionName1 = {
    parameterPath: "interactionName",
    mapper: {
        serializedName: "interactionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: RelationshipResourceFormat
};
const relationshipName = {
    parameterPath: "relationshipName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "relationshipName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const relationshipName1 = {
    parameterPath: "relationshipName",
    mapper: {
        serializedName: "relationshipName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: RelationshipLinkResourceFormat
};
const relationshipLinkName = {
    parameterPath: "relationshipLinkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "relationshipLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const relationshipLinkName1 = {
    parameterPath: "relationshipLinkName",
    mapper: {
        serializedName: "relationshipLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: AuthorizationPolicyResourceFormat
};
const authorizationPolicyName = {
    parameterPath: "authorizationPolicyName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[A-Za-z0-9]$|^[A-Za-z0-9][\\w-\\.]*[A-Za-z0-9]$"),
            MaxLength: 50,
            MinLength: 1
        },
        serializedName: "authorizationPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationPolicyName1 = {
    parameterPath: "authorizationPolicyName",
    mapper: {
        serializedName: "authorizationPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: ConnectorResourceFormat
};
const connectorName = {
    parameterPath: "connectorName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 128,
            MinLength: 1
        },
        serializedName: "connectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectorName1 = {
    parameterPath: "connectorName",
    mapper: {
        serializedName: "connectorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: ConnectorMappingResourceFormat
};
const mappingName = {
    parameterPath: "mappingName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 128,
            MinLength: 1
        },
        serializedName: "mappingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const mappingName1 = {
    parameterPath: "mappingName",
    mapper: {
        serializedName: "mappingName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: KpiResourceFormat
};
const kpiName = {
    parameterPath: "kpiName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "kpiName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const kpiName1 = {
    parameterPath: "kpiName",
    mapper: {
        serializedName: "kpiName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const widgetTypeName = {
    parameterPath: "widgetTypeName",
    mapper: {
        serializedName: "widgetTypeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const userId = {
    parameterPath: "userId",
    mapper: {
        serializedName: "userId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: ViewResourceFormat
};
const viewName = {
    parameterPath: "viewName",
    mapper: {
        constraints: {
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "viewName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const viewName1 = {
    parameterPath: "viewName",
    mapper: {
        serializedName: "viewName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: LinkResourceFormat
};
const linkName = {
    parameterPath: "linkName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "linkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const linkName1 = {
    parameterPath: "linkName",
    mapper: {
        serializedName: "linkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: RoleAssignmentResourceFormat
};
const assignmentName = {
    parameterPath: "assignmentName",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[a-zA-Z][a-zA-Z0-9_]+$"),
            MaxLength: 128,
            MinLength: 1
        },
        serializedName: "assignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const assignmentName1 = {
    parameterPath: "assignmentName",
    mapper: {
        serializedName: "assignmentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: GetImageUploadUrlInput
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: PredictionResourceFormat
};
const predictionName = {
    parameterPath: "predictionName",
    mapper: {
        constraints: {
            MaxLength: 512,
            MinLength: 1
        },
        serializedName: "predictionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const predictionName1 = {
    parameterPath: "predictionName",
    mapper: {
        serializedName: "predictionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: PredictionModelStatus
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Customer Insights REST API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Customer Insights REST API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1 = {
    path: "/providers/Microsoft.CustomerInsights/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class LroImpl {
    constructor(sendOperationFn, args, spec, requestPath = spec.path, requestMethod = spec.httpMethod) {
        this.sendOperationFn = sendOperationFn;
        this.args = args;
        this.spec = spec;
        this.requestPath = requestPath;
        this.requestMethod = requestMethod;
    }
    sendInitialRequest() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.sendOperationFn(this.args, this.spec);
        });
    }
    sendPollRequest(path) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const _a = this.spec, restSpec = tslib.__rest(_a, ["requestBody"]);
            return this.sendOperationFn(this.args, Object.assign(Object.assign({}, restSpec), { path, httpMethod: "GET" }));
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Hubs operations. */
class HubsImpl {
    /**
     * Initialize a new instance of the class Hubs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the hubs in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all hubs in the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates a hub, or updates an existing hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the Hub.
     * @param parameters Parameters supplied to the CreateOrUpdate Hub operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, hubName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, parameters, options }, createOrUpdateOperationSpec$c);
    }
    /**
     * Updates a Hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the Hub.
     * @param parameters Parameters supplied to the Update Hub operation.
     * @param options The options parameters.
     */
    update(resourceGroupName, hubName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, parameters, options }, updateOperationSpec);
    }
    /**
     * Deletes the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, options }, deleteOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, getOperationSpec$d);
    }
    /**
     * Gets all the hubs in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Gets all hubs in the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Hub
        },
        201: {
            bodyMapper: Hub
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        hubName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: Hub
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$f
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    serializer: serializer$f
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Hub
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.CustomerInsights/hubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Profiles operations. */
class ProfilesImpl {
    /**
     * Initialize a new instance of the class Profiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all profile in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a profile within a Hub, or updates an existing profile.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param parameters Parameters supplied to the create/delete Profile type operation
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, profileName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, profileName, parameters, options }, createOrUpdateOperationSpec$b);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a profile within a Hub, or updates an existing profile.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param parameters Parameters supplied to the create/delete Profile type operation
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, profileName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, profileName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified profile.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, profileName, options }, getOperationSpec$c);
    }
    /**
     * Deletes a profile within a hub
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, profileName, options }, deleteOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a profile within a hub
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, profileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, profileName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all profile in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$c);
    }
    /**
     * Gets the KPIs that enrich the profile Type identified by the supplied name. Enrichment happens
     * through participants of the Interaction on an Interaction KPI and through Relationships for Profile
     * KPIs.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param profileName The name of the profile.
     * @param options The options parameters.
     */
    getEnrichingKpis(resourceGroupName, hubName, profileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, profileName, options }, getEnrichingKpisOperationSpec);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/profiles/{profileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ProfileResourceFormat
        },
        201: {
            bodyMapper: ProfileResourceFormat
        },
        202: {
            bodyMapper: ProfileResourceFormat
        },
        204: {
            bodyMapper: ProfileResourceFormat
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        profileName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/profiles/{profileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileResourceFormat
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        profileName1
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/profiles/{profileName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        profileName1
    ],
    serializer: serializer$e
};
const listByHubOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/profiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const getEnrichingKpisOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/profiles/{profileName}/getEnrichingKpis",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: {
                type: {
                    name: "Sequence",
                    element: { type: { name: "Composite", className: "KpiDefinition" } }
                }
            }
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        profileName1
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByHubNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ProfileListResult
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Interactions operations. */
class InteractionsImpl {
    /**
     * Initialize a new instance of the class Interactions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all interactions in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates an interaction or updates an existing interaction within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param interactionName The name of the interaction.
     * @param parameters Parameters supplied to the CreateOrUpdate Interaction operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, interactionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, interactionName, parameters, options }, createOrUpdateOperationSpec$a);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates an interaction or updates an existing interaction within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param interactionName The name of the interaction.
     * @param parameters Parameters supplied to the CreateOrUpdate Interaction operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, interactionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, interactionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified interaction.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param interactionName The name of the interaction.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, interactionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, interactionName, options }, getOperationSpec$b);
    }
    /**
     * Gets all interactions in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$b);
    }
    /**
     * Suggests relationships to create relationship links.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param interactionName The name of the interaction.
     * @param options The options parameters.
     */
    suggestRelationshipLinks(resourceGroupName, hubName, interactionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, interactionName, options }, suggestRelationshipLinksOperationSpec);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/interactions/{interactionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InteractionResourceFormat
        },
        201: {
            bodyMapper: InteractionResourceFormat
        },
        202: {
            bodyMapper: InteractionResourceFormat
        },
        204: {
            bodyMapper: InteractionResourceFormat
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        interactionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$d
};
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/interactions/{interactionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InteractionResourceFormat
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        interactionName1
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByHubOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/interactions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InteractionListResult
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const suggestRelationshipLinksOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/interactions/{interactionName}/suggestRelationshipLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SuggestRelationshipLinksResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        interactionName1
    ],
    headerParameters: [accept],
    serializer: serializer$d
};
const listByHubNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InteractionListResult
        }
    },
    queryParameters: [apiVersion, localeCode],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Relationships operations. */
class RelationshipsImpl {
    /**
     * Initialize a new instance of the class Relationships class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all relationships in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a relationship or updates an existing relationship within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipName The name of the Relationship.
     * @param parameters Parameters supplied to the CreateOrUpdate Relationship operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, relationshipName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, relationshipName, parameters, options }, createOrUpdateOperationSpec$9);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a relationship or updates an existing relationship within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipName The name of the Relationship.
     * @param parameters Parameters supplied to the CreateOrUpdate Relationship operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, relationshipName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, relationshipName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified relationship.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipName The name of the relationship.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, relationshipName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, relationshipName, options }, getOperationSpec$a);
    }
    /**
     * Deletes a relationship within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipName The name of the relationship.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, relationshipName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, relationshipName, options }, deleteOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a relationship within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipName The name of the relationship.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, relationshipName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, relationshipName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all relationships in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$a);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationships/{relationshipName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelationshipResourceFormat
        },
        201: {
            bodyMapper: RelationshipResourceFormat
        },
        202: {
            bodyMapper: RelationshipResourceFormat
        },
        204: {
            bodyMapper: RelationshipResourceFormat
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationships/{relationshipName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipName1
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationships/{relationshipName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipName1
    ],
    serializer: serializer$c
};
const listByHubOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationships",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByHubNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RelationshipLinks operations. */
class RelationshipLinksImpl {
    /**
     * Initialize a new instance of the class RelationshipLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all relationship links in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a relationship link or updates an existing relationship link within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipLinkName The name of the relationship link.
     * @param parameters Parameters supplied to the CreateOrUpdate relationship link operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, relationshipLinkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, relationshipLinkName, parameters, options }, createOrUpdateOperationSpec$8);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a relationship link or updates an existing relationship link within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipLinkName The name of the relationship link.
     * @param parameters Parameters supplied to the CreateOrUpdate relationship link operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, relationshipLinkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, relationshipLinkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified relationship Link.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipLinkName The name of the relationship link.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, relationshipLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, relationshipLinkName, options }, getOperationSpec$9);
    }
    /**
     * Deletes a relationship link within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipLinkName The name of the relationship.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, relationshipLinkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, relationshipLinkName, options }, deleteOperationSpec$7);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a relationship link within a hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param relationshipLinkName The name of the relationship.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, relationshipLinkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, relationshipLinkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all relationship links in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$9);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationshipLinks/{relationshipLinkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RelationshipLinkResourceFormat
        },
        201: {
            bodyMapper: RelationshipLinkResourceFormat
        },
        202: {
            bodyMapper: RelationshipLinkResourceFormat
        },
        204: {
            bodyMapper: RelationshipLinkResourceFormat
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipLinkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationshipLinks/{relationshipLinkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipLinkResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipLinkName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationshipLinks/{relationshipLinkName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        relationshipLinkName1
    ],
    serializer: serializer$b
};
const listByHubOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/relationshipLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipLinkListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listByHubNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RelationshipLinkListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AuthorizationPolicies operations. */
class AuthorizationPoliciesImpl {
    /**
     * Initialize a new instance of the class AuthorizationPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the authorization policies in a specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates an authorization policy or updates an existing authorization policy.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param authorizationPolicyName The name of the policy.
     * @param parameters Parameters supplied to the CreateOrUpdate authorization policy operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, hubName, authorizationPolicyName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            hubName,
            authorizationPolicyName,
            parameters,
            options
        }, createOrUpdateOperationSpec$7);
    }
    /**
     * Gets an authorization policy in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param authorizationPolicyName The name of the policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, authorizationPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, authorizationPolicyName, options }, getOperationSpec$8);
    }
    /**
     * Gets all the authorization policies in a specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$8);
    }
    /**
     * Regenerates the primary policy key of the specified authorization policy.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param authorizationPolicyName The name of the policy.
     * @param options The options parameters.
     */
    regeneratePrimaryKey(resourceGroupName, hubName, authorizationPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, authorizationPolicyName, options }, regeneratePrimaryKeyOperationSpec);
    }
    /**
     * Regenerates the secondary policy key of the specified authorization policy.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param authorizationPolicyName The name of the policy.
     * @param options The options parameters.
     */
    regenerateSecondaryKey(resourceGroupName, hubName, authorizationPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, authorizationPolicyName, options }, regenerateSecondaryKeyOperationSpec);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/authorizationPolicies/{authorizationPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicyResourceFormat
        },
        201: {
            bodyMapper: AuthorizationPolicyResourceFormat
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        authorizationPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$a
};
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/authorizationPolicies/{authorizationPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicyResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        authorizationPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByHubOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/authorizationPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicyListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const regeneratePrimaryKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/authorizationPolicies/{authorizationPolicyName}/regeneratePrimaryKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicy
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        authorizationPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const regenerateSecondaryKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/authorizationPolicies/{authorizationPolicyName}/regenerateSecondaryKey",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicy
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        authorizationPolicyName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};
const listByHubNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationPolicyListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Connectors operations. */
class ConnectorsImpl {
    /**
     * Initialize a new instance of the class Connectors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the connectors in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a connector or updates an existing connector in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param parameters Parameters supplied to the CreateOrUpdate Connector operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, connectorName, parameters, options }, createOrUpdateOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a connector or updates an existing connector in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param parameters Parameters supplied to the CreateOrUpdate Connector operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, connectorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, connectorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a connector in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, connectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, connectorName, options }, getOperationSpec$7);
    }
    /**
     * Deletes a connector in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, connectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, connectorName, options }, deleteOperationSpec$6);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a connector in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, connectorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, connectorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the connectors in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$7);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectorResourceFormat
        },
        201: {
            bodyMapper: ConnectorResourceFormat
        },
        202: {
            bodyMapper: ConnectorResourceFormat
        },
        204: {
            bodyMapper: ConnectorResourceFormat
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1
    ],
    serializer: serializer$9
};
const listByHubOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listByHubNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectorMappings operations. */
class ConnectorMappingsImpl {
    /**
     * Initialize a new instance of the class ConnectorMappings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the connector mappings in the specified connector.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param options The options parameters.
     */
    listByConnector(resourceGroupName, hubName, connectorName, options) {
        const iter = this.listByConnectorPagingAll(resourceGroupName, hubName, connectorName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByConnectorPagingPage(resourceGroupName, hubName, connectorName, options, settings);
            }
        };
    }
    listByConnectorPagingPage(resourceGroupName, hubName, connectorName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByConnectorPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByConnector(resourceGroupName, hubName, connectorName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByConnectorNext(resourceGroupName, hubName, connectorName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByConnectorPagingAll(resourceGroupName, hubName, connectorName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByConnectorPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByConnectorPagingPage(resourceGroupName, hubName, connectorName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a connector mapping or updates an existing connector mapping in the connector.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param mappingName The name of the connector mapping.
     * @param parameters Parameters supplied to the CreateOrUpdate Connector Mapping operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, hubName, connectorName, mappingName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            hubName,
            connectorName,
            mappingName,
            parameters,
            options
        }, createOrUpdateOperationSpec$5);
    }
    /**
     * Gets a connector mapping in the connector.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param mappingName The name of the connector mapping.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, connectorName, mappingName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, connectorName, mappingName, options }, getOperationSpec$6);
    }
    /**
     * Deletes a connector mapping in the connector.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param mappingName The name of the connector mapping.
     * @param options The options parameters.
     */
    delete(resourceGroupName, hubName, connectorName, mappingName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, connectorName, mappingName, options }, deleteOperationSpec$5);
    }
    /**
     * Gets all the connector mappings in the specified connector.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param options The options parameters.
     */
    _listByConnector(resourceGroupName, hubName, connectorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, connectorName, options }, listByConnectorOperationSpec);
    }
    /**
     * ListByConnectorNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param connectorName The name of the connector.
     * @param nextLink The nextLink from the previous successful call to the ListByConnector method.
     * @param options The options parameters.
     */
    _listByConnectorNext(resourceGroupName, hubName, connectorName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, connectorName, nextLink, options }, listByConnectorNextOperationSpec);
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}/mappings/{mappingName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectorMappingResourceFormat
        },
        201: {
            bodyMapper: ConnectorMappingResourceFormat
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1,
        mappingName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}/mappings/{mappingName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorMappingResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1,
        mappingName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}/mappings/{mappingName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1,
        mappingName1
    ],
    serializer: serializer$8
};
const listByConnectorOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/connectors/{connectorName}/mappings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorMappingListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByConnectorNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectorMappingListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1,
        connectorName1
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Kpi operations. */
class KpiImpl {
    /**
     * Initialize a new instance of the class Kpi class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the KPIs in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a KPI or updates an existing KPI in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param parameters Parameters supplied to the create/update KPI operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, kpiName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, kpiName, parameters, options }, createOrUpdateOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a KPI or updates an existing KPI in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param parameters Parameters supplied to the create/update KPI operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, kpiName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, kpiName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a KPI in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, kpiName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, kpiName, options }, getOperationSpec$5);
    }
    /**
     * Deletes a KPI in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, kpiName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, kpiName, options }, deleteOperationSpec$4);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a KPI in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, kpiName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, kpiName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Reprocesses the Kpi values of the specified KPI.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param kpiName The name of the KPI.
     * @param options The options parameters.
     */
    reprocess(resourceGroupName, hubName, kpiName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, kpiName, options }, reprocessOperationSpec);
    }
    /**
     * Gets all the KPIs in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$6);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/kpi/{kpiName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: KpiResourceFormat
        },
        201: {
            bodyMapper: KpiResourceFormat
        },
        202: {
            bodyMapper: KpiResourceFormat
        },
        204: {
            bodyMapper: KpiResourceFormat
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        kpiName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/kpi/{kpiName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KpiResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        kpiName1
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/kpi/{kpiName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        kpiName1
    ],
    serializer: serializer$7
};
const reprocessOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/kpi/{kpiName}/reprocess",
    httpMethod: "POST",
    responses: { 202: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        kpiName1
    ],
    serializer: serializer$7
};
const listByHubOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/kpi",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KpiListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listByHubNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: KpiListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WidgetTypes operations. */
class WidgetTypesImpl {
    /**
     * Initialize a new instance of the class WidgetTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all available widget types in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all available widget types in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$5);
    }
    /**
     * Gets a widget type in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param widgetTypeName The name of the widget type.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, widgetTypeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, widgetTypeName, options }, getOperationSpec$4);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByHubOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/widgetTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WidgetTypeListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/widgetTypes/{widgetTypeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WidgetTypeResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        widgetTypeName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const listByHubNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WidgetTypeListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Views operations. */
class ViewsImpl {
    /**
     * Initialize a new instance of the class Views class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all available views for given user in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param userId The user ID. Use * to retrieve hub level views.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, userId, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, userId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, userId, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, userId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, userId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, userId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, userId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, userId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all available views for given user in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param userId The user ID. Use * to retrieve hub level views.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, userId, options }, listByHubOperationSpec$4);
    }
    /**
     * Creates a view or updates an existing view in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param viewName The name of the view.
     * @param parameters Parameters supplied to the CreateOrUpdate View operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, hubName, viewName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, viewName, parameters, options }, createOrUpdateOperationSpec$3);
    }
    /**
     * Gets a view in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param viewName The name of the view.
     * @param userId The user ID. Use * to retrieve hub level view.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, viewName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, viewName, userId, options }, getOperationSpec$3);
    }
    /**
     * Deletes a view in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param viewName The name of the view.
     * @param userId The user ID. Use * to retrieve hub level view.
     * @param options The options parameters.
     */
    delete(resourceGroupName, hubName, viewName, userId, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, viewName, userId, options }, deleteOperationSpec$3);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param userId The user ID. Use * to retrieve hub level views.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, userId, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, userId, nextLink, options }, listByHubNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByHubOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/views",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        }
    },
    queryParameters: [apiVersion, userId],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/views/{viewName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ViewResourceFormat
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        viewName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$5
};
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/views/{viewName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewResourceFormat
        }
    },
    queryParameters: [apiVersion, userId],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        viewName1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/views/{viewName}",
    httpMethod: "DELETE",
    responses: { 200: {} },
    queryParameters: [apiVersion, userId],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        viewName1
    ],
    serializer: serializer$5
};
const listByHubNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ViewListResult
        }
    },
    queryParameters: [apiVersion, userId],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Links operations. */
class LinksImpl {
    /**
     * Initialize a new instance of the class Links class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the links in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a link or updates an existing link in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param linkName The name of the link.
     * @param parameters Parameters supplied to the CreateOrUpdate Link operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, linkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, linkName, parameters, options }, createOrUpdateOperationSpec$2);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a link or updates an existing link in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param linkName The name of the link.
     * @param parameters Parameters supplied to the CreateOrUpdate Link operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, linkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, linkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a link in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param linkName The name of the link.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, linkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, linkName, options }, getOperationSpec$2);
    }
    /**
     * Deletes a link in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param linkName The name of the link.
     * @param options The options parameters.
     */
    delete(resourceGroupName, hubName, linkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, linkName, options }, deleteOperationSpec$2);
    }
    /**
     * Gets all the links in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$3);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/links/{linkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LinkResourceFormat
        },
        201: {
            bodyMapper: LinkResourceFormat
        },
        202: {
            bodyMapper: LinkResourceFormat
        },
        204: {
            bodyMapper: LinkResourceFormat
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        linkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/links/{linkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LinkResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        linkName1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/links/{linkName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 202: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        linkName1
    ],
    serializer: serializer$4
};
const listByHubOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/links",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LinkListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listByHubNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LinkListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Roles operations. */
class RolesImpl {
    /**
     * Initialize a new instance of the class Roles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the roles for the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the roles for the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$2);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByHubOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/roles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listByHubNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoleAssignments operations. */
class RoleAssignmentsImpl {
    /**
     * Initialize a new instance of the class RoleAssignments class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the role assignments for the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the role assignments for the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec$1);
    }
    /**
     * Creates or updates a role assignment in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param assignmentName The assignment name
     * @param parameters Parameters supplied to the CreateOrUpdate RoleAssignment operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, assignmentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, assignmentName, parameters, options }, createOrUpdateOperationSpec$1);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a role assignment in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param assignmentName The assignment name
     * @param parameters Parameters supplied to the CreateOrUpdate RoleAssignment operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, assignmentName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, assignmentName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the role assignment in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param assignmentName The name of the role assignment.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, assignmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, assignmentName, options }, getOperationSpec$1);
    }
    /**
     * Deletes the role assignment in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param assignmentName The name of the role assignment.
     * @param options The options parameters.
     */
    delete(resourceGroupName, hubName, assignmentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, assignmentName, options }, deleteOperationSpec$1);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listByHubOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/roleAssignments",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/roleAssignments/{assignmentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RoleAssignmentResourceFormat
        },
        201: {
            bodyMapper: RoleAssignmentResourceFormat
        },
        202: {
            bodyMapper: RoleAssignmentResourceFormat
        },
        204: {
            bodyMapper: RoleAssignmentResourceFormat
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        assignmentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/roleAssignments/{assignmentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        assignmentName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/roleAssignments/{assignmentName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        assignmentName1
    ],
    serializer: serializer$2
};
const listByHubNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoleAssignmentListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Images operations. */
class ImagesImpl {
    /**
     * Initialize a new instance of the class Images class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets entity type (profile or interaction) image upload URL.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param parameters Parameters supplied to the GetUploadUrlForEntityType operation.
     * @param options The options parameters.
     */
    getUploadUrlForEntityType(resourceGroupName, hubName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, parameters, options }, getUploadUrlForEntityTypeOperationSpec);
    }
    /**
     * Gets data image upload URL.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param parameters Parameters supplied to the GetUploadUrlForData operation.
     * @param options The options parameters.
     */
    getUploadUrlForData(resourceGroupName, hubName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, parameters, options }, getUploadUrlForDataOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getUploadUrlForEntityTypeOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/images/getEntityTypeImageUploadUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImageDefinition
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const getUploadUrlForDataOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/images/getDataImageUploadUrl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ImageDefinition
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Predictions operations. */
class PredictionsImpl {
    /**
     * Initialize a new instance of the class Predictions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the predictions in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    listByHub(resourceGroupName, hubName, options) {
        const iter = this.listByHubPagingAll(resourceGroupName, hubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByHubPagingPage(resourceGroupName, hubName, options, settings);
            }
        };
    }
    listByHubPagingPage(resourceGroupName, hubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByHub(resourceGroupName, hubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByHubNext(resourceGroupName, hubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByHubPagingAll(resourceGroupName, hubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByHubPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByHubPagingPage(resourceGroupName, hubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a Prediction or updates an existing Prediction in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param parameters Parameters supplied to the create/update Prediction operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, hubName, predictionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, predictionName, parameters, options }, createOrUpdateOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a Prediction or updates an existing Prediction in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param parameters Parameters supplied to the create/update Prediction operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, hubName, predictionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, hubName, predictionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a Prediction in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param options The options parameters.
     */
    get(resourceGroupName, hubName, predictionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, predictionName, options }, getOperationSpec);
    }
    /**
     * Deletes a Prediction in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, hubName, predictionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = new LroImpl(sendOperation, { resourceGroupName, hubName, predictionName, options }, deleteOperationSpec);
            const poller = new coreLro.LroEngine(lro, {
                resumeFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a Prediction in the hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, hubName, predictionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, hubName, predictionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets training results.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param options The options parameters.
     */
    getTrainingResults(resourceGroupName, hubName, predictionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, predictionName, options }, getTrainingResultsOperationSpec);
    }
    /**
     * Gets model status of the prediction.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param options The options parameters.
     */
    getModelStatus(resourceGroupName, hubName, predictionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, predictionName, options }, getModelStatusOperationSpec);
    }
    /**
     * Creates or updates the model status of prediction.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param predictionName The name of the Prediction.
     * @param parameters Parameters supplied to the create/update prediction model status operation.
     * @param options The options parameters.
     */
    modelStatus(resourceGroupName, hubName, predictionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, predictionName, parameters, options }, modelStatusOperationSpec);
    }
    /**
     * Gets all the predictions in the specified hub.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param options The options parameters.
     */
    _listByHub(resourceGroupName, hubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, options }, listByHubOperationSpec);
    }
    /**
     * ListByHubNext
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the hub.
     * @param nextLink The nextLink from the previous successful call to the ListByHub method.
     * @param options The options parameters.
     */
    _listByHubNext(resourceGroupName, hubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, hubName, nextLink, options }, listByHubNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PredictionResourceFormat
        },
        201: {
            bodyMapper: PredictionResourceFormat
        },
        202: {
            bodyMapper: PredictionResourceFormat
        },
        204: {
            bodyMapper: PredictionResourceFormat
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PredictionResourceFormat
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName1
    ],
    headerParameters: [accept],
    serializer
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}",
    httpMethod: "DELETE",
    responses: { 200: {}, 201: {}, 202: {}, 204: {} },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName1
    ],
    serializer
};
const getTrainingResultsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}/getTrainingResults",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PredictionTrainingResults
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName1
    ],
    headerParameters: [accept],
    serializer
};
const getModelStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}/getModelStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PredictionModelStatus
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName1
    ],
    headerParameters: [accept],
    serializer
};
const modelStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions/{predictionName}/modelStatus",
    httpMethod: "POST",
    responses: { 200: {} },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1,
        predictionName1
    ],
    headerParameters: [contentType],
    mediaType: "json",
    serializer
};
const listByHubOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.CustomerInsights/hubs/{hubName}/predictions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PredictionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer
};
const listByHubNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PredictionListResult
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        nextLink,
        resourceGroupName,
        subscriptionId,
        hubName1
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class CustomerInsightsManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the CustomerInsightsManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId Gets subscription credentials which uniquely identify Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-customerinsights/4.1.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.apiVersion = options.apiVersion || "2017-04-26";
        this.operations = new OperationsImpl(this);
        this.hubs = new HubsImpl(this);
        this.profiles = new ProfilesImpl(this);
        this.interactions = new InteractionsImpl(this);
        this.relationships = new RelationshipsImpl(this);
        this.relationshipLinks = new RelationshipLinksImpl(this);
        this.authorizationPolicies = new AuthorizationPoliciesImpl(this);
        this.connectors = new ConnectorsImpl(this);
        this.connectorMappings = new ConnectorMappingsImpl(this);
        this.kpi = new KpiImpl(this);
        this.widgetTypes = new WidgetTypesImpl(this);
        this.views = new ViewsImpl(this);
        this.links = new LinksImpl(this);
        this.roles = new RolesImpl(this);
        this.roleAssignments = new RoleAssignmentsImpl(this);
        this.images = new ImagesImpl(this);
        this.predictions = new PredictionsImpl(this);
        this.addCustomApiVersionPolicy(options.apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            sendRequest(request, next) {
                return tslib.__awaiter(this, void 0, void 0, function* () {
                    const param = request.url.split("?");
                    if (param.length > 1) {
                        const newParams = param[1].split("&").map((item) => {
                            if (item.indexOf("api-version") > -1) {
                                return "api-version=" + apiVersion;
                            }
                            else {
                                return item;
                            }
                        });
                        request.url = param[0] + "?" + newParams.join("&");
                    }
                    return next(request);
                });
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

exports.CustomerInsightsManagementClient = CustomerInsightsManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
