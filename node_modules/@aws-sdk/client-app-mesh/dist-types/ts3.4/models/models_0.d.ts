import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { AppMeshServiceException as __BaseException } from "./AppMeshServiceException";
export interface JsonFormatRef {
  key: string | undefined;
  value: string | undefined;
}
export type LoggingFormat =
  | LoggingFormat.JsonMember
  | LoggingFormat.TextMember
  | LoggingFormat.$UnknownMember;
export declare namespace LoggingFormat {
  interface TextMember {
    text: string;
    json?: never;
    $unknown?: never;
  }
  interface JsonMember {
    text?: never;
    json: JsonFormatRef[];
    $unknown?: never;
  }
  interface $UnknownMember {
    text?: never;
    json?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    text: (value: string) => T;
    json: (value: JsonFormatRef[]) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: LoggingFormat, visitor: Visitor<T>) => T;
}
export interface FileAccessLog {
  path: string | undefined;
  format?: LoggingFormat;
}
export type AccessLog = AccessLog.FileMember | AccessLog.$UnknownMember;
export declare namespace AccessLog {
  interface FileMember {
    file: FileAccessLog;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: FileAccessLog) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: AccessLog, visitor: Visitor<T>) => T;
}
export declare class BadRequestException extends __BaseException {
  readonly name: "BadRequestException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<BadRequestException, __BaseException>
  );
}
export declare class ForbiddenException extends __BaseException {
  readonly name: "ForbiddenException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ForbiddenException, __BaseException>);
}
export declare class InternalServerErrorException extends __BaseException {
  readonly name: "InternalServerErrorException";
  readonly $fault: "server";
  $retryable: {};
  constructor(
    opts: __ExceptionOptionType<InternalServerErrorException, __BaseException>
  );
}
export interface ListTagsForResourceInput {
  resourceArn: string | undefined;
  nextToken?: string;
  limit?: number;
}
export interface TagRef {
  key: string | undefined;
  value: string | undefined;
}
export interface ListTagsForResourceOutput {
  tags: TagRef[] | undefined;
  nextToken?: string;
}
export declare class NotFoundException extends __BaseException {
  readonly name: "NotFoundException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
}
export declare class ServiceUnavailableException extends __BaseException {
  readonly name: "ServiceUnavailableException";
  readonly $fault: "server";
  $retryable: {};
  constructor(
    opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>
  );
}
export declare class TooManyRequestsException extends __BaseException {
  readonly name: "TooManyRequestsException";
  readonly $fault: "client";
  $retryable: {
    throttling: boolean;
  };
  constructor(
    opts: __ExceptionOptionType<TooManyRequestsException, __BaseException>
  );
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export declare const EgressFilterType: {
  readonly ALLOW_ALL: "ALLOW_ALL";
  readonly DROP_ALL: "DROP_ALL";
};
export type EgressFilterType =
  (typeof EgressFilterType)[keyof typeof EgressFilterType];
export interface EgressFilter {
  type: EgressFilterType | undefined;
}
export declare const IpPreference: {
  readonly IPv4_ONLY: "IPv4_ONLY";
  readonly IPv4_PREFERRED: "IPv4_PREFERRED";
  readonly IPv6_ONLY: "IPv6_ONLY";
  readonly IPv6_PREFERRED: "IPv6_PREFERRED";
};
export type IpPreference = (typeof IpPreference)[keyof typeof IpPreference];
export interface MeshServiceDiscovery {
  ipPreference?: IpPreference;
}
export interface MeshSpec {
  egressFilter?: EgressFilter;
  serviceDiscovery?: MeshServiceDiscovery;
}
export interface CreateMeshInput {
  meshName: string | undefined;
  spec?: MeshSpec;
  tags?: TagRef[];
  clientToken?: string;
}
export interface ResourceMetadata {
  arn: string | undefined;
  version: number | undefined;
  uid: string | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
}
export declare const MeshStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type MeshStatusCode =
  (typeof MeshStatusCode)[keyof typeof MeshStatusCode];
export interface MeshStatus {
  status?: MeshStatusCode;
}
export interface MeshData {
  meshName: string | undefined;
  spec: MeshSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: MeshStatus | undefined;
}
export interface CreateMeshOutput {
  mesh: MeshData | undefined;
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export interface DeleteMeshInput {
  meshName: string | undefined;
}
export interface DeleteMeshOutput {
  mesh: MeshData | undefined;
}
export declare class ResourceInUseException extends __BaseException {
  readonly name: "ResourceInUseException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceInUseException, __BaseException>
  );
}
export interface DescribeMeshInput {
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DescribeMeshOutput {
  mesh: MeshData | undefined;
}
export interface ListMeshesInput {
  nextToken?: string;
  limit?: number;
}
export interface MeshRef {
  meshName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListMeshesOutput {
  meshes: MeshRef[] | undefined;
  nextToken?: string;
}
export interface UpdateMeshInput {
  meshName: string | undefined;
  spec?: MeshSpec;
  clientToken?: string;
}
export interface UpdateMeshOutput {
  mesh: MeshData | undefined;
}
export interface VirtualGatewayListenerTlsFileCertificate {
  certificateChain: string | undefined;
  privateKey: string | undefined;
}
export interface VirtualGatewayListenerTlsSdsCertificate {
  secretName: string | undefined;
}
export type VirtualGatewayClientTlsCertificate =
  | VirtualGatewayClientTlsCertificate.FileMember
  | VirtualGatewayClientTlsCertificate.SdsMember
  | VirtualGatewayClientTlsCertificate.$UnknownMember;
export declare namespace VirtualGatewayClientTlsCertificate {
  interface FileMember {
    file: VirtualGatewayListenerTlsFileCertificate;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    file?: never;
    sds: VirtualGatewayListenerTlsSdsCertificate;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: VirtualGatewayListenerTlsFileCertificate) => T;
    sds: (value: VirtualGatewayListenerTlsSdsCertificate) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: VirtualGatewayClientTlsCertificate,
    visitor: Visitor<T>
  ) => T;
}
export interface SubjectAlternativeNameMatchers {
  exact: string[] | undefined;
}
export interface SubjectAlternativeNames {
  match: SubjectAlternativeNameMatchers | undefined;
}
export interface VirtualGatewayTlsValidationContextAcmTrust {
  certificateAuthorityArns: string[] | undefined;
}
export interface VirtualGatewayTlsValidationContextFileTrust {
  certificateChain: string | undefined;
}
export interface VirtualGatewayTlsValidationContextSdsTrust {
  secretName: string | undefined;
}
export type VirtualGatewayTlsValidationContextTrust =
  | VirtualGatewayTlsValidationContextTrust.AcmMember
  | VirtualGatewayTlsValidationContextTrust.FileMember
  | VirtualGatewayTlsValidationContextTrust.SdsMember
  | VirtualGatewayTlsValidationContextTrust.$UnknownMember;
export declare namespace VirtualGatewayTlsValidationContextTrust {
  interface AcmMember {
    acm: VirtualGatewayTlsValidationContextAcmTrust;
    file?: never;
    sds?: never;
    $unknown?: never;
  }
  interface FileMember {
    acm?: never;
    file: VirtualGatewayTlsValidationContextFileTrust;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    acm?: never;
    file?: never;
    sds: VirtualGatewayTlsValidationContextSdsTrust;
    $unknown?: never;
  }
  interface $UnknownMember {
    acm?: never;
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    acm: (value: VirtualGatewayTlsValidationContextAcmTrust) => T;
    file: (value: VirtualGatewayTlsValidationContextFileTrust) => T;
    sds: (value: VirtualGatewayTlsValidationContextSdsTrust) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: VirtualGatewayTlsValidationContextTrust,
    visitor: Visitor<T>
  ) => T;
}
export interface VirtualGatewayTlsValidationContext {
  trust: VirtualGatewayTlsValidationContextTrust | undefined;
  subjectAlternativeNames?: SubjectAlternativeNames;
}
export interface VirtualGatewayClientPolicyTls {
  enforce?: boolean;
  ports?: number[];
  certificate?: VirtualGatewayClientTlsCertificate;
  validation: VirtualGatewayTlsValidationContext | undefined;
}
export interface VirtualGatewayClientPolicy {
  tls?: VirtualGatewayClientPolicyTls;
}
export interface VirtualGatewayBackendDefaults {
  clientPolicy?: VirtualGatewayClientPolicy;
}
export interface VirtualGatewayGrpcConnectionPool {
  maxRequests: number | undefined;
}
export interface VirtualGatewayHttpConnectionPool {
  maxConnections: number | undefined;
  maxPendingRequests?: number;
}
export interface VirtualGatewayHttp2ConnectionPool {
  maxRequests: number | undefined;
}
export type VirtualGatewayConnectionPool =
  | VirtualGatewayConnectionPool.GrpcMember
  | VirtualGatewayConnectionPool.HttpMember
  | VirtualGatewayConnectionPool.Http2Member
  | VirtualGatewayConnectionPool.$UnknownMember;
export declare namespace VirtualGatewayConnectionPool {
  interface HttpMember {
    http: VirtualGatewayHttpConnectionPool;
    http2?: never;
    grpc?: never;
    $unknown?: never;
  }
  interface Http2Member {
    http?: never;
    http2: VirtualGatewayHttp2ConnectionPool;
    grpc?: never;
    $unknown?: never;
  }
  interface GrpcMember {
    http?: never;
    http2?: never;
    grpc: VirtualGatewayGrpcConnectionPool;
    $unknown?: never;
  }
  interface $UnknownMember {
    http?: never;
    http2?: never;
    grpc?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    http: (value: VirtualGatewayHttpConnectionPool) => T;
    http2: (value: VirtualGatewayHttp2ConnectionPool) => T;
    grpc: (value: VirtualGatewayGrpcConnectionPool) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: VirtualGatewayConnectionPool,
    visitor: Visitor<T>
  ) => T;
}
export declare const VirtualGatewayPortProtocol: {
  readonly GRPC: "grpc";
  readonly HTTP: "http";
  readonly HTTP2: "http2";
};
export type VirtualGatewayPortProtocol =
  (typeof VirtualGatewayPortProtocol)[keyof typeof VirtualGatewayPortProtocol];
export interface VirtualGatewayHealthCheckPolicy {
  timeoutMillis: number | undefined;
  intervalMillis: number | undefined;
  protocol: VirtualGatewayPortProtocol | undefined;
  port?: number;
  path?: string;
  healthyThreshold: number | undefined;
  unhealthyThreshold: number | undefined;
}
export interface VirtualGatewayPortMapping {
  port: number | undefined;
  protocol: VirtualGatewayPortProtocol | undefined;
}
export interface VirtualGatewayListenerTlsAcmCertificate {
  certificateArn: string | undefined;
}
export type VirtualGatewayListenerTlsCertificate =
  | VirtualGatewayListenerTlsCertificate.AcmMember
  | VirtualGatewayListenerTlsCertificate.FileMember
  | VirtualGatewayListenerTlsCertificate.SdsMember
  | VirtualGatewayListenerTlsCertificate.$UnknownMember;
export declare namespace VirtualGatewayListenerTlsCertificate {
  interface AcmMember {
    acm: VirtualGatewayListenerTlsAcmCertificate;
    file?: never;
    sds?: never;
    $unknown?: never;
  }
  interface FileMember {
    acm?: never;
    file: VirtualGatewayListenerTlsFileCertificate;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    acm?: never;
    file?: never;
    sds: VirtualGatewayListenerTlsSdsCertificate;
    $unknown?: never;
  }
  interface $UnknownMember {
    acm?: never;
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    acm: (value: VirtualGatewayListenerTlsAcmCertificate) => T;
    file: (value: VirtualGatewayListenerTlsFileCertificate) => T;
    sds: (value: VirtualGatewayListenerTlsSdsCertificate) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: VirtualGatewayListenerTlsCertificate,
    visitor: Visitor<T>
  ) => T;
}
export declare const VirtualGatewayListenerTlsMode: {
  readonly DISABLED: "DISABLED";
  readonly PERMISSIVE: "PERMISSIVE";
  readonly STRICT: "STRICT";
};
export type VirtualGatewayListenerTlsMode =
  (typeof VirtualGatewayListenerTlsMode)[keyof typeof VirtualGatewayListenerTlsMode];
export type VirtualGatewayListenerTlsValidationContextTrust =
  | VirtualGatewayListenerTlsValidationContextTrust.FileMember
  | VirtualGatewayListenerTlsValidationContextTrust.SdsMember
  | VirtualGatewayListenerTlsValidationContextTrust.$UnknownMember;
export declare namespace VirtualGatewayListenerTlsValidationContextTrust {
  interface FileMember {
    file: VirtualGatewayTlsValidationContextFileTrust;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    file?: never;
    sds: VirtualGatewayTlsValidationContextSdsTrust;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: VirtualGatewayTlsValidationContextFileTrust) => T;
    sds: (value: VirtualGatewayTlsValidationContextSdsTrust) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: VirtualGatewayListenerTlsValidationContextTrust,
    visitor: Visitor<T>
  ) => T;
}
export interface VirtualGatewayListenerTlsValidationContext {
  trust: VirtualGatewayListenerTlsValidationContextTrust | undefined;
  subjectAlternativeNames?: SubjectAlternativeNames;
}
export interface VirtualGatewayListenerTls {
  mode: VirtualGatewayListenerTlsMode | undefined;
  validation?: VirtualGatewayListenerTlsValidationContext;
  certificate: VirtualGatewayListenerTlsCertificate | undefined;
}
export interface VirtualGatewayListener {
  healthCheck?: VirtualGatewayHealthCheckPolicy;
  portMapping: VirtualGatewayPortMapping | undefined;
  tls?: VirtualGatewayListenerTls;
  connectionPool?: VirtualGatewayConnectionPool;
}
export interface VirtualGatewayFileAccessLog {
  path: string | undefined;
  format?: LoggingFormat;
}
export type VirtualGatewayAccessLog =
  | VirtualGatewayAccessLog.FileMember
  | VirtualGatewayAccessLog.$UnknownMember;
export declare namespace VirtualGatewayAccessLog {
  interface FileMember {
    file: VirtualGatewayFileAccessLog;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: VirtualGatewayFileAccessLog) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: VirtualGatewayAccessLog, visitor: Visitor<T>) => T;
}
export interface VirtualGatewayLogging {
  accessLog?: VirtualGatewayAccessLog;
}
export interface VirtualGatewaySpec {
  backendDefaults?: VirtualGatewayBackendDefaults;
  listeners: VirtualGatewayListener[] | undefined;
  logging?: VirtualGatewayLogging;
}
export interface CreateVirtualGatewayInput {
  virtualGatewayName: string | undefined;
  meshName: string | undefined;
  spec: VirtualGatewaySpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const VirtualGatewayStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type VirtualGatewayStatusCode =
  (typeof VirtualGatewayStatusCode)[keyof typeof VirtualGatewayStatusCode];
export interface VirtualGatewayStatus {
  status: VirtualGatewayStatusCode | undefined;
}
export interface VirtualGatewayData {
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  spec: VirtualGatewaySpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: VirtualGatewayStatus | undefined;
}
export interface CreateVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData | undefined;
}
export interface DeleteVirtualGatewayInput {
  virtualGatewayName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DeleteVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData | undefined;
}
export interface DescribeVirtualGatewayInput {
  virtualGatewayName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DescribeVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData | undefined;
}
export declare const DefaultGatewayRouteRewrite: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type DefaultGatewayRouteRewrite =
  (typeof DefaultGatewayRouteRewrite)[keyof typeof DefaultGatewayRouteRewrite];
export interface GatewayRouteHostnameRewrite {
  defaultTargetHostname?: DefaultGatewayRouteRewrite;
}
export interface GrpcGatewayRouteRewrite {
  hostname?: GatewayRouteHostnameRewrite;
}
export interface GatewayRouteVirtualService {
  virtualServiceName: string | undefined;
}
export interface GatewayRouteTarget {
  virtualService: GatewayRouteVirtualService | undefined;
  port?: number;
}
export interface GrpcGatewayRouteAction {
  target: GatewayRouteTarget | undefined;
  rewrite?: GrpcGatewayRouteRewrite;
}
export interface GatewayRouteHostnameMatch {
  exact?: string;
  suffix?: string;
}
export interface MatchRange {
  start: number | undefined;
  end: number | undefined;
}
export type GrpcMetadataMatchMethod =
  | GrpcMetadataMatchMethod.ExactMember
  | GrpcMetadataMatchMethod.PrefixMember
  | GrpcMetadataMatchMethod.RangeMember
  | GrpcMetadataMatchMethod.RegexMember
  | GrpcMetadataMatchMethod.SuffixMember
  | GrpcMetadataMatchMethod.$UnknownMember;
export declare namespace GrpcMetadataMatchMethod {
  interface ExactMember {
    exact: string;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RegexMember {
    exact?: never;
    regex: string;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RangeMember {
    exact?: never;
    regex?: never;
    range: MatchRange;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface PrefixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix: string;
    suffix?: never;
    $unknown?: never;
  }
  interface SuffixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    exact: (value: string) => T;
    regex: (value: string) => T;
    range: (value: MatchRange) => T;
    prefix: (value: string) => T;
    suffix: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: GrpcMetadataMatchMethod, visitor: Visitor<T>) => T;
}
export interface GrpcGatewayRouteMetadata {
  name: string | undefined;
  invert?: boolean;
  match?: GrpcMetadataMatchMethod;
}
export interface GrpcGatewayRouteMatch {
  serviceName?: string;
  hostname?: GatewayRouteHostnameMatch;
  metadata?: GrpcGatewayRouteMetadata[];
  port?: number;
}
export interface GrpcGatewayRoute {
  match: GrpcGatewayRouteMatch | undefined;
  action: GrpcGatewayRouteAction | undefined;
}
export interface HttpGatewayRoutePathRewrite {
  exact?: string;
}
export interface HttpGatewayRoutePrefixRewrite {
  defaultPrefix?: DefaultGatewayRouteRewrite;
  value?: string;
}
export interface HttpGatewayRouteRewrite {
  prefix?: HttpGatewayRoutePrefixRewrite;
  path?: HttpGatewayRoutePathRewrite;
  hostname?: GatewayRouteHostnameRewrite;
}
export interface HttpGatewayRouteAction {
  target: GatewayRouteTarget | undefined;
  rewrite?: HttpGatewayRouteRewrite;
}
export type HeaderMatchMethod =
  | HeaderMatchMethod.ExactMember
  | HeaderMatchMethod.PrefixMember
  | HeaderMatchMethod.RangeMember
  | HeaderMatchMethod.RegexMember
  | HeaderMatchMethod.SuffixMember
  | HeaderMatchMethod.$UnknownMember;
export declare namespace HeaderMatchMethod {
  interface ExactMember {
    exact: string;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RegexMember {
    exact?: never;
    regex: string;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RangeMember {
    exact?: never;
    regex?: never;
    range: MatchRange;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface PrefixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix: string;
    suffix?: never;
    $unknown?: never;
  }
  interface SuffixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    exact: (value: string) => T;
    regex: (value: string) => T;
    range: (value: MatchRange) => T;
    prefix: (value: string) => T;
    suffix: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: HeaderMatchMethod, visitor: Visitor<T>) => T;
}
export interface HttpGatewayRouteHeader {
  name: string | undefined;
  invert?: boolean;
  match?: HeaderMatchMethod;
}
export declare const HttpMethod: {
  readonly CONNECT: "CONNECT";
  readonly DELETE: "DELETE";
  readonly GET: "GET";
  readonly HEAD: "HEAD";
  readonly OPTIONS: "OPTIONS";
  readonly PATCH: "PATCH";
  readonly POST: "POST";
  readonly PUT: "PUT";
  readonly TRACE: "TRACE";
};
export type HttpMethod = (typeof HttpMethod)[keyof typeof HttpMethod];
export interface HttpPathMatch {
  exact?: string;
  regex?: string;
}
export interface QueryParameterMatch {
  exact?: string;
}
export interface HttpQueryParameter {
  name: string | undefined;
  match?: QueryParameterMatch;
}
export interface HttpGatewayRouteMatch {
  prefix?: string;
  path?: HttpPathMatch;
  queryParameters?: HttpQueryParameter[];
  method?: HttpMethod;
  hostname?: GatewayRouteHostnameMatch;
  headers?: HttpGatewayRouteHeader[];
  port?: number;
}
export interface HttpGatewayRoute {
  match: HttpGatewayRouteMatch | undefined;
  action: HttpGatewayRouteAction | undefined;
}
export interface GatewayRouteSpec {
  priority?: number;
  httpRoute?: HttpGatewayRoute;
  http2Route?: HttpGatewayRoute;
  grpcRoute?: GrpcGatewayRoute;
}
export interface CreateGatewayRouteInput {
  gatewayRouteName: string | undefined;
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  spec: GatewayRouteSpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const GatewayRouteStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type GatewayRouteStatusCode =
  (typeof GatewayRouteStatusCode)[keyof typeof GatewayRouteStatusCode];
export interface GatewayRouteStatus {
  status: GatewayRouteStatusCode | undefined;
}
export interface GatewayRouteData {
  meshName: string | undefined;
  gatewayRouteName: string | undefined;
  virtualGatewayName: string | undefined;
  spec: GatewayRouteSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: GatewayRouteStatus | undefined;
}
export interface CreateGatewayRouteOutput {
  gatewayRoute: GatewayRouteData | undefined;
}
export interface DeleteGatewayRouteInput {
  gatewayRouteName: string | undefined;
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  meshOwner?: string;
}
export interface DeleteGatewayRouteOutput {
  gatewayRoute: GatewayRouteData | undefined;
}
export interface DescribeGatewayRouteInput {
  gatewayRouteName: string | undefined;
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  meshOwner?: string;
}
export interface DescribeGatewayRouteOutput {
  gatewayRoute: GatewayRouteData | undefined;
}
export interface ListGatewayRoutesInput {
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface GatewayRouteRef {
  meshName: string | undefined;
  gatewayRouteName: string | undefined;
  virtualGatewayName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListGatewayRoutesOutput {
  gatewayRoutes: GatewayRouteRef[] | undefined;
  nextToken?: string;
}
export interface UpdateGatewayRouteInput {
  gatewayRouteName: string | undefined;
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  spec: GatewayRouteSpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateGatewayRouteOutput {
  gatewayRoute: GatewayRouteData | undefined;
}
export interface ListVirtualGatewaysInput {
  meshName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface VirtualGatewayRef {
  meshName: string | undefined;
  virtualGatewayName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListVirtualGatewaysOutput {
  virtualGateways: VirtualGatewayRef[] | undefined;
  nextToken?: string;
}
export interface UpdateVirtualGatewayInput {
  virtualGatewayName: string | undefined;
  meshName: string | undefined;
  spec: VirtualGatewaySpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateVirtualGatewayOutput {
  virtualGateway: VirtualGatewayData | undefined;
}
export interface ListenerTlsFileCertificate {
  certificateChain: string | undefined;
  privateKey: string | undefined;
}
export interface ListenerTlsSdsCertificate {
  secretName: string | undefined;
}
export type ClientTlsCertificate =
  | ClientTlsCertificate.FileMember
  | ClientTlsCertificate.SdsMember
  | ClientTlsCertificate.$UnknownMember;
export declare namespace ClientTlsCertificate {
  interface FileMember {
    file: ListenerTlsFileCertificate;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    file?: never;
    sds: ListenerTlsSdsCertificate;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: ListenerTlsFileCertificate) => T;
    sds: (value: ListenerTlsSdsCertificate) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ClientTlsCertificate, visitor: Visitor<T>) => T;
}
export interface TlsValidationContextAcmTrust {
  certificateAuthorityArns: string[] | undefined;
}
export interface TlsValidationContextFileTrust {
  certificateChain: string | undefined;
}
export interface TlsValidationContextSdsTrust {
  secretName: string | undefined;
}
export type TlsValidationContextTrust =
  | TlsValidationContextTrust.AcmMember
  | TlsValidationContextTrust.FileMember
  | TlsValidationContextTrust.SdsMember
  | TlsValidationContextTrust.$UnknownMember;
export declare namespace TlsValidationContextTrust {
  interface AcmMember {
    acm: TlsValidationContextAcmTrust;
    file?: never;
    sds?: never;
    $unknown?: never;
  }
  interface FileMember {
    acm?: never;
    file: TlsValidationContextFileTrust;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    acm?: never;
    file?: never;
    sds: TlsValidationContextSdsTrust;
    $unknown?: never;
  }
  interface $UnknownMember {
    acm?: never;
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    acm: (value: TlsValidationContextAcmTrust) => T;
    file: (value: TlsValidationContextFileTrust) => T;
    sds: (value: TlsValidationContextSdsTrust) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: TlsValidationContextTrust, visitor: Visitor<T>) => T;
}
export interface TlsValidationContext {
  trust: TlsValidationContextTrust | undefined;
  subjectAlternativeNames?: SubjectAlternativeNames;
}
export interface ClientPolicyTls {
  enforce?: boolean;
  ports?: number[];
  certificate?: ClientTlsCertificate;
  validation: TlsValidationContext | undefined;
}
export interface ClientPolicy {
  tls?: ClientPolicyTls;
}
export interface BackendDefaults {
  clientPolicy?: ClientPolicy;
}
export interface VirtualServiceBackend {
  virtualServiceName: string | undefined;
  clientPolicy?: ClientPolicy;
}
export type Backend = Backend.VirtualServiceMember | Backend.$UnknownMember;
export declare namespace Backend {
  interface VirtualServiceMember {
    virtualService: VirtualServiceBackend;
    $unknown?: never;
  }
  interface $UnknownMember {
    virtualService?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    virtualService: (value: VirtualServiceBackend) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: Backend, visitor: Visitor<T>) => T;
}
export interface VirtualNodeGrpcConnectionPool {
  maxRequests: number | undefined;
}
export interface VirtualNodeHttpConnectionPool {
  maxConnections: number | undefined;
  maxPendingRequests?: number;
}
export interface VirtualNodeHttp2ConnectionPool {
  maxRequests: number | undefined;
}
export interface VirtualNodeTcpConnectionPool {
  maxConnections: number | undefined;
}
export type VirtualNodeConnectionPool =
  | VirtualNodeConnectionPool.GrpcMember
  | VirtualNodeConnectionPool.HttpMember
  | VirtualNodeConnectionPool.Http2Member
  | VirtualNodeConnectionPool.TcpMember
  | VirtualNodeConnectionPool.$UnknownMember;
export declare namespace VirtualNodeConnectionPool {
  interface TcpMember {
    tcp: VirtualNodeTcpConnectionPool;
    http?: never;
    http2?: never;
    grpc?: never;
    $unknown?: never;
  }
  interface HttpMember {
    tcp?: never;
    http: VirtualNodeHttpConnectionPool;
    http2?: never;
    grpc?: never;
    $unknown?: never;
  }
  interface Http2Member {
    tcp?: never;
    http?: never;
    http2: VirtualNodeHttp2ConnectionPool;
    grpc?: never;
    $unknown?: never;
  }
  interface GrpcMember {
    tcp?: never;
    http?: never;
    http2?: never;
    grpc: VirtualNodeGrpcConnectionPool;
    $unknown?: never;
  }
  interface $UnknownMember {
    tcp?: never;
    http?: never;
    http2?: never;
    grpc?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    tcp: (value: VirtualNodeTcpConnectionPool) => T;
    http: (value: VirtualNodeHttpConnectionPool) => T;
    http2: (value: VirtualNodeHttp2ConnectionPool) => T;
    grpc: (value: VirtualNodeGrpcConnectionPool) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: VirtualNodeConnectionPool, visitor: Visitor<T>) => T;
}
export declare const PortProtocol: {
  readonly GRPC: "grpc";
  readonly HTTP: "http";
  readonly HTTP2: "http2";
  readonly TCP: "tcp";
};
export type PortProtocol = (typeof PortProtocol)[keyof typeof PortProtocol];
export interface HealthCheckPolicy {
  timeoutMillis: number | undefined;
  intervalMillis: number | undefined;
  protocol: PortProtocol | undefined;
  port?: number;
  path?: string;
  healthyThreshold: number | undefined;
  unhealthyThreshold: number | undefined;
}
export declare const DurationUnit: {
  readonly MS: "ms";
  readonly S: "s";
};
export type DurationUnit = (typeof DurationUnit)[keyof typeof DurationUnit];
export interface Duration {
  value?: number;
  unit?: DurationUnit;
}
export interface OutlierDetection {
  maxServerErrors: number | undefined;
  interval: Duration | undefined;
  baseEjectionDuration: Duration | undefined;
  maxEjectionPercent: number | undefined;
}
export interface PortMapping {
  port: number | undefined;
  protocol: PortProtocol | undefined;
}
export interface GrpcTimeout {
  perRequest?: Duration;
  idle?: Duration;
}
export interface HttpTimeout {
  perRequest?: Duration;
  idle?: Duration;
}
export interface TcpTimeout {
  idle?: Duration;
}
export type ListenerTimeout =
  | ListenerTimeout.GrpcMember
  | ListenerTimeout.HttpMember
  | ListenerTimeout.Http2Member
  | ListenerTimeout.TcpMember
  | ListenerTimeout.$UnknownMember;
export declare namespace ListenerTimeout {
  interface TcpMember {
    tcp: TcpTimeout;
    http?: never;
    http2?: never;
    grpc?: never;
    $unknown?: never;
  }
  interface HttpMember {
    tcp?: never;
    http: HttpTimeout;
    http2?: never;
    grpc?: never;
    $unknown?: never;
  }
  interface Http2Member {
    tcp?: never;
    http?: never;
    http2: HttpTimeout;
    grpc?: never;
    $unknown?: never;
  }
  interface GrpcMember {
    tcp?: never;
    http?: never;
    http2?: never;
    grpc: GrpcTimeout;
    $unknown?: never;
  }
  interface $UnknownMember {
    tcp?: never;
    http?: never;
    http2?: never;
    grpc?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    tcp: (value: TcpTimeout) => T;
    http: (value: HttpTimeout) => T;
    http2: (value: HttpTimeout) => T;
    grpc: (value: GrpcTimeout) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ListenerTimeout, visitor: Visitor<T>) => T;
}
export interface ListenerTlsAcmCertificate {
  certificateArn: string | undefined;
}
export type ListenerTlsCertificate =
  | ListenerTlsCertificate.AcmMember
  | ListenerTlsCertificate.FileMember
  | ListenerTlsCertificate.SdsMember
  | ListenerTlsCertificate.$UnknownMember;
export declare namespace ListenerTlsCertificate {
  interface AcmMember {
    acm: ListenerTlsAcmCertificate;
    file?: never;
    sds?: never;
    $unknown?: never;
  }
  interface FileMember {
    acm?: never;
    file: ListenerTlsFileCertificate;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    acm?: never;
    file?: never;
    sds: ListenerTlsSdsCertificate;
    $unknown?: never;
  }
  interface $UnknownMember {
    acm?: never;
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    acm: (value: ListenerTlsAcmCertificate) => T;
    file: (value: ListenerTlsFileCertificate) => T;
    sds: (value: ListenerTlsSdsCertificate) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ListenerTlsCertificate, visitor: Visitor<T>) => T;
}
export declare const ListenerTlsMode: {
  readonly DISABLED: "DISABLED";
  readonly PERMISSIVE: "PERMISSIVE";
  readonly STRICT: "STRICT";
};
export type ListenerTlsMode =
  (typeof ListenerTlsMode)[keyof typeof ListenerTlsMode];
export type ListenerTlsValidationContextTrust =
  | ListenerTlsValidationContextTrust.FileMember
  | ListenerTlsValidationContextTrust.SdsMember
  | ListenerTlsValidationContextTrust.$UnknownMember;
export declare namespace ListenerTlsValidationContextTrust {
  interface FileMember {
    file: TlsValidationContextFileTrust;
    sds?: never;
    $unknown?: never;
  }
  interface SdsMember {
    file?: never;
    sds: TlsValidationContextSdsTrust;
    $unknown?: never;
  }
  interface $UnknownMember {
    file?: never;
    sds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    file: (value: TlsValidationContextFileTrust) => T;
    sds: (value: TlsValidationContextSdsTrust) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: ListenerTlsValidationContextTrust,
    visitor: Visitor<T>
  ) => T;
}
export interface ListenerTlsValidationContext {
  trust: ListenerTlsValidationContextTrust | undefined;
  subjectAlternativeNames?: SubjectAlternativeNames;
}
export interface ListenerTls {
  mode: ListenerTlsMode | undefined;
  certificate: ListenerTlsCertificate | undefined;
  validation?: ListenerTlsValidationContext;
}
export interface Listener {
  portMapping: PortMapping | undefined;
  tls?: ListenerTls;
  healthCheck?: HealthCheckPolicy;
  timeout?: ListenerTimeout;
  outlierDetection?: OutlierDetection;
  connectionPool?: VirtualNodeConnectionPool;
}
export interface Logging {
  accessLog?: AccessLog;
}
export interface AwsCloudMapInstanceAttribute {
  key: string | undefined;
  value: string | undefined;
}
export interface AwsCloudMapServiceDiscovery {
  namespaceName: string | undefined;
  serviceName: string | undefined;
  attributes?: AwsCloudMapInstanceAttribute[];
  ipPreference?: IpPreference;
}
export declare const DnsResponseType: {
  readonly ENDPOINTS: "ENDPOINTS";
  readonly LOADBALANCER: "LOADBALANCER";
};
export type DnsResponseType =
  (typeof DnsResponseType)[keyof typeof DnsResponseType];
export interface DnsServiceDiscovery {
  hostname: string | undefined;
  responseType?: DnsResponseType;
  ipPreference?: IpPreference;
}
export type ServiceDiscovery =
  | ServiceDiscovery.AwsCloudMapMember
  | ServiceDiscovery.DnsMember
  | ServiceDiscovery.$UnknownMember;
export declare namespace ServiceDiscovery {
  interface DnsMember {
    dns: DnsServiceDiscovery;
    awsCloudMap?: never;
    $unknown?: never;
  }
  interface AwsCloudMapMember {
    dns?: never;
    awsCloudMap: AwsCloudMapServiceDiscovery;
    $unknown?: never;
  }
  interface $UnknownMember {
    dns?: never;
    awsCloudMap?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    dns: (value: DnsServiceDiscovery) => T;
    awsCloudMap: (value: AwsCloudMapServiceDiscovery) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ServiceDiscovery, visitor: Visitor<T>) => T;
}
export interface VirtualNodeSpec {
  serviceDiscovery?: ServiceDiscovery;
  listeners?: Listener[];
  backends?: Backend[];
  backendDefaults?: BackendDefaults;
  logging?: Logging;
}
export interface CreateVirtualNodeInput {
  virtualNodeName: string | undefined;
  meshName: string | undefined;
  spec: VirtualNodeSpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const VirtualNodeStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type VirtualNodeStatusCode =
  (typeof VirtualNodeStatusCode)[keyof typeof VirtualNodeStatusCode];
export interface VirtualNodeStatus {
  status: VirtualNodeStatusCode | undefined;
}
export interface VirtualNodeData {
  meshName: string | undefined;
  virtualNodeName: string | undefined;
  spec: VirtualNodeSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: VirtualNodeStatus | undefined;
}
export interface CreateVirtualNodeOutput {
  virtualNode: VirtualNodeData | undefined;
}
export interface DeleteVirtualNodeInput {
  virtualNodeName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DeleteVirtualNodeOutput {
  virtualNode: VirtualNodeData | undefined;
}
export interface DescribeVirtualNodeInput {
  virtualNodeName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DescribeVirtualNodeOutput {
  virtualNode: VirtualNodeData | undefined;
}
export interface ListVirtualNodesInput {
  meshName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface VirtualNodeRef {
  meshName: string | undefined;
  virtualNodeName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListVirtualNodesOutput {
  virtualNodes: VirtualNodeRef[] | undefined;
  nextToken?: string;
}
export interface UpdateVirtualNodeInput {
  virtualNodeName: string | undefined;
  meshName: string | undefined;
  spec: VirtualNodeSpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateVirtualNodeOutput {
  virtualNode: VirtualNodeData | undefined;
}
export interface VirtualRouterListener {
  portMapping: PortMapping | undefined;
}
export interface VirtualRouterSpec {
  listeners?: VirtualRouterListener[];
}
export interface CreateVirtualRouterInput {
  virtualRouterName: string | undefined;
  meshName: string | undefined;
  spec: VirtualRouterSpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const VirtualRouterStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type VirtualRouterStatusCode =
  (typeof VirtualRouterStatusCode)[keyof typeof VirtualRouterStatusCode];
export interface VirtualRouterStatus {
  status: VirtualRouterStatusCode | undefined;
}
export interface VirtualRouterData {
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  spec: VirtualRouterSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: VirtualRouterStatus | undefined;
}
export interface CreateVirtualRouterOutput {
  virtualRouter: VirtualRouterData | undefined;
}
export interface DeleteVirtualRouterInput {
  virtualRouterName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DeleteVirtualRouterOutput {
  virtualRouter: VirtualRouterData | undefined;
}
export interface DescribeVirtualRouterInput {
  virtualRouterName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DescribeVirtualRouterOutput {
  virtualRouter: VirtualRouterData | undefined;
}
export interface ListVirtualRoutersInput {
  meshName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface VirtualRouterRef {
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListVirtualRoutersOutput {
  virtualRouters: VirtualRouterRef[] | undefined;
  nextToken?: string;
}
export interface WeightedTarget {
  virtualNode: string | undefined;
  weight: number | undefined;
  port?: number;
}
export interface GrpcRouteAction {
  weightedTargets: WeightedTarget[] | undefined;
}
export type GrpcRouteMetadataMatchMethod =
  | GrpcRouteMetadataMatchMethod.ExactMember
  | GrpcRouteMetadataMatchMethod.PrefixMember
  | GrpcRouteMetadataMatchMethod.RangeMember
  | GrpcRouteMetadataMatchMethod.RegexMember
  | GrpcRouteMetadataMatchMethod.SuffixMember
  | GrpcRouteMetadataMatchMethod.$UnknownMember;
export declare namespace GrpcRouteMetadataMatchMethod {
  interface ExactMember {
    exact: string;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RegexMember {
    exact?: never;
    regex: string;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface RangeMember {
    exact?: never;
    regex?: never;
    range: MatchRange;
    prefix?: never;
    suffix?: never;
    $unknown?: never;
  }
  interface PrefixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix: string;
    suffix?: never;
    $unknown?: never;
  }
  interface SuffixMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    exact?: never;
    regex?: never;
    range?: never;
    prefix?: never;
    suffix?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    exact: (value: string) => T;
    regex: (value: string) => T;
    range: (value: MatchRange) => T;
    prefix: (value: string) => T;
    suffix: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: GrpcRouteMetadataMatchMethod,
    visitor: Visitor<T>
  ) => T;
}
export interface GrpcRouteMetadata {
  name: string | undefined;
  invert?: boolean;
  match?: GrpcRouteMetadataMatchMethod;
}
export interface GrpcRouteMatch {
  serviceName?: string;
  methodName?: string;
  metadata?: GrpcRouteMetadata[];
  port?: number;
}
export declare const GrpcRetryPolicyEvent: {
  readonly CANCELLED: "cancelled";
  readonly DEADLINE_EXCEEDED: "deadline-exceeded";
  readonly INTERNAL: "internal";
  readonly RESOURCE_EXHAUSTED: "resource-exhausted";
  readonly UNAVAILABLE: "unavailable";
};
export type GrpcRetryPolicyEvent =
  (typeof GrpcRetryPolicyEvent)[keyof typeof GrpcRetryPolicyEvent];
export declare const TcpRetryPolicyEvent: {
  readonly CONNECTION_ERROR: "connection-error";
};
export type TcpRetryPolicyEvent =
  (typeof TcpRetryPolicyEvent)[keyof typeof TcpRetryPolicyEvent];
export interface GrpcRetryPolicy {
  perRetryTimeout: Duration | undefined;
  maxRetries: number | undefined;
  httpRetryEvents?: string[];
  tcpRetryEvents?: TcpRetryPolicyEvent[];
  grpcRetryEvents?: GrpcRetryPolicyEvent[];
}
export interface GrpcRoute {
  action: GrpcRouteAction | undefined;
  match: GrpcRouteMatch | undefined;
  retryPolicy?: GrpcRetryPolicy;
  timeout?: GrpcTimeout;
}
export interface HttpRouteAction {
  weightedTargets: WeightedTarget[] | undefined;
}
export interface HttpRouteHeader {
  name: string | undefined;
  invert?: boolean;
  match?: HeaderMatchMethod;
}
export declare const HttpScheme: {
  readonly HTTP: "http";
  readonly HTTPS: "https";
};
export type HttpScheme = (typeof HttpScheme)[keyof typeof HttpScheme];
export interface HttpRouteMatch {
  prefix?: string;
  path?: HttpPathMatch;
  queryParameters?: HttpQueryParameter[];
  method?: HttpMethod;
  scheme?: HttpScheme;
  headers?: HttpRouteHeader[];
  port?: number;
}
export interface HttpRetryPolicy {
  perRetryTimeout: Duration | undefined;
  maxRetries: number | undefined;
  httpRetryEvents?: string[];
  tcpRetryEvents?: TcpRetryPolicyEvent[];
}
export interface HttpRoute {
  match: HttpRouteMatch | undefined;
  action: HttpRouteAction | undefined;
  retryPolicy?: HttpRetryPolicy;
  timeout?: HttpTimeout;
}
export interface TcpRouteAction {
  weightedTargets: WeightedTarget[] | undefined;
}
export interface TcpRouteMatch {
  port?: number;
}
export interface TcpRoute {
  action: TcpRouteAction | undefined;
  timeout?: TcpTimeout;
  match?: TcpRouteMatch;
}
export interface RouteSpec {
  priority?: number;
  httpRoute?: HttpRoute;
  tcpRoute?: TcpRoute;
  http2Route?: HttpRoute;
  grpcRoute?: GrpcRoute;
}
export interface CreateRouteInput {
  routeName: string | undefined;
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  spec: RouteSpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const RouteStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type RouteStatusCode =
  (typeof RouteStatusCode)[keyof typeof RouteStatusCode];
export interface RouteStatus {
  status: RouteStatusCode | undefined;
}
export interface RouteData {
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  routeName: string | undefined;
  spec: RouteSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: RouteStatus | undefined;
}
export interface CreateRouteOutput {
  route: RouteData | undefined;
}
export interface DeleteRouteInput {
  routeName: string | undefined;
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  meshOwner?: string;
}
export interface DeleteRouteOutput {
  route: RouteData | undefined;
}
export interface DescribeRouteInput {
  routeName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
  virtualRouterName: string | undefined;
}
export interface DescribeRouteOutput {
  route: RouteData | undefined;
}
export interface ListRoutesInput {
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface RouteRef {
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  routeName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListRoutesOutput {
  routes: RouteRef[] | undefined;
  nextToken?: string;
}
export interface UpdateRouteInput {
  routeName: string | undefined;
  meshName: string | undefined;
  virtualRouterName: string | undefined;
  spec: RouteSpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateRouteOutput {
  route: RouteData | undefined;
}
export interface UpdateVirtualRouterInput {
  virtualRouterName: string | undefined;
  meshName: string | undefined;
  spec: VirtualRouterSpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateVirtualRouterOutput {
  virtualRouter: VirtualRouterData | undefined;
}
export interface VirtualNodeServiceProvider {
  virtualNodeName: string | undefined;
}
export interface VirtualRouterServiceProvider {
  virtualRouterName: string | undefined;
}
export type VirtualServiceProvider =
  | VirtualServiceProvider.VirtualNodeMember
  | VirtualServiceProvider.VirtualRouterMember
  | VirtualServiceProvider.$UnknownMember;
export declare namespace VirtualServiceProvider {
  interface VirtualNodeMember {
    virtualNode: VirtualNodeServiceProvider;
    virtualRouter?: never;
    $unknown?: never;
  }
  interface VirtualRouterMember {
    virtualNode?: never;
    virtualRouter: VirtualRouterServiceProvider;
    $unknown?: never;
  }
  interface $UnknownMember {
    virtualNode?: never;
    virtualRouter?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    virtualNode: (value: VirtualNodeServiceProvider) => T;
    virtualRouter: (value: VirtualRouterServiceProvider) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: VirtualServiceProvider, visitor: Visitor<T>) => T;
}
export interface VirtualServiceSpec {
  provider?: VirtualServiceProvider;
}
export interface CreateVirtualServiceInput {
  virtualServiceName: string | undefined;
  meshName: string | undefined;
  spec: VirtualServiceSpec | undefined;
  tags?: TagRef[];
  clientToken?: string;
  meshOwner?: string;
}
export declare const VirtualServiceStatusCode: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly INACTIVE: "INACTIVE";
};
export type VirtualServiceStatusCode =
  (typeof VirtualServiceStatusCode)[keyof typeof VirtualServiceStatusCode];
export interface VirtualServiceStatus {
  status: VirtualServiceStatusCode | undefined;
}
export interface VirtualServiceData {
  meshName: string | undefined;
  virtualServiceName: string | undefined;
  spec: VirtualServiceSpec | undefined;
  metadata: ResourceMetadata | undefined;
  status: VirtualServiceStatus | undefined;
}
export interface CreateVirtualServiceOutput {
  virtualService: VirtualServiceData | undefined;
}
export interface DeleteVirtualServiceInput {
  virtualServiceName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DeleteVirtualServiceOutput {
  virtualService: VirtualServiceData | undefined;
}
export interface DescribeVirtualServiceInput {
  virtualServiceName: string | undefined;
  meshName: string | undefined;
  meshOwner?: string;
}
export interface DescribeVirtualServiceOutput {
  virtualService: VirtualServiceData | undefined;
}
export interface ListVirtualServicesInput {
  meshName: string | undefined;
  nextToken?: string;
  limit?: number;
  meshOwner?: string;
}
export interface VirtualServiceRef {
  meshName: string | undefined;
  virtualServiceName: string | undefined;
  meshOwner: string | undefined;
  resourceOwner: string | undefined;
  arn: string | undefined;
  version: number | undefined;
  createdAt: Date | undefined;
  lastUpdatedAt: Date | undefined;
}
export interface ListVirtualServicesOutput {
  virtualServices: VirtualServiceRef[] | undefined;
  nextToken?: string;
}
export interface UpdateVirtualServiceInput {
  virtualServiceName: string | undefined;
  meshName: string | undefined;
  spec: VirtualServiceSpec | undefined;
  clientToken?: string;
  meshOwner?: string;
}
export interface UpdateVirtualServiceOutput {
  virtualService: VirtualServiceData | undefined;
}
export interface TagResourceInput {
  resourceArn: string | undefined;
  tags: TagRef[] | undefined;
}
export interface TagResourceOutput {}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export interface UntagResourceInput {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceOutput {}
