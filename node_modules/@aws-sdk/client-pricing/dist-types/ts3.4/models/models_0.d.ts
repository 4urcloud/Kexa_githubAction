import {
  ExceptionOptionType as __ExceptionOptionType,
  LazyJsonString as __LazyJsonString,
} from "@smithy/smithy-client";
import { PricingServiceException as __BaseException } from "./PricingServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export interface AttributeValue {
  Value?: string;
}
export interface DescribeServicesRequest {
  ServiceCode?: string;
  FormatVersion?: string;
  NextToken?: string;
  MaxResults?: number;
}
export interface Service {
  ServiceCode: string | undefined;
  AttributeNames?: string[];
}
export interface DescribeServicesResponse {
  Services?: Service[];
  FormatVersion?: string;
  NextToken?: string;
}
export declare class ExpiredNextTokenException extends __BaseException {
  readonly name: "ExpiredNextTokenException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ExpiredNextTokenException, __BaseException>
  );
}
export declare class InternalErrorException extends __BaseException {
  readonly name: "InternalErrorException";
  readonly $fault: "server";
  $retryable: {};
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InternalErrorException, __BaseException>
  );
}
export declare class InvalidNextTokenException extends __BaseException {
  readonly name: "InvalidNextTokenException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>
  );
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class NotFoundException extends __BaseException {
  readonly name: "NotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<NotFoundException, __BaseException>);
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  $retryable: {
    throttling: boolean;
  };
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export interface GetAttributeValuesRequest {
  ServiceCode: string | undefined;
  AttributeName: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface GetAttributeValuesResponse {
  AttributeValues?: AttributeValue[];
  NextToken?: string;
}
export interface GetPriceListFileUrlRequest {
  PriceListArn: string | undefined;
  FileFormat: string | undefined;
}
export interface GetPriceListFileUrlResponse {
  Url?: string;
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare const FilterType: {
  readonly TERM_MATCH: "TERM_MATCH";
};
export type FilterType = (typeof FilterType)[keyof typeof FilterType];
export interface Filter {
  Type: FilterType | undefined;
  Field: string | undefined;
  Value: string | undefined;
}
export interface GetProductsRequest {
  ServiceCode: string | undefined;
  Filters?: Filter[];
  FormatVersion?: string;
  NextToken?: string;
  MaxResults?: number;
}
export interface GetProductsResponse {
  FormatVersion?: string;
  PriceList?: (__LazyJsonString | string)[];
  NextToken?: string;
}
export interface ListPriceListsRequest {
  ServiceCode: string | undefined;
  EffectiveDate: Date | undefined;
  RegionCode?: string;
  CurrencyCode: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface PriceList {
  PriceListArn?: string;
  RegionCode?: string;
  CurrencyCode?: string;
  FileFormats?: string[];
}
export interface ListPriceListsResponse {
  PriceLists?: PriceList[];
  NextToken?: string;
}
