import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, map, take, withBaseException, } from "@smithy/smithy-client";
import { MediaPackageVodServiceException as __BaseException } from "../models/MediaPackageVodServiceException";
import { ForbiddenException, InternalServerErrorException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, UnprocessableEntityException, } from "../models/models_0";
export const se_ConfigureLogsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packaging_groups/{Id}/configure_logs");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    body = JSON.stringify(take(input, {
        egressAccessLogs: [, (_) => se_EgressAccessLogs(_, context), `EgressAccessLogs`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/assets");
    let body;
    body = JSON.stringify(take(input, {
        id: [, , `Id`],
        packagingGroupId: [, , `PackagingGroupId`],
        resourceId: [, , `ResourceId`],
        sourceArn: [, , `SourceArn`],
        sourceRoleArn: [, , `SourceRoleArn`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePackagingConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packaging_configurations");
    let body;
    body = JSON.stringify(take(input, {
        cmafPackage: [, (_) => se_CmafPackage(_, context), `CmafPackage`],
        dashPackage: [, (_) => se_DashPackage(_, context), `DashPackage`],
        hlsPackage: [, (_) => se_HlsPackage(_, context), `HlsPackage`],
        id: [, , `Id`],
        mssPackage: [, (_) => se_MssPackage(_, context), `MssPackage`],
        packagingGroupId: [, , `PackagingGroupId`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreatePackagingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packaging_groups");
    let body;
    body = JSON.stringify(take(input, {
        authorization: [, (_) => se_Authorization(_, context), `Authorization`],
        egressAccessLogs: [, (_) => se_EgressAccessLogs(_, context), `EgressAccessLogs`],
        id: [, , `Id`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeletePackagingConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_configurations/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeletePackagingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_groups/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DescribeAssetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribePackagingConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_configurations/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribePackagingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_groups/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListAssetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/assets");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
        [_pGI]: [, input[_PGI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackagingConfigurationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_configurations");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
        [_pGI]: [, input[_PGI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListPackagingGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/packaging_groups");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input[_TK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdatePackagingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/packaging_groups/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorization: [, (_) => se_Authorization(_, context), `Authorization`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_ConfigureLogsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        CreatedAt: [, __expectString, `createdAt`],
        DomainName: [, __expectString, `domainName`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        Id: [, __expectString, `id`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAssetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        EgressEndpoints: [, (_) => de___listOfEgressEndpoint(_, context), `egressEndpoints`],
        Id: [, __expectString, `id`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        ResourceId: [, __expectString, `resourceId`],
        SourceArn: [, __expectString, `sourceArn`],
        SourceRoleArn: [, __expectString, `sourceRoleArn`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreatePackagingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreatePackagingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        CreatedAt: [, __expectString, `createdAt`],
        DomainName: [, __expectString, `domainName`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        Id: [, __expectString, `id`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteAssetCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeletePackagingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeletePackagingGroupCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeAssetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        EgressEndpoints: [, (_) => de___listOfEgressEndpoint(_, context), `egressEndpoints`],
        Id: [, __expectString, `id`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        ResourceId: [, __expectString, `resourceId`],
        SourceArn: [, __expectString, `sourceArn`],
        SourceRoleArn: [, __expectString, `sourceRoleArn`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackagingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribePackagingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApproximateAssetCount: [, __expectInt32, `approximateAssetCount`],
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        CreatedAt: [, __expectString, `createdAt`],
        DomainName: [, __expectString, `domainName`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        Id: [, __expectString, `id`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Assets: [, (_) => de___listOfAssetShallow(_, context), `assets`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackagingConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        PackagingConfigurations: [, (_) => de___listOfPackagingConfiguration(_, context), `packagingConfigurations`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPackagingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        PackagingGroups: [, (_) => de___listOfPackagingGroup(_, context), `packagingGroups`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdatePackagingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApproximateAssetCount: [, __expectInt32, `approximateAssetCount`],
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        CreatedAt: [, __expectString, `createdAt`],
        DomainName: [, __expectString, `domainName`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        Id: [, __expectString, `id`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ForbiddenException":
        case "com.amazonaws.mediapackagevod#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.mediapackagevod#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.mediapackagevod#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.mediapackagevod#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.mediapackagevod#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnprocessableEntityException":
        case "com.amazonaws.mediapackagevod#UnprocessableEntityException":
            throw await de_UnprocessableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerErrorExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new InternalServerErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnprocessableEntityExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new UnprocessableEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se___listOfDashManifest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DashManifest(entry, context);
    });
};
const se___listOfHlsManifest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_HlsManifest(entry, context);
    });
};
const se___listOfMssManifest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MssManifest(entry, context);
    });
};
const se_Authorization = (input, context) => {
    return take(input, {
        cdnIdentifierSecret: [, , `CdnIdentifierSecret`],
        secretsRoleArn: [, , `SecretsRoleArn`],
    });
};
const se_CmafEncryption = (input, context) => {
    return take(input, {
        constantInitializationVector: [, , `ConstantInitializationVector`],
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_CmafPackage = (input, context) => {
    return take(input, {
        encryption: [, (_) => se_CmafEncryption(_, context), `Encryption`],
        hlsManifests: [, (_) => se___listOfHlsManifest(_, context), `HlsManifests`],
        includeEncoderConfigurationInSegments: [, , `IncludeEncoderConfigurationInSegments`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
    });
};
const se_DashEncryption = (input, context) => {
    return take(input, {
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_DashManifest = (input, context) => {
    return take(input, {
        manifestLayout: [, , `ManifestLayout`],
        manifestName: [, , `ManifestName`],
        minBufferTimeSeconds: [, , `MinBufferTimeSeconds`],
        profile: [, , `Profile`],
        scteMarkersSource: [, , `ScteMarkersSource`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
    });
};
const se_DashPackage = (input, context) => {
    return take(input, {
        dashManifests: [, (_) => se___listOfDashManifest(_, context), `DashManifests`],
        encryption: [, (_) => se_DashEncryption(_, context), `Encryption`],
        includeEncoderConfigurationInSegments: [, , `IncludeEncoderConfigurationInSegments`],
        includeIframeOnlyStream: [, , `IncludeIframeOnlyStream`],
        periodTriggers: [, _json, `PeriodTriggers`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        segmentTemplateFormat: [, , `SegmentTemplateFormat`],
    });
};
const se_EgressAccessLogs = (input, context) => {
    return take(input, {
        logGroupName: [, , `LogGroupName`],
    });
};
const se_EncryptionContractConfiguration = (input, context) => {
    return take(input, {
        presetSpeke20Audio: [, , `PresetSpeke20Audio`],
        presetSpeke20Video: [, , `PresetSpeke20Video`],
    });
};
const se_HlsEncryption = (input, context) => {
    return take(input, {
        constantInitializationVector: [, , `ConstantInitializationVector`],
        encryptionMethod: [, , `EncryptionMethod`],
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_HlsManifest = (input, context) => {
    return take(input, {
        adMarkers: [, , `AdMarkers`],
        includeIframeOnlyStream: [, , `IncludeIframeOnlyStream`],
        manifestName: [, , `ManifestName`],
        programDateTimeIntervalSeconds: [, , `ProgramDateTimeIntervalSeconds`],
        repeatExtXKey: [, , `RepeatExtXKey`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
    });
};
const se_HlsPackage = (input, context) => {
    return take(input, {
        encryption: [, (_) => se_HlsEncryption(_, context), `Encryption`],
        hlsManifests: [, (_) => se___listOfHlsManifest(_, context), `HlsManifests`],
        includeDvbSubtitles: [, , `IncludeDvbSubtitles`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        useAudioRenditionGroup: [, , `UseAudioRenditionGroup`],
    });
};
const se_MssEncryption = (input, context) => {
    return take(input, {
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_MssManifest = (input, context) => {
    return take(input, {
        manifestName: [, , `ManifestName`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
    });
};
const se_MssPackage = (input, context) => {
    return take(input, {
        encryption: [, (_) => se_MssEncryption(_, context), `Encryption`],
        mssManifests: [, (_) => se___listOfMssManifest(_, context), `MssManifests`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
    });
};
const se_SpekeKeyProvider = (input, context) => {
    return take(input, {
        encryptionContractConfiguration: [
            ,
            (_) => se_EncryptionContractConfiguration(_, context),
            `EncryptionContractConfiguration`,
        ],
        roleArn: [, , `RoleArn`],
        systemIds: [, _json, `SystemIds`],
        url: [, , `Url`],
    });
};
const se_StreamSelection = (input, context) => {
    return take(input, {
        maxVideoBitsPerSecond: [, , `MaxVideoBitsPerSecond`],
        minVideoBitsPerSecond: [, , `MinVideoBitsPerSecond`],
        streamOrder: [, , `StreamOrder`],
    });
};
const de___listOfAssetShallow = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AssetShallow(entry, context);
    });
    return retVal;
};
const de___listOfDashManifest = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DashManifest(entry, context);
    });
    return retVal;
};
const de___listOfEgressEndpoint = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EgressEndpoint(entry, context);
    });
    return retVal;
};
const de___listOfHlsManifest = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HlsManifest(entry, context);
    });
    return retVal;
};
const de___listOfMssManifest = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MssManifest(entry, context);
    });
    return retVal;
};
const de___listOfPackagingConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackagingConfiguration(entry, context);
    });
    return retVal;
};
const de___listOfPackagingGroup = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackagingGroup(entry, context);
    });
    return retVal;
};
const de_AssetShallow = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Id: [, __expectString, `id`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        ResourceId: [, __expectString, `resourceId`],
        SourceArn: [, __expectString, `sourceArn`],
        SourceRoleArn: [, __expectString, `sourceRoleArn`],
        Tags: [, _json, `tags`],
    });
};
const de_Authorization = (output, context) => {
    return take(output, {
        CdnIdentifierSecret: [, __expectString, `cdnIdentifierSecret`],
        SecretsRoleArn: [, __expectString, `secretsRoleArn`],
    });
};
const de_CmafEncryption = (output, context) => {
    return take(output, {
        ConstantInitializationVector: [, __expectString, `constantInitializationVector`],
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_CmafPackage = (output, context) => {
    return take(output, {
        Encryption: [, (_) => de_CmafEncryption(_, context), `encryption`],
        HlsManifests: [, (_) => de___listOfHlsManifest(_, context), `hlsManifests`],
        IncludeEncoderConfigurationInSegments: [, __expectBoolean, `includeEncoderConfigurationInSegments`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
    });
};
const de_DashEncryption = (output, context) => {
    return take(output, {
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_DashManifest = (output, context) => {
    return take(output, {
        ManifestLayout: [, __expectString, `manifestLayout`],
        ManifestName: [, __expectString, `manifestName`],
        MinBufferTimeSeconds: [, __expectInt32, `minBufferTimeSeconds`],
        Profile: [, __expectString, `profile`],
        ScteMarkersSource: [, __expectString, `scteMarkersSource`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
    });
};
const de_DashPackage = (output, context) => {
    return take(output, {
        DashManifests: [, (_) => de___listOfDashManifest(_, context), `dashManifests`],
        Encryption: [, (_) => de_DashEncryption(_, context), `encryption`],
        IncludeEncoderConfigurationInSegments: [, __expectBoolean, `includeEncoderConfigurationInSegments`],
        IncludeIframeOnlyStream: [, __expectBoolean, `includeIframeOnlyStream`],
        PeriodTriggers: [, _json, `periodTriggers`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        SegmentTemplateFormat: [, __expectString, `segmentTemplateFormat`],
    });
};
const de_EgressAccessLogs = (output, context) => {
    return take(output, {
        LogGroupName: [, __expectString, `logGroupName`],
    });
};
const de_EgressEndpoint = (output, context) => {
    return take(output, {
        PackagingConfigurationId: [, __expectString, `packagingConfigurationId`],
        Status: [, __expectString, `status`],
        Url: [, __expectString, `url`],
    });
};
const de_EncryptionContractConfiguration = (output, context) => {
    return take(output, {
        PresetSpeke20Audio: [, __expectString, `presetSpeke20Audio`],
        PresetSpeke20Video: [, __expectString, `presetSpeke20Video`],
    });
};
const de_HlsEncryption = (output, context) => {
    return take(output, {
        ConstantInitializationVector: [, __expectString, `constantInitializationVector`],
        EncryptionMethod: [, __expectString, `encryptionMethod`],
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_HlsManifest = (output, context) => {
    return take(output, {
        AdMarkers: [, __expectString, `adMarkers`],
        IncludeIframeOnlyStream: [, __expectBoolean, `includeIframeOnlyStream`],
        ManifestName: [, __expectString, `manifestName`],
        ProgramDateTimeIntervalSeconds: [, __expectInt32, `programDateTimeIntervalSeconds`],
        RepeatExtXKey: [, __expectBoolean, `repeatExtXKey`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
    });
};
const de_HlsPackage = (output, context) => {
    return take(output, {
        Encryption: [, (_) => de_HlsEncryption(_, context), `encryption`],
        HlsManifests: [, (_) => de___listOfHlsManifest(_, context), `hlsManifests`],
        IncludeDvbSubtitles: [, __expectBoolean, `includeDvbSubtitles`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        UseAudioRenditionGroup: [, __expectBoolean, `useAudioRenditionGroup`],
    });
};
const de_MssEncryption = (output, context) => {
    return take(output, {
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_MssManifest = (output, context) => {
    return take(output, {
        ManifestName: [, __expectString, `manifestName`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
    });
};
const de_MssPackage = (output, context) => {
    return take(output, {
        Encryption: [, (_) => de_MssEncryption(_, context), `encryption`],
        MssManifests: [, (_) => de___listOfMssManifest(_, context), `mssManifests`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
    });
};
const de_PackagingConfiguration = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        PackagingGroupId: [, __expectString, `packagingGroupId`],
        Tags: [, _json, `tags`],
    });
};
const de_PackagingGroup = (output, context) => {
    return take(output, {
        ApproximateAssetCount: [, __expectInt32, `approximateAssetCount`],
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        CreatedAt: [, __expectString, `createdAt`],
        DomainName: [, __expectString, `domainName`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        Id: [, __expectString, `id`],
        Tags: [, _json, `tags`],
    });
};
const de_SpekeKeyProvider = (output, context) => {
    return take(output, {
        EncryptionContractConfiguration: [
            ,
            (_) => de_EncryptionContractConfiguration(_, context),
            `encryptionContractConfiguration`,
        ],
        RoleArn: [, __expectString, `roleArn`],
        SystemIds: [, _json, `systemIds`],
        Url: [, __expectString, `url`],
    });
};
const de_StreamSelection = (output, context) => {
    return take(output, {
        MaxVideoBitsPerSecond: [, __expectInt32, `maxVideoBitsPerSecond`],
        MinVideoBitsPerSecond: [, __expectInt32, `minVideoBitsPerSecond`],
        StreamOrder: [, __expectString, `streamOrder`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _MR = "MaxResults";
const _NT = "NextToken";
const _PGI = "PackagingGroupId";
const _TK = "TagKeys";
const _mR = "maxResults";
const _nT = "nextToken";
const _pGI = "packagingGroupId";
const _tK = "tagKeys";
