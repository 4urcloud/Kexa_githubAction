import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { MediaConnectServiceException as __BaseException } from "../models/MediaConnectServiceException";
import { AddFlowOutputs420Exception, BadRequestException, ConflictException, CreateBridge420Exception, CreateFlow420Exception, CreateGateway420Exception, ForbiddenException, GrantFlowEntitlements420Exception, InternalServerErrorException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, } from "../models/models_0";
export const se_AddBridgeOutputsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}/outputs");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        outputs: [, (_) => se___listOfAddBridgeOutputRequest(_, context), `Outputs`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddBridgeSourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}/sources");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        sources: [, (_) => se___listOfAddBridgeSourceRequest(_, context), `Sources`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddFlowMediaStreamsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/mediaStreams");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        mediaStreams: [, (_) => se___listOfAddMediaStreamRequest(_, context), `MediaStreams`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddFlowOutputsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/outputs");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        outputs: [, (_) => se___listOfAddOutputRequest(_, context), `Outputs`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddFlowSourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/source");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        sources: [, (_) => se___listOfSetSourceRequest(_, context), `Sources`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddFlowVpcInterfacesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/vpcInterfaces");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        vpcInterfaces: [, (_) => se___listOfVpcInterfaceRequest(_, context), `VpcInterfaces`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateBridgeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges");
    let body;
    body = JSON.stringify(take(input, {
        egressGatewayBridge: [, (_) => se_AddEgressGatewayBridgeRequest(_, context), `EgressGatewayBridge`],
        ingressGatewayBridge: [, (_) => se_AddIngressGatewayBridgeRequest(_, context), `IngressGatewayBridge`],
        name: [, , `Name`],
        outputs: [, (_) => se___listOfAddBridgeOutputRequest(_, context), `Outputs`],
        placementArn: [, , `PlacementArn`],
        sourceFailoverConfig: [, (_) => se_FailoverConfig(_, context), `SourceFailoverConfig`],
        sources: [, (_) => se___listOfAddBridgeSourceRequest(_, context), `Sources`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows");
    let body;
    body = JSON.stringify(take(input, {
        availabilityZone: [, , `AvailabilityZone`],
        entitlements: [, (_) => se___listOfGrantEntitlementRequest(_, context), `Entitlements`],
        maintenance: [, (_) => se_AddMaintenance(_, context), `Maintenance`],
        mediaStreams: [, (_) => se___listOfAddMediaStreamRequest(_, context), `MediaStreams`],
        name: [, , `Name`],
        outputs: [, (_) => se___listOfAddOutputRequest(_, context), `Outputs`],
        source: [, (_) => se_SetSourceRequest(_, context), `Source`],
        sourceFailoverConfig: [, (_) => se_FailoverConfig(_, context), `SourceFailoverConfig`],
        sources: [, (_) => se___listOfSetSourceRequest(_, context), `Sources`],
        vpcInterfaces: [, (_) => se___listOfVpcInterfaceRequest(_, context), `VpcInterfaces`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/gateways");
    let body;
    body = JSON.stringify(take(input, {
        egressCidrBlocks: [, (_) => _json(_), `EgressCidrBlocks`],
        name: [, , `Name`],
        networks: [, (_) => se___listOfGatewayNetwork(_, context), `Networks`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteBridgeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/bridges/{BridgeArn}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateways/{GatewayArn}");
    b.p("GatewayArn", () => input.GatewayArn, "{GatewayArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeregisterGatewayInstanceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateway-instances/{GatewayInstanceArn}");
    b.p("GatewayInstanceArn", () => input.GatewayInstanceArn, "{GatewayInstanceArn}", false);
    const query = map({
        [_f]: [() => input.Force !== void 0, () => input[_F].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeBridgeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/bridges/{BridgeArn}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeFlowSourceMetadataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/source-metadata");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeGatewayCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateways/{GatewayArn}");
    b.p("GatewayArn", () => input.GatewayArn, "{GatewayArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeGatewayInstanceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateway-instances/{GatewayInstanceArn}");
    b.p("GatewayInstanceArn", () => input.GatewayInstanceArn, "{GatewayInstanceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeOfferingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/offerings/{OfferingArn}");
    b.p("OfferingArn", () => input.OfferingArn, "{OfferingArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeReservationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/reservations/{ReservationArn}");
    b.p("ReservationArn", () => input.ReservationArn, "{ReservationArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GrantFlowEntitlementsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/entitlements");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        entitlements: [, (_) => se___listOfGrantEntitlementRequest(_, context), `Entitlements`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListBridgesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/bridges");
    const query = map({
        [_fA]: [, input[_FA]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListEntitlementsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/entitlements");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListFlowsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListGatewayInstancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateway-instances");
    const query = map({
        [_fA]: [, input[_FA]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListGatewaysCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/gateways");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListOfferingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/offerings");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListReservationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/reservations");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_PurchaseOfferingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/offerings/{OfferingArn}");
    b.p("OfferingArn", () => input.OfferingArn, "{OfferingArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        reservationName: [, , `ReservationName`],
        start: [, , `Start`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveBridgeOutputCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/bridges/{BridgeArn}/outputs/{OutputName}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    b.p("OutputName", () => input.OutputName, "{OutputName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveBridgeSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/bridges/{BridgeArn}/sources/{SourceName}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    b.p("SourceName", () => input.SourceName, "{SourceName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveFlowMediaStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/mediaStreams/{MediaStreamName}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("MediaStreamName", () => input.MediaStreamName, "{MediaStreamName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveFlowOutputCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/outputs/{OutputArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("OutputArn", () => input.OutputArn, "{OutputArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveFlowSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/source/{SourceArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("SourceArn", () => input.SourceArn, "{SourceArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveFlowVpcInterfaceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/vpcInterfaces/{VpcInterfaceName}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("VpcInterfaceName", () => input.VpcInterfaceName, "{VpcInterfaceName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RevokeFlowEntitlementCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/{FlowArn}/entitlements/{EntitlementArn}");
    b.p("EntitlementArn", () => input.EntitlementArn, "{EntitlementArn}", false);
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_StartFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/start/{FlowArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StopFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/flows/stop/{FlowArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input[_TK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateBridgeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        egressGatewayBridge: [, (_) => se_UpdateEgressGatewayBridgeRequest(_, context), `EgressGatewayBridge`],
        ingressGatewayBridge: [, (_) => se_UpdateIngressGatewayBridgeRequest(_, context), `IngressGatewayBridge`],
        sourceFailoverConfig: [, (_) => se_UpdateFailoverConfig(_, context), `SourceFailoverConfig`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBridgeOutputCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}/outputs/{OutputName}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    b.p("OutputName", () => input.OutputName, "{OutputName}", false);
    let body;
    body = JSON.stringify(take(input, {
        networkOutput: [, (_) => se_UpdateBridgeNetworkOutputRequest(_, context), `NetworkOutput`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBridgeSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}/sources/{SourceName}");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    b.p("SourceName", () => input.SourceName, "{SourceName}", false);
    let body;
    body = JSON.stringify(take(input, {
        flowSource: [, (_) => se_UpdateBridgeFlowSourceRequest(_, context), `FlowSource`],
        networkSource: [, (_) => se_UpdateBridgeNetworkSourceRequest(_, context), `NetworkSource`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateBridgeStateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/bridges/{BridgeArn}/state");
    b.p("BridgeArn", () => input.BridgeArn, "{BridgeArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        desiredState: [, , `DesiredState`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFlowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        maintenance: [, (_) => se_UpdateMaintenance(_, context), `Maintenance`],
        sourceFailoverConfig: [, (_) => se_UpdateFailoverConfig(_, context), `SourceFailoverConfig`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFlowEntitlementCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/entitlements/{EntitlementArn}");
    b.p("EntitlementArn", () => input.EntitlementArn, "{EntitlementArn}", false);
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
        encryption: [, (_) => se_UpdateEncryption(_, context), `Encryption`],
        entitlementStatus: [, , `EntitlementStatus`],
        subscribers: [, (_) => _json(_), `Subscribers`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFlowMediaStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/mediaStreams/{MediaStreamName}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("MediaStreamName", () => input.MediaStreamName, "{MediaStreamName}", false);
    let body;
    body = JSON.stringify(take(input, {
        attributes: [, (_) => se_MediaStreamAttributesRequest(_, context), `Attributes`],
        clockRate: [, , `ClockRate`],
        description: [, , `Description`],
        mediaStreamType: [, , `MediaStreamType`],
        videoFormat: [, , `VideoFormat`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFlowOutputCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/outputs/{OutputArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("OutputArn", () => input.OutputArn, "{OutputArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        cidrAllowList: [, (_) => _json(_), `CidrAllowList`],
        description: [, , `Description`],
        destination: [, , `Destination`],
        encryption: [, (_) => se_UpdateEncryption(_, context), `Encryption`],
        maxLatency: [, , `MaxLatency`],
        mediaStreamOutputConfigurations: [
            ,
            (_) => se___listOfMediaStreamOutputConfigurationRequest(_, context),
            `MediaStreamOutputConfigurations`,
        ],
        minLatency: [, , `MinLatency`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
        remoteId: [, , `RemoteId`],
        senderControlPort: [, , `SenderControlPort`],
        senderIpAddress: [, , `SenderIpAddress`],
        smoothingLatency: [, , `SmoothingLatency`],
        streamId: [, , `StreamId`],
        vpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `VpcInterfaceAttachment`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFlowSourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/flows/{FlowArn}/source/{SourceArn}");
    b.p("FlowArn", () => input.FlowArn, "{FlowArn}", false);
    b.p("SourceArn", () => input.SourceArn, "{SourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        decryption: [, (_) => se_UpdateEncryption(_, context), `Decryption`],
        description: [, , `Description`],
        entitlementArn: [, , `EntitlementArn`],
        gatewayBridgeSource: [, (_) => se_UpdateGatewayBridgeSourceRequest(_, context), `GatewayBridgeSource`],
        ingestPort: [, , `IngestPort`],
        maxBitrate: [, , `MaxBitrate`],
        maxLatency: [, , `MaxLatency`],
        maxSyncBuffer: [, , `MaxSyncBuffer`],
        mediaStreamSourceConfigurations: [
            ,
            (_) => se___listOfMediaStreamSourceConfigurationRequest(_, context),
            `MediaStreamSourceConfigurations`,
        ],
        minLatency: [, , `MinLatency`],
        protocol: [, , `Protocol`],
        senderControlPort: [, , `SenderControlPort`],
        senderIpAddress: [, , `SenderIpAddress`],
        sourceListenerAddress: [, , `SourceListenerAddress`],
        sourceListenerPort: [, , `SourceListenerPort`],
        streamId: [, , `StreamId`],
        vpcInterfaceName: [, , `VpcInterfaceName`],
        whitelistCidr: [, , `WhitelistCidr`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateGatewayInstanceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/gateway-instances/{GatewayInstanceArn}");
    b.p("GatewayInstanceArn", () => input.GatewayInstanceArn, "{GatewayInstanceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        bridgePlacement: [, , `BridgePlacement`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_AddBridgeOutputsCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        Outputs: [, (_) => de___listOfBridgeOutput(_, context), `outputs`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddBridgeSourcesCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        Sources: [, (_) => de___listOfBridgeSource(_, context), `sources`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddFlowMediaStreamsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        MediaStreams: [, (_) => de___listOfMediaStream(_, context), `mediaStreams`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddFlowOutputsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Outputs: [, (_) => de___listOfOutput(_, context), `outputs`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddFlowSourcesCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Sources: [, (_) => de___listOfSource(_, context), `sources`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddFlowVpcInterfacesCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        VpcInterfaces: [, (_) => de___listOfVpcInterface(_, context), `vpcInterfaces`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBridgeCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Bridge: [, (_) => de_Bridge(_, context), `bridge`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateFlowCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Flow: [, (_) => de_Flow(_, context), `flow`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateGatewayCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Gateway: [, (_) => de_Gateway(_, context), `gateway`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteBridgeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteFlowCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Status: [, __expectString, `status`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteGatewayCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        GatewayArn: [, __expectString, `gatewayArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeregisterGatewayInstanceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        GatewayInstanceArn: [, __expectString, `gatewayInstanceArn`],
        InstanceState: [, __expectString, `instanceState`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeBridgeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Bridge: [, (_) => de_Bridge(_, context), `bridge`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeFlowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Flow: [, (_) => de_Flow(_, context), `flow`],
        Messages: [, (_) => de_Messages(_, context), `messages`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeFlowSourceMetadataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Messages: [, (_) => de___listOfMessageDetail(_, context), `messages`],
        Timestamp: [, (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)), `timestamp`],
        TransportMediaInfo: [, (_) => de_TransportMediaInfo(_, context), `transportMediaInfo`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeGatewayCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Gateway: [, (_) => de_Gateway(_, context), `gateway`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeGatewayInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        GatewayInstance: [, (_) => de_GatewayInstance(_, context), `gatewayInstance`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeOfferingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Offering: [, (_) => de_Offering(_, context), `offering`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeReservationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Reservation: [, (_) => de_Reservation(_, context), `reservation`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GrantFlowEntitlementsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Entitlements: [, (_) => de___listOfEntitlement(_, context), `entitlements`],
        FlowArn: [, __expectString, `flowArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListBridgesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Bridges: [, (_) => de___listOfListedBridge(_, context), `bridges`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEntitlementsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Entitlements: [, (_) => de___listOfListedEntitlement(_, context), `entitlements`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFlowsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Flows: [, (_) => de___listOfListedFlow(_, context), `flows`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListGatewayInstancesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Instances: [, (_) => de___listOfListedGatewayInstance(_, context), `instances`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListGatewaysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Gateways: [, (_) => de___listOfListedGateway(_, context), `gateways`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListOfferingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        Offerings: [, (_) => de___listOfOffering(_, context), `offerings`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListReservationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        Reservations: [, (_) => de___listOfReservation(_, context), `reservations`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PurchaseOfferingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Reservation: [, (_) => de_Reservation(_, context), `reservation`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveBridgeOutputCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        OutputName: [, __expectString, `outputName`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveBridgeSourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        SourceName: [, __expectString, `sourceName`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveFlowMediaStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        MediaStreamName: [, __expectString, `mediaStreamName`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveFlowOutputCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        OutputArn: [, __expectString, `outputArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveFlowSourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        SourceArn: [, __expectString, `sourceArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveFlowVpcInterfaceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        NonDeletedNetworkInterfaceIds: [, _json, `nonDeletedNetworkInterfaceIds`],
        VpcInterfaceName: [, __expectString, `vpcInterfaceName`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RevokeFlowEntitlementCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EntitlementArn: [, __expectString, `entitlementArn`],
        FlowArn: [, __expectString, `flowArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartFlowCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Status: [, __expectString, `status`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopFlowCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Status: [, __expectString, `status`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateBridgeCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Bridge: [, (_) => de_Bridge(_, context), `bridge`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBridgeOutputCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        Output: [, (_) => de_BridgeOutput(_, context), `output`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBridgeSourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        Source: [, (_) => de_BridgeSource(_, context), `source`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBridgeStateCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgeArn: [, __expectString, `bridgeArn`],
        DesiredState: [, __expectString, `desiredState`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFlowCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Flow: [, (_) => de_Flow(_, context), `flow`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFlowEntitlementCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Entitlement: [, (_) => de_Entitlement(_, context), `entitlement`],
        FlowArn: [, __expectString, `flowArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFlowMediaStreamCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        MediaStream: [, (_) => de_MediaStream(_, context), `mediaStream`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFlowOutputCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Output: [, (_) => de_Output(_, context), `output`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFlowSourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FlowArn: [, __expectString, `flowArn`],
        Source: [, (_) => de_Source(_, context), `source`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateGatewayInstanceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BridgePlacement: [, __expectString, `bridgePlacement`],
        GatewayInstanceArn: [, __expectString, `gatewayInstanceArn`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.mediaconnect#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.mediaconnect#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.mediaconnect#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.mediaconnect#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.mediaconnect#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.mediaconnect#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.mediaconnect#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "AddFlowOutputs420Exception":
        case "com.amazonaws.mediaconnect#AddFlowOutputs420Exception":
            throw await de_AddFlowOutputs420ExceptionRes(parsedOutput, context);
        case "CreateBridge420Exception":
        case "com.amazonaws.mediaconnect#CreateBridge420Exception":
            throw await de_CreateBridge420ExceptionRes(parsedOutput, context);
        case "CreateFlow420Exception":
        case "com.amazonaws.mediaconnect#CreateFlow420Exception":
            throw await de_CreateFlow420ExceptionRes(parsedOutput, context);
        case "CreateGateway420Exception":
        case "com.amazonaws.mediaconnect#CreateGateway420Exception":
            throw await de_CreateGateway420ExceptionRes(parsedOutput, context);
        case "GrantFlowEntitlements420Exception":
        case "com.amazonaws.mediaconnect#GrantFlowEntitlements420Exception":
            throw await de_GrantFlowEntitlements420ExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AddFlowOutputs420ExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new AddFlowOutputs420Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CreateBridge420ExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new CreateBridge420Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CreateFlow420ExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new CreateFlow420Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CreateGateway420ExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new CreateGateway420Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_GrantFlowEntitlements420ExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new GrantFlowEntitlements420Exception({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerErrorExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new InternalServerErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se___listOfAddBridgeOutputRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AddBridgeOutputRequest(entry, context);
    });
};
const se___listOfAddBridgeSourceRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AddBridgeSourceRequest(entry, context);
    });
};
const se___listOfAddMediaStreamRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AddMediaStreamRequest(entry, context);
    });
};
const se___listOfAddOutputRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AddOutputRequest(entry, context);
    });
};
const se___listOfDestinationConfigurationRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DestinationConfigurationRequest(entry, context);
    });
};
const se___listOfGatewayNetwork = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GatewayNetwork(entry, context);
    });
};
const se___listOfGrantEntitlementRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_GrantEntitlementRequest(entry, context);
    });
};
const se___listOfInputConfigurationRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_InputConfigurationRequest(entry, context);
    });
};
const se___listOfMediaStreamOutputConfigurationRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MediaStreamOutputConfigurationRequest(entry, context);
    });
};
const se___listOfMediaStreamSourceConfigurationRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MediaStreamSourceConfigurationRequest(entry, context);
    });
};
const se___listOfSetSourceRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_SetSourceRequest(entry, context);
    });
};
const se___listOfVpcInterfaceRequest = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_VpcInterfaceRequest(entry, context);
    });
};
const se_AddBridgeFlowSourceRequest = (input, context) => {
    return take(input, {
        flowArn: [, , `FlowArn`],
        flowVpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `FlowVpcInterfaceAttachment`],
        name: [, , `Name`],
    });
};
const se_AddBridgeNetworkOutputRequest = (input, context) => {
    return take(input, {
        ipAddress: [, , `IpAddress`],
        name: [, , `Name`],
        networkName: [, , `NetworkName`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
        ttl: [, , `Ttl`],
    });
};
const se_AddBridgeNetworkSourceRequest = (input, context) => {
    return take(input, {
        multicastIp: [, , `MulticastIp`],
        name: [, , `Name`],
        networkName: [, , `NetworkName`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
    });
};
const se_AddBridgeOutputRequest = (input, context) => {
    return take(input, {
        networkOutput: [, (_) => se_AddBridgeNetworkOutputRequest(_, context), `NetworkOutput`],
    });
};
const se_AddBridgeSourceRequest = (input, context) => {
    return take(input, {
        flowSource: [, (_) => se_AddBridgeFlowSourceRequest(_, context), `FlowSource`],
        networkSource: [, (_) => se_AddBridgeNetworkSourceRequest(_, context), `NetworkSource`],
    });
};
const se_AddEgressGatewayBridgeRequest = (input, context) => {
    return take(input, {
        maxBitrate: [, , `MaxBitrate`],
    });
};
const se_AddIngressGatewayBridgeRequest = (input, context) => {
    return take(input, {
        maxBitrate: [, , `MaxBitrate`],
        maxOutputs: [, , `MaxOutputs`],
    });
};
const se_AddMaintenance = (input, context) => {
    return take(input, {
        maintenanceDay: [, , `MaintenanceDay`],
        maintenanceStartHour: [, , `MaintenanceStartHour`],
    });
};
const se_AddMediaStreamRequest = (input, context) => {
    return take(input, {
        attributes: [, (_) => se_MediaStreamAttributesRequest(_, context), `Attributes`],
        clockRate: [, , `ClockRate`],
        description: [, , `Description`],
        mediaStreamId: [, , `MediaStreamId`],
        mediaStreamName: [, , `MediaStreamName`],
        mediaStreamType: [, , `MediaStreamType`],
        videoFormat: [, , `VideoFormat`],
    });
};
const se_AddOutputRequest = (input, context) => {
    return take(input, {
        cidrAllowList: [, _json, `CidrAllowList`],
        description: [, , `Description`],
        destination: [, , `Destination`],
        encryption: [, (_) => se_Encryption(_, context), `Encryption`],
        maxLatency: [, , `MaxLatency`],
        mediaStreamOutputConfigurations: [
            ,
            (_) => se___listOfMediaStreamOutputConfigurationRequest(_, context),
            `MediaStreamOutputConfigurations`,
        ],
        minLatency: [, , `MinLatency`],
        name: [, , `Name`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
        remoteId: [, , `RemoteId`],
        senderControlPort: [, , `SenderControlPort`],
        smoothingLatency: [, , `SmoothingLatency`],
        streamId: [, , `StreamId`],
        vpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `VpcInterfaceAttachment`],
    });
};
const se_DestinationConfigurationRequest = (input, context) => {
    return take(input, {
        destinationIp: [, , `DestinationIp`],
        destinationPort: [, , `DestinationPort`],
        interface: [, (_) => se_InterfaceRequest(_, context), `Interface`],
    });
};
const se_EncodingParametersRequest = (input, context) => {
    return take(input, {
        compressionFactor: [, __serializeFloat, `CompressionFactor`],
        encoderProfile: [, , `EncoderProfile`],
    });
};
const se_Encryption = (input, context) => {
    return take(input, {
        algorithm: [, , `Algorithm`],
        constantInitializationVector: [, , `ConstantInitializationVector`],
        deviceId: [, , `DeviceId`],
        keyType: [, , `KeyType`],
        region: [, , `Region`],
        resourceId: [, , `ResourceId`],
        roleArn: [, , `RoleArn`],
        secretArn: [, , `SecretArn`],
        url: [, , `Url`],
    });
};
const se_FailoverConfig = (input, context) => {
    return take(input, {
        failoverMode: [, , `FailoverMode`],
        recoveryWindow: [, , `RecoveryWindow`],
        sourcePriority: [, (_) => se_SourcePriority(_, context), `SourcePriority`],
        state: [, , `State`],
    });
};
const se_FmtpRequest = (input, context) => {
    return take(input, {
        channelOrder: [, , `ChannelOrder`],
        colorimetry: [, , `Colorimetry`],
        exactFramerate: [, , `ExactFramerate`],
        par: [, , `Par`],
        range: [, , `Range`],
        scanMode: [, , `ScanMode`],
        tcs: [, , `Tcs`],
    });
};
const se_GatewayNetwork = (input, context) => {
    return take(input, {
        cidrBlock: [, , `CidrBlock`],
        name: [, , `Name`],
    });
};
const se_GrantEntitlementRequest = (input, context) => {
    return take(input, {
        dataTransferSubscriberFeePercent: [, , `DataTransferSubscriberFeePercent`],
        description: [, , `Description`],
        encryption: [, (_) => se_Encryption(_, context), `Encryption`],
        entitlementStatus: [, , `EntitlementStatus`],
        name: [, , `Name`],
        subscribers: [, _json, `Subscribers`],
    });
};
const se_InputConfigurationRequest = (input, context) => {
    return take(input, {
        inputPort: [, , `InputPort`],
        interface: [, (_) => se_InterfaceRequest(_, context), `Interface`],
    });
};
const se_InterfaceRequest = (input, context) => {
    return take(input, {
        name: [, , `Name`],
    });
};
const se_MediaStreamAttributesRequest = (input, context) => {
    return take(input, {
        fmtp: [, (_) => se_FmtpRequest(_, context), `Fmtp`],
        lang: [, , `Lang`],
    });
};
const se_MediaStreamOutputConfigurationRequest = (input, context) => {
    return take(input, {
        destinationConfigurations: [
            ,
            (_) => se___listOfDestinationConfigurationRequest(_, context),
            `DestinationConfigurations`,
        ],
        encodingName: [, , `EncodingName`],
        encodingParameters: [, (_) => se_EncodingParametersRequest(_, context), `EncodingParameters`],
        mediaStreamName: [, , `MediaStreamName`],
    });
};
const se_MediaStreamSourceConfigurationRequest = (input, context) => {
    return take(input, {
        encodingName: [, , `EncodingName`],
        inputConfigurations: [, (_) => se___listOfInputConfigurationRequest(_, context), `InputConfigurations`],
        mediaStreamName: [, , `MediaStreamName`],
    });
};
const se_SetGatewayBridgeSourceRequest = (input, context) => {
    return take(input, {
        bridgeArn: [, , `BridgeArn`],
        vpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `VpcInterfaceAttachment`],
    });
};
const se_SetSourceRequest = (input, context) => {
    return take(input, {
        decryption: [, (_) => se_Encryption(_, context), `Decryption`],
        description: [, , `Description`],
        entitlementArn: [, , `EntitlementArn`],
        gatewayBridgeSource: [, (_) => se_SetGatewayBridgeSourceRequest(_, context), `GatewayBridgeSource`],
        ingestPort: [, , `IngestPort`],
        maxBitrate: [, , `MaxBitrate`],
        maxLatency: [, , `MaxLatency`],
        maxSyncBuffer: [, , `MaxSyncBuffer`],
        mediaStreamSourceConfigurations: [
            ,
            (_) => se___listOfMediaStreamSourceConfigurationRequest(_, context),
            `MediaStreamSourceConfigurations`,
        ],
        minLatency: [, , `MinLatency`],
        name: [, , `Name`],
        protocol: [, , `Protocol`],
        senderControlPort: [, , `SenderControlPort`],
        senderIpAddress: [, , `SenderIpAddress`],
        sourceListenerAddress: [, , `SourceListenerAddress`],
        sourceListenerPort: [, , `SourceListenerPort`],
        streamId: [, , `StreamId`],
        vpcInterfaceName: [, , `VpcInterfaceName`],
        whitelistCidr: [, , `WhitelistCidr`],
    });
};
const se_SourcePriority = (input, context) => {
    return take(input, {
        primarySource: [, , `PrimarySource`],
    });
};
const se_UpdateBridgeFlowSourceRequest = (input, context) => {
    return take(input, {
        flowArn: [, , `FlowArn`],
        flowVpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `FlowVpcInterfaceAttachment`],
    });
};
const se_UpdateBridgeNetworkOutputRequest = (input, context) => {
    return take(input, {
        ipAddress: [, , `IpAddress`],
        networkName: [, , `NetworkName`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
        ttl: [, , `Ttl`],
    });
};
const se_UpdateBridgeNetworkSourceRequest = (input, context) => {
    return take(input, {
        multicastIp: [, , `MulticastIp`],
        networkName: [, , `NetworkName`],
        port: [, , `Port`],
        protocol: [, , `Protocol`],
    });
};
const se_UpdateEgressGatewayBridgeRequest = (input, context) => {
    return take(input, {
        maxBitrate: [, , `MaxBitrate`],
    });
};
const se_UpdateEncryption = (input, context) => {
    return take(input, {
        algorithm: [, , `Algorithm`],
        constantInitializationVector: [, , `ConstantInitializationVector`],
        deviceId: [, , `DeviceId`],
        keyType: [, , `KeyType`],
        region: [, , `Region`],
        resourceId: [, , `ResourceId`],
        roleArn: [, , `RoleArn`],
        secretArn: [, , `SecretArn`],
        url: [, , `Url`],
    });
};
const se_UpdateFailoverConfig = (input, context) => {
    return take(input, {
        failoverMode: [, , `FailoverMode`],
        recoveryWindow: [, , `RecoveryWindow`],
        sourcePriority: [, (_) => se_SourcePriority(_, context), `SourcePriority`],
        state: [, , `State`],
    });
};
const se_UpdateGatewayBridgeSourceRequest = (input, context) => {
    return take(input, {
        bridgeArn: [, , `BridgeArn`],
        vpcInterfaceAttachment: [, (_) => se_VpcInterfaceAttachment(_, context), `VpcInterfaceAttachment`],
    });
};
const se_UpdateIngressGatewayBridgeRequest = (input, context) => {
    return take(input, {
        maxBitrate: [, , `MaxBitrate`],
        maxOutputs: [, , `MaxOutputs`],
    });
};
const se_UpdateMaintenance = (input, context) => {
    return take(input, {
        maintenanceDay: [, , `MaintenanceDay`],
        maintenanceScheduledDate: [, , `MaintenanceScheduledDate`],
        maintenanceStartHour: [, , `MaintenanceStartHour`],
    });
};
const se_VpcInterfaceAttachment = (input, context) => {
    return take(input, {
        vpcInterfaceName: [, , `VpcInterfaceName`],
    });
};
const se_VpcInterfaceRequest = (input, context) => {
    return take(input, {
        name: [, , `Name`],
        networkInterfaceType: [, , `NetworkInterfaceType`],
        roleArn: [, , `RoleArn`],
        securityGroupIds: [, _json, `SecurityGroupIds`],
        subnetId: [, , `SubnetId`],
    });
};
const de___listOfBridgeOutput = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BridgeOutput(entry, context);
    });
    return retVal;
};
const de___listOfBridgeSource = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BridgeSource(entry, context);
    });
    return retVal;
};
const de___listOfDestinationConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DestinationConfiguration(entry, context);
    });
    return retVal;
};
const de___listOfEntitlement = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Entitlement(entry, context);
    });
    return retVal;
};
const de___listOfGatewayNetwork = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GatewayNetwork(entry, context);
    });
    return retVal;
};
const de___listOfInputConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InputConfiguration(entry, context);
    });
    return retVal;
};
const de___listOfListedBridge = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListedBridge(entry, context);
    });
    return retVal;
};
const de___listOfListedEntitlement = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListedEntitlement(entry, context);
    });
    return retVal;
};
const de___listOfListedFlow = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListedFlow(entry, context);
    });
    return retVal;
};
const de___listOfListedGateway = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListedGateway(entry, context);
    });
    return retVal;
};
const de___listOfListedGatewayInstance = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListedGatewayInstance(entry, context);
    });
    return retVal;
};
const de___listOfMediaStream = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MediaStream(entry, context);
    });
    return retVal;
};
const de___listOfMediaStreamOutputConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MediaStreamOutputConfiguration(entry, context);
    });
    return retVal;
};
const de___listOfMediaStreamSourceConfiguration = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MediaStreamSourceConfiguration(entry, context);
    });
    return retVal;
};
const de___listOfMessageDetail = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MessageDetail(entry, context);
    });
    return retVal;
};
const de___listOfOffering = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Offering(entry, context);
    });
    return retVal;
};
const de___listOfOutput = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Output(entry, context);
    });
    return retVal;
};
const de___listOfReservation = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Reservation(entry, context);
    });
    return retVal;
};
const de___listOfSource = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Source(entry, context);
    });
    return retVal;
};
const de___listOfTransportStream = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransportStream(entry, context);
    });
    return retVal;
};
const de___listOfTransportStreamProgram = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TransportStreamProgram(entry, context);
    });
    return retVal;
};
const de___listOfVpcInterface = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VpcInterface(entry, context);
    });
    return retVal;
};
const de_Bridge = (output, context) => {
    return take(output, {
        BridgeArn: [, __expectString, `bridgeArn`],
        BridgeMessages: [, (_) => de___listOfMessageDetail(_, context), `bridgeMessages`],
        BridgeState: [, __expectString, `bridgeState`],
        EgressGatewayBridge: [, (_) => de_EgressGatewayBridge(_, context), `egressGatewayBridge`],
        IngressGatewayBridge: [, (_) => de_IngressGatewayBridge(_, context), `ingressGatewayBridge`],
        Name: [, __expectString, `name`],
        Outputs: [, (_) => de___listOfBridgeOutput(_, context), `outputs`],
        PlacementArn: [, __expectString, `placementArn`],
        SourceFailoverConfig: [, (_) => de_FailoverConfig(_, context), `sourceFailoverConfig`],
        Sources: [, (_) => de___listOfBridgeSource(_, context), `sources`],
    });
};
const de_BridgeFlowOutput = (output, context) => {
    return take(output, {
        FlowArn: [, __expectString, `flowArn`],
        FlowSourceArn: [, __expectString, `flowSourceArn`],
        Name: [, __expectString, `name`],
    });
};
const de_BridgeFlowSource = (output, context) => {
    return take(output, {
        FlowArn: [, __expectString, `flowArn`],
        FlowVpcInterfaceAttachment: [, (_) => de_VpcInterfaceAttachment(_, context), `flowVpcInterfaceAttachment`],
        Name: [, __expectString, `name`],
        OutputArn: [, __expectString, `outputArn`],
    });
};
const de_BridgeNetworkOutput = (output, context) => {
    return take(output, {
        IpAddress: [, __expectString, `ipAddress`],
        Name: [, __expectString, `name`],
        NetworkName: [, __expectString, `networkName`],
        Port: [, __expectInt32, `port`],
        Protocol: [, __expectString, `protocol`],
        Ttl: [, __expectInt32, `ttl`],
    });
};
const de_BridgeNetworkSource = (output, context) => {
    return take(output, {
        MulticastIp: [, __expectString, `multicastIp`],
        Name: [, __expectString, `name`],
        NetworkName: [, __expectString, `networkName`],
        Port: [, __expectInt32, `port`],
        Protocol: [, __expectString, `protocol`],
    });
};
const de_BridgeOutput = (output, context) => {
    return take(output, {
        FlowOutput: [, (_) => de_BridgeFlowOutput(_, context), `flowOutput`],
        NetworkOutput: [, (_) => de_BridgeNetworkOutput(_, context), `networkOutput`],
    });
};
const de_BridgeSource = (output, context) => {
    return take(output, {
        FlowSource: [, (_) => de_BridgeFlowSource(_, context), `flowSource`],
        NetworkSource: [, (_) => de_BridgeNetworkSource(_, context), `networkSource`],
    });
};
const de_DestinationConfiguration = (output, context) => {
    return take(output, {
        DestinationIp: [, __expectString, `destinationIp`],
        DestinationPort: [, __expectInt32, `destinationPort`],
        Interface: [, (_) => de_Interface(_, context), `interface`],
        OutboundIp: [, __expectString, `outboundIp`],
    });
};
const de_EgressGatewayBridge = (output, context) => {
    return take(output, {
        InstanceId: [, __expectString, `instanceId`],
        MaxBitrate: [, __expectInt32, `maxBitrate`],
    });
};
const de_EncodingParameters = (output, context) => {
    return take(output, {
        CompressionFactor: [, __limitedParseDouble, `compressionFactor`],
        EncoderProfile: [, __expectString, `encoderProfile`],
    });
};
const de_Encryption = (output, context) => {
    return take(output, {
        Algorithm: [, __expectString, `algorithm`],
        ConstantInitializationVector: [, __expectString, `constantInitializationVector`],
        DeviceId: [, __expectString, `deviceId`],
        KeyType: [, __expectString, `keyType`],
        Region: [, __expectString, `region`],
        ResourceId: [, __expectString, `resourceId`],
        RoleArn: [, __expectString, `roleArn`],
        SecretArn: [, __expectString, `secretArn`],
        Url: [, __expectString, `url`],
    });
};
const de_Entitlement = (output, context) => {
    return take(output, {
        DataTransferSubscriberFeePercent: [, __expectInt32, `dataTransferSubscriberFeePercent`],
        Description: [, __expectString, `description`],
        Encryption: [, (_) => de_Encryption(_, context), `encryption`],
        EntitlementArn: [, __expectString, `entitlementArn`],
        EntitlementStatus: [, __expectString, `entitlementStatus`],
        Name: [, __expectString, `name`],
        Subscribers: [, _json, `subscribers`],
    });
};
const de_FailoverConfig = (output, context) => {
    return take(output, {
        FailoverMode: [, __expectString, `failoverMode`],
        RecoveryWindow: [, __expectInt32, `recoveryWindow`],
        SourcePriority: [, (_) => de_SourcePriority(_, context), `sourcePriority`],
        State: [, __expectString, `state`],
    });
};
const de_Flow = (output, context) => {
    return take(output, {
        AvailabilityZone: [, __expectString, `availabilityZone`],
        Description: [, __expectString, `description`],
        EgressIp: [, __expectString, `egressIp`],
        Entitlements: [, (_) => de___listOfEntitlement(_, context), `entitlements`],
        FlowArn: [, __expectString, `flowArn`],
        Maintenance: [, (_) => de_Maintenance(_, context), `maintenance`],
        MediaStreams: [, (_) => de___listOfMediaStream(_, context), `mediaStreams`],
        Name: [, __expectString, `name`],
        Outputs: [, (_) => de___listOfOutput(_, context), `outputs`],
        Source: [, (_) => de_Source(_, context), `source`],
        SourceFailoverConfig: [, (_) => de_FailoverConfig(_, context), `sourceFailoverConfig`],
        Sources: [, (_) => de___listOfSource(_, context), `sources`],
        Status: [, __expectString, `status`],
        VpcInterfaces: [, (_) => de___listOfVpcInterface(_, context), `vpcInterfaces`],
    });
};
const de_Fmtp = (output, context) => {
    return take(output, {
        ChannelOrder: [, __expectString, `channelOrder`],
        Colorimetry: [, __expectString, `colorimetry`],
        ExactFramerate: [, __expectString, `exactFramerate`],
        Par: [, __expectString, `par`],
        Range: [, __expectString, `range`],
        ScanMode: [, __expectString, `scanMode`],
        Tcs: [, __expectString, `tcs`],
    });
};
const de_FrameResolution = (output, context) => {
    return take(output, {
        FrameHeight: [, __expectInt32, `frameHeight`],
        FrameWidth: [, __expectInt32, `frameWidth`],
    });
};
const de_Gateway = (output, context) => {
    return take(output, {
        EgressCidrBlocks: [, _json, `egressCidrBlocks`],
        GatewayArn: [, __expectString, `gatewayArn`],
        GatewayMessages: [, (_) => de___listOfMessageDetail(_, context), `gatewayMessages`],
        GatewayState: [, __expectString, `gatewayState`],
        Name: [, __expectString, `name`],
        Networks: [, (_) => de___listOfGatewayNetwork(_, context), `networks`],
    });
};
const de_GatewayBridgeSource = (output, context) => {
    return take(output, {
        BridgeArn: [, __expectString, `bridgeArn`],
        VpcInterfaceAttachment: [, (_) => de_VpcInterfaceAttachment(_, context), `vpcInterfaceAttachment`],
    });
};
const de_GatewayInstance = (output, context) => {
    return take(output, {
        BridgePlacement: [, __expectString, `bridgePlacement`],
        ConnectionStatus: [, __expectString, `connectionStatus`],
        GatewayArn: [, __expectString, `gatewayArn`],
        GatewayInstanceArn: [, __expectString, `gatewayInstanceArn`],
        InstanceId: [, __expectString, `instanceId`],
        InstanceMessages: [, (_) => de___listOfMessageDetail(_, context), `instanceMessages`],
        InstanceState: [, __expectString, `instanceState`],
        RunningBridgeCount: [, __expectInt32, `runningBridgeCount`],
    });
};
const de_GatewayNetwork = (output, context) => {
    return take(output, {
        CidrBlock: [, __expectString, `cidrBlock`],
        Name: [, __expectString, `name`],
    });
};
const de_IngressGatewayBridge = (output, context) => {
    return take(output, {
        InstanceId: [, __expectString, `instanceId`],
        MaxBitrate: [, __expectInt32, `maxBitrate`],
        MaxOutputs: [, __expectInt32, `maxOutputs`],
    });
};
const de_InputConfiguration = (output, context) => {
    return take(output, {
        InputIp: [, __expectString, `inputIp`],
        InputPort: [, __expectInt32, `inputPort`],
        Interface: [, (_) => de_Interface(_, context), `interface`],
    });
};
const de_Interface = (output, context) => {
    return take(output, {
        Name: [, __expectString, `name`],
    });
};
const de_ListedBridge = (output, context) => {
    return take(output, {
        BridgeArn: [, __expectString, `bridgeArn`],
        BridgeState: [, __expectString, `bridgeState`],
        BridgeType: [, __expectString, `bridgeType`],
        Name: [, __expectString, `name`],
        PlacementArn: [, __expectString, `placementArn`],
    });
};
const de_ListedEntitlement = (output, context) => {
    return take(output, {
        DataTransferSubscriberFeePercent: [, __expectInt32, `dataTransferSubscriberFeePercent`],
        EntitlementArn: [, __expectString, `entitlementArn`],
        EntitlementName: [, __expectString, `entitlementName`],
    });
};
const de_ListedFlow = (output, context) => {
    return take(output, {
        AvailabilityZone: [, __expectString, `availabilityZone`],
        Description: [, __expectString, `description`],
        FlowArn: [, __expectString, `flowArn`],
        Maintenance: [, (_) => de_Maintenance(_, context), `maintenance`],
        Name: [, __expectString, `name`],
        SourceType: [, __expectString, `sourceType`],
        Status: [, __expectString, `status`],
    });
};
const de_ListedGateway = (output, context) => {
    return take(output, {
        GatewayArn: [, __expectString, `gatewayArn`],
        GatewayState: [, __expectString, `gatewayState`],
        Name: [, __expectString, `name`],
    });
};
const de_ListedGatewayInstance = (output, context) => {
    return take(output, {
        GatewayArn: [, __expectString, `gatewayArn`],
        GatewayInstanceArn: [, __expectString, `gatewayInstanceArn`],
        InstanceId: [, __expectString, `instanceId`],
        InstanceState: [, __expectString, `instanceState`],
    });
};
const de_Maintenance = (output, context) => {
    return take(output, {
        MaintenanceDay: [, __expectString, `maintenanceDay`],
        MaintenanceDeadline: [, __expectString, `maintenanceDeadline`],
        MaintenanceScheduledDate: [, __expectString, `maintenanceScheduledDate`],
        MaintenanceStartHour: [, __expectString, `maintenanceStartHour`],
    });
};
const de_MediaStream = (output, context) => {
    return take(output, {
        Attributes: [, (_) => de_MediaStreamAttributes(_, context), `attributes`],
        ClockRate: [, __expectInt32, `clockRate`],
        Description: [, __expectString, `description`],
        Fmt: [, __expectInt32, `fmt`],
        MediaStreamId: [, __expectInt32, `mediaStreamId`],
        MediaStreamName: [, __expectString, `mediaStreamName`],
        MediaStreamType: [, __expectString, `mediaStreamType`],
        VideoFormat: [, __expectString, `videoFormat`],
    });
};
const de_MediaStreamAttributes = (output, context) => {
    return take(output, {
        Fmtp: [, (_) => de_Fmtp(_, context), `fmtp`],
        Lang: [, __expectString, `lang`],
    });
};
const de_MediaStreamOutputConfiguration = (output, context) => {
    return take(output, {
        DestinationConfigurations: [
            ,
            (_) => de___listOfDestinationConfiguration(_, context),
            `destinationConfigurations`,
        ],
        EncodingName: [, __expectString, `encodingName`],
        EncodingParameters: [, (_) => de_EncodingParameters(_, context), `encodingParameters`],
        MediaStreamName: [, __expectString, `mediaStreamName`],
    });
};
const de_MediaStreamSourceConfiguration = (output, context) => {
    return take(output, {
        EncodingName: [, __expectString, `encodingName`],
        InputConfigurations: [, (_) => de___listOfInputConfiguration(_, context), `inputConfigurations`],
        MediaStreamName: [, __expectString, `mediaStreamName`],
    });
};
const de_MessageDetail = (output, context) => {
    return take(output, {
        Code: [, __expectString, `code`],
        Message: [, __expectString, `message`],
        ResourceName: [, __expectString, `resourceName`],
    });
};
const de_Messages = (output, context) => {
    return take(output, {
        Errors: [, _json, `errors`],
    });
};
const de_Offering = (output, context) => {
    return take(output, {
        CurrencyCode: [, __expectString, `currencyCode`],
        Duration: [, __expectInt32, `duration`],
        DurationUnits: [, __expectString, `durationUnits`],
        OfferingArn: [, __expectString, `offeringArn`],
        OfferingDescription: [, __expectString, `offeringDescription`],
        PricePerUnit: [, __expectString, `pricePerUnit`],
        PriceUnits: [, __expectString, `priceUnits`],
        ResourceSpecification: [, (_) => de_ResourceSpecification(_, context), `resourceSpecification`],
    });
};
const de_Output = (output, context) => {
    return take(output, {
        BridgeArn: [, __expectString, `bridgeArn`],
        BridgePorts: [, _json, `bridgePorts`],
        DataTransferSubscriberFeePercent: [, __expectInt32, `dataTransferSubscriberFeePercent`],
        Description: [, __expectString, `description`],
        Destination: [, __expectString, `destination`],
        Encryption: [, (_) => de_Encryption(_, context), `encryption`],
        EntitlementArn: [, __expectString, `entitlementArn`],
        ListenerAddress: [, __expectString, `listenerAddress`],
        MediaLiveInputArn: [, __expectString, `mediaLiveInputArn`],
        MediaStreamOutputConfigurations: [
            ,
            (_) => de___listOfMediaStreamOutputConfiguration(_, context),
            `mediaStreamOutputConfigurations`,
        ],
        Name: [, __expectString, `name`],
        OutputArn: [, __expectString, `outputArn`],
        Port: [, __expectInt32, `port`],
        Transport: [, (_) => de_Transport(_, context), `transport`],
        VpcInterfaceAttachment: [, (_) => de_VpcInterfaceAttachment(_, context), `vpcInterfaceAttachment`],
    });
};
const de_Reservation = (output, context) => {
    return take(output, {
        CurrencyCode: [, __expectString, `currencyCode`],
        Duration: [, __expectInt32, `duration`],
        DurationUnits: [, __expectString, `durationUnits`],
        End: [, __expectString, `end`],
        OfferingArn: [, __expectString, `offeringArn`],
        OfferingDescription: [, __expectString, `offeringDescription`],
        PricePerUnit: [, __expectString, `pricePerUnit`],
        PriceUnits: [, __expectString, `priceUnits`],
        ReservationArn: [, __expectString, `reservationArn`],
        ReservationName: [, __expectString, `reservationName`],
        ReservationState: [, __expectString, `reservationState`],
        ResourceSpecification: [, (_) => de_ResourceSpecification(_, context), `resourceSpecification`],
        Start: [, __expectString, `start`],
    });
};
const de_ResourceSpecification = (output, context) => {
    return take(output, {
        ReservedBitrate: [, __expectInt32, `reservedBitrate`],
        ResourceType: [, __expectString, `resourceType`],
    });
};
const de_Source = (output, context) => {
    return take(output, {
        DataTransferSubscriberFeePercent: [, __expectInt32, `dataTransferSubscriberFeePercent`],
        Decryption: [, (_) => de_Encryption(_, context), `decryption`],
        Description: [, __expectString, `description`],
        EntitlementArn: [, __expectString, `entitlementArn`],
        GatewayBridgeSource: [, (_) => de_GatewayBridgeSource(_, context), `gatewayBridgeSource`],
        IngestIp: [, __expectString, `ingestIp`],
        IngestPort: [, __expectInt32, `ingestPort`],
        MediaStreamSourceConfigurations: [
            ,
            (_) => de___listOfMediaStreamSourceConfiguration(_, context),
            `mediaStreamSourceConfigurations`,
        ],
        Name: [, __expectString, `name`],
        SenderControlPort: [, __expectInt32, `senderControlPort`],
        SenderIpAddress: [, __expectString, `senderIpAddress`],
        SourceArn: [, __expectString, `sourceArn`],
        Transport: [, (_) => de_Transport(_, context), `transport`],
        VpcInterfaceName: [, __expectString, `vpcInterfaceName`],
        WhitelistCidr: [, __expectString, `whitelistCidr`],
    });
};
const de_SourcePriority = (output, context) => {
    return take(output, {
        PrimarySource: [, __expectString, `primarySource`],
    });
};
const de_Transport = (output, context) => {
    return take(output, {
        CidrAllowList: [, _json, `cidrAllowList`],
        MaxBitrate: [, __expectInt32, `maxBitrate`],
        MaxLatency: [, __expectInt32, `maxLatency`],
        MaxSyncBuffer: [, __expectInt32, `maxSyncBuffer`],
        MinLatency: [, __expectInt32, `minLatency`],
        Protocol: [, __expectString, `protocol`],
        RemoteId: [, __expectString, `remoteId`],
        SenderControlPort: [, __expectInt32, `senderControlPort`],
        SenderIpAddress: [, __expectString, `senderIpAddress`],
        SmoothingLatency: [, __expectInt32, `smoothingLatency`],
        SourceListenerAddress: [, __expectString, `sourceListenerAddress`],
        SourceListenerPort: [, __expectInt32, `sourceListenerPort`],
        StreamId: [, __expectString, `streamId`],
    });
};
const de_TransportMediaInfo = (output, context) => {
    return take(output, {
        Programs: [, (_) => de___listOfTransportStreamProgram(_, context), `programs`],
    });
};
const de_TransportStream = (output, context) => {
    return take(output, {
        Channels: [, __expectInt32, `channels`],
        Codec: [, __expectString, `codec`],
        FrameRate: [, __expectString, `frameRate`],
        FrameResolution: [, (_) => de_FrameResolution(_, context), `frameResolution`],
        Pid: [, __expectInt32, `pid`],
        SampleRate: [, __expectInt32, `sampleRate`],
        SampleSize: [, __expectInt32, `sampleSize`],
        StreamType: [, __expectString, `streamType`],
    });
};
const de_TransportStreamProgram = (output, context) => {
    return take(output, {
        PcrPid: [, __expectInt32, `pcrPid`],
        ProgramName: [, __expectString, `programName`],
        ProgramNumber: [, __expectInt32, `programNumber`],
        ProgramPid: [, __expectInt32, `programPid`],
        Streams: [, (_) => de___listOfTransportStream(_, context), `streams`],
    });
};
const de_VpcInterface = (output, context) => {
    return take(output, {
        Name: [, __expectString, `name`],
        NetworkInterfaceIds: [, _json, `networkInterfaceIds`],
        NetworkInterfaceType: [, __expectString, `networkInterfaceType`],
        RoleArn: [, __expectString, `roleArn`],
        SecurityGroupIds: [, _json, `securityGroupIds`],
        SubnetId: [, __expectString, `subnetId`],
    });
};
const de_VpcInterfaceAttachment = (output, context) => {
    return take(output, {
        VpcInterfaceName: [, __expectString, `vpcInterfaceName`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _F = "Force";
const _FA = "FilterArn";
const _MR = "MaxResults";
const _NT = "NextToken";
const _TK = "TagKeys";
const _f = "force";
const _fA = "filterArn";
const _mR = "maxResults";
const _nT = "nextToken";
const _tK = "tagKeys";
