import { awsExpectUnion as __expectUnion, loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody, } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, LazyJsonString as __LazyJsonString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { EvidentlyServiceException as __BaseException } from "../models/EvidentlyServiceException";
import { AccessDeniedException, ConflictException, InternalServerException, ResourceNotFoundException, ServiceQuotaExceededException, ServiceUnavailableException, ThrottlingException, ValidationException, VariableValue, } from "../models/models_0";
export const se_BatchEvaluateFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/evaluations");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        requests: (_) => se_EvaluationRequestsList(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "dataplane." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/experiments");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        metricGoals: (_) => se_MetricGoalConfigList(_, context),
        name: [],
        onlineAbConfig: (_) => _json(_),
        randomizationSalt: [],
        samplingRate: [],
        segment: [],
        tags: (_) => _json(_),
        treatments: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/features");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        defaultVariation: [],
        description: [],
        entityOverrides: (_) => _json(_),
        evaluationStrategy: [],
        name: [],
        tags: (_) => _json(_),
        variations: (_) => se_VariationConfigsList(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/launches");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        groups: (_) => _json(_),
        metricMonitors: (_) => se_MetricMonitorConfigList(_, context),
        name: [],
        randomizationSalt: [],
        scheduledSplitsConfig: (_) => se_ScheduledSplitsLaunchConfig(_, context),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects");
    let body;
    body = JSON.stringify(take(input, {
        appConfigResource: (_) => _json(_),
        dataDelivery: (_) => _json(_),
        description: [],
        name: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateSegmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/segments");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        name: [],
        pattern: (_) => __LazyJsonString.fromObject(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/experiments/{experiment}");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/features/{feature}");
    b.p("project", () => input.project, "{project}", false);
    b.p("feature", () => input.feature, "{feature}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/launches/{launch}");
    b.p("project", () => input.project, "{project}", false);
    b.p("launch", () => input.launch, "{launch}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}");
    b.p("project", () => input.project, "{project}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteSegmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/segments/{segment}");
    b.p("segment", () => input.segment, "{segment}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_EvaluateFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/evaluations/{feature}");
    b.p("project", () => input.project, "{project}", false);
    b.p("feature", () => input.feature, "{feature}", false);
    let body;
    body = JSON.stringify(take(input, {
        entityId: [],
        evaluationContext: (_) => __LazyJsonString.fromObject(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "dataplane." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/experiments/{experiment}");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetExperimentResultsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/experiments/{experiment}/results");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    body = JSON.stringify(take(input, {
        baseStat: [],
        endTime: (_) => Math.round(_.getTime() / 1000),
        metricNames: (_) => _json(_),
        period: [],
        reportNames: (_) => _json(_),
        resultStats: (_) => _json(_),
        startTime: (_) => Math.round(_.getTime() / 1000),
        treatmentNames: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/features/{feature}");
    b.p("project", () => input.project, "{project}", false);
    b.p("feature", () => input.feature, "{feature}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/launches/{launch}");
    b.p("project", () => input.project, "{project}", false);
    b.p("launch", () => input.launch, "{launch}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}");
    b.p("project", () => input.project, "{project}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetSegmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/segments/{segment}");
    b.p("segment", () => input.segment, "{segment}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListExperimentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/experiments");
    b.p("project", () => input.project, "{project}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_s]: [, input[_s]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListFeaturesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/features");
    b.p("project", () => input.project, "{project}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListLaunchesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/launches");
    b.p("project", () => input.project, "{project}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_s]: [, input[_s]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProjectsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListSegmentReferencesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/segments/{segment}/references");
    b.p("segment", () => input.segment, "{segment}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_t]: [, __expectNonNull(input[_t], `type`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListSegmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/segments");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_PutProjectEventsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/events/projects/{project}");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        events: (_) => se_EventList(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "dataplane." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/experiments/{experiment}/start");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    body = JSON.stringify(take(input, {
        analysisCompleteTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/projects/{project}/launches/{launch}/start");
    b.p("project", () => input.project, "{project}", false);
    b.p("launch", () => input.launch, "{launch}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StopExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/experiments/{experiment}/cancel");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    body = JSON.stringify(take(input, {
        desiredState: [],
        reason: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StopLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/launches/{launch}/cancel");
    b.p("project", () => input.project, "{project}", false);
    b.p("launch", () => input.launch, "{launch}", false);
    let body;
    body = JSON.stringify(take(input, {
        desiredState: [],
        reason: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TestSegmentPatternCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/test-segment-pattern");
    let body;
    body = JSON.stringify(take(input, {
        pattern: (_) => __LazyJsonString.fromObject(_),
        payload: (_) => __LazyJsonString.fromObject(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateExperimentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/experiments/{experiment}");
    b.p("project", () => input.project, "{project}", false);
    b.p("experiment", () => input.experiment, "{experiment}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        metricGoals: (_) => se_MetricGoalConfigList(_, context),
        onlineAbConfig: (_) => _json(_),
        randomizationSalt: [],
        removeSegment: [],
        samplingRate: [],
        segment: [],
        treatments: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateFeatureCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/features/{feature}");
    b.p("project", () => input.project, "{project}", false);
    b.p("feature", () => input.feature, "{feature}", false);
    let body;
    body = JSON.stringify(take(input, {
        addOrUpdateVariations: (_) => se_VariationConfigsList(_, context),
        defaultVariation: [],
        description: [],
        entityOverrides: (_) => _json(_),
        evaluationStrategy: [],
        removeVariations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateLaunchCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/launches/{launch}");
    b.p("project", () => input.project, "{project}", false);
    b.p("launch", () => input.launch, "{launch}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        groups: (_) => _json(_),
        metricMonitors: (_) => se_MetricMonitorConfigList(_, context),
        randomizationSalt: [],
        scheduledSplitsConfig: (_) => se_ScheduledSplitsLaunchConfig(_, context),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateProjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        appConfigResource: (_) => _json(_),
        description: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateProjectDataDeliveryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/projects/{project}/data-delivery");
    b.p("project", () => input.project, "{project}", false);
    let body;
    body = JSON.stringify(take(input, {
        cloudWatchLogs: (_) => _json(_),
        s3Destination: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const de_BatchEvaluateFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        results: (_) => de_EvaluationResultsList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        experiment: (_) => de_Experiment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        feature: (_) => de_Feature(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        launch: (_) => de_Launch(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        project: (_) => de_Project(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSegmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        segment: (_) => de_Segment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSegmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_EvaluateFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        details: (_) => new __LazyJsonString(_),
        reason: __expectString,
        value: (_) => de_VariableValue(__expectUnion(_), context),
        variation: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        experiment: (_) => de_Experiment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetExperimentResultsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        details: __expectString,
        reports: (_) => de_ExperimentReportList(_, context),
        resultsData: (_) => de_ExperimentResultsDataList(_, context),
        timestamps: (_) => de_TimestampList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        feature: (_) => de_Feature(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        launch: (_) => de_Launch(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        project: (_) => de_Project(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSegmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        segment: (_) => de_Segment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListExperimentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        experiments: (_) => de_ExperimentList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFeaturesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        features: (_) => de_FeatureSummariesList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListLaunchesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        launches: (_) => de_LaunchesList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        projects: (_) => de_ProjectSummariesList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSegmentReferencesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        referencedBy: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSegmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        segments: (_) => de_SegmentList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutProjectEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        eventResults: _json,
        failedEventCount: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        startedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        launch: (_) => de_Launch(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TestSegmentPatternCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        match: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateExperimentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        experiment: (_) => de_Experiment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateFeatureCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        feature: (_) => de_Feature(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateLaunchCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        launch: (_) => de_Launch(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateProjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        project: (_) => de_Project(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateProjectDataDeliveryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        project: (_) => de_Project(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.evidently#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.evidently#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.evidently#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.evidently#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.evidently#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.evidently#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.evidently#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.evidently#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        quotaCode: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
        serviceCode: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        quotaCode: __expectString,
        serviceCode: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        fieldList: _json,
        message: __expectString,
        reason: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_EvaluationRequest = (input, context) => {
    return take(input, {
        entityId: [],
        evaluationContext: __LazyJsonString.fromObject,
        feature: [],
    });
};
const se_EvaluationRequestsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_EvaluationRequest(entry, context);
    });
};
const se_Event = (input, context) => {
    return take(input, {
        data: __LazyJsonString.fromObject,
        timestamp: (_) => Math.round(_.getTime() / 1000),
        type: [],
    });
};
const se_EventList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Event(entry, context);
    });
};
const se_MetricDefinitionConfig = (input, context) => {
    return take(input, {
        entityIdKey: [],
        eventPattern: __LazyJsonString.fromObject,
        name: [],
        unitLabel: [],
        valueKey: [],
    });
};
const se_MetricGoalConfig = (input, context) => {
    return take(input, {
        desiredChange: [],
        metricDefinition: (_) => se_MetricDefinitionConfig(_, context),
    });
};
const se_MetricGoalConfigList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MetricGoalConfig(entry, context);
    });
};
const se_MetricMonitorConfig = (input, context) => {
    return take(input, {
        metricDefinition: (_) => se_MetricDefinitionConfig(_, context),
    });
};
const se_MetricMonitorConfigList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MetricMonitorConfig(entry, context);
    });
};
const se_ScheduledSplitConfig = (input, context) => {
    return take(input, {
        groupWeights: _json,
        segmentOverrides: _json,
        startTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_ScheduledSplitConfigList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ScheduledSplitConfig(entry, context);
    });
};
const se_ScheduledSplitsLaunchConfig = (input, context) => {
    return take(input, {
        steps: (_) => se_ScheduledSplitConfigList(_, context),
    });
};
const se_VariableValue = (input, context) => {
    return VariableValue.visit(input, {
        boolValue: (value) => ({ boolValue: value }),
        doubleValue: (value) => ({ doubleValue: __serializeFloat(value) }),
        longValue: (value) => ({ longValue: value }),
        stringValue: (value) => ({ stringValue: value }),
        _: (name, value) => ({ name: value }),
    });
};
const se_VariationConfig = (input, context) => {
    return take(input, {
        name: [],
        value: (_) => se_VariableValue(_, context),
    });
};
const se_VariationConfigsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_VariationConfig(entry, context);
    });
};
const de_DoubleValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __limitedParseDouble(entry);
    });
    return retVal;
};
const de_EvaluationResult = (output, context) => {
    return take(output, {
        details: (_) => new __LazyJsonString(_),
        entityId: __expectString,
        feature: __expectString,
        project: __expectString,
        reason: __expectString,
        value: (_) => de_VariableValue(__expectUnion(_), context),
        variation: __expectString,
    });
};
const de_EvaluationResultsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EvaluationResult(entry, context);
    });
    return retVal;
};
const de_Experiment = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        execution: (_) => de_ExperimentExecution(_, context),
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricGoals: (_) => de_MetricGoalsList(_, context),
        name: __expectString,
        onlineAbDefinition: _json,
        project: __expectString,
        randomizationSalt: __expectString,
        samplingRate: __expectLong,
        schedule: (_) => de_ExperimentSchedule(_, context),
        segment: __expectString,
        status: __expectString,
        statusReason: __expectString,
        tags: _json,
        treatments: _json,
        type: __expectString,
    });
};
const de_ExperimentExecution = (output, context) => {
    return take(output, {
        endedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ExperimentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Experiment(entry, context);
    });
    return retVal;
};
const de_ExperimentReport = (output, context) => {
    return take(output, {
        content: (_) => new __LazyJsonString(_),
        metricName: __expectString,
        reportName: __expectString,
        treatmentName: __expectString,
    });
};
const de_ExperimentReportList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExperimentReport(entry, context);
    });
    return retVal;
};
const de_ExperimentResultsData = (output, context) => {
    return take(output, {
        metricName: __expectString,
        resultStat: __expectString,
        treatmentName: __expectString,
        values: (_) => de_DoubleValueList(_, context),
    });
};
const de_ExperimentResultsDataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExperimentResultsData(entry, context);
    });
    return retVal;
};
const de_ExperimentSchedule = (output, context) => {
    return take(output, {
        analysisCompleteTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_Feature = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVariation: __expectString,
        description: __expectString,
        entityOverrides: _json,
        evaluationRules: _json,
        evaluationStrategy: __expectString,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        project: __expectString,
        status: __expectString,
        tags: _json,
        valueType: __expectString,
        variations: (_) => de_VariationsList(_, context),
    });
};
const de_FeatureSummariesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FeatureSummary(entry, context);
    });
    return retVal;
};
const de_FeatureSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        defaultVariation: __expectString,
        evaluationRules: _json,
        evaluationStrategy: __expectString,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        project: __expectString,
        status: __expectString,
        tags: _json,
    });
};
const de_Launch = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        execution: (_) => de_LaunchExecution(_, context),
        groups: _json,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metricMonitors: (_) => de_MetricMonitorList(_, context),
        name: __expectString,
        project: __expectString,
        randomizationSalt: __expectString,
        scheduledSplitsDefinition: (_) => de_ScheduledSplitsLaunchDefinition(_, context),
        status: __expectString,
        statusReason: __expectString,
        tags: _json,
        type: __expectString,
    });
};
const de_LaunchesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Launch(entry, context);
    });
    return retVal;
};
const de_LaunchExecution = (output, context) => {
    return take(output, {
        endedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        startedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_MetricDefinition = (output, context) => {
    return take(output, {
        entityIdKey: __expectString,
        eventPattern: (_) => new __LazyJsonString(_),
        name: __expectString,
        unitLabel: __expectString,
        valueKey: __expectString,
    });
};
const de_MetricGoal = (output, context) => {
    return take(output, {
        desiredChange: __expectString,
        metricDefinition: (_) => de_MetricDefinition(_, context),
    });
};
const de_MetricGoalsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricGoal(entry, context);
    });
    return retVal;
};
const de_MetricMonitor = (output, context) => {
    return take(output, {
        metricDefinition: (_) => de_MetricDefinition(_, context),
    });
};
const de_MetricMonitorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricMonitor(entry, context);
    });
    return retVal;
};
const de_Project = (output, context) => {
    return take(output, {
        activeExperimentCount: __expectLong,
        activeLaunchCount: __expectLong,
        appConfigResource: _json,
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        dataDelivery: _json,
        description: __expectString,
        experimentCount: __expectLong,
        featureCount: __expectLong,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        launchCount: __expectLong,
        name: __expectString,
        status: __expectString,
        tags: _json,
    });
};
const de_ProjectSummariesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProjectSummary(entry, context);
    });
    return retVal;
};
const de_ProjectSummary = (output, context) => {
    return take(output, {
        activeExperimentCount: __expectLong,
        activeLaunchCount: __expectLong,
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        experimentCount: __expectLong,
        featureCount: __expectLong,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        launchCount: __expectLong,
        name: __expectString,
        status: __expectString,
        tags: _json,
    });
};
const de_ScheduledSplit = (output, context) => {
    return take(output, {
        groupWeights: _json,
        segmentOverrides: _json,
        startTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ScheduledSplitsLaunchDefinition = (output, context) => {
    return take(output, {
        steps: (_) => de_ScheduledStepList(_, context),
    });
};
const de_ScheduledStepList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ScheduledSplit(entry, context);
    });
    return retVal;
};
const de_Segment = (output, context) => {
    return take(output, {
        arn: __expectString,
        createdTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        experimentCount: __expectLong,
        lastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        launchCount: __expectLong,
        name: __expectString,
        pattern: (_) => new __LazyJsonString(_),
        tags: _json,
    });
};
const de_SegmentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Segment(entry, context);
    });
    return retVal;
};
const de_TimestampList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectNonNull(__parseEpochTimestamp(__expectNumber(entry)));
    });
    return retVal;
};
const de_VariableValue = (output, context) => {
    if (__expectBoolean(output.boolValue) !== undefined) {
        return { boolValue: __expectBoolean(output.boolValue) };
    }
    if (__limitedParseDouble(output.doubleValue) !== undefined) {
        return { doubleValue: __limitedParseDouble(output.doubleValue) };
    }
    if (__expectLong(output.longValue) !== undefined) {
        return { longValue: __expectLong(output.longValue) };
    }
    if (__expectString(output.stringValue) !== undefined) {
        return { stringValue: __expectString(output.stringValue) };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_Variation = (output, context) => {
    return take(output, {
        name: __expectString,
        value: (_) => de_VariableValue(__expectUnion(_), context),
    });
};
const de_VariationsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Variation(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _mR = "maxResults";
const _nT = "nextToken";
const _s = "status";
const _t = "type";
const _tK = "tagKeys";
