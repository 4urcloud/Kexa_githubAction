import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SnowDeviceManagementServiceException as __BaseException } from "./SnowDeviceManagementServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const AttachmentStatus: {
  readonly ATTACHED: "ATTACHED";
  readonly ATTACHING: "ATTACHING";
  readonly DETACHED: "DETACHED";
  readonly DETACHING: "DETACHING";
};
export type AttachmentStatus =
  (typeof AttachmentStatus)[keyof typeof AttachmentStatus];
export interface CancelTaskInput {
  taskId: string | undefined;
}
export interface CancelTaskOutput {
  taskId?: string;
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  $retryable: {};
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  $retryable: {
    throttling: boolean;
  };
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface Capacity {
  name?: string;
  unit?: string;
  total?: number;
  used?: number;
  available?: number;
}
export interface Reboot {}
export interface Unlock {}
export type Command =
  | Command.RebootMember
  | Command.UnlockMember
  | Command.$UnknownMember;
export declare namespace Command {
  interface UnlockMember {
    unlock: Unlock;
    reboot?: never;
    $unknown?: never;
  }
  interface RebootMember {
    unlock?: never;
    reboot: Reboot;
    $unknown?: never;
  }
  interface $UnknownMember {
    unlock?: never;
    reboot?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    unlock: (value: Unlock) => T;
    reboot: (value: Reboot) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: Command, visitor: Visitor<T>) => T;
}
export interface CpuOptions {
  coreCount?: number;
  threadsPerCore?: number;
}
export interface CreateTaskInput {
  targets: string[] | undefined;
  command: Command | undefined;
  description?: string;
  tags?: Record<string, string>;
  clientToken?: string;
}
export interface CreateTaskOutput {
  taskId?: string;
  taskArn?: string;
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export interface DescribeDeviceInput {
  managedDeviceId: string | undefined;
}
export declare const UnlockState: {
  readonly LOCKED: "LOCKED";
  readonly UNLOCKED: "UNLOCKED";
  readonly UNLOCKING: "UNLOCKING";
};
export type UnlockState = (typeof UnlockState)[keyof typeof UnlockState];
export declare const IpAddressAssignment: {
  readonly DHCP: "DHCP";
  readonly STATIC: "STATIC";
};
export type IpAddressAssignment =
  (typeof IpAddressAssignment)[keyof typeof IpAddressAssignment];
export declare const PhysicalConnectorType: {
  readonly QSFP: "QSFP";
  readonly RJ45: "RJ45";
  readonly RJ45_2: "RJ45_2";
  readonly SFP_PLUS: "SFP_PLUS";
  readonly WIFI: "WIFI";
};
export type PhysicalConnectorType =
  (typeof PhysicalConnectorType)[keyof typeof PhysicalConnectorType];
export interface PhysicalNetworkInterface {
  physicalNetworkInterfaceId?: string;
  physicalConnectorType?: PhysicalConnectorType;
  ipAddressAssignment?: IpAddressAssignment;
  ipAddress?: string;
  netmask?: string;
  defaultGateway?: string;
  macAddress?: string;
}
export interface SoftwareInformation {
  installedVersion?: string;
  installingVersion?: string;
  installState?: string;
}
export interface DescribeDeviceOutput {
  lastReachedOutAt?: Date;
  lastUpdatedAt?: Date;
  tags?: Record<string, string>;
  managedDeviceId?: string;
  managedDeviceArn?: string;
  deviceType?: string;
  associatedWithJob?: string;
  deviceState?: UnlockState;
  physicalNetworkInterfaces?: PhysicalNetworkInterface[];
  deviceCapacities?: Capacity[];
  software?: SoftwareInformation;
}
export interface DescribeDeviceEc2Input {
  managedDeviceId: string | undefined;
  instanceIds: string[] | undefined;
}
export interface EbsInstanceBlockDevice {
  attachTime?: Date;
  deleteOnTermination?: boolean;
  status?: AttachmentStatus;
  volumeId?: string;
}
export interface InstanceBlockDeviceMapping {
  deviceName?: string;
  ebs?: EbsInstanceBlockDevice;
}
export interface SecurityGroupIdentifier {
  groupId?: string;
  groupName?: string;
}
export declare const InstanceStateName: {
  readonly PENDING: "PENDING";
  readonly RUNNING: "RUNNING";
  readonly SHUTTING_DOWN: "SHUTTING_DOWN";
  readonly STOPPED: "STOPPED";
  readonly STOPPING: "STOPPING";
  readonly TERMINATED: "TERMINATED";
};
export type InstanceStateName =
  (typeof InstanceStateName)[keyof typeof InstanceStateName];
export interface InstanceState {
  code?: number;
  name?: InstanceStateName;
}
export interface Instance {
  imageId?: string;
  amiLaunchIndex?: number;
  instanceId?: string;
  state?: InstanceState;
  instanceType?: string;
  privateIpAddress?: string;
  publicIpAddress?: string;
  createdAt?: Date;
  updatedAt?: Date;
  blockDeviceMappings?: InstanceBlockDeviceMapping[];
  securityGroups?: SecurityGroupIdentifier[];
  cpuOptions?: CpuOptions;
  rootDeviceName?: string;
}
export interface InstanceSummary {
  instance?: Instance;
  lastUpdatedAt?: Date;
}
export interface DescribeDeviceEc2Output {
  instances?: InstanceSummary[];
}
export interface DescribeExecutionInput {
  taskId: string | undefined;
  managedDeviceId: string | undefined;
}
export declare const ExecutionState: {
  readonly CANCELED: "CANCELED";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly QUEUED: "QUEUED";
  readonly REJECTED: "REJECTED";
  readonly SUCCEEDED: "SUCCEEDED";
  readonly TIMED_OUT: "TIMED_OUT";
};
export type ExecutionState =
  (typeof ExecutionState)[keyof typeof ExecutionState];
export interface DescribeExecutionOutput {
  taskId?: string;
  executionId?: string;
  managedDeviceId?: string;
  state?: ExecutionState;
  startedAt?: Date;
  lastUpdatedAt?: Date;
}
export interface DescribeTaskInput {
  taskId: string | undefined;
}
export declare const TaskState: {
  readonly CANCELED: "CANCELED";
  readonly COMPLETED: "COMPLETED";
  readonly IN_PROGRESS: "IN_PROGRESS";
};
export type TaskState = (typeof TaskState)[keyof typeof TaskState];
export interface DescribeTaskOutput {
  taskId?: string;
  taskArn?: string;
  targets?: string[];
  state?: TaskState;
  createdAt?: Date;
  lastUpdatedAt?: Date;
  completedAt?: Date;
  description?: string;
  tags?: Record<string, string>;
}
export interface DeviceSummary {
  managedDeviceId?: string;
  managedDeviceArn?: string;
  associatedWithJob?: string;
  tags?: Record<string, string>;
}
export interface ListExecutionsInput {
  taskId: string | undefined;
  state?: ExecutionState;
  maxResults?: number;
  nextToken?: string;
}
export interface ExecutionSummary {
  taskId?: string;
  executionId?: string;
  managedDeviceId?: string;
  state?: ExecutionState;
}
export interface ListExecutionsOutput {
  executions?: ExecutionSummary[];
  nextToken?: string;
}
export interface ListDeviceResourcesInput {
  managedDeviceId: string | undefined;
  type?: string;
  maxResults?: number;
  nextToken?: string;
}
export interface ResourceSummary {
  resourceType: string | undefined;
  arn?: string;
  id?: string;
}
export interface ListDeviceResourcesOutput {
  resources?: ResourceSummary[];
  nextToken?: string;
}
export interface ListDevicesInput {
  jobId?: string;
  maxResults?: number;
  nextToken?: string;
}
export interface ListDevicesOutput {
  devices?: DeviceSummary[];
  nextToken?: string;
}
export interface ListTagsForResourceInput {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceOutput {
  tags?: Record<string, string>;
}
export interface ListTasksInput {
  state?: TaskState;
  maxResults?: number;
  nextToken?: string;
}
export interface TaskSummary {
  taskId: string | undefined;
  taskArn?: string;
  state?: TaskState;
  tags?: Record<string, string>;
}
export interface ListTasksOutput {
  tasks?: TaskSummary[];
  nextToken?: string;
}
export interface TagResourceInput {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface UntagResourceInput {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
