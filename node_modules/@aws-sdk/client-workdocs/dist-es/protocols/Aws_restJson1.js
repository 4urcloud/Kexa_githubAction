import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { ConcurrentModificationException, ConflictingOperationException, CustomMetadataLimitExceededException, DeactivatingLastSystemUserException, DocumentLockedForCommentsException, DraftUploadOutOfSyncException, EntityAlreadyExistsException, EntityNotExistsException, FailedDependencyException, IllegalUserStateException, InvalidArgumentException, InvalidCommentOperationException, InvalidOperationException, InvalidPasswordException, LimitExceededException, ProhibitedStateException, RequestedEntityTooLargeException, ResourceAlreadyCheckedOutException, ServiceUnavailableException, StorageLimitExceededException, StorageLimitWillExceedException, TooManyLabelsException, TooManySubscriptionsException, UnauthorizedOperationException, UnauthorizedResourceAccessException, } from "../models/models_0";
import { WorkDocsServiceException as __BaseException } from "../models/WorkDocsServiceException";
export const se_AbortDocumentVersionUploadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_ActivateUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users/{UserId}/activation");
    b.p("UserId", () => input.UserId, "{UserId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AddResourcePermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/permissions");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        NotificationOptions: (_) => _json(_),
        Principals: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateCommentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}/comment");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        NotifyCollaborators: [],
        ParentId: [],
        Text: [],
        ThreadId: [],
        Visibility: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateCustomMetadataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/customMetadata");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    const query = map({
        [_v]: [, input[_VI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        CustomMetadata: (_) => _json(_),
    }));
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateFolderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
        ParentFolderId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLabelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/labels");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        Labels: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateNotificationSubscriptionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/api/v1/organizations/{OrganizationId}/subscriptions");
    b.p("OrganizationId", () => input.OrganizationId, "{OrganizationId}", false);
    let body;
    body = JSON.stringify(take(input, {
        Endpoint: [],
        Protocol: [],
        SubscriptionType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users");
    let body;
    body = JSON.stringify(take(input, {
        EmailAddress: [],
        GivenName: [],
        OrganizationId: [],
        Password: [],
        StorageRule: (_) => _json(_),
        Surname: [],
        TimeZoneId: [],
        Username: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeactivateUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users/{UserId}/activation");
    b.p("UserId", () => input.UserId, "{UserId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteCommentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}/comment/{CommentId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    b.p("CommentId", () => input.CommentId, "{CommentId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteCustomMetadataCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/customMetadata");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    const query = map({
        [_vI]: [, input[_VI]],
        [_k]: [() => input.Keys !== void 0, () => (input[_K] || []).map((_entry) => _entry)],
        [_dA]: [() => input.DeleteAll !== void 0, () => input[_DA].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteDocumentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDocumentVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documentVersions/{DocumentId}/versions/{VersionId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    const query = map({
        [_dPV]: [__expectNonNull(input.DeletePriorVersions, `DeletePriorVersions`) != null, () => input[_DPV].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteFolderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteFolderContentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}/contents");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteLabelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/labels");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    const query = map({
        [_l]: [() => input.Labels !== void 0, () => (input[_L] || []).map((_entry) => _entry)],
        [_dA]: [() => input.DeleteAll !== void 0, () => input[_DA].toString()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteNotificationSubscriptionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/api/v1/organizations/{OrganizationId}/subscriptions/{SubscriptionId}");
    b.p("SubscriptionId", () => input.SubscriptionId, "{SubscriptionId}", false);
    b.p("OrganizationId", () => input.OrganizationId, "{OrganizationId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users/{UserId}");
    b.p("UserId", () => input.UserId, "{UserId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DescribeActivitiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/activities");
    const query = map({
        [_sT]: [() => input.StartTime !== void 0, () => (input[_ST].toISOString().split(".")[0] + "Z").toString()],
        [_eT]: [() => input.EndTime !== void 0, () => (input[_ET].toISOString().split(".")[0] + "Z").toString()],
        [_oI]: [, input[_OI]],
        [_aT]: [, input[_ATc]],
        [_rI]: [, input[_RI]],
        [_uI]: [, input[_UI]],
        [_iIA]: [() => input.IncludeIndirectActivities !== void 0, () => input[_IIA].toString()],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeCommentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}/comments");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    const query = map({
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeDocumentVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    const query = map({
        [_m]: [, input[_M]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_i]: [, input[_I]],
        [_f]: [, input[_F]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeFolderContentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}/contents");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    const query = map({
        [_s]: [, input[_S]],
        [_o]: [, input[_O]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
        [_t]: [, input[_T]],
        [_i]: [, input[_I]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/groups");
    const query = map({
        [_sQ]: [, __expectNonNull(input[_SQ], `SearchQuery`)],
        [_oI]: [, input[_OI]],
        [_m]: [, input[_M]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeNotificationSubscriptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/api/v1/organizations/{OrganizationId}/subscriptions");
    b.p("OrganizationId", () => input.OrganizationId, "{OrganizationId}", false);
    const query = map({
        [_m]: [, input[_M]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeResourcePermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/permissions");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    const query = map({
        [_pI]: [, input[_PI]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeRootFoldersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/me/root");
    const query = map({
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DescribeUsersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users");
    const query = map({
        [_oI]: [, input[_OI]],
        [_uIs]: [, input[_UIs]],
        [_q]: [, input[_Q]],
        [_i]: [, input[_I]],
        [_o]: [, input[_O]],
        [_s]: [, input[_S]],
        [_m]: [, input[_M]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_f]: [, input[_F]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetCurrentUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/me");
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDocumentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    const query = map({
        [_iCM]: [() => input.IncludeCustomMetadata !== void 0, () => input[_ICM].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDocumentPathCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/path");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    const query = map({
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_f]: [, input[_F]],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDocumentVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    const query = map({
        [_f]: [, input[_F]],
        [_iCM]: [() => input.IncludeCustomMetadata !== void 0, () => input[_ICM].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetFolderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    const query = map({
        [_iCM]: [() => input.IncludeCustomMetadata !== void 0, () => input[_ICM].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetFolderPathCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}/path");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    const query = map({
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_f]: [, input[_F]],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources");
    const query = map({
        [_uI]: [, input[_UI]],
        [_cT]: [, input[_CT]],
        [_li]: [() => input.Limit !== void 0, () => input[_Li].toString()],
        [_m]: [, input[_M]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_InitiateDocumentVersionUploadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents");
    let body;
    body = JSON.stringify(take(input, {
        ContentCreatedTimestamp: (_) => Math.round(_.getTime() / 1000),
        ContentModifiedTimestamp: (_) => Math.round(_.getTime() / 1000),
        ContentType: [],
        DocumentSizeInBytes: [],
        Id: [],
        Name: [],
        ParentFolderId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveAllResourcePermissionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/permissions");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_RemoveResourcePermissionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/resources/{ResourceId}/permissions/{PrincipalId}");
    b.p("ResourceId", () => input.ResourceId, "{ResourceId}", false);
    b.p("PrincipalId", () => input.PrincipalId, "{PrincipalId}", false);
    const query = map({
        [_t]: [, input[_PT]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_RestoreDocumentVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documentVersions/restore/{DocumentId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_SearchResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/search");
    let body;
    body = JSON.stringify(take(input, {
        AdditionalResponseFields: (_) => _json(_),
        Filters: (_) => se_Filters(_, context),
        Limit: [],
        Marker: [],
        OrderBy: (_) => _json(_),
        OrganizationId: [],
        QueryScopes: (_) => _json(_),
        QueryText: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateDocumentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
        ParentFolderId: [],
        ResourceState: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDocumentVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/documents/{DocumentId}/versions/{VersionId}");
    b.p("DocumentId", () => input.DocumentId, "{DocumentId}", false);
    b.p("VersionId", () => input.VersionId, "{VersionId}", false);
    let body;
    body = JSON.stringify(take(input, {
        VersionStatus: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateFolderCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/folders/{FolderId}");
    b.p("FolderId", () => input.FolderId, "{FolderId}", false);
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
        ParentFolderId: [],
        ResourceState: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_a]: input[_AT],
    });
    b.bp("/api/v1/users/{UserId}");
    b.p("UserId", () => input.UserId, "{UserId}", false);
    let body;
    body = JSON.stringify(take(input, {
        GivenName: [],
        GrantPoweruserPrivileges: [],
        Locale: [],
        StorageRule: (_) => _json(_),
        Surname: [],
        TimeZoneId: [],
        Type: [],
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const de_AbortDocumentVersionUploadCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ActivateUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        User: (_) => de_User(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AddResourcePermissionsCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ShareResults: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateCommentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Comment: (_) => de_Comment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateCustomMetadataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateFolderCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Metadata: (_) => de_FolderMetadata(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateLabelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateNotificationSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Subscription: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        User: (_) => de_User(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeactivateUserCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteCommentCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteCustomMetadataCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDocumentCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDocumentVersionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteFolderCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteFolderContentsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLabelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteNotificationSubscriptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeActivitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        UserActivities: (_) => de_UserActivities(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeCommentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Comments: (_) => de_CommentList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeDocumentVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DocumentVersions: (_) => de_DocumentVersionMetadataList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeFolderContentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Documents: (_) => de_DocumentMetadataList(_, context),
        Folders: (_) => de_FolderMetadataList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Groups: _json,
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeNotificationSubscriptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        Subscriptions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeResourcePermissionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        Principals: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeRootFoldersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Folders: (_) => de_FolderMetadataList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeUsersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Marker: __expectString,
        TotalNumberOfUsers: __expectLong,
        Users: (_) => de_OrganizationUserList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetCurrentUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        User: (_) => de_User(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CustomMetadata: _json,
        Metadata: (_) => de_DocumentMetadata(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentPathCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Path: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CustomMetadata: _json,
        Metadata: (_) => de_DocumentVersionMetadata(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFolderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CustomMetadata: _json,
        Metadata: (_) => de_FolderMetadata(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFolderPathCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Path: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Documents: (_) => de_DocumentMetadataList(_, context),
        Folders: (_) => de_FolderMetadataList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_InitiateDocumentVersionUploadCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Metadata: (_) => de_DocumentMetadata(_, context),
        UploadMetadata: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveAllResourcePermissionsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RemoveResourcePermissionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RestoreDocumentVersionsCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SearchResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_ResponseItemsList(_, context),
        Marker: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateDocumentVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateFolderCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        User: (_) => de_User(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.workdocs#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityNotExistsException":
        case "com.amazonaws.workdocs#EntityNotExistsException":
            throw await de_EntityNotExistsExceptionRes(parsedOutput, context);
        case "FailedDependencyException":
        case "com.amazonaws.workdocs#FailedDependencyException":
            throw await de_FailedDependencyExceptionRes(parsedOutput, context);
        case "ProhibitedStateException":
        case "com.amazonaws.workdocs#ProhibitedStateException":
            throw await de_ProhibitedStateExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.workdocs#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedOperationException":
        case "com.amazonaws.workdocs#UnauthorizedOperationException":
            throw await de_UnauthorizedOperationExceptionRes(parsedOutput, context);
        case "UnauthorizedResourceAccessException":
        case "com.amazonaws.workdocs#UnauthorizedResourceAccessException":
            throw await de_UnauthorizedResourceAccessExceptionRes(parsedOutput, context);
        case "DocumentLockedForCommentsException":
        case "com.amazonaws.workdocs#DocumentLockedForCommentsException":
            throw await de_DocumentLockedForCommentsExceptionRes(parsedOutput, context);
        case "InvalidCommentOperationException":
        case "com.amazonaws.workdocs#InvalidCommentOperationException":
            throw await de_InvalidCommentOperationExceptionRes(parsedOutput, context);
        case "CustomMetadataLimitExceededException":
        case "com.amazonaws.workdocs#CustomMetadataLimitExceededException":
            throw await de_CustomMetadataLimitExceededExceptionRes(parsedOutput, context);
        case "ConflictingOperationException":
        case "com.amazonaws.workdocs#ConflictingOperationException":
            throw await de_ConflictingOperationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExistsException":
        case "com.amazonaws.workdocs#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.workdocs#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TooManyLabelsException":
        case "com.amazonaws.workdocs#TooManyLabelsException":
            throw await de_TooManyLabelsExceptionRes(parsedOutput, context);
        case "InvalidArgumentException":
        case "com.amazonaws.workdocs#InvalidArgumentException":
            throw await de_InvalidArgumentExceptionRes(parsedOutput, context);
        case "TooManySubscriptionsException":
        case "com.amazonaws.workdocs#TooManySubscriptionsException":
            throw await de_TooManySubscriptionsExceptionRes(parsedOutput, context);
        case "InvalidOperationException":
        case "com.amazonaws.workdocs#InvalidOperationException":
            throw await de_InvalidOperationExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.workdocs#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "RequestedEntityTooLargeException":
        case "com.amazonaws.workdocs#RequestedEntityTooLargeException":
            throw await de_RequestedEntityTooLargeExceptionRes(parsedOutput, context);
        case "DraftUploadOutOfSyncException":
        case "com.amazonaws.workdocs#DraftUploadOutOfSyncException":
            throw await de_DraftUploadOutOfSyncExceptionRes(parsedOutput, context);
        case "ResourceAlreadyCheckedOutException":
        case "com.amazonaws.workdocs#ResourceAlreadyCheckedOutException":
            throw await de_ResourceAlreadyCheckedOutExceptionRes(parsedOutput, context);
        case "StorageLimitExceededException":
        case "com.amazonaws.workdocs#StorageLimitExceededException":
            throw await de_StorageLimitExceededExceptionRes(parsedOutput, context);
        case "StorageLimitWillExceedException":
        case "com.amazonaws.workdocs#StorageLimitWillExceedException":
            throw await de_StorageLimitWillExceedExceptionRes(parsedOutput, context);
        case "DeactivatingLastSystemUserException":
        case "com.amazonaws.workdocs#DeactivatingLastSystemUserException":
            throw await de_DeactivatingLastSystemUserExceptionRes(parsedOutput, context);
        case "IllegalUserStateException":
        case "com.amazonaws.workdocs#IllegalUserStateException":
            throw await de_IllegalUserStateExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictingOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictingOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CustomMetadataLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new CustomMetadataLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DeactivatingLastSystemUserExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DeactivatingLastSystemUserException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DocumentLockedForCommentsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DocumentLockedForCommentsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DraftUploadOutOfSyncExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DraftUploadOutOfSyncException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_EntityAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new EntityAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_EntityNotExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        EntityIds: _json,
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new EntityNotExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_FailedDependencyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new FailedDependencyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_IllegalUserStateExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new IllegalUserStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidArgumentExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidArgumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidCommentOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidCommentOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidPasswordExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidPasswordException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ProhibitedStateExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ProhibitedStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_RequestedEntityTooLargeExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new RequestedEntityTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceAlreadyCheckedOutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceAlreadyCheckedOutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_StorageLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new StorageLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_StorageLimitWillExceedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new StorageLimitWillExceedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyLabelsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyLabelsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManySubscriptionsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManySubscriptionsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedOperationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Code: __expectString,
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedResourceAccessExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedResourceAccessException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_DateRangeType = (input, context) => {
    return take(input, {
        EndValue: (_) => Math.round(_.getTime() / 1000),
        StartValue: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_Filters = (input, context) => {
    return take(input, {
        AncestorIds: _json,
        ContentCategories: _json,
        CreatedRange: (_) => se_DateRangeType(_, context),
        Labels: _json,
        ModifiedRange: (_) => se_DateRangeType(_, context),
        Principals: _json,
        ResourceTypes: _json,
        SearchCollectionTypes: _json,
        SizeRange: _json,
        TextLocales: _json,
    });
};
const de_Activity = (output, context) => {
    return take(output, {
        CommentMetadata: (_) => de_CommentMetadata(_, context),
        Initiator: _json,
        IsIndirectActivity: __expectBoolean,
        OrganizationId: __expectString,
        OriginalParent: _json,
        Participants: _json,
        ResourceMetadata: _json,
        TimeStamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Type: __expectString,
    });
};
const de_Comment = (output, context) => {
    return take(output, {
        CommentId: __expectString,
        Contributor: (_) => de_User(_, context),
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ParentId: __expectString,
        RecipientId: __expectString,
        Status: __expectString,
        Text: __expectString,
        ThreadId: __expectString,
        Visibility: __expectString,
    });
};
const de_CommentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Comment(entry, context);
    });
    return retVal;
};
const de_CommentMetadata = (output, context) => {
    return take(output, {
        CommentId: __expectString,
        CommentStatus: __expectString,
        Contributor: (_) => de_User(_, context),
        ContributorId: __expectString,
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RecipientId: __expectString,
    });
};
const de_DocumentMetadata = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        CreatorId: __expectString,
        Id: __expectString,
        Labels: _json,
        LatestVersionMetadata: (_) => de_DocumentVersionMetadata(_, context),
        ModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ParentFolderId: __expectString,
        ResourceState: __expectString,
    });
};
const de_DocumentMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DocumentMetadata(entry, context);
    });
    return retVal;
};
const de_DocumentVersionMetadata = (output, context) => {
    return take(output, {
        ContentCreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ContentModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ContentType: __expectString,
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        CreatorId: __expectString,
        Id: __expectString,
        ModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Name: __expectString,
        Signature: __expectString,
        Size: __expectLong,
        Source: _json,
        Status: __expectString,
        Thumbnail: _json,
    });
};
const de_DocumentVersionMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DocumentVersionMetadata(entry, context);
    });
    return retVal;
};
const de_FolderMetadata = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        CreatorId: __expectString,
        Id: __expectString,
        Labels: _json,
        LatestVersionSize: __expectLong,
        ModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Name: __expectString,
        ParentFolderId: __expectString,
        ResourceState: __expectString,
        Signature: __expectString,
        Size: __expectLong,
    });
};
const de_FolderMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FolderMetadata(entry, context);
    });
    return retVal;
};
const de_OrganizationUserList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_User(entry, context);
    });
    return retVal;
};
const de_ResponseItem = (output, context) => {
    return take(output, {
        CommentMetadata: (_) => de_CommentMetadata(_, context),
        DocumentMetadata: (_) => de_DocumentMetadata(_, context),
        DocumentVersionMetadata: (_) => de_DocumentVersionMetadata(_, context),
        FolderMetadata: (_) => de_FolderMetadata(_, context),
        ResourceType: __expectString,
        WebUrl: __expectString,
    });
};
const de_ResponseItemsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseItem(entry, context);
    });
    return retVal;
};
const de_User = (output, context) => {
    return take(output, {
        CreatedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        EmailAddress: __expectString,
        GivenName: __expectString,
        Id: __expectString,
        Locale: __expectString,
        ModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        OrganizationId: __expectString,
        RecycleBinFolderId: __expectString,
        RootFolderId: __expectString,
        Status: __expectString,
        Storage: _json,
        Surname: __expectString,
        TimeZoneId: __expectString,
        Type: __expectString,
        Username: __expectString,
    });
};
const de_UserActivities = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Activity(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _AT = "AuthenticationToken";
const _ATc = "ActivityTypes";
const _CT = "CollectionType";
const _DA = "DeleteAll";
const _DPV = "DeletePriorVersions";
const _ET = "EndTime";
const _F = "Fields";
const _I = "Include";
const _ICM = "IncludeCustomMetadata";
const _IIA = "IncludeIndirectActivities";
const _K = "Keys";
const _L = "Labels";
const _Li = "Limit";
const _M = "Marker";
const _O = "Order";
const _OI = "OrganizationId";
const _PI = "PrincipalId";
const _PT = "PrincipalType";
const _Q = "Query";
const _RI = "ResourceId";
const _S = "Sort";
const _SQ = "SearchQuery";
const _ST = "StartTime";
const _T = "Type";
const _UI = "UserId";
const _UIs = "UserIds";
const _VI = "VersionId";
const _a = "authentication";
const _aT = "activityTypes";
const _cT = "collectionType";
const _dA = "deleteAll";
const _dPV = "deletePriorVersions";
const _eT = "endTime";
const _f = "fields";
const _i = "include";
const _iCM = "includeCustomMetadata";
const _iIA = "includeIndirectActivities";
const _k = "keys";
const _l = "labels";
const _li = "limit";
const _m = "marker";
const _o = "order";
const _oI = "organizationId";
const _pI = "principalId";
const _q = "query";
const _rI = "resourceId";
const _s = "sort";
const _sQ = "searchQuery";
const _sT = "startTime";
const _t = "type";
const _uI = "userId";
const _uIs = "userIds";
const _v = "versionid";
const _vI = "versionId";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
