import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { WorkDocsServiceException as __BaseException } from "./WorkDocsServiceException";
/**
 * @public
 */
export interface AbortDocumentVersionUploadRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The ID of the version.</p>
     * @public
     */
    VersionId: string | undefined;
}
/**
 * <p>The resource hierarchy is changing.</p>
 * @public
 */
export declare class ConcurrentModificationException extends __BaseException {
    readonly name: "ConcurrentModificationException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConcurrentModificationException, __BaseException>);
}
/**
 * <p>The resource does not exist.</p>
 * @public
 */
export declare class EntityNotExistsException extends __BaseException {
    readonly name: "EntityNotExistsException";
    readonly $fault: "client";
    Message?: string;
    /**
     * <p>The IDs of the non-existent resources.</p>
     * @public
     */
    EntityIds?: string[];
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<EntityNotExistsException, __BaseException>);
}
/**
 * <p>The Directory Service cannot reach an on-premises instance. Or a dependency
 *             under the control of the organization is failing, such as a connected Active
 *             Directory.</p>
 * @public
 */
export declare class FailedDependencyException extends __BaseException {
    readonly name: "FailedDependencyException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<FailedDependencyException, __BaseException>);
}
/**
 * <p>The specified document version is not in the INITIALIZED state.</p>
 * @public
 */
export declare class ProhibitedStateException extends __BaseException {
    readonly name: "ProhibitedStateException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ProhibitedStateException, __BaseException>);
}
/**
 * <p>One or more of the dependencies is unavailable.</p>
 * @public
 */
export declare class ServiceUnavailableException extends __BaseException {
    readonly name: "ServiceUnavailableException";
    readonly $fault: "server";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServiceUnavailableException, __BaseException>);
}
/**
 * <p>The operation is not permitted.</p>
 * @public
 */
export declare class UnauthorizedOperationException extends __BaseException {
    readonly name: "UnauthorizedOperationException";
    readonly $fault: "client";
    Message?: string;
    Code?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnauthorizedOperationException, __BaseException>);
}
/**
 * <p>The caller does not have access to perform the action on the resource.</p>
 * @public
 */
export declare class UnauthorizedResourceAccessException extends __BaseException {
    readonly name: "UnauthorizedResourceAccessException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<UnauthorizedResourceAccessException, __BaseException>);
}
/**
 * @public
 */
export interface ActivateUserRequest {
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    UserId: string | undefined;
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
}
/**
 * @public
 * @enum
 */
export declare const LocaleType: {
    readonly DE: "de";
    readonly DEFAULT: "default";
    readonly EN: "en";
    readonly ES: "es";
    readonly FR: "fr";
    readonly JA: "ja";
    readonly KO: "ko";
    readonly PT_BR: "pt_BR";
    readonly RU: "ru";
    readonly ZH_CN: "zh_CN";
    readonly ZH_TW: "zh_TW";
};
/**
 * @public
 */
export type LocaleType = (typeof LocaleType)[keyof typeof LocaleType];
/**
 * @public
 * @enum
 */
export declare const UserStatusType: {
    readonly ACTIVE: "ACTIVE";
    readonly INACTIVE: "INACTIVE";
    readonly PENDING: "PENDING";
};
/**
 * @public
 */
export type UserStatusType = (typeof UserStatusType)[keyof typeof UserStatusType];
/**
 * @public
 * @enum
 */
export declare const StorageType: {
    readonly QUOTA: "QUOTA";
    readonly UNLIMITED: "UNLIMITED";
};
/**
 * @public
 */
export type StorageType = (typeof StorageType)[keyof typeof StorageType];
/**
 * <p>Describes the storage for a user.</p>
 * @public
 */
export interface StorageRuleType {
    /**
     * <p>The amount of storage allocated, in bytes.</p>
     * @public
     */
    StorageAllocatedInBytes?: number;
    /**
     * <p>The type of storage.</p>
     * @public
     */
    StorageType?: StorageType;
}
/**
 * <p>Describes the storage for a user.</p>
 * @public
 */
export interface UserStorageMetadata {
    /**
     * <p>The amount of storage used, in bytes.</p>
     * @public
     */
    StorageUtilizedInBytes?: number;
    /**
     * <p>The storage for a user.</p>
     * @public
     */
    StorageRule?: StorageRuleType;
}
/**
 * @public
 * @enum
 */
export declare const UserType: {
    readonly ADMIN: "ADMIN";
    readonly MINIMALUSER: "MINIMALUSER";
    readonly POWERUSER: "POWERUSER";
    readonly USER: "USER";
    readonly WORKSPACESUSER: "WORKSPACESUSER";
};
/**
 * @public
 */
export type UserType = (typeof UserType)[keyof typeof UserType];
/**
 * <p>Describes a user.</p>
 * @public
 */
export interface User {
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The login name of the user.</p>
     * @public
     */
    Username?: string;
    /**
     * <p>The email address of the user.</p>
     * @public
     */
    EmailAddress?: string;
    /**
     * <p>The given name of the user.</p>
     * @public
     */
    GivenName?: string;
    /**
     * <p>The surname of the user.</p>
     * @public
     */
    Surname?: string;
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>The ID of the root folder.</p>
     * @public
     */
    RootFolderId?: string;
    /**
     * <p>The ID of the recycle bin folder.</p>
     * @public
     */
    RecycleBinFolderId?: string;
    /**
     * <p>The status of the user.</p>
     * @public
     */
    Status?: UserStatusType;
    /**
     * <p>The type of user.</p>
     * @public
     */
    Type?: UserType;
    /**
     * <p>The time when the user was created.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The time when the user was modified.</p>
     * @public
     */
    ModifiedTimestamp?: Date;
    /**
     * <p>The time zone ID of the user.</p>
     * @public
     */
    TimeZoneId?: string;
    /**
     * <p>The locale of the user.</p>
     * @public
     */
    Locale?: LocaleType;
    /**
     * <p>The storage for the user.</p>
     * @public
     */
    Storage?: UserStorageMetadata;
}
/**
 * @public
 */
export interface ActivateUserResponse {
    /**
     * <p>The user information.</p>
     * @public
     */
    User?: User;
}
/**
 * @public
 * @enum
 */
export declare const CommentStatusType: {
    readonly DELETED: "DELETED";
    readonly DRAFT: "DRAFT";
    readonly PUBLISHED: "PUBLISHED";
};
/**
 * @public
 */
export type CommentStatusType = (typeof CommentStatusType)[keyof typeof CommentStatusType];
/**
 * <p>Describes the metadata of a comment.</p>
 * @public
 */
export interface CommentMetadata {
    /**
     * <p>The ID of the comment.</p>
     * @public
     */
    CommentId?: string;
    /**
     * <p>The user who made the comment.</p>
     * @public
     */
    Contributor?: User;
    /**
     * <p>The timestamp that the comment was created.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The status of the comment.</p>
     * @public
     */
    CommentStatus?: CommentStatusType;
    /**
     * <p>The ID of the user being replied to.</p>
     * @public
     */
    RecipientId?: string;
    /**
     * <p>The ID of the user who made the comment.</p>
     * @public
     */
    ContributorId?: string;
}
/**
 * <p>Describes the metadata of the user.</p>
 * @public
 */
export interface UserMetadata {
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the user.</p>
     * @public
     */
    Username?: string;
    /**
     * <p>The given name of the user before a rename operation.</p>
     * @public
     */
    GivenName?: string;
    /**
     * <p>The surname of the user.</p>
     * @public
     */
    Surname?: string;
    /**
     * <p>The email address of the user.</p>
     * @public
     */
    EmailAddress?: string;
}
/**
 * @public
 * @enum
 */
export declare const ResourceType: {
    readonly DOCUMENT: "DOCUMENT";
    readonly FOLDER: "FOLDER";
};
/**
 * @public
 */
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
/**
 * <p>Describes the metadata of a resource.</p>
 * @public
 */
export interface ResourceMetadata {
    /**
     * <p>The type of resource.</p>
     * @public
     */
    Type?: ResourceType;
    /**
     * <p>The name of the resource.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The original name of the resource before a rename operation.</p>
     * @public
     */
    OriginalName?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The version ID of the resource. This is an optional field and is filled for action
     *             on document version.</p>
     * @public
     */
    VersionId?: string;
    /**
     * <p>The owner of the resource.</p>
     * @public
     */
    Owner?: UserMetadata;
    /**
     * <p>The parent ID of the resource before a rename operation.</p>
     * @public
     */
    ParentId?: string;
}
/**
 * <p>Describes the metadata of a user group.</p>
 * @public
 */
export interface GroupMetadata {
    /**
     * <p>The ID of the user group.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the group.</p>
     * @public
     */
    Name?: string;
}
/**
 * <p>Describes the users or user groups.</p>
 * @public
 */
export interface Participants {
    /**
     * <p>The list of users.</p>
     * @public
     */
    Users?: UserMetadata[];
    /**
     * <p>The list of user groups.</p>
     * @public
     */
    Groups?: GroupMetadata[];
}
/**
 * @public
 * @enum
 */
export declare const ActivityType: {
    readonly DOCUMENT_ANNOTATION_ADDED: "DOCUMENT_ANNOTATION_ADDED";
    readonly DOCUMENT_ANNOTATION_DELETED: "DOCUMENT_ANNOTATION_DELETED";
    readonly DOCUMENT_CHECKED_IN: "DOCUMENT_CHECKED_IN";
    readonly DOCUMENT_CHECKED_OUT: "DOCUMENT_CHECKED_OUT";
    readonly DOCUMENT_COMMENT_ADDED: "DOCUMENT_COMMENT_ADDED";
    readonly DOCUMENT_COMMENT_DELETED: "DOCUMENT_COMMENT_DELETED";
    readonly DOCUMENT_MOVED: "DOCUMENT_MOVED";
    readonly DOCUMENT_RECYCLED: "DOCUMENT_RECYCLED";
    readonly DOCUMENT_RENAMED: "DOCUMENT_RENAMED";
    readonly DOCUMENT_RESTORED: "DOCUMENT_RESTORED";
    readonly DOCUMENT_REVERTED: "DOCUMENT_REVERTED";
    readonly DOCUMENT_SHAREABLE_LINK_CREATED: "DOCUMENT_SHAREABLE_LINK_CREATED";
    readonly DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED: "DOCUMENT_SHAREABLE_LINK_PERMISSION_CHANGED";
    readonly DOCUMENT_SHAREABLE_LINK_REMOVED: "DOCUMENT_SHAREABLE_LINK_REMOVED";
    readonly DOCUMENT_SHARED: "DOCUMENT_SHARED";
    readonly DOCUMENT_SHARE_PERMISSION_CHANGED: "DOCUMENT_SHARE_PERMISSION_CHANGED";
    readonly DOCUMENT_UNSHARED: "DOCUMENT_UNSHARED";
    readonly DOCUMENT_VERSION_DELETED: "DOCUMENT_VERSION_DELETED";
    readonly DOCUMENT_VERSION_DOWNLOADED: "DOCUMENT_VERSION_DOWNLOADED";
    readonly DOCUMENT_VERSION_UPLOADED: "DOCUMENT_VERSION_UPLOADED";
    readonly DOCUMENT_VERSION_VIEWED: "DOCUMENT_VERSION_VIEWED";
    readonly FOLDER_CREATED: "FOLDER_CREATED";
    readonly FOLDER_DELETED: "FOLDER_DELETED";
    readonly FOLDER_MOVED: "FOLDER_MOVED";
    readonly FOLDER_RECYCLED: "FOLDER_RECYCLED";
    readonly FOLDER_RENAMED: "FOLDER_RENAMED";
    readonly FOLDER_RESTORED: "FOLDER_RESTORED";
    readonly FOLDER_SHAREABLE_LINK_CREATED: "FOLDER_SHAREABLE_LINK_CREATED";
    readonly FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED: "FOLDER_SHAREABLE_LINK_PERMISSION_CHANGED";
    readonly FOLDER_SHAREABLE_LINK_REMOVED: "FOLDER_SHAREABLE_LINK_REMOVED";
    readonly FOLDER_SHARED: "FOLDER_SHARED";
    readonly FOLDER_SHARE_PERMISSION_CHANGED: "FOLDER_SHARE_PERMISSION_CHANGED";
    readonly FOLDER_UNSHARED: "FOLDER_UNSHARED";
};
/**
 * @public
 */
export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType];
/**
 * <p>Describes the activity information.</p>
 * @public
 */
export interface Activity {
    /**
     * <p>The activity type.</p>
     * @public
     */
    Type?: ActivityType;
    /**
     * <p>The timestamp when the action was performed.</p>
     * @public
     */
    TimeStamp?: Date;
    /**
     * <p>Indicates whether an activity is indirect or direct. An indirect activity results
     *             from a direct activity performed on a parent resource. For example, sharing a parent
     *             folder (the direct activity) shares all of the subfolders and documents within the
     *             parent folder (the indirect activity).</p>
     * @public
     */
    IsIndirectActivity?: boolean;
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>The user who performed the action.</p>
     * @public
     */
    Initiator?: UserMetadata;
    /**
     * <p>The list of users or groups impacted by this action. This is an optional field and
     *             is filled for the following sharing activities: DOCUMENT_SHARED, DOCUMENT_SHARED,
     *             DOCUMENT_UNSHARED, FOLDER_SHARED, FOLDER_UNSHARED.</p>
     * @public
     */
    Participants?: Participants;
    /**
     * <p>The metadata of the resource involved in the user action.</p>
     * @public
     */
    ResourceMetadata?: ResourceMetadata;
    /**
     * <p>The original parent of the resource. This is an optional field and is filled for
     *             move activities.</p>
     * @public
     */
    OriginalParent?: ResourceMetadata;
    /**
     * <p>Metadata of the commenting activity. This is an optional field and is filled for
     *             commenting activities.</p>
     * @public
     */
    CommentMetadata?: CommentMetadata;
}
/**
 * @public
 * @enum
 */
export declare const AdditionalResponseFieldType: {
    readonly WEBURL: "WEBURL";
};
/**
 * @public
 */
export type AdditionalResponseFieldType = (typeof AdditionalResponseFieldType)[keyof typeof AdditionalResponseFieldType];
/**
 * <p>Set of options which defines notification preferences of given action.</p>
 * @public
 */
export interface NotificationOptions {
    /**
     * <p>Boolean value to indicate an email notification should be sent to the
     *             recipients.</p>
     * @public
     */
    SendEmail?: boolean;
    /**
     * <p>Text value to be included in the email body.</p>
     * @public
     */
    EmailMessage?: string;
}
/**
 * @public
 * @enum
 */
export declare const RoleType: {
    readonly CONTRIBUTOR: "CONTRIBUTOR";
    readonly COOWNER: "COOWNER";
    readonly OWNER: "OWNER";
    readonly VIEWER: "VIEWER";
};
/**
 * @public
 */
export type RoleType = (typeof RoleType)[keyof typeof RoleType];
/**
 * @public
 * @enum
 */
export declare const PrincipalType: {
    readonly ANONYMOUS: "ANONYMOUS";
    readonly GROUP: "GROUP";
    readonly INVITE: "INVITE";
    readonly ORGANIZATION: "ORGANIZATION";
    readonly USER: "USER";
};
/**
 * @public
 */
export type PrincipalType = (typeof PrincipalType)[keyof typeof PrincipalType];
/**
 * <p>Describes the recipient type and ID, if available.</p>
 * @public
 */
export interface SharePrincipal {
    /**
     * <p>The ID of the recipient.</p>
     * @public
     */
    Id: string | undefined;
    /**
     * <p>The type of the recipient.</p>
     * @public
     */
    Type: PrincipalType | undefined;
    /**
     * <p>The role of the recipient.</p>
     * @public
     */
    Role: RoleType | undefined;
}
/**
 * @public
 */
export interface AddResourcePermissionsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>The users, groups, or organization being granted permission.</p>
     * @public
     */
    Principals: SharePrincipal[] | undefined;
    /**
     * <p>The notification options.</p>
     * @public
     */
    NotificationOptions?: NotificationOptions;
}
/**
 * @public
 * @enum
 */
export declare const ShareStatusType: {
    readonly FAILURE: "FAILURE";
    readonly SUCCESS: "SUCCESS";
};
/**
 * @public
 */
export type ShareStatusType = (typeof ShareStatusType)[keyof typeof ShareStatusType];
/**
 * <p>Describes the share results of a resource.</p>
 * @public
 */
export interface ShareResult {
    /**
     * <p>The ID of the principal.</p>
     * @public
     */
    PrincipalId?: string;
    /**
     * <p>The ID of the invited user.</p>
     * @public
     */
    InviteePrincipalId?: string;
    /**
     * <p>The role.</p>
     * @public
     */
    Role?: RoleType;
    /**
     * <p>The status.</p>
     * @public
     */
    Status?: ShareStatusType;
    /**
     * <p>The ID of the resource that was shared.</p>
     * @public
     */
    ShareId?: string;
    /**
     * <p>The status message.</p>
     * @public
     */
    StatusMessage?: string;
}
/**
 * @public
 */
export interface AddResourcePermissionsResponse {
    /**
     * <p>The share results.</p>
     * @public
     */
    ShareResults?: ShareResult[];
}
/**
 * @public
 * @enum
 */
export declare const CommentVisibilityType: {
    readonly PRIVATE: "PRIVATE";
    readonly PUBLIC: "PUBLIC";
};
/**
 * @public
 */
export type CommentVisibilityType = (typeof CommentVisibilityType)[keyof typeof CommentVisibilityType];
/**
 * @public
 */
export interface CreateCommentRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The ID of the document version.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>The ID of the parent comment.</p>
     * @public
     */
    ParentId?: string;
    /**
     * <p>The ID of the root comment in the thread.</p>
     * @public
     */
    ThreadId?: string;
    /**
     * <p>The text of the comment.</p>
     * @public
     */
    Text: string | undefined;
    /**
     * <p>The visibility of the comment. Options are either PRIVATE, where the comment is
     *             visible only to the comment author and document owner and co-owners, or PUBLIC, where
     *             the comment is visible to document owners, co-owners, and contributors.</p>
     * @public
     */
    Visibility?: CommentVisibilityType;
    /**
     * <p>Set this parameter to TRUE to send an email out to the document collaborators after
     *             the comment is created.</p>
     * @public
     */
    NotifyCollaborators?: boolean;
}
/**
 * <p>Describes a comment.</p>
 * @public
 */
export interface Comment {
    /**
     * <p>The ID of the comment.</p>
     * @public
     */
    CommentId: string | undefined;
    /**
     * <p>The ID of the parent comment.</p>
     * @public
     */
    ParentId?: string;
    /**
     * <p>The ID of the root comment in the thread.</p>
     * @public
     */
    ThreadId?: string;
    /**
     * <p>The text of the comment.</p>
     * @public
     */
    Text?: string;
    /**
     * <p>The details of the user who made the comment.</p>
     * @public
     */
    Contributor?: User;
    /**
     * <p>The time that the comment was created.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The status of the comment.</p>
     * @public
     */
    Status?: CommentStatusType;
    /**
     * <p>The visibility of the comment. Options are either PRIVATE, where the comment is
     *             visible only to the comment author and document owner and co-owners, or PUBLIC, where
     *             the comment is visible to document owners, co-owners, and contributors.</p>
     * @public
     */
    Visibility?: CommentVisibilityType;
    /**
     * <p>If the comment is a reply to another user's comment, this field contains the user
     *             ID of the user being replied to.</p>
     * @public
     */
    RecipientId?: string;
}
/**
 * @public
 */
export interface CreateCommentResponse {
    /**
     * <p>The comment that has been created.</p>
     * @public
     */
    Comment?: Comment;
}
/**
 * <p>This exception is thrown when the document is locked for comments and user tries to
 *             create or delete a comment on that document.</p>
 * @public
 */
export declare class DocumentLockedForCommentsException extends __BaseException {
    readonly name: "DocumentLockedForCommentsException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DocumentLockedForCommentsException, __BaseException>);
}
/**
 * <p>The requested operation is not allowed on the specified comment object.</p>
 * @public
 */
export declare class InvalidCommentOperationException extends __BaseException {
    readonly name: "InvalidCommentOperationException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidCommentOperationException, __BaseException>);
}
/**
 * @public
 */
export interface CreateCustomMetadataRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>The ID of the version, if the custom metadata is being added to a document
     *             version.</p>
     * @public
     */
    VersionId?: string;
    /**
     * <p>Custom metadata in the form of name-value pairs.</p>
     * @public
     */
    CustomMetadata: Record<string, string> | undefined;
}
/**
 * @public
 */
export interface CreateCustomMetadataResponse {
}
/**
 * <p>The limit has been reached on the number of custom properties for the specified
 *             resource.</p>
 * @public
 */
export declare class CustomMetadataLimitExceededException extends __BaseException {
    readonly name: "CustomMetadataLimitExceededException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<CustomMetadataLimitExceededException, __BaseException>);
}
/**
 * <p>Another operation is in progress on the resource that conflicts with the current operation.</p>
 * @public
 */
export declare class ConflictingOperationException extends __BaseException {
    readonly name: "ConflictingOperationException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictingOperationException, __BaseException>);
}
/**
 * @public
 */
export interface CreateFolderRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The name of the new folder.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId: string | undefined;
}
/**
 * @public
 * @enum
 */
export declare const ResourceStateType: {
    readonly ACTIVE: "ACTIVE";
    readonly RECYCLED: "RECYCLED";
    readonly RECYCLING: "RECYCLING";
    readonly RESTORING: "RESTORING";
};
/**
 * @public
 */
export type ResourceStateType = (typeof ResourceStateType)[keyof typeof ResourceStateType];
/**
 * <p>Describes a folder.</p>
 * @public
 */
export interface FolderMetadata {
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the folder.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The ID of the creator.</p>
     * @public
     */
    CreatorId?: string;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId?: string;
    /**
     * <p>The time when the folder was created.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The time when the folder was updated.</p>
     * @public
     */
    ModifiedTimestamp?: Date;
    /**
     * <p>The resource state of the folder.</p>
     * @public
     */
    ResourceState?: ResourceStateType;
    /**
     * <p>The unique identifier created from the subfolders and documents of the
     *             folder.</p>
     * @public
     */
    Signature?: string;
    /**
     * <p>List of labels on the folder.</p>
     * @public
     */
    Labels?: string[];
    /**
     * <p>The size of the folder metadata.</p>
     * @public
     */
    Size?: number;
    /**
     * <p>The size of the latest version of the folder metadata.</p>
     * @public
     */
    LatestVersionSize?: number;
}
/**
 * @public
 */
export interface CreateFolderResponse {
    /**
     * <p>The metadata of the folder.</p>
     * @public
     */
    Metadata?: FolderMetadata;
}
/**
 * <p>The resource already exists.</p>
 * @public
 */
export declare class EntityAlreadyExistsException extends __BaseException {
    readonly name: "EntityAlreadyExistsException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<EntityAlreadyExistsException, __BaseException>);
}
/**
 * <p>The maximum of 100,000 files and folders under the parent folder has been exceeded.</p>
 * @public
 */
export declare class LimitExceededException extends __BaseException {
    readonly name: "LimitExceededException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<LimitExceededException, __BaseException>);
}
/**
 * @public
 */
export interface CreateLabelsRequest {
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>List of labels to add to the resource.</p>
     * @public
     */
    Labels: string[] | undefined;
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
}
/**
 * @public
 */
export interface CreateLabelsResponse {
}
/**
 * <p>The limit has been reached on the number of labels for the specified
 *             resource.</p>
 * @public
 */
export declare class TooManyLabelsException extends __BaseException {
    readonly name: "TooManyLabelsException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyLabelsException, __BaseException>);
}
/**
 * @public
 * @enum
 */
export declare const SubscriptionProtocolType: {
    readonly HTTPS: "HTTPS";
    readonly SQS: "SQS";
};
/**
 * @public
 */
export type SubscriptionProtocolType = (typeof SubscriptionProtocolType)[keyof typeof SubscriptionProtocolType];
/**
 * @public
 * @enum
 */
export declare const SubscriptionType: {
    readonly ALL: "ALL";
};
/**
 * @public
 */
export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType];
/**
 * @public
 */
export interface CreateNotificationSubscriptionRequest {
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId: string | undefined;
    /**
     * <p>The endpoint to receive the notifications. If the protocol is HTTPS, the endpoint
     *             is a URL that begins with <code>https</code>.</p>
     * @public
     */
    Endpoint: string | undefined;
    /**
     * <p>The protocol to use. The supported value is https, which delivers JSON-encoded
     *             messages using HTTPS POST.</p>
     * @public
     */
    Protocol: SubscriptionProtocolType | undefined;
    /**
     * <p>The notification type.</p>
     * @public
     */
    SubscriptionType: SubscriptionType | undefined;
}
/**
 * <p>Describes a subscription.</p>
 * @public
 */
export interface Subscription {
    /**
     * <p>The ID of the subscription.</p>
     * @public
     */
    SubscriptionId?: string;
    /**
     * <p>The endpoint of the subscription.</p>
     * @public
     */
    EndPoint?: string;
    /**
     * <p>The protocol of the subscription.</p>
     * @public
     */
    Protocol?: SubscriptionProtocolType;
}
/**
 * @public
 */
export interface CreateNotificationSubscriptionResponse {
    /**
     * <p>The subscription.</p>
     * @public
     */
    Subscription?: Subscription;
}
/**
 * <p>The pagination marker or limit fields are not valid.</p>
 * @public
 */
export declare class InvalidArgumentException extends __BaseException {
    readonly name: "InvalidArgumentException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidArgumentException, __BaseException>);
}
/**
 * <p>You've reached the limit on the number of subscriptions for the WorkDocs
 *             instance.</p>
 * @public
 */
export declare class TooManySubscriptionsException extends __BaseException {
    readonly name: "TooManySubscriptionsException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManySubscriptionsException, __BaseException>);
}
/**
 * @public
 */
export interface CreateUserRequest {
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>The login name of the user.</p>
     * @public
     */
    Username: string | undefined;
    /**
     * <p>The email address of the user.</p>
     * @public
     */
    EmailAddress?: string;
    /**
     * <p>The given name of the user.</p>
     * @public
     */
    GivenName: string | undefined;
    /**
     * <p>The surname of the user.</p>
     * @public
     */
    Surname: string | undefined;
    /**
     * <p>The password of the user.</p>
     * @public
     */
    Password: string | undefined;
    /**
     * <p>The time zone ID of the user.</p>
     * @public
     */
    TimeZoneId?: string;
    /**
     * <p>The amount of storage for the user.</p>
     * @public
     */
    StorageRule?: StorageRuleType;
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
}
/**
 * @public
 */
export interface CreateUserResponse {
    /**
     * <p>The user information.</p>
     * @public
     */
    User?: User;
}
/**
 * @public
 */
export interface DeactivateUserRequest {
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    UserId: string | undefined;
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
}
/**
 * @public
 */
export interface DeleteCommentRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The ID of the document version.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>The ID of the comment.</p>
     * @public
     */
    CommentId: string | undefined;
}
/**
 * @public
 */
export interface DeleteCustomMetadataRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource, either a document or folder.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>The ID of the version, if the custom metadata is being deleted from a document
     *             version.</p>
     * @public
     */
    VersionId?: string;
    /**
     * <p>List of properties to remove.</p>
     * @public
     */
    Keys?: string[];
    /**
     * <p>Flag to indicate removal of all custom metadata properties from the specified
     *             resource.</p>
     * @public
     */
    DeleteAll?: boolean;
}
/**
 * @public
 */
export interface DeleteCustomMetadataResponse {
}
/**
 * @public
 */
export interface DeleteDocumentRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
}
/**
 * @public
 */
export interface DeleteDocumentVersionRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document associated with the version being deleted.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The ID of the version being deleted.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>Deletes all versions of a document prior to the current version.</p>
     * @public
     */
    DeletePriorVersions: boolean | undefined;
}
/**
 * <p>The operation is invalid.</p>
 * @public
 */
export declare class InvalidOperationException extends __BaseException {
    readonly name: "InvalidOperationException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidOperationException, __BaseException>);
}
/**
 * @public
 */
export interface DeleteFolderRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
}
/**
 * @public
 */
export interface DeleteFolderContentsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
}
/**
 * @public
 */
export interface DeleteLabelsRequest {
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>List of labels to delete from the resource.</p>
     * @public
     */
    Labels?: string[];
    /**
     * <p>Flag to request removal of all labels from the specified resource.</p>
     * @public
     */
    DeleteAll?: boolean;
}
/**
 * @public
 */
export interface DeleteLabelsResponse {
}
/**
 * @public
 */
export interface DeleteNotificationSubscriptionRequest {
    /**
     * <p>The ID of the subscription.</p>
     * @public
     */
    SubscriptionId: string | undefined;
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId: string | undefined;
}
/**
 * @public
 */
export interface DeleteUserRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Do not set this field when using
     *             administrative API actions, as in accessing the API using Amazon Web Services credentials.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    UserId: string | undefined;
}
/**
 * @public
 */
export interface DescribeActivitiesRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The timestamp that determines the starting time of the activities. The response
     *             includes the activities performed after the specified timestamp.</p>
     * @public
     */
    StartTime?: Date;
    /**
     * <p>The timestamp that determines the end time of the activities. The response includes
     *             the activities performed before the specified timestamp.</p>
     * @public
     */
    EndTime?: Date;
    /**
     * <p>The ID of the organization. This is a mandatory parameter when using administrative
     *             API (SigV4) requests.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>Specifies which activity types to include in the response. If this field is left
     *             empty, all activity types are returned.</p>
     * @public
     */
    ActivityTypes?: string;
    /**
     * <p>The document or folder ID for which to describe activity types.</p>
     * @public
     */
    ResourceId?: string;
    /**
     * <p>The ID of the user who performed the action. The response includes activities
     *             pertaining to this user. This is an optional parameter and is only applicable for
     *             administrative API (SigV4) requests.</p>
     * @public
     */
    UserId?: string;
    /**
     * <p>Includes indirect activities. An indirect activity results from a direct activity
     *             performed on a parent resource. For example, sharing a parent folder (the direct
     *             activity) shares all of the subfolders and documents within the parent folder (the
     *             indirect activity).</p>
     * @public
     */
    IncludeIndirectActivities?: boolean;
    /**
     * <p>The maximum number of items to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeActivitiesResponse {
    /**
     * <p>The list of activities for the specified user and time period.</p>
     * @public
     */
    UserActivities?: Activity[];
    /**
     * <p>The marker for the next set of results.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeCommentsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The ID of the document version.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>The maximum number of items to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results. This marker was received from a previous
     *             call.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeCommentsResponse {
    /**
     * <p>The list of comments for the specified document version.</p>
     * @public
     */
    Comments?: Comment[];
    /**
     * <p>The marker for the next set of results. This marker was received from a previous
     *             call.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeDocumentVersionsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call.)</p>
     * @public
     */
    Marker?: string;
    /**
     * <p>The maximum number of versions to return with this call.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>A comma-separated list of values. Specify "INITIALIZED" to include incomplete
     *             versions.</p>
     * @public
     */
    Include?: string;
    /**
     * <p>Specify "SOURCE" to include initialized versions and a URL for the source
     *             document.</p>
     * @public
     */
    Fields?: string;
}
/**
 * @public
 * @enum
 */
export declare const DocumentSourceType: {
    readonly ORIGINAL: "ORIGINAL";
    readonly WITH_COMMENTS: "WITH_COMMENTS";
};
/**
 * @public
 */
export type DocumentSourceType = (typeof DocumentSourceType)[keyof typeof DocumentSourceType];
/**
 * @public
 * @enum
 */
export declare const DocumentStatusType: {
    readonly ACTIVE: "ACTIVE";
    readonly INITIALIZED: "INITIALIZED";
};
/**
 * @public
 */
export type DocumentStatusType = (typeof DocumentStatusType)[keyof typeof DocumentStatusType];
/**
 * @public
 * @enum
 */
export declare const DocumentThumbnailType: {
    readonly LARGE: "LARGE";
    readonly SMALL: "SMALL";
    readonly SMALL_HQ: "SMALL_HQ";
};
/**
 * @public
 */
export type DocumentThumbnailType = (typeof DocumentThumbnailType)[keyof typeof DocumentThumbnailType];
/**
 * <p>Describes a version of a document.</p>
 * @public
 */
export interface DocumentVersionMetadata {
    /**
     * <p>The ID of the version.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the version.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The content type of the document.</p>
     * @public
     */
    ContentType?: string;
    /**
     * <p>The size of the document, in bytes.</p>
     * @public
     */
    Size?: number;
    /**
     * <p>The signature of the document.</p>
     * @public
     */
    Signature?: string;
    /**
     * <p>The status of the document.</p>
     * @public
     */
    Status?: DocumentStatusType;
    /**
     * <p>The timestamp when the document was first uploaded.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The timestamp when the document was last uploaded.</p>
     * @public
     */
    ModifiedTimestamp?: Date;
    /**
     * <p>The timestamp when the content of the document was originally created.</p>
     * @public
     */
    ContentCreatedTimestamp?: Date;
    /**
     * <p>The timestamp when the content of the document was modified.</p>
     * @public
     */
    ContentModifiedTimestamp?: Date;
    /**
     * <p>The ID of the creator.</p>
     * @public
     */
    CreatorId?: string;
    /**
     * <p>The thumbnail of the document.</p>
     * @public
     */
    Thumbnail?: Partial<Record<DocumentThumbnailType, string>>;
    /**
     * <p>The source of the document.</p>
     * @public
     */
    Source?: Partial<Record<DocumentSourceType, string>>;
}
/**
 * @public
 */
export interface DescribeDocumentVersionsResponse {
    /**
     * <p>The document versions.</p>
     * @public
     */
    DocumentVersions?: DocumentVersionMetadata[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no
     *             additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * <p>The password is invalid.</p>
 * @public
 */
export declare class InvalidPasswordException extends __BaseException {
    readonly name: "InvalidPasswordException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidPasswordException, __BaseException>);
}
/**
 * @public
 * @enum
 */
export declare const OrderType: {
    readonly ASCENDING: "ASCENDING";
    readonly DESCENDING: "DESCENDING";
};
/**
 * @public
 */
export type OrderType = (typeof OrderType)[keyof typeof OrderType];
/**
 * @public
 * @enum
 */
export declare const ResourceSortType: {
    readonly DATE: "DATE";
    readonly NAME: "NAME";
};
/**
 * @public
 */
export type ResourceSortType = (typeof ResourceSortType)[keyof typeof ResourceSortType];
/**
 * @public
 * @enum
 */
export declare const FolderContentType: {
    readonly ALL: "ALL";
    readonly DOCUMENT: "DOCUMENT";
    readonly FOLDER: "FOLDER";
};
/**
 * @public
 */
export type FolderContentType = (typeof FolderContentType)[keyof typeof FolderContentType];
/**
 * @public
 */
export interface DescribeFolderContentsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
    /**
     * <p>The sorting criteria.</p>
     * @public
     */
    Sort?: ResourceSortType;
    /**
     * <p>The order for the contents of the folder.</p>
     * @public
     */
    Order?: OrderType;
    /**
     * <p>The maximum number of items to return with this call.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results. This marker was received from a previous
     *             call.</p>
     * @public
     */
    Marker?: string;
    /**
     * <p>The type of items.</p>
     * @public
     */
    Type?: FolderContentType;
    /**
     * <p>The contents to include. Specify "INITIALIZED" to include initialized
     *             documents.</p>
     * @public
     */
    Include?: string;
}
/**
 * <p>Describes the document.</p>
 * @public
 */
export interface DocumentMetadata {
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The ID of the creator.</p>
     * @public
     */
    CreatorId?: string;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId?: string;
    /**
     * <p>The time when the document was created.</p>
     * @public
     */
    CreatedTimestamp?: Date;
    /**
     * <p>The time when the document was updated.</p>
     * @public
     */
    ModifiedTimestamp?: Date;
    /**
     * <p>The latest version of the document.</p>
     * @public
     */
    LatestVersionMetadata?: DocumentVersionMetadata;
    /**
     * <p>The resource state.</p>
     * @public
     */
    ResourceState?: ResourceStateType;
    /**
     * <p>List of labels on the document.</p>
     * @public
     */
    Labels?: string[];
}
/**
 * @public
 */
export interface DescribeFolderContentsResponse {
    /**
     * <p>The subfolders in the specified folder.</p>
     * @public
     */
    Folders?: FolderMetadata[];
    /**
     * <p>The documents in the specified folder.</p>
     * @public
     */
    Documents?: DocumentMetadata[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no
     *             additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeGroupsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>A query to describe groups by group name.</p>
     * @public
     */
    SearchQuery: string | undefined;
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call.)</p>
     * @public
     */
    Marker?: string;
    /**
     * <p>The maximum number of items to return with this call.</p>
     * @public
     */
    Limit?: number;
}
/**
 * @public
 */
export interface DescribeGroupsResponse {
    /**
     * <p>The list of groups.</p>
     * @public
     */
    Groups?: GroupMetadata[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no additional
     *             results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeNotificationSubscriptionsRequest {
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId: string | undefined;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call.)</p>
     * @public
     */
    Marker?: string;
    /**
     * <p>The maximum number of items to return with this call.</p>
     * @public
     */
    Limit?: number;
}
/**
 * @public
 */
export interface DescribeNotificationSubscriptionsResponse {
    /**
     * <p>The subscriptions.</p>
     * @public
     */
    Subscriptions?: Subscription[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no
     *             additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeResourcePermissionsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>The ID of the principal to filter permissions by.</p>
     * @public
     */
    PrincipalId?: string;
    /**
     * <p>The maximum number of items to return with this call.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call)</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 * @enum
 */
export declare const RolePermissionType: {
    readonly DIRECT: "DIRECT";
    readonly INHERITED: "INHERITED";
};
/**
 * @public
 */
export type RolePermissionType = (typeof RolePermissionType)[keyof typeof RolePermissionType];
/**
 * <p>Describes the permissions.</p>
 * @public
 */
export interface PermissionInfo {
    /**
     * <p>The role of the user.</p>
     * @public
     */
    Role?: RoleType;
    /**
     * <p>The type of permissions.</p>
     * @public
     */
    Type?: RolePermissionType;
}
/**
 * <p>Describes a resource.</p>
 * @public
 */
export interface Principal {
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The type of resource.</p>
     * @public
     */
    Type?: PrincipalType;
    /**
     * <p>The permission information for the resource.</p>
     * @public
     */
    Roles?: PermissionInfo[];
}
/**
 * @public
 */
export interface DescribeResourcePermissionsResponse {
    /**
     * <p>The principals.</p>
     * @public
     */
    Principals?: Principal[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no
     *             additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeRootFoldersRequest {
    /**
     * <p>Amazon WorkDocs authentication token.</p>
     * @public
     */
    AuthenticationToken: string | undefined;
    /**
     * <p>The maximum number of items to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call.)</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface DescribeRootFoldersResponse {
    /**
     * <p>The user's special folders.</p>
     * @public
     */
    Folders?: FolderMetadata[];
    /**
     * <p>The marker for the next set of results.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 * @enum
 */
export declare const UserFilterType: {
    readonly ACTIVE_PENDING: "ACTIVE_PENDING";
    readonly ALL: "ALL";
};
/**
 * @public
 */
export type UserFilterType = (typeof UserFilterType)[keyof typeof UserFilterType];
/**
 * @public
 * @enum
 */
export declare const UserSortType: {
    readonly FULL_NAME: "FULL_NAME";
    readonly STORAGE_LIMIT: "STORAGE_LIMIT";
    readonly STORAGE_USED: "STORAGE_USED";
    readonly USER_NAME: "USER_NAME";
    readonly USER_STATUS: "USER_STATUS";
};
/**
 * @public
 */
export type UserSortType = (typeof UserSortType)[keyof typeof UserSortType];
/**
 * @public
 */
export interface DescribeUsersRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the organization.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>The IDs of the users.</p>
     * @public
     */
    UserIds?: string;
    /**
     * <p>A query to filter users by user name. Remember the following about the <code>Userids</code> and <code>Query</code> parameters:</p>
     *          <ul>
     *             <li>
     *                <p>If you don't use either parameter, the API returns a paginated list of all users on the site.</p>
     *             </li>
     *             <li>
     *                <p>If you use both parameters, the API ignores the <code>Query</code> parameter.</p>
     *             </li>
     *             <li>
     *                <p>The <code>Userid</code> parameter only returns user names that match a corresponding user ID.</p>
     *             </li>
     *             <li>
     *                <p>The <code>Query</code> parameter runs a "prefix" search for users by the <code>GivenName</code>, <code>SurName</code>, or <code>UserName</code> fields included in a
     *                 <a href="https://docs.aws.amazon.com/workdocs/latest/APIReference/API_CreateUser.html">CreateUser</a> API call. For example, querying on
     *                 <code>Ma</code> returns Márcia Oliveira, María García, and Mateo Jackson. If you use multiple characters, the API only returns data that matches all characters. For example, querying on <code>Ma J</code> only
     *                 returns Mateo Jackson.</p>
     *             </li>
     *          </ul>
     * @public
     */
    Query?: string;
    /**
     * <p>The state of the users. Specify "ALL" to include inactive users.</p>
     * @public
     */
    Include?: UserFilterType;
    /**
     * <p>The order for the results.</p>
     * @public
     */
    Order?: OrderType;
    /**
     * <p>The sorting criteria.</p>
     * @public
     */
    Sort?: UserSortType;
    /**
     * <p>The marker for the next set of results. (You received this marker from a previous
     *             call.)</p>
     * @public
     */
    Marker?: string;
    /**
     * <p>The maximum number of items to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>A comma-separated list of values. Specify "STORAGE_METADATA" to include the user
     *             storage quota and utilization information.</p>
     * @public
     */
    Fields?: string;
}
/**
 * @public
 */
export interface DescribeUsersResponse {
    /**
     * <p>The users.</p>
     * @public
     */
    Users?: User[];
    /**
     * @deprecated
     *
     * <p>The total number of users included in the results.</p>
     * @public
     */
    TotalNumberOfUsers?: number;
    /**
     * <p>The marker to use when requesting the next set of results. If there are no
     *             additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * <p>The response is too large to return. The request must include a filter to reduce the size of the response.</p>
 * @public
 */
export declare class RequestedEntityTooLargeException extends __BaseException {
    readonly name: "RequestedEntityTooLargeException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<RequestedEntityTooLargeException, __BaseException>);
}
/**
 * @public
 */
export interface GetCurrentUserRequest {
    /**
     * <p>Amazon WorkDocs authentication token.</p>
     * @public
     */
    AuthenticationToken: string | undefined;
}
/**
 * @public
 */
export interface GetCurrentUserResponse {
    /**
     * <p>Metadata of the user.</p>
     * @public
     */
    User?: User;
}
/**
 * @public
 */
export interface GetDocumentRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>Set this to <code>TRUE</code> to include custom metadata in the response.</p>
     * @public
     */
    IncludeCustomMetadata?: boolean;
}
/**
 * @public
 */
export interface GetDocumentResponse {
    /**
     * <p>The metadata details of the document.</p>
     * @public
     */
    Metadata?: DocumentMetadata;
    /**
     * <p>The custom metadata on the document.</p>
     * @public
     */
    CustomMetadata?: Record<string, string>;
}
/**
 * @public
 */
export interface GetDocumentPathRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The maximum number of levels in the hierarchy to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>A comma-separated list of values. Specify <code>NAME</code> to include the names of
     *             the parent folders.</p>
     * @public
     */
    Fields?: string;
    /**
     * <p>This value is not supported.</p>
     * @public
     */
    Marker?: string;
}
/**
 * <p>Describes the resource path.</p>
 * @public
 */
export interface ResourcePathComponent {
    /**
     * <p>The ID of the resource path.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the resource path.</p>
     * @public
     */
    Name?: string;
}
/**
 * <p>Describes the path information of a resource.</p>
 * @public
 */
export interface ResourcePath {
    /**
     * <p>The components of the resource path.</p>
     * @public
     */
    Components?: ResourcePathComponent[];
}
/**
 * @public
 */
export interface GetDocumentPathResponse {
    /**
     * <p>The path information.</p>
     * @public
     */
    Path?: ResourcePath;
}
/**
 * @public
 */
export interface GetDocumentVersionRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The version ID of the document.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>A comma-separated list of values. Specify "SOURCE" to include a URL for the source
     *             document.</p>
     * @public
     */
    Fields?: string;
    /**
     * <p>Set this to TRUE to include custom metadata in the response.</p>
     * @public
     */
    IncludeCustomMetadata?: boolean;
}
/**
 * @public
 */
export interface GetDocumentVersionResponse {
    /**
     * <p>The version metadata.</p>
     * @public
     */
    Metadata?: DocumentVersionMetadata;
    /**
     * <p>The custom metadata on the document version.</p>
     * @public
     */
    CustomMetadata?: Record<string, string>;
}
/**
 * @public
 */
export interface GetFolderRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
    /**
     * <p>Set to TRUE to include custom metadata in the response.</p>
     * @public
     */
    IncludeCustomMetadata?: boolean;
}
/**
 * @public
 */
export interface GetFolderResponse {
    /**
     * <p>The metadata of the folder.</p>
     * @public
     */
    Metadata?: FolderMetadata;
    /**
     * <p>The custom metadata on the folder.</p>
     * @public
     */
    CustomMetadata?: Record<string, string>;
}
/**
 * @public
 */
export interface GetFolderPathRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
    /**
     * <p>The maximum number of levels in the hierarchy to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>A comma-separated list of values. Specify "NAME" to include the names of the parent
     *             folders.</p>
     * @public
     */
    Fields?: string;
    /**
     * <p>This value is not supported.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface GetFolderPathResponse {
    /**
     * <p>The path information.</p>
     * @public
     */
    Path?: ResourcePath;
}
/**
 * @public
 * @enum
 */
export declare const ResourceCollectionType: {
    readonly SHARED_WITH_ME: "SHARED_WITH_ME";
};
/**
 * @public
 */
export type ResourceCollectionType = (typeof ResourceCollectionType)[keyof typeof ResourceCollectionType];
/**
 * @public
 */
export interface GetResourcesRequest {
    /**
     * <p>The Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The user ID for the resource collection. This is a required field for accessing the
     *             API operation using IAM credentials.</p>
     * @public
     */
    UserId?: string;
    /**
     * <p>The collection type.</p>
     * @public
     */
    CollectionType?: ResourceCollectionType;
    /**
     * <p>The maximum number of resources to return.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results. This marker was received from a previous call.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface GetResourcesResponse {
    /**
     * <p>The folders in the specified folder.</p>
     * @public
     */
    Folders?: FolderMetadata[];
    /**
     * <p>The documents in the specified collection.</p>
     * @public
     */
    Documents?: DocumentMetadata[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * <p>This exception is thrown when a valid checkout ID is not presented on document
 *             version upload calls for a document that has been checked out from Web client.</p>
 * @public
 */
export declare class DraftUploadOutOfSyncException extends __BaseException {
    readonly name: "DraftUploadOutOfSyncException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DraftUploadOutOfSyncException, __BaseException>);
}
/**
 * @public
 */
export interface InitiateDocumentVersionUploadRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    Id?: string;
    /**
     * <p>The name of the document.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The timestamp when the content of the document was originally created.</p>
     * @public
     */
    ContentCreatedTimestamp?: Date;
    /**
     * <p>The timestamp when the content of the document was modified.</p>
     * @public
     */
    ContentModifiedTimestamp?: Date;
    /**
     * <p>The content type of the document.</p>
     * @public
     */
    ContentType?: string;
    /**
     * <p>The size of the document, in bytes.</p>
     * @public
     */
    DocumentSizeInBytes?: number;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId?: string;
}
/**
 * <p>Describes the upload.</p>
 * @public
 */
export interface UploadMetadata {
    /**
     * <p>The URL of the upload.</p>
     * @public
     */
    UploadUrl?: string;
    /**
     * <p>The signed headers.</p>
     * @public
     */
    SignedHeaders?: Record<string, string>;
}
/**
 * @public
 */
export interface InitiateDocumentVersionUploadResponse {
    /**
     * <p>The document metadata.</p>
     * @public
     */
    Metadata?: DocumentMetadata;
    /**
     * <p>The upload metadata.</p>
     * @public
     */
    UploadMetadata?: UploadMetadata;
}
/**
 * <p>The resource is already checked out.</p>
 * @public
 */
export declare class ResourceAlreadyCheckedOutException extends __BaseException {
    readonly name: "ResourceAlreadyCheckedOutException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ResourceAlreadyCheckedOutException, __BaseException>);
}
/**
 * <p>The storage limit has been exceeded.</p>
 * @public
 */
export declare class StorageLimitExceededException extends __BaseException {
    readonly name: "StorageLimitExceededException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<StorageLimitExceededException, __BaseException>);
}
/**
 * <p>The storage limit will be exceeded.</p>
 * @public
 */
export declare class StorageLimitWillExceedException extends __BaseException {
    readonly name: "StorageLimitWillExceedException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<StorageLimitWillExceedException, __BaseException>);
}
/**
 * @public
 */
export interface RemoveAllResourcePermissionsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
}
/**
 * @public
 */
export interface RemoveResourcePermissionRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the resource.</p>
     * @public
     */
    ResourceId: string | undefined;
    /**
     * <p>The principal ID of the resource.</p>
     * @public
     */
    PrincipalId: string | undefined;
    /**
     * <p>The principal type of the resource.</p>
     * @public
     */
    PrincipalType?: PrincipalType;
}
/**
 * @public
 */
export interface RestoreDocumentVersionsRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
}
/**
 * @public
 * @enum
 */
export declare const ContentCategoryType: {
    readonly AUDIO: "AUDIO";
    readonly DOCUMENT: "DOCUMENT";
    readonly IMAGE: "IMAGE";
    readonly OTHER: "OTHER";
    readonly PDF: "PDF";
    readonly PRESENTATION: "PRESENTATION";
    readonly SOURCE_CODE: "SOURCE_CODE";
    readonly SPREADSHEET: "SPREADSHEET";
    readonly VIDEO: "VIDEO";
};
/**
 * @public
 */
export type ContentCategoryType = (typeof ContentCategoryType)[keyof typeof ContentCategoryType];
/**
 * <p>Filters results based on timestamp range (in epochs).</p>
 * @public
 */
export interface DateRangeType {
    /**
     * <p>Timestamp range start value (in epochs)</p>
     * @public
     */
    StartValue?: Date;
    /**
     * <p>Timestamp range end value (in epochs).</p>
     * @public
     */
    EndValue?: Date;
}
/**
 * @public
 * @enum
 */
export declare const PrincipalRoleType: {
    readonly CONTRIBUTOR: "CONTRIBUTOR";
    readonly COOWNER: "COOWNER";
    readonly OWNER: "OWNER";
    readonly VIEWER: "VIEWER";
};
/**
 * @public
 */
export type PrincipalRoleType = (typeof PrincipalRoleType)[keyof typeof PrincipalRoleType];
/**
 * <p>Filter based on UserIds or GroupIds.</p>
 * @public
 */
export interface SearchPrincipalType {
    /**
     * <p>UserIds or GroupIds.</p>
     * @public
     */
    Id: string | undefined;
    /**
     * <p>The Role of a User or Group.</p>
     * @public
     */
    Roles?: PrincipalRoleType[];
}
/**
 * @public
 * @enum
 */
export declare const SearchResourceType: {
    readonly COMMENT: "COMMENT";
    readonly DOCUMENT: "DOCUMENT";
    readonly DOCUMENT_VERSION: "DOCUMENT_VERSION";
    readonly FOLDER: "FOLDER";
};
/**
 * @public
 */
export type SearchResourceType = (typeof SearchResourceType)[keyof typeof SearchResourceType];
/**
 * @public
 * @enum
 */
export declare const SearchCollectionType: {
    readonly OWNED: "OWNED";
    readonly SHARED_WITH_ME: "SHARED_WITH_ME";
};
/**
 * @public
 */
export type SearchCollectionType = (typeof SearchCollectionType)[keyof typeof SearchCollectionType];
/**
 * <p>Filter based on size (in bytes).</p>
 * @public
 */
export interface LongRangeType {
    /**
     * <p>The size start range (in bytes).</p>
     * @public
     */
    StartValue?: number;
    /**
     * <p>The size end range (in bytes).</p>
     * @public
     */
    EndValue?: number;
}
/**
 * @public
 * @enum
 */
export declare const LanguageCodeType: {
    readonly AR: "AR";
    readonly BG: "BG";
    readonly BN: "BN";
    readonly CS: "CS";
    readonly DA: "DA";
    readonly DE: "DE";
    readonly DEFAULT: "DEFAULT";
    readonly EL: "EL";
    readonly EN: "EN";
    readonly ES: "ES";
    readonly FA: "FA";
    readonly FI: "FI";
    readonly FR: "FR";
    readonly HI: "HI";
    readonly HU: "HU";
    readonly ID: "ID";
    readonly IT: "IT";
    readonly JA: "JA";
    readonly KO: "KO";
    readonly LT: "LT";
    readonly LV: "LV";
    readonly NL: "NL";
    readonly NO: "NO";
    readonly PT: "PT";
    readonly RO: "RO";
    readonly RU: "RU";
    readonly SV: "SV";
    readonly SW: "SW";
    readonly TH: "TH";
    readonly TR: "TR";
    readonly ZH: "ZH";
};
/**
 * @public
 */
export type LanguageCodeType = (typeof LanguageCodeType)[keyof typeof LanguageCodeType];
/**
 * <p>Filters results based on entity metadata.</p>
 * @public
 */
export interface Filters {
    /**
     * <p>Filters by the locale of the content or comment.</p>
     * @public
     */
    TextLocales?: LanguageCodeType[];
    /**
     * <p>Filters by content category.</p>
     * @public
     */
    ContentCategories?: ContentCategoryType[];
    /**
     * <p>Filters based on entity type.</p>
     * @public
     */
    ResourceTypes?: SearchResourceType[];
    /**
     * <p>Filter by labels using exact match.</p>
     * @public
     */
    Labels?: string[];
    /**
     * <p>Filter based on UserIds or GroupIds.</p>
     * @public
     */
    Principals?: SearchPrincipalType[];
    /**
     * <p>Filter based on resource’s path.</p>
     * @public
     */
    AncestorIds?: string[];
    /**
     * <p>Filter based on file groupings.</p>
     * @public
     */
    SearchCollectionTypes?: SearchCollectionType[];
    /**
     * <p>Filter based on size (in bytes).</p>
     * @public
     */
    SizeRange?: LongRangeType;
    /**
     * <p>Filter based on resource’s creation timestamp.</p>
     * @public
     */
    CreatedRange?: DateRangeType;
    /**
     * <p>Filter based on resource’s modified timestamp.</p>
     * @public
     */
    ModifiedRange?: DateRangeType;
}
/**
 * @public
 * @enum
 */
export declare const OrderByFieldType: {
    readonly CREATED_TIMESTAMP: "CREATED_TIMESTAMP";
    readonly MODIFIED_TIMESTAMP: "MODIFIED_TIMESTAMP";
    readonly NAME: "NAME";
    readonly RELEVANCE: "RELEVANCE";
    readonly SIZE: "SIZE";
};
/**
 * @public
 */
export type OrderByFieldType = (typeof OrderByFieldType)[keyof typeof OrderByFieldType];
/**
 * @public
 * @enum
 */
export declare const SortOrder: {
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * @public
 */
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
/**
 * <p>The result of the sort operation.</p>
 * @public
 */
export interface SearchSortResult {
    /**
     * <p>Sort search results based on this field name.</p>
     * @public
     */
    Field?: OrderByFieldType;
    /**
     * <p>Sort direction.</p>
     * @public
     */
    Order?: SortOrder;
}
/**
 * @public
 * @enum
 */
export declare const SearchQueryScopeType: {
    readonly CONTENT: "CONTENT";
    readonly NAME: "NAME";
};
/**
 * @public
 */
export type SearchQueryScopeType = (typeof SearchQueryScopeType)[keyof typeof SearchQueryScopeType];
/**
 * @public
 */
export interface SearchResourcesRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The String to search for. Searches across different text fields based on request parameters. Use double quotes around the query string for exact phrase matches.</p>
     * @public
     */
    QueryText?: string;
    /**
     * <p>Filter based on the text field type. A Folder has only a name and no content. A Comment has only content and no name. A Document or Document Version has a name and content</p>
     * @public
     */
    QueryScopes?: SearchQueryScopeType[];
    /**
     * <p>Filters based on the resource owner OrgId. This is a mandatory parameter when using Admin SigV4 credentials.</p>
     * @public
     */
    OrganizationId?: string;
    /**
     * <p>A list of attributes to include in the response. Used to request fields that are not normally
     *             returned in a standard response.</p>
     * @public
     */
    AdditionalResponseFields?: AdditionalResponseFieldType[];
    /**
     * <p>Filters results based on entity metadata.</p>
     * @public
     */
    Filters?: Filters;
    /**
     * <p>Order by results in one or more categories.</p>
     * @public
     */
    OrderBy?: SearchSortResult[];
    /**
     * <p>Max results count per page.</p>
     * @public
     */
    Limit?: number;
    /**
     * <p>The marker for the next set of results.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 * @enum
 */
export declare const ResponseItemType: {
    readonly COMMENT: "COMMENT";
    readonly DOCUMENT: "DOCUMENT";
    readonly DOCUMENT_VERSION: "DOCUMENT_VERSION";
    readonly FOLDER: "FOLDER";
};
/**
 * @public
 */
export type ResponseItemType = (typeof ResponseItemType)[keyof typeof ResponseItemType];
/**
 * <p>List of Documents, Folders, Comments, and Document Versions matching the query.</p>
 * @public
 */
export interface ResponseItem {
    /**
     * <p>The type of item being returned.</p>
     * @public
     */
    ResourceType?: ResponseItemType;
    /**
     * <p>The webUrl of the item being returned.</p>
     * @public
     */
    WebUrl?: string;
    /**
     * <p>The document that matches the query.</p>
     * @public
     */
    DocumentMetadata?: DocumentMetadata;
    /**
     * <p>The folder that matches the query.</p>
     * @public
     */
    FolderMetadata?: FolderMetadata;
    /**
     * <p>The comment that matches the query.</p>
     * @public
     */
    CommentMetadata?: CommentMetadata;
    /**
     * <p>The document version that matches the metadata.</p>
     * @public
     */
    DocumentVersionMetadata?: DocumentVersionMetadata;
}
/**
 * @public
 */
export interface SearchResourcesResponse {
    /**
     * <p>List of Documents, Folders, Comments, and Document Versions matching the query.</p>
     * @public
     */
    Items?: ResponseItem[];
    /**
     * <p>The marker to use when requesting the next set of results. If there are no additional results, the string is empty.</p>
     * @public
     */
    Marker?: string;
}
/**
 * @public
 */
export interface UpdateDocumentRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The name of the document.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId?: string;
    /**
     * <p>The resource state of the document. Only ACTIVE and RECYCLED are
     *             supported.</p>
     * @public
     */
    ResourceState?: ResourceStateType;
}
/**
 * @public
 * @enum
 */
export declare const DocumentVersionStatus: {
    readonly ACTIVE: "ACTIVE";
};
/**
 * @public
 */
export type DocumentVersionStatus = (typeof DocumentVersionStatus)[keyof typeof DocumentVersionStatus];
/**
 * @public
 */
export interface UpdateDocumentVersionRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the document.</p>
     * @public
     */
    DocumentId: string | undefined;
    /**
     * <p>The version ID of the document.</p>
     * @public
     */
    VersionId: string | undefined;
    /**
     * <p>The status of the version.</p>
     * @public
     */
    VersionStatus?: DocumentVersionStatus;
}
/**
 * @public
 */
export interface UpdateFolderRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the folder.</p>
     * @public
     */
    FolderId: string | undefined;
    /**
     * <p>The name of the folder.</p>
     * @public
     */
    Name?: string;
    /**
     * <p>The ID of the parent folder.</p>
     * @public
     */
    ParentFolderId?: string;
    /**
     * <p>The resource state of the folder. Only ACTIVE and RECYCLED are accepted values from
     *             the API.</p>
     * @public
     */
    ResourceState?: ResourceStateType;
}
/**
 * <p>The last user in the organization is being deactivated.</p>
 * @public
 */
export declare class DeactivatingLastSystemUserException extends __BaseException {
    readonly name: "DeactivatingLastSystemUserException";
    readonly $fault: "client";
    Message?: string;
    Code?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DeactivatingLastSystemUserException, __BaseException>);
}
/**
 * <p>The user is undergoing transfer of ownership.</p>
 * @public
 */
export declare class IllegalUserStateException extends __BaseException {
    readonly name: "IllegalUserStateException";
    readonly $fault: "client";
    Message?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<IllegalUserStateException, __BaseException>);
}
/**
 * @public
 * @enum
 */
export declare const BooleanEnumType: {
    readonly FALSE: "FALSE";
    readonly TRUE: "TRUE";
};
/**
 * @public
 */
export type BooleanEnumType = (typeof BooleanEnumType)[keyof typeof BooleanEnumType];
/**
 * @public
 */
export interface UpdateUserRequest {
    /**
     * <p>Amazon WorkDocs authentication token. Not required when using Amazon Web Services administrator credentials to access the API.</p>
     * @public
     */
    AuthenticationToken?: string;
    /**
     * <p>The ID of the user.</p>
     * @public
     */
    UserId: string | undefined;
    /**
     * <p>The given name of the user.</p>
     * @public
     */
    GivenName?: string;
    /**
     * <p>The surname of the user.</p>
     * @public
     */
    Surname?: string;
    /**
     * <p>The type of the user.</p>
     * @public
     */
    Type?: UserType;
    /**
     * <p>The amount of storage for the user.</p>
     * @public
     */
    StorageRule?: StorageRuleType;
    /**
     * <p>The time zone ID of the user.</p>
     * @public
     */
    TimeZoneId?: string;
    /**
     * <p>The locale of the user.</p>
     * @public
     */
    Locale?: LocaleType;
    /**
     * <p>Boolean value to determine whether the user is granted Power user privileges.</p>
     * @public
     */
    GrantPoweruserPrivileges?: BooleanEnumType;
}
/**
 * @public
 */
export interface UpdateUserResponse {
    /**
     * <p>The user information.</p>
     * @public
     */
    User?: User;
}
/**
 * @internal
 */
export declare const AbortDocumentVersionUploadRequestFilterSensitiveLog: (obj: AbortDocumentVersionUploadRequest) => any;
/**
 * @internal
 */
export declare const ActivateUserRequestFilterSensitiveLog: (obj: ActivateUserRequest) => any;
/**
 * @internal
 */
export declare const UserFilterSensitiveLog: (obj: User) => any;
/**
 * @internal
 */
export declare const ActivateUserResponseFilterSensitiveLog: (obj: ActivateUserResponse) => any;
/**
 * @internal
 */
export declare const CommentMetadataFilterSensitiveLog: (obj: CommentMetadata) => any;
/**
 * @internal
 */
export declare const UserMetadataFilterSensitiveLog: (obj: UserMetadata) => any;
/**
 * @internal
 */
export declare const ResourceMetadataFilterSensitiveLog: (obj: ResourceMetadata) => any;
/**
 * @internal
 */
export declare const ParticipantsFilterSensitiveLog: (obj: Participants) => any;
/**
 * @internal
 */
export declare const ActivityFilterSensitiveLog: (obj: Activity) => any;
/**
 * @internal
 */
export declare const NotificationOptionsFilterSensitiveLog: (obj: NotificationOptions) => any;
/**
 * @internal
 */
export declare const AddResourcePermissionsRequestFilterSensitiveLog: (obj: AddResourcePermissionsRequest) => any;
/**
 * @internal
 */
export declare const ShareResultFilterSensitiveLog: (obj: ShareResult) => any;
/**
 * @internal
 */
export declare const AddResourcePermissionsResponseFilterSensitiveLog: (obj: AddResourcePermissionsResponse) => any;
/**
 * @internal
 */
export declare const CreateCommentRequestFilterSensitiveLog: (obj: CreateCommentRequest) => any;
/**
 * @internal
 */
export declare const CommentFilterSensitiveLog: (obj: Comment) => any;
/**
 * @internal
 */
export declare const CreateCommentResponseFilterSensitiveLog: (obj: CreateCommentResponse) => any;
/**
 * @internal
 */
export declare const CreateCustomMetadataRequestFilterSensitiveLog: (obj: CreateCustomMetadataRequest) => any;
/**
 * @internal
 */
export declare const CreateFolderRequestFilterSensitiveLog: (obj: CreateFolderRequest) => any;
/**
 * @internal
 */
export declare const FolderMetadataFilterSensitiveLog: (obj: FolderMetadata) => any;
/**
 * @internal
 */
export declare const CreateFolderResponseFilterSensitiveLog: (obj: CreateFolderResponse) => any;
/**
 * @internal
 */
export declare const CreateLabelsRequestFilterSensitiveLog: (obj: CreateLabelsRequest) => any;
/**
 * @internal
 */
export declare const CreateUserRequestFilterSensitiveLog: (obj: CreateUserRequest) => any;
/**
 * @internal
 */
export declare const CreateUserResponseFilterSensitiveLog: (obj: CreateUserResponse) => any;
/**
 * @internal
 */
export declare const DeactivateUserRequestFilterSensitiveLog: (obj: DeactivateUserRequest) => any;
/**
 * @internal
 */
export declare const DeleteCommentRequestFilterSensitiveLog: (obj: DeleteCommentRequest) => any;
/**
 * @internal
 */
export declare const DeleteCustomMetadataRequestFilterSensitiveLog: (obj: DeleteCustomMetadataRequest) => any;
/**
 * @internal
 */
export declare const DeleteDocumentRequestFilterSensitiveLog: (obj: DeleteDocumentRequest) => any;
/**
 * @internal
 */
export declare const DeleteDocumentVersionRequestFilterSensitiveLog: (obj: DeleteDocumentVersionRequest) => any;
/**
 * @internal
 */
export declare const DeleteFolderRequestFilterSensitiveLog: (obj: DeleteFolderRequest) => any;
/**
 * @internal
 */
export declare const DeleteFolderContentsRequestFilterSensitiveLog: (obj: DeleteFolderContentsRequest) => any;
/**
 * @internal
 */
export declare const DeleteLabelsRequestFilterSensitiveLog: (obj: DeleteLabelsRequest) => any;
/**
 * @internal
 */
export declare const DeleteUserRequestFilterSensitiveLog: (obj: DeleteUserRequest) => any;
/**
 * @internal
 */
export declare const DescribeActivitiesRequestFilterSensitiveLog: (obj: DescribeActivitiesRequest) => any;
/**
 * @internal
 */
export declare const DescribeActivitiesResponseFilterSensitiveLog: (obj: DescribeActivitiesResponse) => any;
/**
 * @internal
 */
export declare const DescribeCommentsRequestFilterSensitiveLog: (obj: DescribeCommentsRequest) => any;
/**
 * @internal
 */
export declare const DescribeCommentsResponseFilterSensitiveLog: (obj: DescribeCommentsResponse) => any;
/**
 * @internal
 */
export declare const DescribeDocumentVersionsRequestFilterSensitiveLog: (obj: DescribeDocumentVersionsRequest) => any;
/**
 * @internal
 */
export declare const DocumentVersionMetadataFilterSensitiveLog: (obj: DocumentVersionMetadata) => any;
/**
 * @internal
 */
export declare const DescribeDocumentVersionsResponseFilterSensitiveLog: (obj: DescribeDocumentVersionsResponse) => any;
/**
 * @internal
 */
export declare const DescribeFolderContentsRequestFilterSensitiveLog: (obj: DescribeFolderContentsRequest) => any;
/**
 * @internal
 */
export declare const DocumentMetadataFilterSensitiveLog: (obj: DocumentMetadata) => any;
/**
 * @internal
 */
export declare const DescribeFolderContentsResponseFilterSensitiveLog: (obj: DescribeFolderContentsResponse) => any;
/**
 * @internal
 */
export declare const DescribeGroupsRequestFilterSensitiveLog: (obj: DescribeGroupsRequest) => any;
/**
 * @internal
 */
export declare const DescribeResourcePermissionsRequestFilterSensitiveLog: (obj: DescribeResourcePermissionsRequest) => any;
/**
 * @internal
 */
export declare const DescribeRootFoldersRequestFilterSensitiveLog: (obj: DescribeRootFoldersRequest) => any;
/**
 * @internal
 */
export declare const DescribeRootFoldersResponseFilterSensitiveLog: (obj: DescribeRootFoldersResponse) => any;
/**
 * @internal
 */
export declare const DescribeUsersRequestFilterSensitiveLog: (obj: DescribeUsersRequest) => any;
/**
 * @internal
 */
export declare const DescribeUsersResponseFilterSensitiveLog: (obj: DescribeUsersResponse) => any;
/**
 * @internal
 */
export declare const GetCurrentUserRequestFilterSensitiveLog: (obj: GetCurrentUserRequest) => any;
/**
 * @internal
 */
export declare const GetCurrentUserResponseFilterSensitiveLog: (obj: GetCurrentUserResponse) => any;
/**
 * @internal
 */
export declare const GetDocumentRequestFilterSensitiveLog: (obj: GetDocumentRequest) => any;
/**
 * @internal
 */
export declare const GetDocumentResponseFilterSensitiveLog: (obj: GetDocumentResponse) => any;
/**
 * @internal
 */
export declare const GetDocumentPathRequestFilterSensitiveLog: (obj: GetDocumentPathRequest) => any;
/**
 * @internal
 */
export declare const ResourcePathComponentFilterSensitiveLog: (obj: ResourcePathComponent) => any;
/**
 * @internal
 */
export declare const ResourcePathFilterSensitiveLog: (obj: ResourcePath) => any;
/**
 * @internal
 */
export declare const GetDocumentPathResponseFilterSensitiveLog: (obj: GetDocumentPathResponse) => any;
/**
 * @internal
 */
export declare const GetDocumentVersionRequestFilterSensitiveLog: (obj: GetDocumentVersionRequest) => any;
/**
 * @internal
 */
export declare const GetDocumentVersionResponseFilterSensitiveLog: (obj: GetDocumentVersionResponse) => any;
/**
 * @internal
 */
export declare const GetFolderRequestFilterSensitiveLog: (obj: GetFolderRequest) => any;
/**
 * @internal
 */
export declare const GetFolderResponseFilterSensitiveLog: (obj: GetFolderResponse) => any;
/**
 * @internal
 */
export declare const GetFolderPathRequestFilterSensitiveLog: (obj: GetFolderPathRequest) => any;
/**
 * @internal
 */
export declare const GetFolderPathResponseFilterSensitiveLog: (obj: GetFolderPathResponse) => any;
/**
 * @internal
 */
export declare const GetResourcesRequestFilterSensitiveLog: (obj: GetResourcesRequest) => any;
/**
 * @internal
 */
export declare const GetResourcesResponseFilterSensitiveLog: (obj: GetResourcesResponse) => any;
/**
 * @internal
 */
export declare const InitiateDocumentVersionUploadRequestFilterSensitiveLog: (obj: InitiateDocumentVersionUploadRequest) => any;
/**
 * @internal
 */
export declare const UploadMetadataFilterSensitiveLog: (obj: UploadMetadata) => any;
/**
 * @internal
 */
export declare const InitiateDocumentVersionUploadResponseFilterSensitiveLog: (obj: InitiateDocumentVersionUploadResponse) => any;
/**
 * @internal
 */
export declare const RemoveAllResourcePermissionsRequestFilterSensitiveLog: (obj: RemoveAllResourcePermissionsRequest) => any;
/**
 * @internal
 */
export declare const RemoveResourcePermissionRequestFilterSensitiveLog: (obj: RemoveResourcePermissionRequest) => any;
/**
 * @internal
 */
export declare const RestoreDocumentVersionsRequestFilterSensitiveLog: (obj: RestoreDocumentVersionsRequest) => any;
/**
 * @internal
 */
export declare const SearchResourcesRequestFilterSensitiveLog: (obj: SearchResourcesRequest) => any;
/**
 * @internal
 */
export declare const ResponseItemFilterSensitiveLog: (obj: ResponseItem) => any;
/**
 * @internal
 */
export declare const SearchResourcesResponseFilterSensitiveLog: (obj: SearchResourcesResponse) => any;
/**
 * @internal
 */
export declare const UpdateDocumentRequestFilterSensitiveLog: (obj: UpdateDocumentRequest) => any;
/**
 * @internal
 */
export declare const UpdateDocumentVersionRequestFilterSensitiveLog: (obj: UpdateDocumentVersionRequest) => any;
/**
 * @internal
 */
export declare const UpdateFolderRequestFilterSensitiveLog: (obj: UpdateFolderRequest) => any;
/**
 * @internal
 */
export declare const UpdateUserRequestFilterSensitiveLog: (obj: UpdateUserRequest) => any;
/**
 * @internal
 */
export declare const UpdateUserResponseFilterSensitiveLog: (obj: UpdateUserResponse) => any;
