import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, serializeFloat as __serializeFloat, strictParseFloat as __strictParseFloat, strictParseInt32 as __strictParseInt32, strictParseLong as __strictParseLong, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { CloudSearchServiceException as __BaseException } from "../models/CloudSearchServiceException";
import { BaseException, DisabledOperationException, InternalException, InvalidTypeException, LimitExceededException, ResourceAlreadyExistsException, ResourceNotFoundException, ValidationException, } from "../models/models_0";
export const se_BuildSuggestersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_BuildSuggestersRequest(input, context),
        [_A]: _BS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateDomainRequest(input, context),
        [_A]: _CD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DefineAnalysisSchemeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DefineAnalysisSchemeRequest(input, context),
        [_A]: _DAS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DefineExpressionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DefineExpressionRequest(input, context),
        [_A]: _DE,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DefineIndexFieldCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DefineIndexFieldRequest(input, context),
        [_A]: _DIF,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DefineSuggesterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DefineSuggesterRequest(input, context),
        [_A]: _DS,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAnalysisSchemeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAnalysisSchemeRequest(input, context),
        [_A]: _DASe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDomainCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteDomainRequest(input, context),
        [_A]: _DD,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteExpressionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteExpressionRequest(input, context),
        [_A]: _DEe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteIndexFieldCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteIndexFieldRequest(input, context),
        [_A]: _DIFe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSuggesterCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSuggesterRequest(input, context),
        [_A]: _DSe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAnalysisSchemesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAnalysisSchemesRequest(input, context),
        [_A]: _DASes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeAvailabilityOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAvailabilityOptionsRequest(input, context),
        [_A]: _DAO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDomainEndpointOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDomainEndpointOptionsRequest(input, context),
        [_A]: _DDEO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDomainsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeDomainsRequest(input, context),
        [_A]: _DDe,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeExpressionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeExpressionsRequest(input, context),
        [_A]: _DEes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeIndexFieldsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeIndexFieldsRequest(input, context),
        [_A]: _DIFes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeScalingParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeScalingParametersRequest(input, context),
        [_A]: _DSP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeServiceAccessPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeServiceAccessPoliciesRequest(input, context),
        [_A]: _DSAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSuggestersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSuggestersRequest(input, context),
        [_A]: _DSes,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_IndexDocumentsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_IndexDocumentsRequest(input, context),
        [_A]: _ID,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListDomainNamesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        [_A]: _LDN,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAvailabilityOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAvailabilityOptionsRequest(input, context),
        [_A]: _UAO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDomainEndpointOptionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateDomainEndpointOptionsRequest(input, context),
        [_A]: _UDEO,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateScalingParametersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateScalingParametersRequest(input, context),
        [_A]: _USP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateServiceAccessPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServiceAccessPoliciesRequest(input, context),
        [_A]: _USAP,
        [_V]: _,
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_BuildSuggestersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BuildSuggestersResponse(data.BuildSuggestersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDomainResponse(data.CreateDomainResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DefineAnalysisSchemeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DefineAnalysisSchemeResponse(data.DefineAnalysisSchemeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DefineExpressionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DefineExpressionResponse(data.DefineExpressionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DefineIndexFieldCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DefineIndexFieldResponse(data.DefineIndexFieldResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DefineSuggesterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DefineSuggesterResponse(data.DefineSuggesterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteAnalysisSchemeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteAnalysisSchemeResponse(data.DeleteAnalysisSchemeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDomainCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteDomainResponse(data.DeleteDomainResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteExpressionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteExpressionResponse(data.DeleteExpressionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteIndexFieldCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteIndexFieldResponse(data.DeleteIndexFieldResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSuggesterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSuggesterResponse(data.DeleteSuggesterResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAnalysisSchemesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAnalysisSchemesResponse(data.DescribeAnalysisSchemesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeAvailabilityOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAvailabilityOptionsResponse(data.DescribeAvailabilityOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDomainEndpointOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDomainEndpointOptionsResponse(data.DescribeDomainEndpointOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDomainsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDomainsResponse(data.DescribeDomainsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeExpressionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeExpressionsResponse(data.DescribeExpressionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeIndexFieldsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIndexFieldsResponse(data.DescribeIndexFieldsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeScalingParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeScalingParametersResponse(data.DescribeScalingParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeServiceAccessPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeServiceAccessPoliciesResponse(data.DescribeServiceAccessPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSuggestersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSuggestersResponse(data.DescribeSuggestersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_IndexDocumentsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_IndexDocumentsResponse(data.IndexDocumentsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListDomainNamesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDomainNamesResponse(data.ListDomainNamesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateAvailabilityOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateAvailabilityOptionsResponse(data.UpdateAvailabilityOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateDomainEndpointOptionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateDomainEndpointOptionsResponse(data.UpdateDomainEndpointOptionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateScalingParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateScalingParametersResponse(data.UpdateScalingParametersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateServiceAccessPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateServiceAccessPoliciesResponse(data.UpdateServiceAccessPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BaseException":
        case "com.amazonaws.cloudsearch#BaseException":
            throw await de_BaseExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.cloudsearch#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.cloudsearch#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.cloudsearch#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.cloudsearch#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExists":
        case "com.amazonaws.cloudsearch#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidType":
        case "com.amazonaws.cloudsearch#InvalidTypeException":
            throw await de_InvalidTypeExceptionRes(parsedOutput, context);
        case "DisabledAction":
        case "com.amazonaws.cloudsearch#DisabledOperationException":
            throw await de_DisabledOperationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_BaseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_BaseException(body.Error, context);
    const exception = new BaseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DisabledOperationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DisabledOperationException(body.Error, context);
    const exception = new DisabledOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InternalException(body.Error, context);
    const exception = new InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTypeException(body.Error, context);
    const exception = new InvalidTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceAlreadyExistsException(body.Error, context);
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceNotFoundException(body.Error, context);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ValidationException(body.Error, context);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AnalysisOptions = (input, context) => {
    const entries = {};
    if (input[_S] != null) {
        entries[_S] = input[_S];
    }
    if (input[_St] != null) {
        entries[_St] = input[_St];
    }
    if (input[_SD] != null) {
        entries[_SD] = input[_SD];
    }
    if (input[_JTD] != null) {
        entries[_JTD] = input[_JTD];
    }
    if (input[_AS] != null) {
        entries[_AS] = input[_AS];
    }
    return entries;
};
const se_AnalysisScheme = (input, context) => {
    const entries = {};
    if (input[_ASN] != null) {
        entries[_ASN] = input[_ASN];
    }
    if (input[_ASL] != null) {
        entries[_ASL] = input[_ASL];
    }
    if (input[_AO] != null) {
        const memberEntries = se_AnalysisOptions(input[_AO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnalysisOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_BuildSuggestersRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    return entries;
};
const se_CreateDomainRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    return entries;
};
const se_DateArrayOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SF] != null) {
        entries[_SF] = input[_SF];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    return entries;
};
const se_DateOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    return entries;
};
const se_DefineAnalysisSchemeRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_ASn] != null) {
        const memberEntries = se_AnalysisScheme(input[_ASn], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnalysisScheme.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DefineExpressionRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_E] != null) {
        const memberEntries = se_Expression(input[_E], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Expression.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DefineIndexFieldRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_IF] != null) {
        const memberEntries = se_IndexField(input[_IF], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IndexField.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DefineSuggesterRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_Su] != null) {
        const memberEntries = se_Suggester(input[_Su], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Suggester.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeleteAnalysisSchemeRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_ASN] != null) {
        entries[_ASN] = input[_ASN];
    }
    return entries;
};
const se_DeleteDomainRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    return entries;
};
const se_DeleteExpressionRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    return entries;
};
const se_DeleteIndexFieldRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_IFN] != null) {
        entries[_IFN] = input[_IFN];
    }
    return entries;
};
const se_DeleteSuggesterRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    return entries;
};
const se_DescribeAnalysisSchemesRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_ASNn] != null) {
        const memberEntries = se_StandardNameList(input[_ASNn], context);
        if (input[_ASNn]?.length === 0) {
            entries.AnalysisSchemeNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AnalysisSchemeNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeAvailabilityOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeDomainEndpointOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeDomainsRequest = (input, context) => {
    const entries = {};
    if (input[_DNo] != null) {
        const memberEntries = se_DomainNameList(input[_DNo], context);
        if (input[_DNo]?.length === 0) {
            entries.DomainNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DomainNames.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeExpressionsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_ENx] != null) {
        const memberEntries = se_StandardNameList(input[_ENx], context);
        if (input[_ENx]?.length === 0) {
            entries.ExpressionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ExpressionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeIndexFieldsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_FN] != null) {
        const memberEntries = se_DynamicFieldNameList(input[_FN], context);
        if (input[_FN]?.length === 0) {
            entries.FieldNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FieldNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeScalingParametersRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    return entries;
};
const se_DescribeServiceAccessPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DescribeSuggestersRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_SNu] != null) {
        const memberEntries = se_StandardNameList(input[_SNu], context);
        if (input[_SNu]?.length === 0) {
            entries.SuggesterNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SuggesterNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_D] != null) {
        entries[_D] = input[_D];
    }
    return entries;
};
const se_DocumentSuggesterOptions = (input, context) => {
    const entries = {};
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FM] != null) {
        entries[_FM] = input[_FM];
    }
    if (input[_SEor] != null) {
        entries[_SEor] = input[_SEor];
    }
    return entries;
};
const se_DomainEndpointOptions = (input, context) => {
    const entries = {};
    if (input[_EHTTPS] != null) {
        entries[_EHTTPS] = input[_EHTTPS];
    }
    if (input[_TLSSP] != null) {
        entries[_TLSSP] = input[_TLSSP];
    }
    return entries;
};
const se_DomainNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_DoubleArrayOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = __serializeFloat(input[_DV]);
    }
    if (input[_SF] != null) {
        entries[_SF] = input[_SF];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    return entries;
};
const se_DoubleOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = __serializeFloat(input[_DV]);
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    return entries;
};
const se_DynamicFieldNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Expression = (input, context) => {
    const entries = {};
    if (input[_EN] != null) {
        entries[_EN] = input[_EN];
    }
    if (input[_EV] != null) {
        entries[_EV] = input[_EV];
    }
    return entries;
};
const se_IndexDocumentsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    return entries;
};
const se_IndexField = (input, context) => {
    const entries = {};
    if (input[_IFN] != null) {
        entries[_IFN] = input[_IFN];
    }
    if (input[_IFT] != null) {
        entries[_IFT] = input[_IFT];
    }
    if (input[_IO] != null) {
        const memberEntries = se_IntOptions(input[_IO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IntOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DO] != null) {
        const memberEntries = se_DoubleOptions(input[_DO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DoubleOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LO] != null) {
        const memberEntries = se_LiteralOptions(input[_LO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LiteralOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TO] != null) {
        const memberEntries = se_TextOptions(input[_TO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TextOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DOa] != null) {
        const memberEntries = se_DateOptions(input[_DOa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DateOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LLO] != null) {
        const memberEntries = se_LatLonOptions(input[_LLO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LatLonOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_IAO] != null) {
        const memberEntries = se_IntArrayOptions(input[_IAO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `IntArrayOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAOo] != null) {
        const memberEntries = se_DoubleArrayOptions(input[_DAOo], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DoubleArrayOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_LAO] != null) {
        const memberEntries = se_LiteralArrayOptions(input[_LAO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LiteralArrayOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_TAO] != null) {
        const memberEntries = se_TextArrayOptions(input[_TAO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TextArrayOptions.${key}`;
            entries[loc] = value;
        });
    }
    if (input[_DAOa] != null) {
        const memberEntries = se_DateArrayOptions(input[_DAOa], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DateArrayOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_IntArrayOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SF] != null) {
        entries[_SF] = input[_SF];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    return entries;
};
const se_IntOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    return entries;
};
const se_LatLonOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    return entries;
};
const se_LiteralArrayOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SF] != null) {
        entries[_SF] = input[_SF];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    return entries;
};
const se_LiteralOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_FE] != null) {
        entries[_FE] = input[_FE];
    }
    if (input[_SE] != null) {
        entries[_SE] = input[_SE];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    return entries;
};
const se_ScalingParameters = (input, context) => {
    const entries = {};
    if (input[_DIT] != null) {
        entries[_DIT] = input[_DIT];
    }
    if (input[_DRC] != null) {
        entries[_DRC] = input[_DRC];
    }
    if (input[_DPC] != null) {
        entries[_DPC] = input[_DPC];
    }
    return entries;
};
const se_StandardNameList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Suggester = (input, context) => {
    const entries = {};
    if (input[_SN] != null) {
        entries[_SN] = input[_SN];
    }
    if (input[_DSO] != null) {
        const memberEntries = se_DocumentSuggesterOptions(input[_DSO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DocumentSuggesterOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TextArrayOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SF] != null) {
        entries[_SF] = input[_SF];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_ASn] != null) {
        entries[_ASn] = input[_ASn];
    }
    return entries;
};
const se_TextOptions = (input, context) => {
    const entries = {};
    if (input[_DV] != null) {
        entries[_DV] = input[_DV];
    }
    if (input[_SFo] != null) {
        entries[_SFo] = input[_SFo];
    }
    if (input[_RE] != null) {
        entries[_RE] = input[_RE];
    }
    if (input[_SEo] != null) {
        entries[_SEo] = input[_SEo];
    }
    if (input[_HE] != null) {
        entries[_HE] = input[_HE];
    }
    if (input[_ASn] != null) {
        entries[_ASn] = input[_ASn];
    }
    return entries;
};
const se_UpdateAvailabilityOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_MAZ] != null) {
        entries[_MAZ] = input[_MAZ];
    }
    return entries;
};
const se_UpdateDomainEndpointOptionsRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_DEO] != null) {
        const memberEntries = se_DomainEndpointOptions(input[_DEO], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DomainEndpointOptions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateScalingParametersRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_SP] != null) {
        const memberEntries = se_ScalingParameters(input[_SP], context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ScalingParameters.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateServiceAccessPoliciesRequest = (input, context) => {
    const entries = {};
    if (input[_DN] != null) {
        entries[_DN] = input[_DN];
    }
    if (input[_AP] != null) {
        entries[_AP] = input[_AP];
    }
    return entries;
};
const de_AccessPoliciesStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = __expectString(output[_O]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_AnalysisOptions = (output, context) => {
    const contents = {};
    if (output[_S] != null) {
        contents[_S] = __expectString(output[_S]);
    }
    if (output[_St] != null) {
        contents[_St] = __expectString(output[_St]);
    }
    if (output[_SD] != null) {
        contents[_SD] = __expectString(output[_SD]);
    }
    if (output[_JTD] != null) {
        contents[_JTD] = __expectString(output[_JTD]);
    }
    if (output[_AS] != null) {
        contents[_AS] = __expectString(output[_AS]);
    }
    return contents;
};
const de_AnalysisScheme = (output, context) => {
    const contents = {};
    if (output[_ASN] != null) {
        contents[_ASN] = __expectString(output[_ASN]);
    }
    if (output[_ASL] != null) {
        contents[_ASL] = __expectString(output[_ASL]);
    }
    if (output[_AO] != null) {
        contents[_AO] = de_AnalysisOptions(output[_AO], context);
    }
    return contents;
};
const de_AnalysisSchemeStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_AnalysisScheme(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_AnalysisSchemeStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalysisSchemeStatus(entry, context);
    });
};
const de_AvailabilityOptionsStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = __parseBoolean(output[_O]);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_BaseException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_BuildSuggestersResponse = (output, context) => {
    const contents = {};
    if (output.FieldNames === "") {
        contents[_FN] = [];
    }
    else if (output[_FN] != null && output[_FN][_m] != null) {
        contents[_FN] = de_FieldNameList(__getArrayIfSingleItem(output[_FN][_m]), context);
    }
    return contents;
};
const de_CreateDomainResponse = (output, context) => {
    const contents = {};
    if (output[_DSo] != null) {
        contents[_DSo] = de_DomainStatus(output[_DSo], context);
    }
    return contents;
};
const de_DateArrayOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SF] != null) {
        contents[_SF] = __expectString(output[_SF]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    return contents;
};
const de_DateOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    return contents;
};
const de_DefineAnalysisSchemeResponse = (output, context) => {
    const contents = {};
    if (output[_ASn] != null) {
        contents[_ASn] = de_AnalysisSchemeStatus(output[_ASn], context);
    }
    return contents;
};
const de_DefineExpressionResponse = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = de_ExpressionStatus(output[_E], context);
    }
    return contents;
};
const de_DefineIndexFieldResponse = (output, context) => {
    const contents = {};
    if (output[_IF] != null) {
        contents[_IF] = de_IndexFieldStatus(output[_IF], context);
    }
    return contents;
};
const de_DefineSuggesterResponse = (output, context) => {
    const contents = {};
    if (output[_Su] != null) {
        contents[_Su] = de_SuggesterStatus(output[_Su], context);
    }
    return contents;
};
const de_DeleteAnalysisSchemeResponse = (output, context) => {
    const contents = {};
    if (output[_ASn] != null) {
        contents[_ASn] = de_AnalysisSchemeStatus(output[_ASn], context);
    }
    return contents;
};
const de_DeleteDomainResponse = (output, context) => {
    const contents = {};
    if (output[_DSo] != null) {
        contents[_DSo] = de_DomainStatus(output[_DSo], context);
    }
    return contents;
};
const de_DeleteExpressionResponse = (output, context) => {
    const contents = {};
    if (output[_E] != null) {
        contents[_E] = de_ExpressionStatus(output[_E], context);
    }
    return contents;
};
const de_DeleteIndexFieldResponse = (output, context) => {
    const contents = {};
    if (output[_IF] != null) {
        contents[_IF] = de_IndexFieldStatus(output[_IF], context);
    }
    return contents;
};
const de_DeleteSuggesterResponse = (output, context) => {
    const contents = {};
    if (output[_Su] != null) {
        contents[_Su] = de_SuggesterStatus(output[_Su], context);
    }
    return contents;
};
const de_DescribeAnalysisSchemesResponse = (output, context) => {
    const contents = {};
    if (output.AnalysisSchemes === "") {
        contents[_ASna] = [];
    }
    else if (output[_ASna] != null && output[_ASna][_m] != null) {
        contents[_ASna] = de_AnalysisSchemeStatusList(__getArrayIfSingleItem(output[_ASna][_m]), context);
    }
    return contents;
};
const de_DescribeAvailabilityOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_AOv] != null) {
        contents[_AOv] = de_AvailabilityOptionsStatus(output[_AOv], context);
    }
    return contents;
};
const de_DescribeDomainEndpointOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_DEO] != null) {
        contents[_DEO] = de_DomainEndpointOptionsStatus(output[_DEO], context);
    }
    return contents;
};
const de_DescribeDomainsResponse = (output, context) => {
    const contents = {};
    if (output.DomainStatusList === "") {
        contents[_DSL] = [];
    }
    else if (output[_DSL] != null && output[_DSL][_m] != null) {
        contents[_DSL] = de_DomainStatusList(__getArrayIfSingleItem(output[_DSL][_m]), context);
    }
    return contents;
};
const de_DescribeExpressionsResponse = (output, context) => {
    const contents = {};
    if (output.Expressions === "") {
        contents[_Ex] = [];
    }
    else if (output[_Ex] != null && output[_Ex][_m] != null) {
        contents[_Ex] = de_ExpressionStatusList(__getArrayIfSingleItem(output[_Ex][_m]), context);
    }
    return contents;
};
const de_DescribeIndexFieldsResponse = (output, context) => {
    const contents = {};
    if (output.IndexFields === "") {
        contents[_IFn] = [];
    }
    else if (output[_IFn] != null && output[_IFn][_m] != null) {
        contents[_IFn] = de_IndexFieldStatusList(__getArrayIfSingleItem(output[_IFn][_m]), context);
    }
    return contents;
};
const de_DescribeScalingParametersResponse = (output, context) => {
    const contents = {};
    if (output[_SP] != null) {
        contents[_SP] = de_ScalingParametersStatus(output[_SP], context);
    }
    return contents;
};
const de_DescribeServiceAccessPoliciesResponse = (output, context) => {
    const contents = {};
    if (output[_AP] != null) {
        contents[_AP] = de_AccessPoliciesStatus(output[_AP], context);
    }
    return contents;
};
const de_DescribeSuggestersResponse = (output, context) => {
    const contents = {};
    if (output.Suggesters === "") {
        contents[_Sug] = [];
    }
    else if (output[_Sug] != null && output[_Sug][_m] != null) {
        contents[_Sug] = de_SuggesterStatusList(__getArrayIfSingleItem(output[_Sug][_m]), context);
    }
    return contents;
};
const de_DisabledOperationException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_DocumentSuggesterOptions = (output, context) => {
    const contents = {};
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FM] != null) {
        contents[_FM] = __expectString(output[_FM]);
    }
    if (output[_SEor] != null) {
        contents[_SEor] = __expectString(output[_SEor]);
    }
    return contents;
};
const de_DomainEndpointOptions = (output, context) => {
    const contents = {};
    if (output[_EHTTPS] != null) {
        contents[_EHTTPS] = __parseBoolean(output[_EHTTPS]);
    }
    if (output[_TLSSP] != null) {
        contents[_TLSSP] = __expectString(output[_TLSSP]);
    }
    return contents;
};
const de_DomainEndpointOptionsStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_DomainEndpointOptions(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_DomainNameMap = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_DomainStatus = (output, context) => {
    const contents = {};
    if (output[_DI] != null) {
        contents[_DI] = __expectString(output[_DI]);
    }
    if (output[_DN] != null) {
        contents[_DN] = __expectString(output[_DN]);
    }
    if (output[_ARN] != null) {
        contents[_ARN] = __expectString(output[_ARN]);
    }
    if (output[_Cr] != null) {
        contents[_Cr] = __parseBoolean(output[_Cr]);
    }
    if (output[_De] != null) {
        contents[_De] = __parseBoolean(output[_De]);
    }
    if (output[_DSoc] != null) {
        contents[_DSoc] = de_ServiceEndpoint(output[_DSoc], context);
    }
    if (output[_SS] != null) {
        contents[_SS] = de_ServiceEndpoint(output[_SS], context);
    }
    if (output[_RID] != null) {
        contents[_RID] = __parseBoolean(output[_RID]);
    }
    if (output[_P] != null) {
        contents[_P] = __parseBoolean(output[_P]);
    }
    if (output[_SIT] != null) {
        contents[_SIT] = __expectString(output[_SIT]);
    }
    if (output[_SPC] != null) {
        contents[_SPC] = __strictParseInt32(output[_SPC]);
    }
    if (output[_SIC] != null) {
        contents[_SIC] = __strictParseInt32(output[_SIC]);
    }
    if (output[_L] != null) {
        contents[_L] = de_Limits(output[_L], context);
    }
    return contents;
};
const de_DomainStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainStatus(entry, context);
    });
};
const de_DoubleArrayOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __strictParseFloat(output[_DV]);
    }
    if (output[_SF] != null) {
        contents[_SF] = __expectString(output[_SF]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    return contents;
};
const de_DoubleOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __strictParseFloat(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    return contents;
};
const de_Expression = (output, context) => {
    const contents = {};
    if (output[_EN] != null) {
        contents[_EN] = __expectString(output[_EN]);
    }
    if (output[_EV] != null) {
        contents[_EV] = __expectString(output[_EV]);
    }
    return contents;
};
const de_ExpressionStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_Expression(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_ExpressionStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExpressionStatus(entry, context);
    });
};
const de_FieldNameList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_IndexDocumentsResponse = (output, context) => {
    const contents = {};
    if (output.FieldNames === "") {
        contents[_FN] = [];
    }
    else if (output[_FN] != null && output[_FN][_m] != null) {
        contents[_FN] = de_FieldNameList(__getArrayIfSingleItem(output[_FN][_m]), context);
    }
    return contents;
};
const de_IndexField = (output, context) => {
    const contents = {};
    if (output[_IFN] != null) {
        contents[_IFN] = __expectString(output[_IFN]);
    }
    if (output[_IFT] != null) {
        contents[_IFT] = __expectString(output[_IFT]);
    }
    if (output[_IO] != null) {
        contents[_IO] = de_IntOptions(output[_IO], context);
    }
    if (output[_DO] != null) {
        contents[_DO] = de_DoubleOptions(output[_DO], context);
    }
    if (output[_LO] != null) {
        contents[_LO] = de_LiteralOptions(output[_LO], context);
    }
    if (output[_TO] != null) {
        contents[_TO] = de_TextOptions(output[_TO], context);
    }
    if (output[_DOa] != null) {
        contents[_DOa] = de_DateOptions(output[_DOa], context);
    }
    if (output[_LLO] != null) {
        contents[_LLO] = de_LatLonOptions(output[_LLO], context);
    }
    if (output[_IAO] != null) {
        contents[_IAO] = de_IntArrayOptions(output[_IAO], context);
    }
    if (output[_DAOo] != null) {
        contents[_DAOo] = de_DoubleArrayOptions(output[_DAOo], context);
    }
    if (output[_LAO] != null) {
        contents[_LAO] = de_LiteralArrayOptions(output[_LAO], context);
    }
    if (output[_TAO] != null) {
        contents[_TAO] = de_TextArrayOptions(output[_TAO], context);
    }
    if (output[_DAOa] != null) {
        contents[_DAOa] = de_DateArrayOptions(output[_DAOa], context);
    }
    return contents;
};
const de_IndexFieldStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_IndexField(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_IndexFieldStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IndexFieldStatus(entry, context);
    });
};
const de_IntArrayOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __strictParseLong(output[_DV]);
    }
    if (output[_SF] != null) {
        contents[_SF] = __expectString(output[_SF]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    return contents;
};
const de_InternalException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_IntOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __strictParseLong(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    return contents;
};
const de_InvalidTypeException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_LatLonOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_Limits = (output, context) => {
    const contents = {};
    if (output[_MRC] != null) {
        contents[_MRC] = __strictParseInt32(output[_MRC]);
    }
    if (output[_MPC] != null) {
        contents[_MPC] = __strictParseInt32(output[_MPC]);
    }
    return contents;
};
const de_ListDomainNamesResponse = (output, context) => {
    const contents = {};
    if (output.DomainNames === "") {
        contents[_DNo] = {};
    }
    else if (output[_DNo] != null && output[_DNo][_e] != null) {
        contents[_DNo] = de_DomainNameMap(__getArrayIfSingleItem(output[_DNo][_e]), context);
    }
    return contents;
};
const de_LiteralArrayOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SF] != null) {
        contents[_SF] = __expectString(output[_SF]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    return contents;
};
const de_LiteralOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_FE] != null) {
        contents[_FE] = __parseBoolean(output[_FE]);
    }
    if (output[_SE] != null) {
        contents[_SE] = __parseBoolean(output[_SE]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    return contents;
};
const de_OptionStatus = (output, context) => {
    const contents = {};
    if (output[_CDr] != null) {
        contents[_CDr] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_CDr]));
    }
    if (output[_UD] != null) {
        contents[_UD] = __expectNonNull(__parseRfc3339DateTimeWithOffset(output[_UD]));
    }
    if (output[_UV] != null) {
        contents[_UV] = __strictParseInt32(output[_UV]);
    }
    if (output[_Stat] != null) {
        contents[_Stat] = __expectString(output[_Stat]);
    }
    if (output[_PD] != null) {
        contents[_PD] = __parseBoolean(output[_PD]);
    }
    return contents;
};
const de_ResourceAlreadyExistsException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ResourceNotFoundException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const de_ScalingParameters = (output, context) => {
    const contents = {};
    if (output[_DIT] != null) {
        contents[_DIT] = __expectString(output[_DIT]);
    }
    if (output[_DRC] != null) {
        contents[_DRC] = __strictParseInt32(output[_DRC]);
    }
    if (output[_DPC] != null) {
        contents[_DPC] = __strictParseInt32(output[_DPC]);
    }
    return contents;
};
const de_ScalingParametersStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_ScalingParameters(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_ServiceEndpoint = (output, context) => {
    const contents = {};
    if (output[_En] != null) {
        contents[_En] = __expectString(output[_En]);
    }
    return contents;
};
const de_Suggester = (output, context) => {
    const contents = {};
    if (output[_SN] != null) {
        contents[_SN] = __expectString(output[_SN]);
    }
    if (output[_DSO] != null) {
        contents[_DSO] = de_DocumentSuggesterOptions(output[_DSO], context);
    }
    return contents;
};
const de_SuggesterStatus = (output, context) => {
    const contents = {};
    if (output[_O] != null) {
        contents[_O] = de_Suggester(output[_O], context);
    }
    if (output[_Sta] != null) {
        contents[_Sta] = de_OptionStatus(output[_Sta], context);
    }
    return contents;
};
const de_SuggesterStatusList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SuggesterStatus(entry, context);
    });
};
const de_TextArrayOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SF] != null) {
        contents[_SF] = __expectString(output[_SF]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_HE] != null) {
        contents[_HE] = __parseBoolean(output[_HE]);
    }
    if (output[_ASn] != null) {
        contents[_ASn] = __expectString(output[_ASn]);
    }
    return contents;
};
const de_TextOptions = (output, context) => {
    const contents = {};
    if (output[_DV] != null) {
        contents[_DV] = __expectString(output[_DV]);
    }
    if (output[_SFo] != null) {
        contents[_SFo] = __expectString(output[_SFo]);
    }
    if (output[_RE] != null) {
        contents[_RE] = __parseBoolean(output[_RE]);
    }
    if (output[_SEo] != null) {
        contents[_SEo] = __parseBoolean(output[_SEo]);
    }
    if (output[_HE] != null) {
        contents[_HE] = __parseBoolean(output[_HE]);
    }
    if (output[_ASn] != null) {
        contents[_ASn] = __expectString(output[_ASn]);
    }
    return contents;
};
const de_UpdateAvailabilityOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_AOv] != null) {
        contents[_AOv] = de_AvailabilityOptionsStatus(output[_AOv], context);
    }
    return contents;
};
const de_UpdateDomainEndpointOptionsResponse = (output, context) => {
    const contents = {};
    if (output[_DEO] != null) {
        contents[_DEO] = de_DomainEndpointOptionsStatus(output[_DEO], context);
    }
    return contents;
};
const de_UpdateScalingParametersResponse = (output, context) => {
    const contents = {};
    if (output[_SP] != null) {
        contents[_SP] = de_ScalingParametersStatus(output[_SP], context);
    }
    return contents;
};
const de_UpdateServiceAccessPoliciesResponse = (output, context) => {
    const contents = {};
    if (output[_AP] != null) {
        contents[_AP] = de_AccessPoliciesStatus(output[_AP], context);
    }
    return contents;
};
const de_ValidationException = (output, context) => {
    const contents = {};
    if (output[_C] != null) {
        contents[_C] = __expectString(output[_C]);
    }
    if (output[_M] != null) {
        contents[_M] = __expectString(output[_M]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const _ = "2013-01-01";
const _A = "Action";
const _AO = "AnalysisOptions";
const _AOv = "AvailabilityOptions";
const _AP = "AccessPolicies";
const _ARN = "ARN";
const _AS = "AlgorithmicStemming";
const _ASL = "AnalysisSchemeLanguage";
const _ASN = "AnalysisSchemeName";
const _ASNn = "AnalysisSchemeNames";
const _ASn = "AnalysisScheme";
const _ASna = "AnalysisSchemes";
const _BS = "BuildSuggesters";
const _C = "Code";
const _CD = "CreateDomain";
const _CDr = "CreationDate";
const _Cr = "Created";
const _D = "Deployed";
const _DAO = "DescribeAvailabilityOptions";
const _DAOa = "DateArrayOptions";
const _DAOo = "DoubleArrayOptions";
const _DAS = "DefineAnalysisScheme";
const _DASe = "DeleteAnalysisScheme";
const _DASes = "DescribeAnalysisSchemes";
const _DD = "DeleteDomain";
const _DDEO = "DescribeDomainEndpointOptions";
const _DDe = "DescribeDomains";
const _DE = "DefineExpression";
const _DEO = "DomainEndpointOptions";
const _DEe = "DeleteExpression";
const _DEes = "DescribeExpressions";
const _DI = "DomainId";
const _DIF = "DefineIndexField";
const _DIFe = "DeleteIndexField";
const _DIFes = "DescribeIndexFields";
const _DIT = "DesiredInstanceType";
const _DN = "DomainName";
const _DNo = "DomainNames";
const _DO = "DoubleOptions";
const _DOa = "DateOptions";
const _DPC = "DesiredPartitionCount";
const _DRC = "DesiredReplicationCount";
const _DS = "DefineSuggester";
const _DSAP = "DescribeServiceAccessPolicies";
const _DSL = "DomainStatusList";
const _DSO = "DocumentSuggesterOptions";
const _DSP = "DescribeScalingParameters";
const _DSe = "DeleteSuggester";
const _DSes = "DescribeSuggesters";
const _DSo = "DomainStatus";
const _DSoc = "DocService";
const _DV = "DefaultValue";
const _De = "Deleted";
const _E = "Expression";
const _EHTTPS = "EnforceHTTPS";
const _EN = "ExpressionName";
const _ENx = "ExpressionNames";
const _EV = "ExpressionValue";
const _En = "Endpoint";
const _Ex = "Expressions";
const _FE = "FacetEnabled";
const _FM = "FuzzyMatching";
const _FN = "FieldNames";
const _HE = "HighlightEnabled";
const _IAO = "IntArrayOptions";
const _ID = "IndexDocuments";
const _IF = "IndexField";
const _IFN = "IndexFieldName";
const _IFT = "IndexFieldType";
const _IFn = "IndexFields";
const _IO = "IntOptions";
const _JTD = "JapaneseTokenizationDictionary";
const _L = "Limits";
const _LAO = "LiteralArrayOptions";
const _LDN = "ListDomainNames";
const _LLO = "LatLonOptions";
const _LO = "LiteralOptions";
const _M = "Message";
const _MAZ = "MultiAZ";
const _MPC = "MaximumPartitionCount";
const _MRC = "MaximumReplicationCount";
const _O = "Options";
const _P = "Processing";
const _PD = "PendingDeletion";
const _RE = "ReturnEnabled";
const _RID = "RequiresIndexDocuments";
const _S = "Synonyms";
const _SD = "StemmingDictionary";
const _SE = "SearchEnabled";
const _SEo = "SortEnabled";
const _SEor = "SortExpression";
const _SF = "SourceFields";
const _SFo = "SourceField";
const _SIC = "SearchInstanceCount";
const _SIT = "SearchInstanceType";
const _SN = "SuggesterName";
const _SNu = "SuggesterNames";
const _SP = "ScalingParameters";
const _SPC = "SearchPartitionCount";
const _SS = "SearchService";
const _St = "Stopwords";
const _Sta = "Status";
const _Stat = "State";
const _Su = "Suggester";
const _Sug = "Suggesters";
const _TAO = "TextArrayOptions";
const _TLSSP = "TLSSecurityPolicy";
const _TO = "TextOptions";
const _UAO = "UpdateAvailabilityOptions";
const _UD = "UpdateDate";
const _UDEO = "UpdateDomainEndpointOptions";
const _USAP = "UpdateServiceAccessPolicies";
const _USP = "UpdateScalingParameters";
const _UV = "UpdateVersion";
const _V = "Version";
const _e = "entry";
const _m = "member";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
