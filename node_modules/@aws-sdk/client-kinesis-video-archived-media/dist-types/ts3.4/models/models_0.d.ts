import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { StreamingBlobTypes } from "@smithy/types";
import { KinesisVideoArchivedMediaServiceException as __BaseException } from "./KinesisVideoArchivedMediaServiceException";
export declare class ClientLimitExceededException extends __BaseException {
  readonly name: "ClientLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ClientLimitExceededException, __BaseException>
  );
}
export declare const ClipFragmentSelectorType: {
  readonly PRODUCER_TIMESTAMP: "PRODUCER_TIMESTAMP";
  readonly SERVER_TIMESTAMP: "SERVER_TIMESTAMP";
};
export type ClipFragmentSelectorType =
  (typeof ClipFragmentSelectorType)[keyof typeof ClipFragmentSelectorType];
export interface ClipTimestampRange {
  StartTimestamp: Date | undefined;
  EndTimestamp: Date | undefined;
}
export interface ClipFragmentSelector {
  FragmentSelectorType: ClipFragmentSelectorType | undefined;
  TimestampRange: ClipTimestampRange | undefined;
}
export interface GetClipInput {
  StreamName?: string;
  StreamARN?: string;
  ClipFragmentSelector: ClipFragmentSelector | undefined;
}
export interface GetClipOutput {
  ContentType?: string;
  Payload?: StreamingBlobTypes;
}
export declare class InvalidArgumentException extends __BaseException {
  readonly name: "InvalidArgumentException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidArgumentException, __BaseException>
  );
}
export declare class InvalidCodecPrivateDataException extends __BaseException {
  readonly name: "InvalidCodecPrivateDataException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      InvalidCodecPrivateDataException,
      __BaseException
    >
  );
}
export declare class InvalidMediaFrameException extends __BaseException {
  readonly name: "InvalidMediaFrameException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidMediaFrameException, __BaseException>
  );
}
export declare class MissingCodecPrivateDataException extends __BaseException {
  readonly name: "MissingCodecPrivateDataException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      MissingCodecPrivateDataException,
      __BaseException
    >
  );
}
export declare class NoDataRetentionException extends __BaseException {
  readonly name: "NoDataRetentionException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<NoDataRetentionException, __BaseException>
  );
}
export declare class NotAuthorizedException extends __BaseException {
  readonly name: "NotAuthorizedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<NotAuthorizedException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class UnsupportedStreamMediaTypeException extends __BaseException {
  readonly name: "UnsupportedStreamMediaTypeException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedStreamMediaTypeException,
      __BaseException
    >
  );
}
export declare const DASHFragmentSelectorType: {
  readonly PRODUCER_TIMESTAMP: "PRODUCER_TIMESTAMP";
  readonly SERVER_TIMESTAMP: "SERVER_TIMESTAMP";
};
export type DASHFragmentSelectorType =
  (typeof DASHFragmentSelectorType)[keyof typeof DASHFragmentSelectorType];
export interface DASHTimestampRange {
  StartTimestamp?: Date;
  EndTimestamp?: Date;
}
export interface DASHFragmentSelector {
  FragmentSelectorType?: DASHFragmentSelectorType;
  TimestampRange?: DASHTimestampRange;
}
export declare const DASHDisplayFragmentNumber: {
  readonly ALWAYS: "ALWAYS";
  readonly NEVER: "NEVER";
};
export type DASHDisplayFragmentNumber =
  (typeof DASHDisplayFragmentNumber)[keyof typeof DASHDisplayFragmentNumber];
export declare const DASHDisplayFragmentTimestamp: {
  readonly ALWAYS: "ALWAYS";
  readonly NEVER: "NEVER";
};
export type DASHDisplayFragmentTimestamp =
  (typeof DASHDisplayFragmentTimestamp)[keyof typeof DASHDisplayFragmentTimestamp];
export declare const DASHPlaybackMode: {
  readonly LIVE: "LIVE";
  readonly LIVE_REPLAY: "LIVE_REPLAY";
  readonly ON_DEMAND: "ON_DEMAND";
};
export type DASHPlaybackMode =
  (typeof DASHPlaybackMode)[keyof typeof DASHPlaybackMode];
export interface GetDASHStreamingSessionURLInput {
  StreamName?: string;
  StreamARN?: string;
  PlaybackMode?: DASHPlaybackMode;
  DisplayFragmentTimestamp?: DASHDisplayFragmentTimestamp;
  DisplayFragmentNumber?: DASHDisplayFragmentNumber;
  DASHFragmentSelector?: DASHFragmentSelector;
  Expires?: number;
  MaxManifestFragmentResults?: number;
}
export interface GetDASHStreamingSessionURLOutput {
  DASHStreamingSessionURL?: string;
}
export declare const ContainerFormat: {
  readonly FRAGMENTED_MP4: "FRAGMENTED_MP4";
  readonly MPEG_TS: "MPEG_TS";
};
export type ContainerFormat =
  (typeof ContainerFormat)[keyof typeof ContainerFormat];
export declare const HLSDiscontinuityMode: {
  readonly ALWAYS: "ALWAYS";
  readonly NEVER: "NEVER";
  readonly ON_DISCONTINUITY: "ON_DISCONTINUITY";
};
export type HLSDiscontinuityMode =
  (typeof HLSDiscontinuityMode)[keyof typeof HLSDiscontinuityMode];
export declare const HLSDisplayFragmentTimestamp: {
  readonly ALWAYS: "ALWAYS";
  readonly NEVER: "NEVER";
};
export type HLSDisplayFragmentTimestamp =
  (typeof HLSDisplayFragmentTimestamp)[keyof typeof HLSDisplayFragmentTimestamp];
export declare const HLSFragmentSelectorType: {
  readonly PRODUCER_TIMESTAMP: "PRODUCER_TIMESTAMP";
  readonly SERVER_TIMESTAMP: "SERVER_TIMESTAMP";
};
export type HLSFragmentSelectorType =
  (typeof HLSFragmentSelectorType)[keyof typeof HLSFragmentSelectorType];
export interface HLSTimestampRange {
  StartTimestamp?: Date;
  EndTimestamp?: Date;
}
export interface HLSFragmentSelector {
  FragmentSelectorType?: HLSFragmentSelectorType;
  TimestampRange?: HLSTimestampRange;
}
export declare const HLSPlaybackMode: {
  readonly LIVE: "LIVE";
  readonly LIVE_REPLAY: "LIVE_REPLAY";
  readonly ON_DEMAND: "ON_DEMAND";
};
export type HLSPlaybackMode =
  (typeof HLSPlaybackMode)[keyof typeof HLSPlaybackMode];
export interface GetHLSStreamingSessionURLInput {
  StreamName?: string;
  StreamARN?: string;
  PlaybackMode?: HLSPlaybackMode;
  HLSFragmentSelector?: HLSFragmentSelector;
  ContainerFormat?: ContainerFormat;
  DiscontinuityMode?: HLSDiscontinuityMode;
  DisplayFragmentTimestamp?: HLSDisplayFragmentTimestamp;
  Expires?: number;
  MaxMediaPlaylistFragmentResults?: number;
}
export interface GetHLSStreamingSessionURLOutput {
  HLSStreamingSessionURL?: string;
}
export declare const Format: {
  readonly JPEG: "JPEG";
  readonly PNG: "PNG";
};
export type Format = (typeof Format)[keyof typeof Format];
export declare const FormatConfigKey: {
  readonly JPEGQuality: "JPEGQuality";
};
export type FormatConfigKey =
  (typeof FormatConfigKey)[keyof typeof FormatConfigKey];
export declare const ImageSelectorType: {
  readonly PRODUCER_TIMESTAMP: "PRODUCER_TIMESTAMP";
  readonly SERVER_TIMESTAMP: "SERVER_TIMESTAMP";
};
export type ImageSelectorType =
  (typeof ImageSelectorType)[keyof typeof ImageSelectorType];
export interface GetImagesInput {
  StreamName?: string;
  StreamARN?: string;
  ImageSelectorType: ImageSelectorType | undefined;
  StartTimestamp: Date | undefined;
  EndTimestamp: Date | undefined;
  SamplingInterval?: number;
  Format: Format | undefined;
  FormatConfig?: Partial<Record<FormatConfigKey, string>>;
  WidthPixels?: number;
  HeightPixels?: number;
  MaxResults?: number;
  NextToken?: string;
}
export declare const ImageError: {
  readonly MEDIA_ERROR: "MEDIA_ERROR";
  readonly NO_MEDIA: "NO_MEDIA";
};
export type ImageError = (typeof ImageError)[keyof typeof ImageError];
export interface Image {
  TimeStamp?: Date;
  Error?: ImageError;
  ImageContent?: string;
}
export interface GetImagesOutput {
  Images?: Image[];
  NextToken?: string;
}
export interface GetMediaForFragmentListInput {
  StreamName?: string;
  StreamARN?: string;
  Fragments: string[] | undefined;
}
export interface GetMediaForFragmentListOutput {
  ContentType?: string;
  Payload?: StreamingBlobTypes;
}
export declare const FragmentSelectorType: {
  readonly PRODUCER_TIMESTAMP: "PRODUCER_TIMESTAMP";
  readonly SERVER_TIMESTAMP: "SERVER_TIMESTAMP";
};
export type FragmentSelectorType =
  (typeof FragmentSelectorType)[keyof typeof FragmentSelectorType];
export interface TimestampRange {
  StartTimestamp: Date | undefined;
  EndTimestamp: Date | undefined;
}
export interface FragmentSelector {
  FragmentSelectorType: FragmentSelectorType | undefined;
  TimestampRange: TimestampRange | undefined;
}
export interface ListFragmentsInput {
  StreamName?: string;
  StreamARN?: string;
  MaxResults?: number;
  NextToken?: string;
  FragmentSelector?: FragmentSelector;
}
export interface Fragment {
  FragmentNumber?: string;
  FragmentSizeInBytes?: number;
  ProducerTimestamp?: Date;
  ServerTimestamp?: Date;
  FragmentLengthInMilliseconds?: number;
}
export interface ListFragmentsOutput {
  Fragments?: Fragment[];
  NextToken?: string;
}
export declare const GetClipOutputFilterSensitiveLog: (
  obj: GetClipOutput
) => any;
export declare const GetMediaForFragmentListOutputFilterSensitiveLog: (
  obj: GetMediaForFragmentListOutput
) => any;
