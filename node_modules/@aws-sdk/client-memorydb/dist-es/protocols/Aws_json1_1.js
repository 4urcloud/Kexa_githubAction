import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, limitedParseDouble as __limitedParseDouble, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { MemoryDBServiceException as __BaseException } from "../models/MemoryDBServiceException";
import { ACLAlreadyExistsFault, ACLNotFoundFault, ACLQuotaExceededFault, APICallRateForCustomerExceededFault, ClusterAlreadyExistsFault, ClusterNotFoundFault, ClusterQuotaForCustomerExceededFault, DefaultUserRequired, DuplicateUserNameFault, InsufficientClusterCapacityFault, InvalidACLStateFault, InvalidARNFault, InvalidClusterStateFault, InvalidCredentialsException, InvalidKMSKeyFault, InvalidNodeStateFault, InvalidParameterCombinationException, InvalidParameterGroupStateFault, InvalidParameterValueException, InvalidSnapshotStateFault, InvalidSubnet, InvalidUserStateFault, InvalidVPCNetworkStateFault, NodeQuotaForClusterExceededFault, NodeQuotaForCustomerExceededFault, NoOperationFault, ParameterGroupAlreadyExistsFault, ParameterGroupNotFoundFault, ParameterGroupQuotaExceededFault, ReservedNodeAlreadyExistsFault, ReservedNodeNotFoundFault, ReservedNodeQuotaExceededFault, ReservedNodesOfferingNotFoundFault, ServiceLinkedRoleNotFoundFault, ServiceUpdateNotFoundFault, ShardNotFoundFault, ShardsPerClusterQuotaExceededFault, SnapshotAlreadyExistsFault, SnapshotNotFoundFault, SnapshotQuotaExceededFault, SubnetGroupAlreadyExistsFault, SubnetGroupInUseFault, SubnetGroupNotFoundFault, SubnetGroupQuotaExceededFault, SubnetInUse, SubnetNotAllowedFault, SubnetQuotaExceededFault, TagNotFoundFault, TagQuotaPerResourceExceeded, TestFailoverNotAvailableFault, UserAlreadyExistsFault, UserNotFoundFault, UserQuotaExceededFault, } from "../models/models_0";
export const se_BatchUpdateClusterCommand = async (input, context) => {
    const headers = sharedHeaders("BatchUpdateCluster");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopySnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("CopySnapshot");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateACLCommand = async (input, context) => {
    const headers = sharedHeaders("CreateACL");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateClusterCommand = async (input, context) => {
    const headers = sharedHeaders("CreateCluster");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateParameterGroupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateParameterGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("CreateSnapshot");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSubnetGroupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateSubnetGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateUserCommand = async (input, context) => {
    const headers = sharedHeaders("CreateUser");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteACLCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteACL");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteClusterCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteCluster");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteParameterGroupCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteParameterGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteSnapshot");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSubnetGroupCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteSubnetGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteUser");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeACLsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeACLs");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeClustersCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeClusters");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEngineVersionsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeEngineVersions");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeEventsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeEvents");
    let body;
    body = JSON.stringify(se_DescribeEventsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeParameterGroupsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeParameterGroups");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeParametersCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeParameters");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedNodesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeReservedNodes");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeReservedNodesOfferingsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeReservedNodesOfferings");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeServiceUpdatesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeServiceUpdates");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeSnapshots");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSubnetGroupsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeSubnetGroups");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeUsersCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeUsers");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_FailoverShardCommand = async (input, context) => {
    const headers = sharedHeaders("FailoverShard");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAllowedNodeTypeUpdatesCommand = async (input, context) => {
    const headers = sharedHeaders("ListAllowedNodeTypeUpdates");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsCommand = async (input, context) => {
    const headers = sharedHeaders("ListTags");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PurchaseReservedNodesOfferingCommand = async (input, context) => {
    const headers = sharedHeaders("PurchaseReservedNodesOffering");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetParameterGroupCommand = async (input, context) => {
    const headers = sharedHeaders("ResetParameterGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateACLCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateACL");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateClusterCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateCluster");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateParameterGroupCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateParameterGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSubnetGroupCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateSubnetGroup");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateUserCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateUser");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_BatchUpdateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_BatchUpdateClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopySnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopySnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateACLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteACLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteSnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeACLsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeClustersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeClustersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEngineVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeEventsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeParameterGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeParametersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedNodesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedNodesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeReservedNodesOfferingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeReservedNodesOfferingsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeServiceUpdatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeServiceUpdatesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSubnetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeUsersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_FailoverShardCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_FailoverShardResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListAllowedNodeTypeUpdatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_PurchaseReservedNodesOfferingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_PurchaseReservedNodesOfferingResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ResetParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateACLCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateClusterCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateClusterResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateParameterGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateSubnetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidParameterValueException":
        case "com.amazonaws.memorydb#InvalidParameterValueException":
            throw await de_InvalidParameterValueExceptionRes(parsedOutput, context);
        case "ServiceUpdateNotFoundFault":
        case "com.amazonaws.memorydb#ServiceUpdateNotFoundFault":
            throw await de_ServiceUpdateNotFoundFaultRes(parsedOutput, context);
        case "InvalidParameterCombinationException":
        case "com.amazonaws.memorydb#InvalidParameterCombinationException":
            throw await de_InvalidParameterCombinationExceptionRes(parsedOutput, context);
        case "InvalidSnapshotStateFault":
        case "com.amazonaws.memorydb#InvalidSnapshotStateFault":
            throw await de_InvalidSnapshotStateFaultRes(parsedOutput, context);
        case "ServiceLinkedRoleNotFoundFault":
        case "com.amazonaws.memorydb#ServiceLinkedRoleNotFoundFault":
            throw await de_ServiceLinkedRoleNotFoundFaultRes(parsedOutput, context);
        case "SnapshotAlreadyExistsFault":
        case "com.amazonaws.memorydb#SnapshotAlreadyExistsFault":
            throw await de_SnapshotAlreadyExistsFaultRes(parsedOutput, context);
        case "SnapshotNotFoundFault":
        case "com.amazonaws.memorydb#SnapshotNotFoundFault":
            throw await de_SnapshotNotFoundFaultRes(parsedOutput, context);
        case "SnapshotQuotaExceededFault":
        case "com.amazonaws.memorydb#SnapshotQuotaExceededFault":
            throw await de_SnapshotQuotaExceededFaultRes(parsedOutput, context);
        case "TagQuotaPerResourceExceeded":
        case "com.amazonaws.memorydb#TagQuotaPerResourceExceeded":
            throw await de_TagQuotaPerResourceExceededRes(parsedOutput, context);
        case "ACLAlreadyExistsFault":
        case "com.amazonaws.memorydb#ACLAlreadyExistsFault":
            throw await de_ACLAlreadyExistsFaultRes(parsedOutput, context);
        case "ACLQuotaExceededFault":
        case "com.amazonaws.memorydb#ACLQuotaExceededFault":
            throw await de_ACLQuotaExceededFaultRes(parsedOutput, context);
        case "DefaultUserRequired":
        case "com.amazonaws.memorydb#DefaultUserRequired":
            throw await de_DefaultUserRequiredRes(parsedOutput, context);
        case "DuplicateUserNameFault":
        case "com.amazonaws.memorydb#DuplicateUserNameFault":
            throw await de_DuplicateUserNameFaultRes(parsedOutput, context);
        case "UserNotFoundFault":
        case "com.amazonaws.memorydb#UserNotFoundFault":
            throw await de_UserNotFoundFaultRes(parsedOutput, context);
        case "ACLNotFoundFault":
        case "com.amazonaws.memorydb#ACLNotFoundFault":
            throw await de_ACLNotFoundFaultRes(parsedOutput, context);
        case "ClusterAlreadyExistsFault":
        case "com.amazonaws.memorydb#ClusterAlreadyExistsFault":
            throw await de_ClusterAlreadyExistsFaultRes(parsedOutput, context);
        case "ClusterQuotaForCustomerExceededFault":
        case "com.amazonaws.memorydb#ClusterQuotaForCustomerExceededFault":
            throw await de_ClusterQuotaForCustomerExceededFaultRes(parsedOutput, context);
        case "InsufficientClusterCapacityFault":
        case "com.amazonaws.memorydb#InsufficientClusterCapacityFault":
            throw await de_InsufficientClusterCapacityFaultRes(parsedOutput, context);
        case "InvalidACLStateFault":
        case "com.amazonaws.memorydb#InvalidACLStateFault":
            throw await de_InvalidACLStateFaultRes(parsedOutput, context);
        case "InvalidCredentialsException":
        case "com.amazonaws.memorydb#InvalidCredentialsException":
            throw await de_InvalidCredentialsExceptionRes(parsedOutput, context);
        case "InvalidVPCNetworkStateFault":
        case "com.amazonaws.memorydb#InvalidVPCNetworkStateFault":
            throw await de_InvalidVPCNetworkStateFaultRes(parsedOutput, context);
        case "NodeQuotaForClusterExceededFault":
        case "com.amazonaws.memorydb#NodeQuotaForClusterExceededFault":
            throw await de_NodeQuotaForClusterExceededFaultRes(parsedOutput, context);
        case "NodeQuotaForCustomerExceededFault":
        case "com.amazonaws.memorydb#NodeQuotaForCustomerExceededFault":
            throw await de_NodeQuotaForCustomerExceededFaultRes(parsedOutput, context);
        case "ParameterGroupNotFoundFault":
        case "com.amazonaws.memorydb#ParameterGroupNotFoundFault":
            throw await de_ParameterGroupNotFoundFaultRes(parsedOutput, context);
        case "ShardsPerClusterQuotaExceededFault":
        case "com.amazonaws.memorydb#ShardsPerClusterQuotaExceededFault":
            throw await de_ShardsPerClusterQuotaExceededFaultRes(parsedOutput, context);
        case "SubnetGroupNotFoundFault":
        case "com.amazonaws.memorydb#SubnetGroupNotFoundFault":
            throw await de_SubnetGroupNotFoundFaultRes(parsedOutput, context);
        case "InvalidParameterGroupStateFault":
        case "com.amazonaws.memorydb#InvalidParameterGroupStateFault":
            throw await de_InvalidParameterGroupStateFaultRes(parsedOutput, context);
        case "ParameterGroupAlreadyExistsFault":
        case "com.amazonaws.memorydb#ParameterGroupAlreadyExistsFault":
            throw await de_ParameterGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "ParameterGroupQuotaExceededFault":
        case "com.amazonaws.memorydb#ParameterGroupQuotaExceededFault":
            throw await de_ParameterGroupQuotaExceededFaultRes(parsedOutput, context);
        case "ClusterNotFoundFault":
        case "com.amazonaws.memorydb#ClusterNotFoundFault":
            throw await de_ClusterNotFoundFaultRes(parsedOutput, context);
        case "InvalidClusterStateFault":
        case "com.amazonaws.memorydb#InvalidClusterStateFault":
            throw await de_InvalidClusterStateFaultRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.memorydb#InvalidSubnet":
            throw await de_InvalidSubnetRes(parsedOutput, context);
        case "SubnetGroupAlreadyExistsFault":
        case "com.amazonaws.memorydb#SubnetGroupAlreadyExistsFault":
            throw await de_SubnetGroupAlreadyExistsFaultRes(parsedOutput, context);
        case "SubnetGroupQuotaExceededFault":
        case "com.amazonaws.memorydb#SubnetGroupQuotaExceededFault":
            throw await de_SubnetGroupQuotaExceededFaultRes(parsedOutput, context);
        case "SubnetNotAllowedFault":
        case "com.amazonaws.memorydb#SubnetNotAllowedFault":
            throw await de_SubnetNotAllowedFaultRes(parsedOutput, context);
        case "SubnetQuotaExceededFault":
        case "com.amazonaws.memorydb#SubnetQuotaExceededFault":
            throw await de_SubnetQuotaExceededFaultRes(parsedOutput, context);
        case "UserAlreadyExistsFault":
        case "com.amazonaws.memorydb#UserAlreadyExistsFault":
            throw await de_UserAlreadyExistsFaultRes(parsedOutput, context);
        case "UserQuotaExceededFault":
        case "com.amazonaws.memorydb#UserQuotaExceededFault":
            throw await de_UserQuotaExceededFaultRes(parsedOutput, context);
        case "SubnetGroupInUseFault":
        case "com.amazonaws.memorydb#SubnetGroupInUseFault":
            throw await de_SubnetGroupInUseFaultRes(parsedOutput, context);
        case "InvalidUserStateFault":
        case "com.amazonaws.memorydb#InvalidUserStateFault":
            throw await de_InvalidUserStateFaultRes(parsedOutput, context);
        case "ReservedNodeNotFoundFault":
        case "com.amazonaws.memorydb#ReservedNodeNotFoundFault":
            throw await de_ReservedNodeNotFoundFaultRes(parsedOutput, context);
        case "ReservedNodesOfferingNotFoundFault":
        case "com.amazonaws.memorydb#ReservedNodesOfferingNotFoundFault":
            throw await de_ReservedNodesOfferingNotFoundFaultRes(parsedOutput, context);
        case "APICallRateForCustomerExceededFault":
        case "com.amazonaws.memorydb#APICallRateForCustomerExceededFault":
            throw await de_APICallRateForCustomerExceededFaultRes(parsedOutput, context);
        case "InvalidKMSKeyFault":
        case "com.amazonaws.memorydb#InvalidKMSKeyFault":
            throw await de_InvalidKMSKeyFaultRes(parsedOutput, context);
        case "ShardNotFoundFault":
        case "com.amazonaws.memorydb#ShardNotFoundFault":
            throw await de_ShardNotFoundFaultRes(parsedOutput, context);
        case "TestFailoverNotAvailableFault":
        case "com.amazonaws.memorydb#TestFailoverNotAvailableFault":
            throw await de_TestFailoverNotAvailableFaultRes(parsedOutput, context);
        case "InvalidARNFault":
        case "com.amazonaws.memorydb#InvalidARNFault":
            throw await de_InvalidARNFaultRes(parsedOutput, context);
        case "ReservedNodeAlreadyExistsFault":
        case "com.amazonaws.memorydb#ReservedNodeAlreadyExistsFault":
            throw await de_ReservedNodeAlreadyExistsFaultRes(parsedOutput, context);
        case "ReservedNodeQuotaExceededFault":
        case "com.amazonaws.memorydb#ReservedNodeQuotaExceededFault":
            throw await de_ReservedNodeQuotaExceededFaultRes(parsedOutput, context);
        case "TagNotFoundFault":
        case "com.amazonaws.memorydb#TagNotFoundFault":
            throw await de_TagNotFoundFaultRes(parsedOutput, context);
        case "InvalidNodeStateFault":
        case "com.amazonaws.memorydb#InvalidNodeStateFault":
            throw await de_InvalidNodeStateFaultRes(parsedOutput, context);
        case "NoOperationFault":
        case "com.amazonaws.memorydb#NoOperationFault":
            throw await de_NoOperationFaultRes(parsedOutput, context);
        case "SubnetInUse":
        case "com.amazonaws.memorydb#SubnetInUse":
            throw await de_SubnetInUseRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ACLAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ACLAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ACLNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ACLNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ACLQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ACLQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_APICallRateForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new APICallRateForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ClusterAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ClusterNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ClusterQuotaForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ClusterQuotaForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DefaultUserRequiredRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DefaultUserRequired({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateUserNameFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DuplicateUserNameFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InsufficientClusterCapacityFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InsufficientClusterCapacityFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidACLStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidACLStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidARNFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidARNFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidClusterStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidClusterStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCredentialsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidCredentialsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidKMSKeyFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidKMSKeyFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNodeStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidNodeStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterCombinationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidParameterCombinationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterGroupStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidParameterGroupStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidParameterValueExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidParameterValueException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSnapshotStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidSnapshotStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSubnetRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidSubnet({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUserStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidUserStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidVPCNetworkStateFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidVPCNetworkStateFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeQuotaForClusterExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new NodeQuotaForClusterExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NodeQuotaForCustomerExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new NodeQuotaForCustomerExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NoOperationFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new NoOperationFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ParameterGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ParameterGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ParameterGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ParameterGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ReservedNodeAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ReservedNodeNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodeQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ReservedNodeQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReservedNodesOfferingNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ReservedNodesOfferingNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceLinkedRoleNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ServiceLinkedRoleNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceUpdateNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ServiceUpdateNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ShardNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ShardNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ShardsPerClusterQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ShardsPerClusterQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SnapshotAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SnapshotNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SnapshotQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetGroupAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetGroupAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetGroupInUseFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetGroupInUseFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetGroupNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetGroupNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetGroupQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetGroupQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetInUseRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetInUse({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetNotAllowedFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetNotAllowedFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SubnetQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SubnetQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TagNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new TagNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TagQuotaPerResourceExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new TagQuotaPerResourceExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_TestFailoverNotAvailableFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new TestFailoverNotAvailableFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserAlreadyExistsFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UserAlreadyExistsFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserNotFoundFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UserNotFoundFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UserQuotaExceededFaultRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UserQuotaExceededFault({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_DescribeEventsRequest = (input, context) => {
    return take(input, {
        Duration: [],
        EndTime: (_) => Math.round(_.getTime() / 1000),
        MaxResults: [],
        NextToken: [],
        SourceName: [],
        SourceType: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_BatchUpdateClusterResponse = (output, context) => {
    return take(output, {
        ProcessedClusters: (_) => de_ClusterList(_, context),
        UnprocessedClusters: _json,
    });
};
const de_Cluster = (output, context) => {
    return take(output, {
        ACLName: __expectString,
        ARN: __expectString,
        AutoMinorVersionUpgrade: __expectBoolean,
        AvailabilityMode: __expectString,
        ClusterEndpoint: _json,
        DataTiering: __expectString,
        Description: __expectString,
        EnginePatchVersion: __expectString,
        EngineVersion: __expectString,
        KmsKeyId: __expectString,
        MaintenanceWindow: __expectString,
        Name: __expectString,
        NodeType: __expectString,
        NumberOfShards: __expectInt32,
        ParameterGroupName: __expectString,
        ParameterGroupStatus: __expectString,
        PendingUpdates: (_) => de_ClusterPendingUpdates(_, context),
        SecurityGroups: _json,
        Shards: (_) => de_ShardList(_, context),
        SnapshotRetentionLimit: __expectInt32,
        SnapshotWindow: __expectString,
        SnsTopicArn: __expectString,
        SnsTopicStatus: __expectString,
        Status: __expectString,
        SubnetGroupName: __expectString,
        TLSEnabled: __expectBoolean,
    });
};
const de_ClusterConfiguration = (output, context) => {
    return take(output, {
        Description: __expectString,
        EngineVersion: __expectString,
        MaintenanceWindow: __expectString,
        Name: __expectString,
        NodeType: __expectString,
        NumShards: __expectInt32,
        ParameterGroupName: __expectString,
        Port: __expectInt32,
        Shards: (_) => de_ShardDetails(_, context),
        SnapshotRetentionLimit: __expectInt32,
        SnapshotWindow: __expectString,
        SubnetGroupName: __expectString,
        TopicArn: __expectString,
        VpcId: __expectString,
    });
};
const de_ClusterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cluster(entry, context);
    });
    return retVal;
};
const de_ClusterPendingUpdates = (output, context) => {
    return take(output, {
        ACLs: _json,
        Resharding: (_) => de_ReshardingStatus(_, context),
        ServiceUpdates: _json,
    });
};
const de_CopySnapshotResponse = (output, context) => {
    return take(output, {
        Snapshot: (_) => de_Snapshot(_, context),
    });
};
const de_CreateClusterResponse = (output, context) => {
    return take(output, {
        Cluster: (_) => de_Cluster(_, context),
    });
};
const de_CreateSnapshotResponse = (output, context) => {
    return take(output, {
        Snapshot: (_) => de_Snapshot(_, context),
    });
};
const de_DeleteClusterResponse = (output, context) => {
    return take(output, {
        Cluster: (_) => de_Cluster(_, context),
    });
};
const de_DeleteSnapshotResponse = (output, context) => {
    return take(output, {
        Snapshot: (_) => de_Snapshot(_, context),
    });
};
const de_DescribeClustersResponse = (output, context) => {
    return take(output, {
        Clusters: (_) => de_ClusterList(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeEventsResponse = (output, context) => {
    return take(output, {
        Events: (_) => de_EventList(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeReservedNodesOfferingsResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        ReservedNodesOfferings: (_) => de_ReservedNodesOfferingList(_, context),
    });
};
const de_DescribeReservedNodesResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        ReservedNodes: (_) => de_ReservedNodeList(_, context),
    });
};
const de_DescribeServiceUpdatesResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        ServiceUpdates: (_) => de_ServiceUpdateList(_, context),
    });
};
const de_DescribeSnapshotsResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        Snapshots: (_) => de_SnapshotList(_, context),
    });
};
const de_Event = (output, context) => {
    return take(output, {
        Date: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Message: __expectString,
        SourceName: __expectString,
        SourceType: __expectString,
    });
};
const de_EventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Event(entry, context);
    });
    return retVal;
};
const de_FailoverShardResponse = (output, context) => {
    return take(output, {
        Cluster: (_) => de_Cluster(_, context),
    });
};
const de_Node = (output, context) => {
    return take(output, {
        AvailabilityZone: __expectString,
        CreateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Endpoint: _json,
        Name: __expectString,
        Status: __expectString,
    });
};
const de_NodeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Node(entry, context);
    });
    return retVal;
};
const de_PurchaseReservedNodesOfferingResponse = (output, context) => {
    return take(output, {
        ReservedNode: (_) => de_ReservedNode(_, context),
    });
};
const de_RecurringCharge = (output, context) => {
    return take(output, {
        RecurringChargeAmount: __limitedParseDouble,
        RecurringChargeFrequency: __expectString,
    });
};
const de_RecurringChargeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RecurringCharge(entry, context);
    });
    return retVal;
};
const de_ReservedNode = (output, context) => {
    return take(output, {
        ARN: __expectString,
        Duration: __expectInt32,
        FixedPrice: __limitedParseDouble,
        NodeCount: __expectInt32,
        NodeType: __expectString,
        OfferingType: __expectString,
        RecurringCharges: (_) => de_RecurringChargeList(_, context),
        ReservationId: __expectString,
        ReservedNodesOfferingId: __expectString,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        State: __expectString,
    });
};
const de_ReservedNodeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNode(entry, context);
    });
    return retVal;
};
const de_ReservedNodesOffering = (output, context) => {
    return take(output, {
        Duration: __expectInt32,
        FixedPrice: __limitedParseDouble,
        NodeType: __expectString,
        OfferingType: __expectString,
        RecurringCharges: (_) => de_RecurringChargeList(_, context),
        ReservedNodesOfferingId: __expectString,
    });
};
const de_ReservedNodesOfferingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ReservedNodesOffering(entry, context);
    });
    return retVal;
};
const de_ReshardingStatus = (output, context) => {
    return take(output, {
        SlotMigration: (_) => de_SlotMigration(_, context),
    });
};
const de_ServiceUpdate = (output, context) => {
    return take(output, {
        AutoUpdateStartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ClusterName: __expectString,
        Description: __expectString,
        NodesUpdated: __expectString,
        ReleaseDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ServiceUpdateName: __expectString,
        Status: __expectString,
        Type: __expectString,
    });
};
const de_ServiceUpdateList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceUpdate(entry, context);
    });
    return retVal;
};
const de_Shard = (output, context) => {
    return take(output, {
        Name: __expectString,
        Nodes: (_) => de_NodeList(_, context),
        NumberOfNodes: __expectInt32,
        Slots: __expectString,
        Status: __expectString,
    });
};
const de_ShardDetail = (output, context) => {
    return take(output, {
        Configuration: _json,
        Name: __expectString,
        Size: __expectString,
        SnapshotCreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ShardDetails = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ShardDetail(entry, context);
    });
    return retVal;
};
const de_ShardList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Shard(entry, context);
    });
    return retVal;
};
const de_SlotMigration = (output, context) => {
    return take(output, {
        ProgressPercentage: __limitedParseDouble,
    });
};
const de_Snapshot = (output, context) => {
    return take(output, {
        ARN: __expectString,
        ClusterConfiguration: (_) => de_ClusterConfiguration(_, context),
        DataTiering: __expectString,
        KmsKeyId: __expectString,
        Name: __expectString,
        Source: __expectString,
        Status: __expectString,
    });
};
const de_SnapshotList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Snapshot(entry, context);
    });
    return retVal;
};
const de_UpdateClusterResponse = (output, context) => {
    return take(output, {
        Cluster: (_) => de_Cluster(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `AmazonMemoryDB.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
