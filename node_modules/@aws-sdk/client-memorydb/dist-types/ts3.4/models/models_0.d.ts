import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { MemoryDBServiceException as __BaseException } from "./MemoryDBServiceException";
export interface ACLPendingChanges {
  UserNamesToRemove?: string[];
  UserNamesToAdd?: string[];
}
export interface ACL {
  Name?: string;
  Status?: string;
  UserNames?: string[];
  MinimumEngineVersion?: string;
  PendingChanges?: ACLPendingChanges;
  Clusters?: string[];
  ARN?: string;
}
export declare class ACLAlreadyExistsFault extends __BaseException {
  readonly name: "ACLAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ACLAlreadyExistsFault, __BaseException>
  );
}
export declare class ACLNotFoundFault extends __BaseException {
  readonly name: "ACLNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ACLNotFoundFault, __BaseException>);
}
export declare class ACLQuotaExceededFault extends __BaseException {
  readonly name: "ACLQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ACLQuotaExceededFault, __BaseException>
  );
}
export interface ACLsUpdateStatus {
  ACLToApply?: string;
}
export interface ServiceUpdateRequest {
  ServiceUpdateNameToApply?: string;
}
export interface BatchUpdateClusterRequest {
  ClusterNames: string[] | undefined;
  ServiceUpdate?: ServiceUpdateRequest;
}
export declare const AZStatus: {
  readonly MultiAZ: "multiaz";
  readonly SingleAZ: "singleaz";
};
export type AZStatus = (typeof AZStatus)[keyof typeof AZStatus];
export interface Endpoint {
  Address?: string;
  Port?: number;
}
export declare const DataTieringStatus: {
  readonly FALSE: "false";
  readonly TRUE: "true";
};
export type DataTieringStatus =
  (typeof DataTieringStatus)[keyof typeof DataTieringStatus];
export interface SlotMigration {
  ProgressPercentage?: number;
}
export interface ReshardingStatus {
  SlotMigration?: SlotMigration;
}
export declare const ServiceUpdateStatus: {
  readonly COMPLETE: "complete";
  readonly IN_PROGRESS: "in-progress";
  readonly NOT_APPLIED: "available";
  readonly SCHEDULED: "scheduled";
};
export type ServiceUpdateStatus =
  (typeof ServiceUpdateStatus)[keyof typeof ServiceUpdateStatus];
export interface PendingModifiedServiceUpdate {
  ServiceUpdateName?: string;
  Status?: ServiceUpdateStatus;
}
export interface ClusterPendingUpdates {
  Resharding?: ReshardingStatus;
  ACLs?: ACLsUpdateStatus;
  ServiceUpdates?: PendingModifiedServiceUpdate[];
}
export interface SecurityGroupMembership {
  SecurityGroupId?: string;
  Status?: string;
}
export interface Node {
  Name?: string;
  Status?: string;
  AvailabilityZone?: string;
  CreateTime?: Date;
  Endpoint?: Endpoint;
}
export interface Shard {
  Name?: string;
  Status?: string;
  Slots?: string;
  Nodes?: Node[];
  NumberOfNodes?: number;
}
export interface Cluster {
  Name?: string;
  Description?: string;
  Status?: string;
  PendingUpdates?: ClusterPendingUpdates;
  NumberOfShards?: number;
  Shards?: Shard[];
  AvailabilityMode?: AZStatus;
  ClusterEndpoint?: Endpoint;
  NodeType?: string;
  EngineVersion?: string;
  EnginePatchVersion?: string;
  ParameterGroupName?: string;
  ParameterGroupStatus?: string;
  SecurityGroups?: SecurityGroupMembership[];
  SubnetGroupName?: string;
  TLSEnabled?: boolean;
  KmsKeyId?: string;
  ARN?: string;
  SnsTopicArn?: string;
  SnsTopicStatus?: string;
  SnapshotRetentionLimit?: number;
  MaintenanceWindow?: string;
  SnapshotWindow?: string;
  ACLName?: string;
  AutoMinorVersionUpgrade?: boolean;
  DataTiering?: DataTieringStatus;
}
export interface UnprocessedCluster {
  ClusterName?: string;
  ErrorType?: string;
  ErrorMessage?: string;
}
export interface BatchUpdateClusterResponse {
  ProcessedClusters?: Cluster[];
  UnprocessedClusters?: UnprocessedCluster[];
}
export declare class InvalidParameterValueException extends __BaseException {
  readonly name: "InvalidParameterValueException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterValueException, __BaseException>
  );
}
export declare class ServiceUpdateNotFoundFault extends __BaseException {
  readonly name: "ServiceUpdateNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceUpdateNotFoundFault, __BaseException>
  );
}
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface CopySnapshotRequest {
  SourceSnapshotName: string | undefined;
  TargetSnapshotName: string | undefined;
  TargetBucket?: string;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface ShardConfiguration {
  Slots?: string;
  ReplicaCount?: number;
}
export interface ShardDetail {
  Name?: string;
  Configuration?: ShardConfiguration;
  Size?: string;
  SnapshotCreationTime?: Date;
}
export interface ClusterConfiguration {
  Name?: string;
  Description?: string;
  NodeType?: string;
  EngineVersion?: string;
  MaintenanceWindow?: string;
  TopicArn?: string;
  Port?: number;
  ParameterGroupName?: string;
  SubnetGroupName?: string;
  VpcId?: string;
  SnapshotRetentionLimit?: number;
  SnapshotWindow?: string;
  NumShards?: number;
  Shards?: ShardDetail[];
}
export interface Snapshot {
  Name?: string;
  Status?: string;
  Source?: string;
  KmsKeyId?: string;
  ARN?: string;
  ClusterConfiguration?: ClusterConfiguration;
  DataTiering?: DataTieringStatus;
}
export interface CopySnapshotResponse {
  Snapshot?: Snapshot;
}
export declare class InvalidParameterCombinationException extends __BaseException {
  readonly name: "InvalidParameterCombinationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidParameterCombinationException,
      __BaseException
    >
  );
}
export declare class InvalidSnapshotStateFault extends __BaseException {
  readonly name: "InvalidSnapshotStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidSnapshotStateFault, __BaseException>
  );
}
export declare class ServiceLinkedRoleNotFoundFault extends __BaseException {
  readonly name: "ServiceLinkedRoleNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceLinkedRoleNotFoundFault, __BaseException>
  );
}
export declare class SnapshotAlreadyExistsFault extends __BaseException {
  readonly name: "SnapshotAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotAlreadyExistsFault, __BaseException>
  );
}
export declare class SnapshotNotFoundFault extends __BaseException {
  readonly name: "SnapshotNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotNotFoundFault, __BaseException>
  );
}
export declare class SnapshotQuotaExceededFault extends __BaseException {
  readonly name: "SnapshotQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SnapshotQuotaExceededFault, __BaseException>
  );
}
export declare class TagQuotaPerResourceExceeded extends __BaseException {
  readonly name: "TagQuotaPerResourceExceeded";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TagQuotaPerResourceExceeded, __BaseException>
  );
}
export interface CreateACLRequest {
  ACLName: string | undefined;
  UserNames?: string[];
  Tags?: Tag[];
}
export interface CreateACLResponse {
  ACL?: ACL;
}
export declare class DefaultUserRequired extends __BaseException {
  readonly name: "DefaultUserRequired";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<DefaultUserRequired, __BaseException>
  );
}
export declare class DuplicateUserNameFault extends __BaseException {
  readonly name: "DuplicateUserNameFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<DuplicateUserNameFault, __BaseException>
  );
}
export declare class UserNotFoundFault extends __BaseException {
  readonly name: "UserNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<UserNotFoundFault, __BaseException>);
}
export declare class ClusterAlreadyExistsFault extends __BaseException {
  readonly name: "ClusterAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterAlreadyExistsFault, __BaseException>
  );
}
export declare class ClusterQuotaForCustomerExceededFault extends __BaseException {
  readonly name: "ClusterQuotaForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ClusterQuotaForCustomerExceededFault,
      __BaseException
    >
  );
}
export interface CreateClusterRequest {
  ClusterName: string | undefined;
  NodeType: string | undefined;
  ParameterGroupName?: string;
  Description?: string;
  NumShards?: number;
  NumReplicasPerShard?: number;
  SubnetGroupName?: string;
  SecurityGroupIds?: string[];
  MaintenanceWindow?: string;
  Port?: number;
  SnsTopicArn?: string;
  TLSEnabled?: boolean;
  KmsKeyId?: string;
  SnapshotArns?: string[];
  SnapshotName?: string;
  SnapshotRetentionLimit?: number;
  Tags?: Tag[];
  SnapshotWindow?: string;
  ACLName: string | undefined;
  EngineVersion?: string;
  AutoMinorVersionUpgrade?: boolean;
  DataTiering?: boolean;
}
export interface CreateClusterResponse {
  Cluster?: Cluster;
}
export declare class InsufficientClusterCapacityFault extends __BaseException {
  readonly name: "InsufficientClusterCapacityFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InsufficientClusterCapacityFault,
      __BaseException
    >
  );
}
export declare class InvalidACLStateFault extends __BaseException {
  readonly name: "InvalidACLStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidACLStateFault, __BaseException>
  );
}
export declare class InvalidCredentialsException extends __BaseException {
  readonly name: "InvalidCredentialsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidCredentialsException, __BaseException>
  );
}
export declare class InvalidVPCNetworkStateFault extends __BaseException {
  readonly name: "InvalidVPCNetworkStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidVPCNetworkStateFault, __BaseException>
  );
}
export declare class NodeQuotaForClusterExceededFault extends __BaseException {
  readonly name: "NodeQuotaForClusterExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NodeQuotaForClusterExceededFault,
      __BaseException
    >
  );
}
export declare class NodeQuotaForCustomerExceededFault extends __BaseException {
  readonly name: "NodeQuotaForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      NodeQuotaForCustomerExceededFault,
      __BaseException
    >
  );
}
export declare class ParameterGroupNotFoundFault extends __BaseException {
  readonly name: "ParameterGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ParameterGroupNotFoundFault, __BaseException>
  );
}
export declare class ShardsPerClusterQuotaExceededFault extends __BaseException {
  readonly name: "ShardsPerClusterQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ShardsPerClusterQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class SubnetGroupNotFoundFault extends __BaseException {
  readonly name: "SubnetGroupNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetGroupNotFoundFault, __BaseException>
  );
}
export interface CreateParameterGroupRequest {
  ParameterGroupName: string | undefined;
  Family: string | undefined;
  Description?: string;
  Tags?: Tag[];
}
export interface ParameterGroup {
  Name?: string;
  Family?: string;
  Description?: string;
  ARN?: string;
}
export interface CreateParameterGroupResponse {
  ParameterGroup?: ParameterGroup;
}
export declare class InvalidParameterGroupStateFault extends __BaseException {
  readonly name: "InvalidParameterGroupStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      InvalidParameterGroupStateFault,
      __BaseException
    >
  );
}
export declare class ParameterGroupAlreadyExistsFault extends __BaseException {
  readonly name: "ParameterGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ParameterGroupAlreadyExistsFault,
      __BaseException
    >
  );
}
export declare class ParameterGroupQuotaExceededFault extends __BaseException {
  readonly name: "ParameterGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ParameterGroupQuotaExceededFault,
      __BaseException
    >
  );
}
export declare class ClusterNotFoundFault extends __BaseException {
  readonly name: "ClusterNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ClusterNotFoundFault, __BaseException>
  );
}
export interface CreateSnapshotRequest {
  ClusterName: string | undefined;
  SnapshotName: string | undefined;
  KmsKeyId?: string;
  Tags?: Tag[];
}
export interface CreateSnapshotResponse {
  Snapshot?: Snapshot;
}
export declare class InvalidClusterStateFault extends __BaseException {
  readonly name: "InvalidClusterStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidClusterStateFault, __BaseException>
  );
}
export interface CreateSubnetGroupRequest {
  SubnetGroupName: string | undefined;
  Description?: string;
  SubnetIds: string[] | undefined;
  Tags?: Tag[];
}
export interface AvailabilityZone {
  Name?: string;
}
export interface Subnet {
  Identifier?: string;
  AvailabilityZone?: AvailabilityZone;
}
export interface SubnetGroup {
  Name?: string;
  Description?: string;
  VpcId?: string;
  Subnets?: Subnet[];
  ARN?: string;
}
export interface CreateSubnetGroupResponse {
  SubnetGroup?: SubnetGroup;
}
export declare class InvalidSubnet extends __BaseException {
  readonly name: "InvalidSubnet";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidSubnet, __BaseException>);
}
export declare class SubnetGroupAlreadyExistsFault extends __BaseException {
  readonly name: "SubnetGroupAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetGroupAlreadyExistsFault, __BaseException>
  );
}
export declare class SubnetGroupQuotaExceededFault extends __BaseException {
  readonly name: "SubnetGroupQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetGroupQuotaExceededFault, __BaseException>
  );
}
export declare class SubnetNotAllowedFault extends __BaseException {
  readonly name: "SubnetNotAllowedFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetNotAllowedFault, __BaseException>
  );
}
export declare class SubnetQuotaExceededFault extends __BaseException {
  readonly name: "SubnetQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetQuotaExceededFault, __BaseException>
  );
}
export declare const InputAuthenticationType: {
  readonly IAM: "iam";
  readonly PASSWORD: "password";
};
export type InputAuthenticationType =
  (typeof InputAuthenticationType)[keyof typeof InputAuthenticationType];
export interface AuthenticationMode {
  Type?: InputAuthenticationType;
  Passwords?: string[];
}
export interface CreateUserRequest {
  UserName: string | undefined;
  AuthenticationMode: AuthenticationMode | undefined;
  AccessString: string | undefined;
  Tags?: Tag[];
}
export declare const AuthenticationType: {
  readonly IAM: "iam";
  readonly NO_PASSWORD: "no-password";
  readonly PASSWORD: "password";
};
export type AuthenticationType =
  (typeof AuthenticationType)[keyof typeof AuthenticationType];
export interface Authentication {
  Type?: AuthenticationType;
  PasswordCount?: number;
}
export interface User {
  Name?: string;
  Status?: string;
  AccessString?: string;
  ACLNames?: string[];
  MinimumEngineVersion?: string;
  Authentication?: Authentication;
  ARN?: string;
}
export interface CreateUserResponse {
  User?: User;
}
export declare class UserAlreadyExistsFault extends __BaseException {
  readonly name: "UserAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserAlreadyExistsFault, __BaseException>
  );
}
export declare class UserQuotaExceededFault extends __BaseException {
  readonly name: "UserQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UserQuotaExceededFault, __BaseException>
  );
}
export interface DeleteACLRequest {
  ACLName: string | undefined;
}
export interface DeleteACLResponse {
  ACL?: ACL;
}
export interface DeleteClusterRequest {
  ClusterName: string | undefined;
  FinalSnapshotName?: string;
}
export interface DeleteClusterResponse {
  Cluster?: Cluster;
}
export interface DeleteParameterGroupRequest {
  ParameterGroupName: string | undefined;
}
export interface DeleteParameterGroupResponse {
  ParameterGroup?: ParameterGroup;
}
export interface DeleteSnapshotRequest {
  SnapshotName: string | undefined;
}
export interface DeleteSnapshotResponse {
  Snapshot?: Snapshot;
}
export interface DeleteSubnetGroupRequest {
  SubnetGroupName: string | undefined;
}
export interface DeleteSubnetGroupResponse {
  SubnetGroup?: SubnetGroup;
}
export declare class SubnetGroupInUseFault extends __BaseException {
  readonly name: "SubnetGroupInUseFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<SubnetGroupInUseFault, __BaseException>
  );
}
export interface DeleteUserRequest {
  UserName: string | undefined;
}
export interface DeleteUserResponse {
  User?: User;
}
export declare class InvalidUserStateFault extends __BaseException {
  readonly name: "InvalidUserStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidUserStateFault, __BaseException>
  );
}
export interface DescribeACLsRequest {
  ACLName?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface DescribeACLsResponse {
  ACLs?: ACL[];
  NextToken?: string;
}
export interface DescribeClustersRequest {
  ClusterName?: string;
  MaxResults?: number;
  NextToken?: string;
  ShowShardDetails?: boolean;
}
export interface DescribeClustersResponse {
  NextToken?: string;
  Clusters?: Cluster[];
}
export interface DescribeEngineVersionsRequest {
  EngineVersion?: string;
  ParameterGroupFamily?: string;
  MaxResults?: number;
  NextToken?: string;
  DefaultOnly?: boolean;
}
export interface EngineVersionInfo {
  EngineVersion?: string;
  EnginePatchVersion?: string;
  ParameterGroupFamily?: string;
}
export interface DescribeEngineVersionsResponse {
  NextToken?: string;
  EngineVersions?: EngineVersionInfo[];
}
export declare const SourceType: {
  readonly acl: "acl";
  readonly cluster: "cluster";
  readonly node: "node";
  readonly parameter_group: "parameter-group";
  readonly subnet_group: "subnet-group";
  readonly user: "user";
};
export type SourceType = (typeof SourceType)[keyof typeof SourceType];
export interface DescribeEventsRequest {
  SourceName?: string;
  SourceType?: SourceType;
  StartTime?: Date;
  EndTime?: Date;
  Duration?: number;
  MaxResults?: number;
  NextToken?: string;
}
export interface Event {
  SourceName?: string;
  SourceType?: SourceType;
  Message?: string;
  Date?: Date;
}
export interface DescribeEventsResponse {
  NextToken?: string;
  Events?: Event[];
}
export interface DescribeParameterGroupsRequest {
  ParameterGroupName?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface DescribeParameterGroupsResponse {
  NextToken?: string;
  ParameterGroups?: ParameterGroup[];
}
export interface DescribeParametersRequest {
  ParameterGroupName: string | undefined;
  MaxResults?: number;
  NextToken?: string;
}
export interface Parameter {
  Name?: string;
  Value?: string;
  Description?: string;
  DataType?: string;
  AllowedValues?: string;
  MinimumEngineVersion?: string;
}
export interface DescribeParametersResponse {
  NextToken?: string;
  Parameters?: Parameter[];
}
export interface DescribeReservedNodesRequest {
  ReservationId?: string;
  ReservedNodesOfferingId?: string;
  NodeType?: string;
  Duration?: string;
  OfferingType?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface RecurringCharge {
  RecurringChargeAmount?: number;
  RecurringChargeFrequency?: string;
}
export interface ReservedNode {
  ReservationId?: string;
  ReservedNodesOfferingId?: string;
  NodeType?: string;
  StartTime?: Date;
  Duration?: number;
  FixedPrice?: number;
  NodeCount?: number;
  OfferingType?: string;
  State?: string;
  RecurringCharges?: RecurringCharge[];
  ARN?: string;
}
export interface DescribeReservedNodesResponse {
  NextToken?: string;
  ReservedNodes?: ReservedNode[];
}
export declare class ReservedNodeNotFoundFault extends __BaseException {
  readonly name: "ReservedNodeNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedNodeNotFoundFault, __BaseException>
  );
}
export interface DescribeReservedNodesOfferingsRequest {
  ReservedNodesOfferingId?: string;
  NodeType?: string;
  Duration?: string;
  OfferingType?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface ReservedNodesOffering {
  ReservedNodesOfferingId?: string;
  NodeType?: string;
  Duration?: number;
  FixedPrice?: number;
  OfferingType?: string;
  RecurringCharges?: RecurringCharge[];
}
export interface DescribeReservedNodesOfferingsResponse {
  NextToken?: string;
  ReservedNodesOfferings?: ReservedNodesOffering[];
}
export declare class ReservedNodesOfferingNotFoundFault extends __BaseException {
  readonly name: "ReservedNodesOfferingNotFoundFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReservedNodesOfferingNotFoundFault,
      __BaseException
    >
  );
}
export interface DescribeServiceUpdatesRequest {
  ServiceUpdateName?: string;
  ClusterNames?: string[];
  Status?: ServiceUpdateStatus[];
  MaxResults?: number;
  NextToken?: string;
}
export declare const ServiceUpdateType: {
  readonly SECURITY_UPDATE: "security-update";
};
export type ServiceUpdateType =
  (typeof ServiceUpdateType)[keyof typeof ServiceUpdateType];
export interface ServiceUpdate {
  ClusterName?: string;
  ServiceUpdateName?: string;
  ReleaseDate?: Date;
  Description?: string;
  Status?: ServiceUpdateStatus;
  Type?: ServiceUpdateType;
  NodesUpdated?: string;
  AutoUpdateStartDate?: Date;
}
export interface DescribeServiceUpdatesResponse {
  NextToken?: string;
  ServiceUpdates?: ServiceUpdate[];
}
export interface DescribeSnapshotsRequest {
  ClusterName?: string;
  SnapshotName?: string;
  Source?: string;
  NextToken?: string;
  MaxResults?: number;
  ShowDetail?: boolean;
}
export interface DescribeSnapshotsResponse {
  NextToken?: string;
  Snapshots?: Snapshot[];
}
export interface DescribeSubnetGroupsRequest {
  SubnetGroupName?: string;
  MaxResults?: number;
  NextToken?: string;
}
export interface DescribeSubnetGroupsResponse {
  NextToken?: string;
  SubnetGroups?: SubnetGroup[];
}
export interface Filter {
  Name: string | undefined;
  Values: string[] | undefined;
}
export interface DescribeUsersRequest {
  UserName?: string;
  Filters?: Filter[];
  MaxResults?: number;
  NextToken?: string;
}
export interface DescribeUsersResponse {
  Users?: User[];
  NextToken?: string;
}
export declare class APICallRateForCustomerExceededFault extends __BaseException {
  readonly name: "APICallRateForCustomerExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      APICallRateForCustomerExceededFault,
      __BaseException
    >
  );
}
export interface FailoverShardRequest {
  ClusterName: string | undefined;
  ShardName: string | undefined;
}
export interface FailoverShardResponse {
  Cluster?: Cluster;
}
export declare class InvalidKMSKeyFault extends __BaseException {
  readonly name: "InvalidKMSKeyFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidKMSKeyFault, __BaseException>);
}
export declare class ShardNotFoundFault extends __BaseException {
  readonly name: "ShardNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ShardNotFoundFault, __BaseException>);
}
export declare class TestFailoverNotAvailableFault extends __BaseException {
  readonly name: "TestFailoverNotAvailableFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TestFailoverNotAvailableFault, __BaseException>
  );
}
export interface ListAllowedNodeTypeUpdatesRequest {
  ClusterName: string | undefined;
}
export interface ListAllowedNodeTypeUpdatesResponse {
  ScaleUpNodeTypes?: string[];
  ScaleDownNodeTypes?: string[];
}
export declare class InvalidARNFault extends __BaseException {
  readonly name: "InvalidARNFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<InvalidARNFault, __BaseException>);
}
export interface ListTagsRequest {
  ResourceArn: string | undefined;
}
export interface ListTagsResponse {
  TagList?: Tag[];
}
export interface PurchaseReservedNodesOfferingRequest {
  ReservedNodesOfferingId: string | undefined;
  ReservationId?: string;
  NodeCount?: number;
  Tags?: Tag[];
}
export interface PurchaseReservedNodesOfferingResponse {
  ReservedNode?: ReservedNode;
}
export declare class ReservedNodeAlreadyExistsFault extends __BaseException {
  readonly name: "ReservedNodeAlreadyExistsFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedNodeAlreadyExistsFault, __BaseException>
  );
}
export declare class ReservedNodeQuotaExceededFault extends __BaseException {
  readonly name: "ReservedNodeQuotaExceededFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ReservedNodeQuotaExceededFault, __BaseException>
  );
}
export interface ResetParameterGroupRequest {
  ParameterGroupName: string | undefined;
  AllParameters?: boolean;
  ParameterNames?: string[];
}
export interface ResetParameterGroupResponse {
  ParameterGroup?: ParameterGroup;
}
export interface TagResourceRequest {
  ResourceArn: string | undefined;
  Tags: Tag[] | undefined;
}
export interface TagResourceResponse {
  TagList?: Tag[];
}
export declare class TagNotFoundFault extends __BaseException {
  readonly name: "TagNotFoundFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<TagNotFoundFault, __BaseException>);
}
export interface UntagResourceRequest {
  ResourceArn: string | undefined;
  TagKeys: string[] | undefined;
}
export interface UntagResourceResponse {
  TagList?: Tag[];
}
export interface UpdateACLRequest {
  ACLName: string | undefined;
  UserNamesToAdd?: string[];
  UserNamesToRemove?: string[];
}
export interface UpdateACLResponse {
  ACL?: ACL;
}
export declare class InvalidNodeStateFault extends __BaseException {
  readonly name: "InvalidNodeStateFault";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidNodeStateFault, __BaseException>
  );
}
export declare class NoOperationFault extends __BaseException {
  readonly name: "NoOperationFault";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<NoOperationFault, __BaseException>);
}
export interface ReplicaConfigurationRequest {
  ReplicaCount?: number;
}
export interface ShardConfigurationRequest {
  ShardCount?: number;
}
export interface UpdateClusterRequest {
  ClusterName: string | undefined;
  Description?: string;
  SecurityGroupIds?: string[];
  MaintenanceWindow?: string;
  SnsTopicArn?: string;
  SnsTopicStatus?: string;
  ParameterGroupName?: string;
  SnapshotWindow?: string;
  SnapshotRetentionLimit?: number;
  NodeType?: string;
  EngineVersion?: string;
  ReplicaConfiguration?: ReplicaConfigurationRequest;
  ShardConfiguration?: ShardConfigurationRequest;
  ACLName?: string;
}
export interface UpdateClusterResponse {
  Cluster?: Cluster;
}
export interface ParameterNameValue {
  ParameterName?: string;
  ParameterValue?: string;
}
export interface UpdateParameterGroupRequest {
  ParameterGroupName: string | undefined;
  ParameterNameValues: ParameterNameValue[] | undefined;
}
export interface UpdateParameterGroupResponse {
  ParameterGroup?: ParameterGroup;
}
export declare class SubnetInUse extends __BaseException {
  readonly name: "SubnetInUse";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<SubnetInUse, __BaseException>);
}
export interface UpdateSubnetGroupRequest {
  SubnetGroupName: string | undefined;
  Description?: string;
  SubnetIds?: string[];
}
export interface UpdateSubnetGroupResponse {
  SubnetGroup?: SubnetGroup;
}
export interface UpdateUserRequest {
  UserName: string | undefined;
  AuthenticationMode?: AuthenticationMode;
  AccessString?: string;
}
export interface UpdateUserResponse {
  User?: User;
}
