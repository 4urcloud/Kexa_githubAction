import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { MigrationHubStrategyServiceException as __BaseException } from "./MigrationHubStrategyServiceException";
/**
 * <p> The user does not have permission to perform the action. Check the
 *       AWS Identity and Access Management (IAM) policy associated with this user.</p>
 * @public
 */
export declare class AccessDeniedException extends __BaseException {
    readonly name: "AccessDeniedException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
}
/**
 * @public
 * @enum
 */
export declare const RuntimeAnalysisStatus: {
    readonly ANALYSIS_FAILED: "ANALYSIS_FAILED";
    readonly ANALYSIS_STARTED: "ANALYSIS_STARTED";
    readonly ANALYSIS_SUCCESS: "ANALYSIS_SUCCESS";
    readonly ANALYSIS_TO_BE_SCHEDULED: "ANALYSIS_TO_BE_SCHEDULED";
};
/**
 * @public
 */
export type RuntimeAnalysisStatus = (typeof RuntimeAnalysisStatus)[keyof typeof RuntimeAnalysisStatus];
/**
 * @public
 * @enum
 */
export declare const SrcCodeOrDbAnalysisStatus: {
    readonly ANALYSIS_FAILED: "ANALYSIS_FAILED";
    readonly ANALYSIS_PARTIAL_SUCCESS: "ANALYSIS_PARTIAL_SUCCESS";
    readonly ANALYSIS_STARTED: "ANALYSIS_STARTED";
    readonly ANALYSIS_SUCCESS: "ANALYSIS_SUCCESS";
    readonly ANALYSIS_TO_BE_SCHEDULED: "ANALYSIS_TO_BE_SCHEDULED";
    readonly CONFIGURED: "CONFIGURED";
    readonly UNCONFIGURED: "UNCONFIGURED";
};
/**
 * @public
 */
export type SrcCodeOrDbAnalysisStatus = (typeof SrcCodeOrDbAnalysisStatus)[keyof typeof SrcCodeOrDbAnalysisStatus];
/**
 * <p>A combination of existing analysis statuses.</p>
 * @public
 */
export type AnalysisStatusUnion = AnalysisStatusUnion.RuntimeAnalysisStatusMember | AnalysisStatusUnion.SrcCodeOrDbAnalysisStatusMember | AnalysisStatusUnion.$UnknownMember;
/**
 * @public
 */
export declare namespace AnalysisStatusUnion {
    /**
     * <p>The status of the analysis.</p>
     * @public
     */
    interface RuntimeAnalysisStatusMember {
        runtimeAnalysisStatus: RuntimeAnalysisStatus;
        srcCodeOrDbAnalysisStatus?: never;
        $unknown?: never;
    }
    /**
     * <p>The status of the source code or database analysis.</p>
     * @public
     */
    interface SrcCodeOrDbAnalysisStatusMember {
        runtimeAnalysisStatus?: never;
        srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus;
        $unknown?: never;
    }
    /**
     * @public
     */
    interface $UnknownMember {
        runtimeAnalysisStatus?: never;
        srcCodeOrDbAnalysisStatus?: never;
        $unknown: [string, any];
    }
    interface Visitor<T> {
        runtimeAnalysisStatus: (value: RuntimeAnalysisStatus) => T;
        srcCodeOrDbAnalysisStatus: (value: SrcCodeOrDbAnalysisStatus) => T;
        _: (name: string, value: any) => T;
    }
    const visit: <T>(value: AnalysisStatusUnion, visitor: Visitor<T>) => T;
}
/**
 * @public
 * @enum
 */
export declare const AnalysisType: {
    readonly BINARY_ANALYSIS: "BINARY_ANALYSIS";
    readonly DATABASE_ANALYSIS: "DATABASE_ANALYSIS";
    readonly RUNTIME_ANALYSIS: "RUNTIME_ANALYSIS";
    readonly SOURCE_CODE_ANALYSIS: "SOURCE_CODE_ANALYSIS";
};
/**
 * @public
 */
export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType];
/**
 * Summary information about an analyzable server.
 * @public
 */
export interface AnalyzableServerSummary {
    /**
     * The host name of the analyzable server.
     * @public
     */
    hostname?: string;
    /**
     * The ip address of the analyzable server.
     * @public
     */
    ipAddress?: string;
    /**
     * The data source of the analyzable server.
     * @public
     */
    source?: string;
    /**
     * The virtual machine id of the analyzable server.
     * @public
     */
    vmId?: string;
}
/**
 * @public
 * @enum
 */
export declare const BinaryAnalyzerName: {
    readonly BYTECODE_ANALYZER: "BYTECODE_ANALYZER";
    readonly DLL_ANALYZER: "DLL_ANALYZER";
};
/**
 * @public
 */
export type BinaryAnalyzerName = (typeof BinaryAnalyzerName)[keyof typeof BinaryAnalyzerName];
/**
 * @public
 * @enum
 */
export declare const RunTimeAnalyzerName: {
    readonly A2C_ANALYZER: "A2C_ANALYZER";
    readonly DATABASE_ANALYZER: "DATABASE_ANALYZER";
    readonly EMP_PA_ANALYZER: "EMP_PA_ANALYZER";
    readonly REHOST_ANALYZER: "REHOST_ANALYZER";
    readonly SCT_ANALYZER: "SCT_ANALYZER";
};
/**
 * @public
 */
export type RunTimeAnalyzerName = (typeof RunTimeAnalyzerName)[keyof typeof RunTimeAnalyzerName];
/**
 * @public
 * @enum
 */
export declare const SourceCodeAnalyzerName: {
    readonly BYTECODE_ANALYZER: "BYTECODE_ANALYZER";
    readonly CSHARP_ANALYZER: "CSHARP_ANALYZER";
    readonly JAVA_ANALYZER: "JAVA_ANALYZER";
    readonly PORTING_ASSISTANT: "PORTING_ASSISTANT";
};
/**
 * @public
 */
export type SourceCodeAnalyzerName = (typeof SourceCodeAnalyzerName)[keyof typeof SourceCodeAnalyzerName];
/**
 * <p>The combination of the existing analyzers.</p>
 * @public
 */
export type AnalyzerNameUnion = AnalyzerNameUnion.BinaryAnalyzerNameMember | AnalyzerNameUnion.RunTimeAnalyzerNameMember | AnalyzerNameUnion.SourceCodeAnalyzerNameMember | AnalyzerNameUnion.$UnknownMember;
/**
 * @public
 */
export declare namespace AnalyzerNameUnion {
    /**
     * <p>The binary analyzer names.</p>
     * @public
     */
    interface BinaryAnalyzerNameMember {
        binaryAnalyzerName: BinaryAnalyzerName;
        runTimeAnalyzerName?: never;
        sourceCodeAnalyzerName?: never;
        $unknown?: never;
    }
    /**
     * <p>The assessment analyzer names.</p>
     * @public
     */
    interface RunTimeAnalyzerNameMember {
        binaryAnalyzerName?: never;
        runTimeAnalyzerName: RunTimeAnalyzerName;
        sourceCodeAnalyzerName?: never;
        $unknown?: never;
    }
    /**
     * <p>The source code analyzer names.</p>
     * @public
     */
    interface SourceCodeAnalyzerNameMember {
        binaryAnalyzerName?: never;
        runTimeAnalyzerName?: never;
        sourceCodeAnalyzerName: SourceCodeAnalyzerName;
        $unknown?: never;
    }
    /**
     * @public
     */
    interface $UnknownMember {
        binaryAnalyzerName?: never;
        runTimeAnalyzerName?: never;
        sourceCodeAnalyzerName?: never;
        $unknown: [string, any];
    }
    interface Visitor<T> {
        binaryAnalyzerName: (value: BinaryAnalyzerName) => T;
        runTimeAnalyzerName: (value: RunTimeAnalyzerName) => T;
        sourceCodeAnalyzerName: (value: SourceCodeAnalyzerName) => T;
        _: (name: string, value: any) => T;
    }
    const visit: <T>(value: AnalyzerNameUnion, visitor: Visitor<T>) => T;
}
/**
 * <p> Contains the S3 bucket name and the Amazon S3 key name. </p>
 * @public
 */
export interface S3Object {
    /**
     * <p> The S3 bucket name. </p>
     * @public
     */
    s3Bucket?: string;
    /**
     * <p> The Amazon S3 key name. </p>
     * @public
     */
    s3key?: string;
}
/**
 * @public
 * @enum
 */
export declare const AntipatternReportStatus: {
    readonly FAILED: "FAILED";
    readonly IN_PROGRESS: "IN_PROGRESS";
    readonly SUCCESS: "SUCCESS";
};
/**
 * @public
 */
export type AntipatternReportStatus = (typeof AntipatternReportStatus)[keyof typeof AntipatternReportStatus];
/**
 * <p>The anti-pattern report result.</p>
 * @public
 */
export interface AntipatternReportResult {
    /**
     * <p>The analyzer name.</p>
     * @public
     */
    analyzerName?: AnalyzerNameUnion;
    /**
     * <p> Contains the S3 bucket name and the Amazon S3 key name. </p>
     * @public
     */
    antiPatternReportS3Object?: S3Object;
    /**
     * <p>The status of the anti-pattern report generation.</p>
     * @public
     */
    antipatternReportStatus?: AntipatternReportStatus;
    /**
     * <p>The status message for the anti-pattern.</p>
     * @public
     */
    antipatternReportStatusMessage?: string;
}
/**
 * @public
 * @enum
 */
export declare const Severity: {
    readonly HIGH: "HIGH";
    readonly LOW: "LOW";
    readonly MEDIUM: "MEDIUM";
};
/**
 * @public
 */
export type Severity = (typeof Severity)[keyof typeof Severity];
/**
 * <p> Contains the summary of anti-patterns and their severity. </p>
 * @public
 */
export interface AntipatternSeveritySummary {
    /**
     * <p> Contains the severity of anti-patterns. </p>
     * @public
     */
    severity?: Severity;
    /**
     * <p> Contains the count of anti-patterns. </p>
     * @public
     */
    count?: number;
}
/**
 * @public
 * @enum
 */
export declare const ApplicationComponentCriteria: {
    readonly ANALYSIS_STATUS: "ANALYSIS_STATUS";
    readonly APP_NAME: "APP_NAME";
    readonly APP_TYPE: "APP_TYPE";
    readonly DESTINATION: "DESTINATION";
    readonly ERROR_CATEGORY: "ERROR_CATEGORY";
    readonly NOT_DEFINED: "NOT_DEFINED";
    readonly SERVER_ID: "SERVER_ID";
    readonly STRATEGY: "STRATEGY";
};
/**
 * @public
 */
export type ApplicationComponentCriteria = (typeof ApplicationComponentCriteria)[keyof typeof ApplicationComponentCriteria];
/**
 * @public
 * @enum
 */
export declare const AppType: {
    readonly IIS: "IIS";
    readonly cassandra: "Cassandra";
    readonly db2: "DB2";
    readonly dotNetFramework: "DotNetFramework";
    readonly dotnet: "Dotnet";
    readonly dotnetcore: "DotnetCore";
    readonly java: "Java";
    readonly jboss: "JBoss";
    readonly mariadb: "Maria DB";
    readonly mongodb: "Mongo DB";
    readonly mysql: "MySQL";
    readonly oracle: "Oracle";
    readonly other: "Other";
    readonly postgresqlserver: "PostgreSQLServer";
    readonly spring: "Spring";
    readonly sqlServer: "SQLServer";
    readonly sybase: "Sybase";
    readonly tomcat: "Tomcat";
    readonly unknown: "Unknown";
    readonly visualbasic: "Visual Basic";
    readonly weblogic: "Oracle WebLogic";
    readonly websphere: "IBM WebSphere";
};
/**
 * @public
 */
export type AppType = (typeof AppType)[keyof typeof AppType];
/**
 * @public
 * @enum
 */
export declare const AppUnitErrorCategory: {
    readonly CONNECTIVITY_ERROR: "CONNECTIVITY_ERROR";
    readonly CREDENTIAL_ERROR: "CREDENTIAL_ERROR";
    readonly OTHER_ERROR: "OTHER_ERROR";
    readonly PERMISSION_ERROR: "PERMISSION_ERROR";
    readonly UNSUPPORTED_ERROR: "UNSUPPORTED_ERROR";
};
/**
 * @public
 */
export type AppUnitErrorCategory = (typeof AppUnitErrorCategory)[keyof typeof AppUnitErrorCategory];
/**
 * <p>Error in the analysis of the application unit.</p>
 * @public
 */
export interface AppUnitError {
    /**
     * <p>The category of the error.</p>
     * @public
     */
    appUnitErrorCategory?: AppUnitErrorCategory;
}
/**
 * <p> Configuration information used for assessing databases. </p>
 * @public
 */
export interface DatabaseConfigDetail {
    /**
     * <p> AWS Secrets Manager key that holds the credentials that you use to connect to a database.
     *     </p>
     * @public
     */
    secretName?: string;
}
/**
 * @public
 * @enum
 */
export declare const InclusionStatus: {
    readonly EXCLUDE_FROM_RECOMMENDATION: "excludeFromAssessment";
    readonly INCLUDE_IN_RECOMMENDATION: "includeInAssessment";
};
/**
 * @public
 */
export type InclusionStatus = (typeof InclusionStatus)[keyof typeof InclusionStatus];
/**
 * @public
 * @enum
 */
export declare const Strategy: {
    readonly REFACTOR: "Refactor";
    readonly REHOST: "Rehost";
    readonly RELOCATE: "Relocate";
    readonly REPLATFORM: "Replatform";
    readonly REPURCHASE: "Repurchase";
    readonly RETAIN: "Retain";
    readonly RETIREMENT: "Retirement";
};
/**
 * @public
 */
export type Strategy = (typeof Strategy)[keyof typeof Strategy];
/**
 * @public
 * @enum
 */
export declare const TargetDestination: {
    readonly AMAZON_DOCUMENTDB: "Amazon DocumentDB";
    readonly AMAZON_DYNAMODB: "Amazon DynamoDB";
    readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
    readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
    readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
    readonly AMAZON_RDS: "Amazon Relational Database Service";
    readonly AMAZON_RDS_MYSQL: "Amazon Relational Database Service on MySQL";
    readonly AMAZON_RDS_POSTGRESQL: "Amazon Relational Database Service on PostgreSQL";
    readonly AURORA_MYSQL: "Aurora MySQL";
    readonly AURORA_POSTGRESQL: "Aurora PostgreSQL";
    readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
    readonly AWS_FARGATE: "AWS Fargate";
    readonly BABELFISH_AURORA_POSTGRESQL: "Babelfish for Aurora PostgreSQL";
    readonly NONE_SPECIFIED: "None specified";
};
/**
 * @public
 */
export type TargetDestination = (typeof TargetDestination)[keyof typeof TargetDestination];
/**
 * @public
 * @enum
 */
export declare const TransformationToolName: {
    readonly APP2CONTAINER: "App2Container";
    readonly DMS: "Database Migration Service";
    readonly EMP: "End of Support Migration";
    readonly IN_PLACE_OS_UPGRADE: "In Place Operating System Upgrade";
    readonly MGN: "Application Migration Service";
    readonly NATIVE_SQL: "Native SQL Server Backup/Restore";
    readonly PORTING_ASSISTANT: "Porting Assistant For .NET";
    readonly SCT: "Schema Conversion Tool";
    readonly STRATEGY_RECOMMENDATION_SUPPORT: "Strategy Recommendation Support";
    readonly WWAMA: "Windows Web Application Migration Assistant";
};
/**
 * @public
 */
export type TransformationToolName = (typeof TransformationToolName)[keyof typeof TransformationToolName];
/**
 * <p> Information of the transformation tool that can be used to migrate and modernize the
 *       application. </p>
 * @public
 */
export interface TransformationTool {
    /**
     * <p> Name of the tool. </p>
     * @public
     */
    name?: TransformationToolName;
    /**
     * <p> Description of the tool. </p>
     * @public
     */
    description?: string;
    /**
     * <p> URL for installing the tool. </p>
     * @public
     */
    tranformationToolInstallationLink?: string;
}
/**
 * <p> Contains a recommendation set. </p>
 * @public
 */
export interface RecommendationSet {
    /**
     * <p> The target destination for the recommendation set. </p>
     * @public
     */
    transformationTool?: TransformationTool;
    /**
     * <p> The recommended target destination. </p>
     * @public
     */
    targetDestination?: TargetDestination;
    /**
     * <p> The recommended strategy. </p>
     * @public
     */
    strategy?: Strategy;
}
/**
 * @public
 * @enum
 */
export declare const ResourceSubType: {
    readonly DATABASE: "Database";
    readonly DATABASE_PROCESS: "DatabaseProcess";
    readonly PROCESS: "Process";
};
/**
 * @public
 */
export type ResourceSubType = (typeof ResourceSubType)[keyof typeof ResourceSubType];
/**
 * <p>The error in server analysis.</p>
 * @public
 */
export interface Result {
    /**
     * <p>The error in server analysis.</p>
     * @public
     */
    analysisType?: AnalysisType;
    /**
     * <p>The error in server analysis.</p>
     * @public
     */
    analysisStatus?: AnalysisStatusUnion;
    /**
     * <p>The error in server analysis.</p>
     * @public
     */
    statusMessage?: string;
    /**
     * <p>The error in server analysis.</p>
     * @public
     */
    antipatternReportResultList?: AntipatternReportResult[];
}
/**
 * <p> Object containing source code information that is linked to an application component.
 *     </p>
 * @public
 */
export interface SourceCodeRepository {
    /**
     * <p> The repository name for the source code. </p>
     * @public
     */
    repository?: string;
    /**
     * <p> The branch of the source code. </p>
     * @public
     */
    branch?: string;
    /**
     * <p> The type of repository to use for the source code. </p>
     * @public
     */
    versionControlType?: string;
    /**
     * <p>The name of the project.</p>
     * @public
     */
    projectName?: string;
}
/**
 * <p> Contains detailed information about an application component. </p>
 * @public
 */
export interface ApplicationComponentDetail {
    /**
     * <p> The ID of the application component. </p>
     * @public
     */
    id?: string;
    /**
     * <p> The name of application component. </p>
     * @public
     */
    name?: string;
    /**
     * <p> The top recommendation set for the application component. </p>
     * @public
     */
    recommendationSet?: RecommendationSet;
    /**
     * <p> The status of analysis, if the application component has source code or an associated
     *       database. </p>
     * @public
     */
    analysisStatus?: SrcCodeOrDbAnalysisStatus;
    /**
     * <p> A detailed description of the analysis status and any failure message. </p>
     * @public
     */
    statusMessage?: string;
    /**
     * <p> A list of anti-pattern severity summaries. </p>
     * @public
     */
    listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
    /**
     * <p> Configuration details for the database associated with the application component. </p>
     * @public
     */
    databaseConfigDetail?: DatabaseConfigDetail;
    /**
     * <p> Details about the source code repository associated with the application component.
     *     </p>
     * @public
     */
    sourceCodeRepositories?: SourceCodeRepository[];
    /**
     * <p> The type of application component. </p>
     * @public
     */
    appType?: AppType;
    /**
     * <p> The application component subtype.</p>
     * @public
     */
    resourceSubType?: ResourceSubType;
    /**
     * <p> Indicates whether the application component has been included for server recommendation
     *       or not. </p>
     * @public
     */
    inclusionStatus?: InclusionStatus;
    /**
     * <p> The S3 bucket name and the Amazon S3 key name for the anti-pattern report. </p>
     * @public
     */
    antipatternReportS3Object?: S3Object;
    /**
     * <p> The status of the anti-pattern report generation.</p>
     * @public
     */
    antipatternReportStatus?: AntipatternReportStatus;
    /**
     * <p> The status message for the anti-pattern. </p>
     * @public
     */
    antipatternReportStatusMessage?: string;
    /**
     * <p> OS version. </p>
     * @public
     */
    osVersion?: string;
    /**
     * <p> OS driver. </p>
     * @public
     */
    osDriver?: string;
    /**
     * <p> The timestamp of when the application component was assessed. </p>
     * @public
     */
    lastAnalyzedTimestamp?: Date;
    /**
     * <p> The ID of the server that the application component is running on. </p>
     * @public
     */
    associatedServerId?: string;
    /**
     * <p> Set to true if the application component is running on multiple servers.</p>
     * @public
     */
    moreServerAssociationExists?: boolean;
    /**
     * <p>The status of the application unit.</p>
     * @public
     */
    runtimeStatus?: RuntimeAnalysisStatus;
    /**
     * <p>The status message for the application unit.</p>
     * @public
     */
    runtimeStatusMessage?: string;
    /**
     * <p>The error in the analysis of the source code or database.</p>
     * @public
     */
    appUnitError?: AppUnitError;
    /**
     * <p>A list of the analysis results.</p>
     * @public
     */
    resultList?: Result[];
}
/**
 * <p>Summary of the analysis status of the application component.</p>
 * @public
 */
export interface ApplicationComponentStatusSummary {
    /**
     * <p>The status of database analysis.</p>
     * @public
     */
    srcCodeOrDbAnalysisStatus?: SrcCodeOrDbAnalysisStatus;
    /**
     * <p>The number of application components successfully analyzed, partially successful or failed
     *       analysis.</p>
     * @public
     */
    count?: number;
}
/**
 * @public
 * @enum
 */
export declare const StrategyRecommendation: {
    readonly NOT_RECOMMENDED: "notRecommended";
    readonly POTENTIAL: "potential";
    readonly RECOMMENDED: "recommended";
    readonly VIABLE_OPTION: "viableOption";
};
/**
 * @public
 */
export type StrategyRecommendation = (typeof StrategyRecommendation)[keyof typeof StrategyRecommendation];
/**
 * <p> Contains information about a strategy recommendation for an application component.
 *     </p>
 * @public
 */
export interface ApplicationComponentStrategy {
    /**
     * <p> Strategy recommendation for the application component. </p>
     * @public
     */
    recommendation?: RecommendationSet;
    /**
     * <p> The recommendation status of a strategy for an application component. </p>
     * @public
     */
    status?: StrategyRecommendation;
    /**
     * <p> Set to true if the recommendation is set as preferred. </p>
     * @public
     */
    isPreferred?: boolean;
}
/**
 * <p> Contains the summary of application components. </p>
 * @public
 */
export interface ApplicationComponentSummary {
    /**
     * <p> Contains the name of application types. </p>
     * @public
     */
    appType?: AppType;
    /**
     * <p> Contains the count of application type. </p>
     * @public
     */
    count?: number;
}
/**
 * @public
 * @enum
 */
export declare const ApplicationMode: {
    readonly ALL: "ALL";
    readonly KNOWN: "KNOWN";
    readonly UNKNOWN: "UNKNOWN";
};
/**
 * @public
 */
export type ApplicationMode = (typeof ApplicationMode)[keyof typeof ApplicationMode];
/**
 * @public
 * @enum
 */
export declare const AwsManagedTargetDestination: {
    readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
    readonly AWS_FARGATE: "AWS Fargate";
    readonly NONE_SPECIFIED: "None specified";
};
/**
 * @public
 */
export type AwsManagedTargetDestination = (typeof AwsManagedTargetDestination)[keyof typeof AwsManagedTargetDestination];
/**
 * <p> Object containing the choice of application destination that you specify. </p>
 * @public
 */
export interface AwsManagedResources {
    /**
     * <p> The choice of application destination that you specify. </p>
     * @public
     */
    targetDestination: AwsManagedTargetDestination[] | undefined;
}
/**
 * @public
 * @enum
 */
export declare const NoPreferenceTargetDestination: {
    readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
    readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
    readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
    readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
    readonly AWS_FARGATE: "AWS Fargate";
    readonly NONE_SPECIFIED: "None specified";
};
/**
 * @public
 */
export type NoPreferenceTargetDestination = (typeof NoPreferenceTargetDestination)[keyof typeof NoPreferenceTargetDestination];
/**
 * <p> Object containing the choice of application destination that you specify. </p>
 * @public
 */
export interface NoManagementPreference {
    /**
     * <p> The choice of application destination that you specify. </p>
     * @public
     */
    targetDestination: NoPreferenceTargetDestination[] | undefined;
}
/**
 * @public
 * @enum
 */
export declare const SelfManageTargetDestination: {
    readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
    readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
    readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
    readonly NONE_SPECIFIED: "None specified";
};
/**
 * @public
 */
export type SelfManageTargetDestination = (typeof SelfManageTargetDestination)[keyof typeof SelfManageTargetDestination];
/**
 * <p> Self-managed resources. </p>
 * @public
 */
export interface SelfManageResources {
    /**
     * <p> Self-managed resources target destination. </p>
     * @public
     */
    targetDestination: SelfManageTargetDestination[] | undefined;
}
/**
 * <p> Preferences for migrating an application to AWS. </p>
 * @public
 */
export type ManagementPreference = ManagementPreference.AwsManagedResourcesMember | ManagementPreference.NoPreferenceMember | ManagementPreference.SelfManageResourcesMember | ManagementPreference.$UnknownMember;
/**
 * @public
 */
export declare namespace ManagementPreference {
    /**
     * <p> Indicates interest in solutions that are managed by AWS. </p>
     * @public
     */
    interface AwsManagedResourcesMember {
        awsManagedResources: AwsManagedResources;
        selfManageResources?: never;
        noPreference?: never;
        $unknown?: never;
    }
    /**
     * <p> Indicates interest in managing your own resources on AWS. </p>
     * @public
     */
    interface SelfManageResourcesMember {
        awsManagedResources?: never;
        selfManageResources: SelfManageResources;
        noPreference?: never;
        $unknown?: never;
    }
    /**
     * <p> No specific preference. </p>
     * @public
     */
    interface NoPreferenceMember {
        awsManagedResources?: never;
        selfManageResources?: never;
        noPreference: NoManagementPreference;
        $unknown?: never;
    }
    /**
     * @public
     */
    interface $UnknownMember {
        awsManagedResources?: never;
        selfManageResources?: never;
        noPreference?: never;
        $unknown: [string, any];
    }
    interface Visitor<T> {
        awsManagedResources: (value: AwsManagedResources) => T;
        selfManageResources: (value: SelfManageResources) => T;
        noPreference: (value: NoManagementPreference) => T;
        _: (name: string, value: any) => T;
    }
    const visit: <T>(value: ManagementPreference, visitor: Visitor<T>) => T;
}
/**
 * <p> Application preferences that you specify. </p>
 * @public
 */
export interface ApplicationPreferences {
    /**
     * <p> Application preferences that you specify to prefer managed environment. </p>
     * @public
     */
    managementPreference?: ManagementPreference;
}
/**
 * @public
 * @enum
 */
export declare const AssessmentDataSourceType: {
    readonly ADS: "ApplicationDiscoveryService";
    readonly MANUAL_IMPORT: "ManualImport";
    readonly SR_COLLECTOR: "StrategyRecommendationsApplicationDataCollector";
};
/**
 * @public
 */
export type AssessmentDataSourceType = (typeof AssessmentDataSourceType)[keyof typeof AssessmentDataSourceType];
/**
 * @public
 * @enum
 */
export declare const AssessmentStatus: {
    readonly COMPLETE: "COMPLETE";
    readonly FAILED: "FAILED";
    readonly IN_PROGRESS: "IN_PROGRESS";
    readonly STOPPED: "STOPPED";
};
/**
 * @public
 */
export type AssessmentStatus = (typeof AssessmentStatus)[keyof typeof AssessmentStatus];
/**
 * <p> Object containing the summary of the strategy recommendations. </p>
 * @public
 */
export interface StrategySummary {
    /**
     * <p> The name of recommended strategy. </p>
     * @public
     */
    strategy?: Strategy;
    /**
     * <p> The count of recommendations per strategy. </p>
     * @public
     */
    count?: number;
}
/**
 * @public
 * @enum
 */
export declare const RunTimeAssessmentStatus: {
    readonly DC_FAILED: "dataCollectionTaskFailed";
    readonly DC_PARTIAL_SUCCESS: "dataCollectionTaskPartialSuccess";
    readonly DC_REQ_SENT: "dataCollectionTaskScheduled";
    readonly DC_STARTED: "dataCollectionTaskStarted";
    readonly DC_STOPPED: "dataCollectionTaskStopped";
    readonly DC_SUCCESS: "dataCollectionTaskSuccess";
    readonly DC_TO_BE_SCHEDULED: "dataCollectionTaskToBeScheduled";
};
/**
 * @public
 */
export type RunTimeAssessmentStatus = (typeof RunTimeAssessmentStatus)[keyof typeof RunTimeAssessmentStatus];
/**
 * <p>The status summary of the server analysis.</p>
 * @public
 */
export interface ServerStatusSummary {
    /**
     * <p>The status of the run time.</p>
     * @public
     */
    runTimeAssessmentStatus?: RunTimeAssessmentStatus;
    /**
     * <p>The number of servers successfully analyzed, partially successful or failed
     *       analysis.</p>
     * @public
     */
    count?: number;
}
/**
 * @public
 * @enum
 */
export declare const ServerOsType: {
    readonly amazonLinux: "AmazonLinux";
    readonly endOfSupportWindowsServer: "EndOfSupportWindowsServer";
    readonly other: "Other";
    readonly redhat: "Redhat";
    readonly windowsServer: "WindowsServer";
};
/**
 * @public
 */
export type ServerOsType = (typeof ServerOsType)[keyof typeof ServerOsType];
/**
 * <p> Object containing details about the servers imported by Application Discovery Service </p>
 * @public
 */
export interface ServerSummary {
    /**
     * <p> Type of operating system for the servers. </p>
     * @public
     */
    ServerOsType?: ServerOsType;
    /**
     * <p> Number of servers. </p>
     * @public
     */
    count?: number;
}
/**
 * <p> Contains the summary of the assessment results. </p>
 * @public
 */
export interface AssessmentSummary {
    /**
     * <p> List of ServerStrategySummary. </p>
     * @public
     */
    listServerStrategySummary?: StrategySummary[];
    /**
     * <p> List of ApplicationComponentStrategySummary. </p>
     * @public
     */
    listApplicationComponentStrategySummary?: StrategySummary[];
    /**
     * <p> List of AntipatternSeveritySummary. </p>
     * @public
     */
    listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
    /**
     * <p> List of ApplicationComponentSummary. </p>
     * @public
     */
    listApplicationComponentSummary?: ApplicationComponentSummary[];
    /**
     * <p> List of ServerSummary. </p>
     * @public
     */
    listServerSummary?: ServerSummary[];
    /**
     * <p> The Amazon S3 object containing the anti-pattern report. </p>
     * @public
     */
    antipatternReportS3Object?: S3Object;
    /**
     * <p> The status of the anti-pattern report. </p>
     * @public
     */
    antipatternReportStatus?: AntipatternReportStatus;
    /**
     * <p> The status message of the anti-pattern report. </p>
     * @public
     */
    antipatternReportStatusMessage?: string;
    /**
     * <p> The time the assessment was performed. </p>
     * @public
     */
    lastAnalyzedTimestamp?: Date;
    /**
     * <p>List of status summaries of the analyzed application components.</p>
     * @public
     */
    listApplicationComponentStatusSummary?: ApplicationComponentStatusSummary[];
    /**
     * <p>List of status summaries of the analyzed servers.</p>
     * @public
     */
    listServerStatusSummary?: ServerStatusSummary[];
}
/**
 * @public
 * @enum
 */
export declare const Condition: {
    readonly CONTAINS: "CONTAINS";
    readonly EQUALS: "EQUALS";
    readonly NOT_CONTAINS: "NOT_CONTAINS";
    readonly NOT_EQUALS: "NOT_EQUALS";
};
/**
 * @public
 */
export type Condition = (typeof Condition)[keyof typeof Condition];
/**
 * <p>Defines the criteria of assessment.</p>
 * @public
 */
export interface AssessmentTarget {
    /**
     * <p>Condition of an assessment.</p>
     * @public
     */
    condition: Condition | undefined;
    /**
     * <p>Name of an assessment.</p>
     * @public
     */
    name: string | undefined;
    /**
     * <p>Values of an assessment.</p>
     * @public
     */
    values: string[] | undefined;
}
/**
 * <p> Object containing details about applications as defined in Application Discovery Service. </p>
 * @public
 */
export interface AssociatedApplication {
    /**
     * <p> Name of the application as defined in Application Discovery Service. </p>
     * @public
     */
    name?: string;
    /**
     * <p> ID of the application as defined in Application Discovery Service. </p>
     * @public
     */
    id?: string;
}
/**
 * @public
 * @enum
 */
export declare const AuthType: {
    readonly CERT: "CERT";
    readonly NTLM: "NTLM";
    readonly SSH: "SSH";
};
/**
 * @public
 */
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
/**
 * @public
 */
export interface GetApplicationComponentDetailsRequest {
    /**
     * <p> The ID of the application component. The ID is unique within an AWS account.</p>
     * @public
     */
    applicationComponentId: string | undefined;
}
/**
 * @public
 */
export interface GetApplicationComponentDetailsResponse {
    /**
     * <p> Detailed information about an application component. </p>
     * @public
     */
    applicationComponentDetail?: ApplicationComponentDetail;
    /**
     * <p> The associated application group as defined in AWS Application Discovery Service. </p>
     * @public
     */
    associatedApplications?: AssociatedApplication[];
    /**
     * <p> Set to true if the application component belongs to more than one application group.
     *     </p>
     * @public
     */
    moreApplicationResource?: boolean;
    /**
     * <p> A list of the IDs of the servers on which the application component is running. </p>
     * @public
     */
    associatedServerIds?: string[];
}
/**
 * <p> The server experienced an internal error. Try again. </p>
 * @public
 */
export declare class InternalServerException extends __BaseException {
    readonly name: "InternalServerException";
    readonly $fault: "server";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
}
/**
 * <p> The specified ID in the request is not found. </p>
 * @public
 */
export declare class ResourceNotFoundException extends __BaseException {
    readonly name: "ResourceNotFoundException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
}
/**
 * <p> The request was denied due to request throttling. </p>
 * @public
 */
export declare class ThrottlingException extends __BaseException {
    readonly name: "ThrottlingException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
}
/**
 * @public
 */
export interface GetApplicationComponentStrategiesRequest {
    /**
     * <p> The ID of the application component. The ID is unique within an AWS account.</p>
     * @public
     */
    applicationComponentId: string | undefined;
}
/**
 * @public
 */
export interface GetApplicationComponentStrategiesResponse {
    /**
     * <p> A list of application component strategy recommendations. </p>
     * @public
     */
    applicationComponentStrategies?: ApplicationComponentStrategy[];
}
/**
 * @public
 */
export interface GetAssessmentRequest {
    /**
     * <p> The <code>assessmentid</code> returned by <a>StartAssessment</a>.</p>
     * @public
     */
    id: string | undefined;
}
/**
 * <p> Detailed information about an assessment. </p>
 * @public
 */
export interface DataCollectionDetails {
    /**
     * <p> The status of the assessment. </p>
     * @public
     */
    status?: AssessmentStatus;
    /**
     * <p> The total number of servers in the assessment. </p>
     * @public
     */
    servers?: number;
    /**
     * <p> The number of failed servers in the assessment. </p>
     * @public
     */
    failed?: number;
    /**
     * <p> The number of successful servers in the assessment. </p>
     * @public
     */
    success?: number;
    /**
     * <p> The number of servers with the assessment status <code>IN_PROGESS</code>. </p>
     * @public
     */
    inProgress?: number;
    /**
     * <p> The start time of assessment. </p>
     * @public
     */
    startTime?: Date;
    /**
     * <p> The time the assessment completes. </p>
     * @public
     */
    completionTime?: Date;
    /**
     * <p>The status message of the assessment.</p>
     * @public
     */
    statusMessage?: string;
}
/**
 * @public
 */
export interface GetAssessmentResponse {
    /**
     * <p> The ID for the specific assessment task. </p>
     * @public
     */
    id?: string;
    /**
     * <p> Detailed information about the assessment. </p>
     * @public
     */
    dataCollectionDetails?: DataCollectionDetails;
    /**
     * <p>List of criteria for assessment.</p>
     * @public
     */
    assessmentTargets?: AssessmentTarget[];
}
/**
 * @public
 */
export interface GetImportFileTaskRequest {
    /**
     * <p> The ID of the import file task. This ID is returned in the response of <a>StartImportFileTask</a>. </p>
     * @public
     */
    id: string | undefined;
}
/**
 * @public
 * @enum
 */
export declare const ImportFileTaskStatus: {
    readonly DELETE_FAILED: "DeleteFailed";
    readonly DELETE_IN_PROGRESS: "DeleteInProgress";
    readonly DELETE_PARTIAL_SUCCESS: "DeletePartialSuccess";
    readonly DELETE_SUCCESS: "DeleteSuccess";
    readonly IMPORT_FAILED: "ImportFailed";
    readonly IMPORT_IN_PROGRESS: "ImportInProgress";
    readonly IMPORT_PARTIAL_SUCCESS: "ImportPartialSuccess";
    readonly IMPORT_SUCCESS: "ImportSuccess";
};
/**
 * @public
 */
export type ImportFileTaskStatus = (typeof ImportFileTaskStatus)[keyof typeof ImportFileTaskStatus];
/**
 * @public
 */
export interface GetImportFileTaskResponse {
    /**
     * <p> The import file task <code>id</code> returned in the response of <a>StartImportFileTask</a>. </p>
     * @public
     */
    id?: string;
    /**
     * <p> Status of import file task. </p>
     * @public
     */
    status?: ImportFileTaskStatus;
    /**
     * <p> Start time of the import task. </p>
     * @public
     */
    startTime?: Date;
    /**
     * <p> The S3 bucket where import file is located. </p>
     * @public
     */
    inputS3Bucket?: string;
    /**
     * <p> The Amazon S3 key name of the import file. </p>
     * @public
     */
    inputS3Key?: string;
    /**
     * <p> The S3 bucket name for status report of import task. </p>
     * @public
     */
    statusReportS3Bucket?: string;
    /**
     * <p> The Amazon S3 key name for status report of import task. The report contains details about
     *       whether each record imported successfully or why it did not.</p>
     * @public
     */
    statusReportS3Key?: string;
    /**
     * <p> The time that the import task completed. </p>
     * @public
     */
    completionTime?: Date;
    /**
     * <p> The number of records successfully imported. </p>
     * @public
     */
    numberOfRecordsSuccess?: number;
    /**
     * <p> The number of records that failed to be imported. </p>
     * @public
     */
    numberOfRecordsFailed?: number;
    /**
     * <p> The name of the import task given in <a>StartImportFileTask</a>. </p>
     * @public
     */
    importName?: string;
}
/**
 * <p> The request body isn't valid. </p>
 * @public
 */
export declare class ValidationException extends __BaseException {
    readonly name: "ValidationException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
}
/**
 * <p>Dependency encountered an error.</p>
 * @public
 */
export declare class DependencyException extends __BaseException {
    readonly name: "DependencyException";
    readonly $fault: "server";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<DependencyException, __BaseException>);
}
/**
 * @public
 */
export interface GetLatestAssessmentIdRequest {
}
/**
 * @public
 */
export interface GetLatestAssessmentIdResponse {
    /**
     * <p>The latest ID for the specific assessment task.</p>
     * @public
     */
    id?: string;
}
/**
 * @public
 */
export interface GetPortfolioPreferencesRequest {
}
/**
 * @public
 * @enum
 */
export declare const DatabaseManagementPreference: {
    readonly AWS_MANAGED: "AWS-managed";
    readonly NO_PREFERENCE: "No preference";
    readonly SELF_MANAGE: "Self-manage";
};
/**
 * @public
 */
export type DatabaseManagementPreference = (typeof DatabaseManagementPreference)[keyof typeof DatabaseManagementPreference];
/**
 * @public
 * @enum
 */
export declare const HeterogeneousTargetDatabaseEngine: {
    readonly AMAZON_AURORA: "Amazon Aurora";
    readonly AWS_POSTGRESQL: "AWS PostgreSQL";
    readonly DB2_LUW: "Db2 LUW";
    readonly MARIA_DB: "MariaDB";
    readonly MICROSOFT_SQL_SERVER: "Microsoft SQL Server";
    readonly MONGO_DB: "MongoDB";
    readonly MYSQL: "MySQL";
    readonly NONE_SPECIFIED: "None specified";
    readonly ORACLE_DATABASE: "Oracle Database";
    readonly SAP: "SAP";
};
/**
 * @public
 */
export type HeterogeneousTargetDatabaseEngine = (typeof HeterogeneousTargetDatabaseEngine)[keyof typeof HeterogeneousTargetDatabaseEngine];
/**
 * <p> The object containing details about heterogeneous database preferences. </p>
 * @public
 */
export interface Heterogeneous {
    /**
     * <p> The target database engine for heterogeneous database migration preference. </p>
     * @public
     */
    targetDatabaseEngine: HeterogeneousTargetDatabaseEngine[] | undefined;
}
/**
 * @public
 * @enum
 */
export declare const HomogeneousTargetDatabaseEngine: {
    readonly NONE_SPECIFIED: "None specified";
};
/**
 * @public
 */
export type HomogeneousTargetDatabaseEngine = (typeof HomogeneousTargetDatabaseEngine)[keyof typeof HomogeneousTargetDatabaseEngine];
/**
 * <p> The object containing details about homogeneous database preferences. </p>
 * @public
 */
export interface Homogeneous {
    /**
     * <p> The target database engine for homogeneous database migration preferences. </p>
     * @public
     */
    targetDatabaseEngine?: HomogeneousTargetDatabaseEngine[];
}
/**
 * @public
 * @enum
 */
export declare const TargetDatabaseEngine: {
    readonly AMAZON_AURORA: "Amazon Aurora";
    readonly AWS_POSTGRESQL: "AWS PostgreSQL";
    readonly DB2_LUW: "Db2 LUW";
    readonly MARIA_DB: "MariaDB";
    readonly MICROSOFT_SQL_SERVER: "Microsoft SQL Server";
    readonly MONGO_DB: "MongoDB";
    readonly MYSQL: "MySQL";
    readonly NONE_SPECIFIED: "None specified";
    readonly ORACLE_DATABASE: "Oracle Database";
    readonly SAP: "SAP";
};
/**
 * @public
 */
export type TargetDatabaseEngine = (typeof TargetDatabaseEngine)[keyof typeof TargetDatabaseEngine];
/**
 * <p> The object containing details about database migration preferences, when you have no
 *       particular preference. </p>
 * @public
 */
export interface NoDatabaseMigrationPreference {
    /**
     * <p> The target database engine for database migration preference that you specify. </p>
     * @public
     */
    targetDatabaseEngine: TargetDatabaseEngine[] | undefined;
}
/**
 * <p> Preferences for migrating a database to AWS. </p>
 * @public
 */
export type DatabaseMigrationPreference = DatabaseMigrationPreference.HeterogeneousMember | DatabaseMigrationPreference.HomogeneousMember | DatabaseMigrationPreference.NoPreferenceMember | DatabaseMigrationPreference.$UnknownMember;
/**
 * @public
 */
export declare namespace DatabaseMigrationPreference {
    /**
     * <p> Indicates whether you are interested in moving from one type of database to another. For
     *       example, from SQL Server to Amazon Aurora MySQL-Compatible Edition. </p>
     * @public
     */
    interface HeterogeneousMember {
        heterogeneous: Heterogeneous;
        homogeneous?: never;
        noPreference?: never;
        $unknown?: never;
    }
    /**
     * <p> Indicates whether you are interested in moving to the same type of database into AWS.
     *       For example, from SQL Server in your environment to SQL Server on AWS. </p>
     * @public
     */
    interface HomogeneousMember {
        heterogeneous?: never;
        homogeneous: Homogeneous;
        noPreference?: never;
        $unknown?: never;
    }
    /**
     * <p> Indicated that you do not prefer heterogeneous or homogeneous. </p>
     * @public
     */
    interface NoPreferenceMember {
        heterogeneous?: never;
        homogeneous?: never;
        noPreference: NoDatabaseMigrationPreference;
        $unknown?: never;
    }
    /**
     * @public
     */
    interface $UnknownMember {
        heterogeneous?: never;
        homogeneous?: never;
        noPreference?: never;
        $unknown: [string, any];
    }
    interface Visitor<T> {
        heterogeneous: (value: Heterogeneous) => T;
        homogeneous: (value: Homogeneous) => T;
        noPreference: (value: NoDatabaseMigrationPreference) => T;
        _: (name: string, value: any) => T;
    }
    const visit: <T>(value: DatabaseMigrationPreference, visitor: Visitor<T>) => T;
}
/**
 * <p> Preferences on managing your databases on AWS. </p>
 * @public
 */
export interface DatabasePreferences {
    /**
     * <p> Specifies whether you're interested in self-managed databases or databases managed by
     *       AWS. </p>
     * @public
     */
    databaseManagementPreference?: DatabaseManagementPreference;
    /**
     * <p> Specifies your preferred migration path. </p>
     * @public
     */
    databaseMigrationPreference?: DatabaseMigrationPreference;
}
/**
 * <p> Business goals that you specify. </p>
 * @public
 */
export interface BusinessGoals {
    /**
     * <p> Business goal to achieve migration at a fast pace. </p>
     * @public
     */
    speedOfMigration?: number;
    /**
     * <p> Business goal to reduce the operational overhead on the team by moving into managed
     *       services. </p>
     * @public
     */
    reduceOperationalOverheadWithManagedServices?: number;
    /**
     * <p> Business goal to modernize infrastructure by moving to cloud native technologies. </p>
     * @public
     */
    modernizeInfrastructureWithCloudNativeTechnologies?: number;
    /**
     * <p> Business goal to reduce license costs. </p>
     * @public
     */
    licenseCostReduction?: number;
}
/**
 * <p> Rank of business goals based on priority. </p>
 * @public
 */
export interface PrioritizeBusinessGoals {
    /**
     * <p> Rank of business goals based on priority. </p>
     * @public
     */
    businessGoals?: BusinessGoals;
}
/**
 * @public
 */
export interface GetPortfolioPreferencesResponse {
    /**
     * <p> The rank of business goals based on priority. </p>
     * @public
     */
    prioritizeBusinessGoals?: PrioritizeBusinessGoals;
    /**
     * <p> The transformation preferences for non-database applications. </p>
     * @public
     */
    applicationPreferences?: ApplicationPreferences;
    /**
     * <p> The transformation preferences for database applications. </p>
     * @public
     */
    databasePreferences?: DatabasePreferences;
    /**
     * <p>The classification for application component types.</p>
     * @public
     */
    applicationMode?: ApplicationMode;
}
/**
 * @public
 */
export interface GetPortfolioSummaryRequest {
}
/**
 * @public
 */
export interface GetPortfolioSummaryResponse {
    /**
     * <p> An assessment summary for the portfolio including the number of servers to rehost and the
     *       overall number of anti-patterns. </p>
     * @public
     */
    assessmentSummary?: AssessmentSummary;
}
/**
 * @public
 */
export interface GetRecommendationReportDetailsRequest {
    /**
     * <p> The recommendation report generation task <code>id</code> returned by <a>StartRecommendationReportGeneration</a>. </p>
     * @public
     */
    id: string | undefined;
}
/**
 * @public
 * @enum
 */
export declare const RecommendationReportStatus: {
    readonly FAILED: "FAILED";
    readonly IN_PROGRESS: "IN_PROGRESS";
    readonly SUCCESS: "SUCCESS";
};
/**
 * @public
 */
export type RecommendationReportStatus = (typeof RecommendationReportStatus)[keyof typeof RecommendationReportStatus];
/**
 * <p> Contains detailed information about a recommendation report. </p>
 * @public
 */
export interface RecommendationReportDetails {
    /**
     * <p> The status of the recommendation report generation task. </p>
     * @public
     */
    status?: RecommendationReportStatus;
    /**
     * <p> The status message for recommendation report generation. </p>
     * @public
     */
    statusMessage?: string;
    /**
     * <p> The time that the recommendation report generation task starts. </p>
     * @public
     */
    startTime?: Date;
    /**
     * <p> The time that the recommendation report generation task completes. </p>
     * @public
     */
    completionTime?: Date;
    /**
     * <p> The S3 bucket where the report file is located. </p>
     * @public
     */
    s3Bucket?: string;
    /**
     * <p> The Amazon S3 key name of the report file. </p>
     * @public
     */
    s3Keys?: string[];
}
/**
 * @public
 */
export interface GetRecommendationReportDetailsResponse {
    /**
     * <p> The ID of the recommendation report generation task. See the response of <a>StartRecommendationReportGeneration</a>. </p>
     * @public
     */
    id?: string;
    /**
     * <p> Detailed information about the recommendation report. </p>
     * @public
     */
    recommendationReportDetails?: RecommendationReportDetails;
}
/**
 * @public
 */
export interface GetServerDetailsRequest {
    /**
     * <p> The ID of the server. </p>
     * @public
     */
    serverId: string | undefined;
    /**
     * <p> The token from a previous call that you use to retrieve the next set of results. For example,
     * if a previous call to this action returned 100 items, but you set <code>maxResults</code> to 10. You'll receive a set of 10 results along
     *       with a token. You then use the returned token to retrieve the next set of 10. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> The maximum number of items to include in the response. The maximum value is 100. </p>
     * @public
     */
    maxResults?: number;
}
/**
 * @public
 * @enum
 */
export declare const ServerErrorCategory: {
    readonly ARCHITECTURE_ERROR: "ARCHITECTURE_ERROR";
    readonly CONNECTIVITY_ERROR: "CONNECTIVITY_ERROR";
    readonly CREDENTIAL_ERROR: "CREDENTIAL_ERROR";
    readonly OTHER_ERROR: "OTHER_ERROR";
    readonly PERMISSION_ERROR: "PERMISSION_ERROR";
};
/**
 * @public
 */
export type ServerErrorCategory = (typeof ServerErrorCategory)[keyof typeof ServerErrorCategory];
/**
 * <p>The error in server analysis.</p>
 * @public
 */
export interface ServerError {
    /**
     * <p>The error category of server analysis.</p>
     * @public
     */
    serverErrorCategory?: ServerErrorCategory;
}
/**
 * <p> Information about the server's network for which the assessment was run. </p>
 * @public
 */
export interface NetworkInfo {
    /**
     * <p> Information about the name of the interface of the server for which the assessment was
     *       run. </p>
     * @public
     */
    interfaceName: string | undefined;
    /**
     * <p> Information about the IP address of the server for which the assessment was run. </p>
     * @public
     */
    ipAddress: string | undefined;
    /**
     * <p> Information about the MAC address of the server for which the assessment was run. </p>
     * @public
     */
    macAddress: string | undefined;
    /**
     * <p> Information about the subnet mask of the server for which the assessment was run. </p>
     * @public
     */
    netMask: string | undefined;
}
/**
 * @public
 * @enum
 */
export declare const OSType: {
    readonly LINUX: "LINUX";
    readonly WINDOWS: "WINDOWS";
};
/**
 * @public
 */
export type OSType = (typeof OSType)[keyof typeof OSType];
/**
 * <p> Information about the operating system. </p>
 * @public
 */
export interface OSInfo {
    /**
     * <p> Information about the type of operating system. </p>
     * @public
     */
    type?: OSType;
    /**
     * <p> Information about the version of operating system. </p>
     * @public
     */
    version?: string;
}
/**
 * <p> Information about the server that hosts application components. </p>
 * @public
 */
export interface SystemInfo {
    /**
     * <p> Operating system corresponding to a server. </p>
     * @public
     */
    osInfo?: OSInfo;
    /**
     * <p> File system type for the server. </p>
     * @public
     */
    fileSystemType?: string;
    /**
     * <p> Networking information related to a server. </p>
     * @public
     */
    networkInfoList?: NetworkInfo[];
    /**
     * <p> CPU architecture type for the server. </p>
     * @public
     */
    cpuArchitecture?: string;
}
/**
 * <p> Detailed information about a server. </p>
 * @public
 */
export interface ServerDetail {
    /**
     * <p> The server ID. </p>
     * @public
     */
    id?: string;
    /**
     * <p> The name of the server. </p>
     * @public
     */
    name?: string;
    /**
     * <p> A set of recommendations. </p>
     * @public
     */
    recommendationSet?: RecommendationSet;
    /**
     * <p> The status of assessment for the server. </p>
     * @public
     */
    dataCollectionStatus?: RunTimeAssessmentStatus;
    /**
     * <p> A message about the status of data collection, which contains detailed descriptions of
     *       any error messages. </p>
     * @public
     */
    statusMessage?: string;
    /**
     * <p> A list of anti-pattern severity summaries. </p>
     * @public
     */
    listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
    /**
     * <p> System information about the server. </p>
     * @public
     */
    systemInfo?: SystemInfo;
    /**
     * <p> A list of strategy summaries. </p>
     * @public
     */
    applicationComponentStrategySummary?: StrategySummary[];
    /**
     * <p> The S3 bucket name and Amazon S3 key name for anti-pattern report. </p>
     * @public
     */
    antipatternReportS3Object?: S3Object;
    /**
     * <p> The status of the anti-pattern report generation. </p>
     * @public
     */
    antipatternReportStatus?: AntipatternReportStatus;
    /**
     * <p> A message about the status of the anti-pattern report generation. </p>
     * @public
     */
    antipatternReportStatusMessage?: string;
    /**
     * <p> The type of server. </p>
     * @public
     */
    serverType?: string;
    /**
     * <p> The timestamp of when the server was assessed. </p>
     * @public
     */
    lastAnalyzedTimestamp?: Date;
    /**
     * <p>The error in server analysis.</p>
     * @public
     */
    serverError?: ServerError;
}
/**
 * @public
 */
export interface GetServerDetailsResponse {
    /**
     * <p> The token you use to retrieve the next set of results, or null if there are no more results. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> Detailed information about the server. </p>
     * @public
     */
    serverDetail?: ServerDetail;
    /**
     * <p> The associated application group the server belongs to, as defined in AWS Application Discovery Service.
     *     </p>
     * @public
     */
    associatedApplications?: AssociatedApplication[];
}
/**
 * @public
 */
export interface GetServerStrategiesRequest {
    /**
     * <p> The ID of the server. </p>
     * @public
     */
    serverId: string | undefined;
}
/**
 * <p> Contains information about a strategy recommendation for a server. </p>
 * @public
 */
export interface ServerStrategy {
    /**
     * <p> Strategy recommendation for the server. </p>
     * @public
     */
    recommendation?: RecommendationSet;
    /**
     * <p> The recommendation status of the strategy for the server. </p>
     * @public
     */
    status?: StrategyRecommendation;
    /**
     * <p> The number of application components with this strategy recommendation running on the
     *       server. </p>
     * @public
     */
    numberOfApplicationComponents?: number;
    /**
     * <p> Set to true if the recommendation is set as preferred. </p>
     * @public
     */
    isPreferred?: boolean;
}
/**
 * @public
 */
export interface GetServerStrategiesResponse {
    /**
     * <p> A list of strategy recommendations for the server. </p>
     * @public
     */
    serverStrategies?: ServerStrategy[];
}
/**
 * @public
 * @enum
 */
export declare const SortOrder: {
    readonly ASC: "ASC";
    readonly DESC: "DESC";
};
/**
 * @public
 */
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
/**
 * Represents input for ListAnalyzableServers operation.
 * @public
 */
export interface ListAnalyzableServersRequest {
    /**
     * Specifies whether to sort by ascending (ASC) or descending (DESC) order.
     * @public
     */
    sort?: SortOrder;
    /**
     * The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
     * @public
     */
    nextToken?: string;
    /**
     * The maximum number of items to include in the response. The maximum value is 100.
     * @public
     */
    maxResults?: number;
}
/**
 * Represents output for ListAnalyzableServers operation.
 * @public
 */
export interface ListAnalyzableServersResponse {
    /**
     * The list of analyzable servers with summary information about each server.
     * @public
     */
    analyzableServers?: AnalyzableServerSummary[];
    /**
     * The token you use to retrieve the next set of results, or null if there are no more results.
     * @public
     */
    nextToken?: string;
}
/**
 * @public
 * @enum
 */
export declare const GroupName: {
    readonly EXTERNAL_ID: "ExternalId";
    readonly EXTERNAL_SOURCE_TYPE: "ExternalSourceType";
};
/**
 * @public
 */
export type GroupName = (typeof GroupName)[keyof typeof GroupName];
/**
 * <p> The object containing information about distinct imports or groups for Strategy Recommendations. </p>
 * @public
 */
export interface Group {
    /**
     * <p> The key of the specific import group. </p>
     * @public
     */
    name?: GroupName;
    /**
     * <p> The value of the specific import group. </p>
     * @public
     */
    value?: string;
}
/**
 * @public
 */
export interface ListApplicationComponentsRequest {
    /**
     * <p> Criteria for filtering the list of application components. </p>
     * @public
     */
    applicationComponentCriteria?: ApplicationComponentCriteria;
    /**
     * <p> Specify the value based on the application component criteria type. For example, if
     *         <code>applicationComponentCriteria</code> is set to <code>SERVER_ID</code> and
     *         <code>filterValue</code> is set to <code>server1</code>, then <a>ListApplicationComponents</a> returns all the application components running on
     *       server1. </p>
     * @public
     */
    filterValue?: string;
    /**
     * <p> Specifies whether to sort by ascending (<code>ASC</code>) or descending
     *         (<code>DESC</code>) order. </p>
     * @public
     */
    sort?: SortOrder;
    /**
     * <p> The group ID specified in to filter on. </p>
     * @public
     */
    groupIdFilter?: Group[];
    /**
     * <p> The token from a previous call that you use to retrieve the next set of results. For example,
     * if a previous call to this action returned 100 items, but you set <code>maxResults</code> to 10. You'll receive a set of 10 results along
     *       with a token. You then use the returned token to retrieve the next set of 10. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> The maximum number of items to include in the response. The maximum value is 100. </p>
     * @public
     */
    maxResults?: number;
}
/**
 * @public
 */
export interface ListApplicationComponentsResponse {
    /**
     * <p> The list of application components with detailed information about each component.
     *     </p>
     * @public
     */
    applicationComponentInfos?: ApplicationComponentDetail[];
    /**
     * <p> The token you use to retrieve the next set of results, or null if there are no more results. </p>
     * @public
     */
    nextToken?: string;
}
/**
 * <p> Exception to indicate that the service-linked role (SLR) is locked. </p>
 * @public
 */
export declare class ServiceLinkedRoleLockClientException extends __BaseException {
    readonly name: "ServiceLinkedRoleLockClientException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServiceLinkedRoleLockClientException, __BaseException>);
}
/**
 * @public
 */
export interface ListCollectorsRequest {
    /**
     * <p> The token from a previous call that you use to retrieve the next set of results. For example,
     * if a previous call to this action returned 100 items, but you set <code>maxResults</code> to 10. You'll receive a set of 10 results along
     *       with a token. You then use the returned token to retrieve the next set of 10. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> The maximum number of items to include in the response. The maximum value is 100. </p>
     * @public
     */
    maxResults?: number;
}
/**
 * @public
 * @enum
 */
export declare const CollectorHealth: {
    readonly COLLECTOR_HEALTHY: "COLLECTOR_HEALTHY";
    readonly COLLECTOR_UNHEALTHY: "COLLECTOR_UNHEALTHY";
};
/**
 * @public
 */
export type CollectorHealth = (typeof CollectorHealth)[keyof typeof CollectorHealth];
/**
 * <p>IP address based configurations.</p>
 * @public
 */
export interface IPAddressBasedRemoteInfo {
    /**
     * <p>The time stamp of the configuration.</p>
     * @public
     */
    ipAddressConfigurationTimeStamp?: string;
    /**
     * <p>The type of authorization.</p>
     * @public
     */
    authType?: AuthType;
    /**
     * <p>The type of the operating system.</p>
     * @public
     */
    osType?: OSType;
}
/**
 * @public
 * @enum
 */
export declare const PipelineType: {
    readonly AZURE_DEVOPS: "AZURE_DEVOPS";
};
/**
 * @public
 */
export type PipelineType = (typeof PipelineType)[keyof typeof PipelineType];
/**
 * <p>Detailed information of the pipeline.</p>
 * @public
 */
export interface PipelineInfo {
    /**
     * <p>The type of pipeline.</p>
     * @public
     */
    pipelineType?: PipelineType;
    /**
     * <p>The time when the pipeline info was configured.</p>
     * @public
     */
    pipelineConfigurationTimeStamp?: string;
}
/**
 * <p>Information about the server configured for source code analysis.</p>
 * @public
 */
export interface RemoteSourceCodeAnalysisServerInfo {
    /**
     * <p>The time when the remote source code server was configured.</p>
     * @public
     */
    remoteSourceCodeAnalysisServerConfigurationTimestamp?: string;
}
/**
 * <p>Details about the server in vCenter.</p>
 * @public
 */
export interface VcenterBasedRemoteInfo {
    /**
     * <p>The time when the remote server based on vCenter was last configured.</p>
     * @public
     */
    vcenterConfigurationTimeStamp?: string;
    /**
     * <p>The type of the operating system.</p>
     * @public
     */
    osType?: OSType;
}
/**
 * @public
 * @enum
 */
export declare const VersionControlType: {
    readonly AZURE_DEVOPS_GIT: "AZURE_DEVOPS_GIT";
    readonly GITHUB: "GITHUB";
    readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
};
/**
 * @public
 */
export type VersionControlType = (typeof VersionControlType)[keyof typeof VersionControlType];
/**
 * <p>Details about the version control configuration.</p>
 * @public
 */
export interface VersionControlInfo {
    /**
     * <p>The type of version control.</p>
     * @public
     */
    versionControlType?: VersionControlType;
    /**
     * <p>The time when the version control system was last configured.</p>
     * @public
     */
    versionControlConfigurationTimeStamp?: string;
}
/**
 * <p>Summary of the collector configuration.</p>
 * @public
 */
export interface ConfigurationSummary {
    /**
     * <p>The list of vCenter configurations.</p>
     * @public
     */
    vcenterBasedRemoteInfoList?: VcenterBasedRemoteInfo[];
    /**
     * <p>IP address based configurations.</p>
     * @public
     */
    ipAddressBasedRemoteInfoList?: IPAddressBasedRemoteInfo[];
    /**
     * <p>The list of the version control configurations.</p>
     * @public
     */
    versionControlInfoList?: VersionControlInfo[];
    /**
     * <p>The list of pipeline info configurations.</p>
     * @public
     */
    pipelineInfoList?: PipelineInfo[];
    /**
     * <p>Info about the remote server source code configuration.</p>
     * @public
     */
    remoteSourceCodeAnalysisServerInfo?: RemoteSourceCodeAnalysisServerInfo;
}
/**
 * <p> Process data collector that runs in the environment that you specify. </p>
 * @public
 */
export interface Collector {
    /**
     * <p> The ID of the collector. </p>
     * @public
     */
    collectorId?: string;
    /**
     * <p> IP address of the server that is hosting the collector. </p>
     * @public
     */
    ipAddress?: string;
    /**
     * <p> Hostname of the server that is hosting the collector. </p>
     * @public
     */
    hostName?: string;
    /**
     * <p> Indicates the health of a collector. </p>
     * @public
     */
    collectorHealth?: CollectorHealth;
    /**
     * <p> Current version of the collector that is running in the environment that you specify.
     *     </p>
     * @public
     */
    collectorVersion?: string;
    /**
     * <p> Time when the collector registered with the service. </p>
     * @public
     */
    registeredTimeStamp?: string;
    /**
     * <p> Time when the collector last pinged the service. </p>
     * @public
     */
    lastActivityTimeStamp?: string;
    /**
     * <p>Summary of the collector configuration.</p>
     * @public
     */
    configurationSummary?: ConfigurationSummary;
}
/**
 * @public
 */
export interface ListCollectorsResponse {
    /**
     * <p> The list of all the installed collectors. </p>
     * @public
     */
    Collectors?: Collector[];
    /**
     * <p> The token you use to retrieve the next set of results, or null if there are no more results. </p>
     * @public
     */
    nextToken?: string;
}
/**
 * @public
 */
export interface ListImportFileTaskRequest {
    /**
     * <p> The token from a previous call that you use to retrieve the next set of results. For example,
     * if a previous call to this action returned 100 items, but you set <code>maxResults</code> to 10. You'll receive a set of 10 results along
     *       with a token. You then use the returned token to retrieve the next set of 10. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> The total number of items to return. The maximum value is 100. </p>
     * @public
     */
    maxResults?: number;
}
/**
 * <p> Information about the import file tasks you request. </p>
 * @public
 */
export interface ImportFileTaskInformation {
    /**
     * <p> The ID of the import file task. </p>
     * @public
     */
    id?: string;
    /**
     * <p> Status of import file task. </p>
     * @public
     */
    status?: ImportFileTaskStatus;
    /**
     * <p> Start time of the import task. </p>
     * @public
     */
    startTime?: Date;
    /**
     * <p> The S3 bucket where the import file is located. </p>
     * @public
     */
    inputS3Bucket?: string;
    /**
     * <p> The Amazon S3 key name of the import file. </p>
     * @public
     */
    inputS3Key?: string;
    /**
     * <p> The S3 bucket name for status report of import task. </p>
     * @public
     */
    statusReportS3Bucket?: string;
    /**
     * <p> The Amazon S3 key name for status report of import task. The report contains details about
     *       whether each record imported successfully or why it did not. </p>
     * @public
     */
    statusReportS3Key?: string;
    /**
     * <p> The time that the import task completes. </p>
     * @public
     */
    completionTime?: Date;
    /**
     * <p> The number of records successfully imported. </p>
     * @public
     */
    numberOfRecordsSuccess?: number;
    /**
     * <p> The number of records that failed to be imported. </p>
     * @public
     */
    numberOfRecordsFailed?: number;
    /**
     * <p> The name of the import task given in <code>StartImportFileTask</code>. </p>
     * @public
     */
    importName?: string;
}
/**
 * @public
 */
export interface ListImportFileTaskResponse {
    /**
     * <p> Lists information about the files you import.</p>
     * @public
     */
    taskInfos?: ImportFileTaskInformation[];
    /**
     * <p> The token you use to retrieve the next set of results, or null if there are no more results. </p>
     * @public
     */
    nextToken?: string;
}
/**
 * @public
 * @enum
 */
export declare const ServerCriteria: {
    readonly ANALYSIS_STATUS: "ANALYSIS_STATUS";
    readonly DESTINATION: "DESTINATION";
    readonly ERROR_CATEGORY: "ERROR_CATEGORY";
    readonly NOT_DEFINED: "NOT_DEFINED";
    readonly OS_NAME: "OS_NAME";
    readonly SERVER_ID: "SERVER_ID";
    readonly STRATEGY: "STRATEGY";
};
/**
 * @public
 */
export type ServerCriteria = (typeof ServerCriteria)[keyof typeof ServerCriteria];
/**
 * @public
 */
export interface ListServersRequest {
    /**
     * <p> Criteria for filtering servers. </p>
     * @public
     */
    serverCriteria?: ServerCriteria;
    /**
     * <p> Specifies the filter value, which is based on the type of server criteria. For example,
     *       if <code>serverCriteria</code> is <code>OS_NAME</code>, and the <code>filterValue</code> is
     *       equal to <code>WindowsServer</code>, then <code>ListServers</code> returns all of the servers
     *       matching the OS name <code>WindowsServer</code>. </p>
     * @public
     */
    filterValue?: string;
    /**
     * <p> Specifies whether to sort by ascending (<code>ASC</code>) or descending
     *         (<code>DESC</code>) order. </p>
     * @public
     */
    sort?: SortOrder;
    /**
     * <p> Specifies the group ID to filter on. </p>
     * @public
     */
    groupIdFilter?: Group[];
    /**
     * <p> The token from a previous call that you use to retrieve the next set of results. For example,
     * if a previous call to this action returned 100 items, but you set <code>maxResults</code> to 10. You'll receive a set of 10 results along
     *       with a token. You then use the returned token to retrieve the next set of 10. </p>
     * @public
     */
    nextToken?: string;
    /**
     * <p> The maximum number of items to include in the response. The maximum value is 100. </p>
     * @public
     */
    maxResults?: number;
}
/**
 * @public
 */
export interface ListServersResponse {
    /**
     * <p> The list of servers with detailed information about each server. </p>
     * @public
     */
    serverInfos?: ServerDetail[];
    /**
     * <p> The token you use to retrieve the next set of results, or null if there are no more results. </p>
     * @public
     */
    nextToken?: string;
}
/**
 * <p> Exception to indicate that there is an ongoing task when a new task is created. Return
 *       when once the existing tasks are complete. </p>
 * @public
 */
export declare class ConflictException extends __BaseException {
    readonly name: "ConflictException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
/**
 * @public
 */
export interface PutPortfolioPreferencesRequest {
    /**
     * <p> The rank of the business goals based on priority. </p>
     * @public
     */
    prioritizeBusinessGoals?: PrioritizeBusinessGoals;
    /**
     * <p> The transformation preferences for non-database applications. </p>
     * @public
     */
    applicationPreferences?: ApplicationPreferences;
    /**
     * <p> The transformation preferences for database applications. </p>
     * @public
     */
    databasePreferences?: DatabasePreferences;
    /**
     * <p>The classification for application component types.</p>
     * @public
     */
    applicationMode?: ApplicationMode;
}
/**
 * @public
 */
export interface PutPortfolioPreferencesResponse {
}
/**
 * <p> The AWS account has reached its quota of imports. Contact AWS Support to increase the
 *       quota for this account. </p>
 * @public
 */
export declare class ServiceQuotaExceededException extends __BaseException {
    readonly name: "ServiceQuotaExceededException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>);
}
/**
 * @public
 */
export interface StartAssessmentRequest {
    /**
     * <p> The S3 bucket used by the collectors to send analysis data to the service. The bucket
     *       name must begin with <code>migrationhub-strategy-</code>. </p>
     * @public
     */
    s3bucketForAnalysisData?: string;
    /**
     * <p> The S3 bucket where all the reports generated by the service are stored. The bucket name
     *       must begin with <code>migrationhub-strategy-</code>. </p>
     * @public
     */
    s3bucketForReportData?: string;
    /**
     * <p>List of criteria for assessment.</p>
     * @public
     */
    assessmentTargets?: AssessmentTarget[];
    /**
     * The data source type of an assessment to be started.
     * @public
     */
    assessmentDataSourceType?: AssessmentDataSourceType;
}
/**
 * @public
 */
export interface StartAssessmentResponse {
    /**
     * <p> The ID of the assessment. </p>
     * @public
     */
    assessmentId?: string;
}
/**
 * @public
 * @enum
 */
export declare const DataSourceType: {
    readonly ADS: "ApplicationDiscoveryService";
    readonly IMPORT: "Import";
    readonly MHSR_COLLECTOR: "StrategyRecommendationsApplicationDataCollector";
    readonly MPA: "MPA";
};
/**
 * @public
 */
export type DataSourceType = (typeof DataSourceType)[keyof typeof DataSourceType];
/**
 * @public
 */
export interface StartImportFileTaskRequest {
    /**
     * <p> A descriptive name for the request. </p>
     * @public
     */
    name: string | undefined;
    /**
     * <p> The S3 bucket where the import file is located. The bucket name is required to begin with
     *         <code>migrationhub-strategy-</code>.</p>
     * @public
     */
    S3Bucket: string | undefined;
    /**
     * <p> The Amazon S3 key name of the import file. </p>
     * @public
     */
    s3key: string | undefined;
    /**
     * <p>Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that
     *       the servers specified in the import file are available in AWS Application Discovery Service. </p>
     * @public
     */
    dataSourceType?: DataSourceType;
    /**
     * <p>Groups the resources in the import file together with a unique name. This ID can be as
     *       filter in <code>ListApplicationComponents</code> and <code>ListServers</code>. </p>
     * @public
     */
    groupId?: Group[];
    /**
     * <p> The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to
     *       begin with migrationhub-strategy-. </p>
     * @public
     */
    s3bucketForReportData?: string;
}
/**
 * @public
 */
export interface StartImportFileTaskResponse {
    /**
     * <p> The ID for a specific import task. The ID is unique within an AWS account. </p>
     * @public
     */
    id?: string;
}
/**
 * @public
 * @enum
 */
export declare const OutputFormat: {
    readonly Excel: "Excel";
    readonly Json: "Json";
};
/**
 * @public
 */
export type OutputFormat = (typeof OutputFormat)[keyof typeof OutputFormat];
/**
 * @public
 */
export interface StartRecommendationReportGenerationRequest {
    /**
     * <p> The output format for the recommendation report file. The default format is Microsoft
     *       Excel. </p>
     * @public
     */
    outputFormat?: OutputFormat;
    /**
     * <p> Groups the resources in the recommendation report with a unique name. </p>
     * @public
     */
    groupIdFilter?: Group[];
}
/**
 * @public
 */
export interface StartRecommendationReportGenerationResponse {
    /**
     * <p> The ID of the recommendation report generation task. </p>
     * @public
     */
    id?: string;
}
/**
 * @public
 */
export interface StopAssessmentRequest {
    /**
     * <p> The <code>assessmentId</code> returned by <a>StartAssessment</a>. </p>
     * @public
     */
    assessmentId: string | undefined;
}
/**
 * @public
 */
export interface StopAssessmentResponse {
}
/**
 * @public
 * @enum
 */
export declare const VersionControl: {
    readonly AZURE_DEVOPS_GIT: "AZURE_DEVOPS_GIT";
    readonly GITHUB: "GITHUB";
    readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
};
/**
 * @public
 */
export type VersionControl = (typeof VersionControl)[keyof typeof VersionControl];
/**
 * <p> Object containing source code information that is linked to an application component.
 *     </p>
 * @public
 */
export interface SourceCode {
    /**
     * <p> The type of repository to use for the source code. </p>
     * @public
     */
    versionControl?: VersionControl;
    /**
     * <p> The branch of the source code. </p>
     * @public
     */
    sourceVersion?: string;
    /**
     * <p> The repository name for the source code. </p>
     * @public
     */
    location?: string;
    /**
     * <p>The name of the project.</p>
     * @public
     */
    projectName?: string;
}
/**
 * <p> Information about all the available strategy options for migrating and modernizing an
 *       application component. </p>
 * @public
 */
export interface StrategyOption {
    /**
     * <p> Type of transformation. For example, Rehost, Replatform, and so on. </p>
     * @public
     */
    strategy?: Strategy;
    /**
     * <p> The name of the tool that can be used to transform an application component using this
     *       strategy. </p>
     * @public
     */
    toolName?: TransformationToolName;
    /**
     * <p> Destination information about where the application component can migrate to. For
     *       example, <code>EC2</code>, <code>ECS</code>, and so on. </p>
     * @public
     */
    targetDestination?: TargetDestination;
    /**
     * <p> Indicates if a specific strategy is preferred for the application component. </p>
     * @public
     */
    isPreferred?: boolean;
}
/**
 * @public
 */
export interface UpdateApplicationComponentConfigRequest {
    /**
     * <p> The ID of the application component. The ID is unique within an AWS account. </p>
     * @public
     */
    applicationComponentId: string | undefined;
    /**
     * <p> Indicates whether the application component has been included for server recommendation
     *       or not. </p>
     * @public
     */
    inclusionStatus?: InclusionStatus;
    /**
     * <p> The preferred strategy options for the application component. Use values from the <a>GetApplicationComponentStrategies</a> response. </p>
     * @public
     */
    strategyOption?: StrategyOption;
    /**
     * <p> The list of source code configurations to update for the application component. </p>
     * @public
     */
    sourceCodeList?: SourceCode[];
    /**
     * <p> Database credentials. </p>
     * @public
     */
    secretsManagerKey?: string;
    /**
     * <p>Update the configuration request of an application component. If it is set to true, the
     *       source code and/or database credentials are updated. If it is set to false, the source code
     *       and/or database credentials are updated and an analysis is initiated.</p>
     * @public
     */
    configureOnly?: boolean;
    /**
     * <p>The type of known component.</p>
     * @public
     */
    appType?: AppType;
}
/**
 * @public
 */
export interface UpdateApplicationComponentConfigResponse {
}
/**
 * @public
 */
export interface UpdateServerConfigRequest {
    /**
     * <p> The ID of the server. </p>
     * @public
     */
    serverId: string | undefined;
    /**
     * <p> The preferred strategy options for the application component. See the response from <a>GetServerStrategies</a>.</p>
     * @public
     */
    strategyOption?: StrategyOption;
}
/**
 * @public
 */
export interface UpdateServerConfigResponse {
}
/**
 * @internal
 */
export declare const UpdateApplicationComponentConfigRequestFilterSensitiveLog: (obj: UpdateApplicationComponentConfigRequest) => any;
