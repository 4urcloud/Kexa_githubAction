import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { MigrationHubStrategyServiceException as __BaseException } from "./MigrationHubStrategyServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const RuntimeAnalysisStatus: {
  readonly ANALYSIS_FAILED: "ANALYSIS_FAILED";
  readonly ANALYSIS_STARTED: "ANALYSIS_STARTED";
  readonly ANALYSIS_SUCCESS: "ANALYSIS_SUCCESS";
  readonly ANALYSIS_TO_BE_SCHEDULED: "ANALYSIS_TO_BE_SCHEDULED";
};
export type RuntimeAnalysisStatus =
  (typeof RuntimeAnalysisStatus)[keyof typeof RuntimeAnalysisStatus];
export declare const SrcCodeOrDbAnalysisStatus: {
  readonly ANALYSIS_FAILED: "ANALYSIS_FAILED";
  readonly ANALYSIS_PARTIAL_SUCCESS: "ANALYSIS_PARTIAL_SUCCESS";
  readonly ANALYSIS_STARTED: "ANALYSIS_STARTED";
  readonly ANALYSIS_SUCCESS: "ANALYSIS_SUCCESS";
  readonly ANALYSIS_TO_BE_SCHEDULED: "ANALYSIS_TO_BE_SCHEDULED";
  readonly CONFIGURED: "CONFIGURED";
  readonly UNCONFIGURED: "UNCONFIGURED";
};
export type SrcCodeOrDbAnalysisStatus =
  (typeof SrcCodeOrDbAnalysisStatus)[keyof typeof SrcCodeOrDbAnalysisStatus];
export type AnalysisStatusUnion =
  | AnalysisStatusUnion.RuntimeAnalysisStatusMember
  | AnalysisStatusUnion.SrcCodeOrDbAnalysisStatusMember
  | AnalysisStatusUnion.$UnknownMember;
export declare namespace AnalysisStatusUnion {
  interface RuntimeAnalysisStatusMember {
    runtimeAnalysisStatus: RuntimeAnalysisStatus;
    srcCodeOrDbAnalysisStatus?: never;
    $unknown?: never;
  }
  interface SrcCodeOrDbAnalysisStatusMember {
    runtimeAnalysisStatus?: never;
    srcCodeOrDbAnalysisStatus: SrcCodeOrDbAnalysisStatus;
    $unknown?: never;
  }
  interface $UnknownMember {
    runtimeAnalysisStatus?: never;
    srcCodeOrDbAnalysisStatus?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    runtimeAnalysisStatus: (value: RuntimeAnalysisStatus) => T;
    srcCodeOrDbAnalysisStatus: (value: SrcCodeOrDbAnalysisStatus) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: AnalysisStatusUnion, visitor: Visitor<T>) => T;
}
export declare const AnalysisType: {
  readonly BINARY_ANALYSIS: "BINARY_ANALYSIS";
  readonly DATABASE_ANALYSIS: "DATABASE_ANALYSIS";
  readonly RUNTIME_ANALYSIS: "RUNTIME_ANALYSIS";
  readonly SOURCE_CODE_ANALYSIS: "SOURCE_CODE_ANALYSIS";
};
export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType];
export interface AnalyzableServerSummary {
  hostname?: string;
  ipAddress?: string;
  source?: string;
  vmId?: string;
}
export declare const BinaryAnalyzerName: {
  readonly BYTECODE_ANALYZER: "BYTECODE_ANALYZER";
  readonly DLL_ANALYZER: "DLL_ANALYZER";
};
export type BinaryAnalyzerName =
  (typeof BinaryAnalyzerName)[keyof typeof BinaryAnalyzerName];
export declare const RunTimeAnalyzerName: {
  readonly A2C_ANALYZER: "A2C_ANALYZER";
  readonly DATABASE_ANALYZER: "DATABASE_ANALYZER";
  readonly EMP_PA_ANALYZER: "EMP_PA_ANALYZER";
  readonly REHOST_ANALYZER: "REHOST_ANALYZER";
  readonly SCT_ANALYZER: "SCT_ANALYZER";
};
export type RunTimeAnalyzerName =
  (typeof RunTimeAnalyzerName)[keyof typeof RunTimeAnalyzerName];
export declare const SourceCodeAnalyzerName: {
  readonly BYTECODE_ANALYZER: "BYTECODE_ANALYZER";
  readonly CSHARP_ANALYZER: "CSHARP_ANALYZER";
  readonly JAVA_ANALYZER: "JAVA_ANALYZER";
  readonly PORTING_ASSISTANT: "PORTING_ASSISTANT";
};
export type SourceCodeAnalyzerName =
  (typeof SourceCodeAnalyzerName)[keyof typeof SourceCodeAnalyzerName];
export type AnalyzerNameUnion =
  | AnalyzerNameUnion.BinaryAnalyzerNameMember
  | AnalyzerNameUnion.RunTimeAnalyzerNameMember
  | AnalyzerNameUnion.SourceCodeAnalyzerNameMember
  | AnalyzerNameUnion.$UnknownMember;
export declare namespace AnalyzerNameUnion {
  interface BinaryAnalyzerNameMember {
    binaryAnalyzerName: BinaryAnalyzerName;
    runTimeAnalyzerName?: never;
    sourceCodeAnalyzerName?: never;
    $unknown?: never;
  }
  interface RunTimeAnalyzerNameMember {
    binaryAnalyzerName?: never;
    runTimeAnalyzerName: RunTimeAnalyzerName;
    sourceCodeAnalyzerName?: never;
    $unknown?: never;
  }
  interface SourceCodeAnalyzerNameMember {
    binaryAnalyzerName?: never;
    runTimeAnalyzerName?: never;
    sourceCodeAnalyzerName: SourceCodeAnalyzerName;
    $unknown?: never;
  }
  interface $UnknownMember {
    binaryAnalyzerName?: never;
    runTimeAnalyzerName?: never;
    sourceCodeAnalyzerName?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    binaryAnalyzerName: (value: BinaryAnalyzerName) => T;
    runTimeAnalyzerName: (value: RunTimeAnalyzerName) => T;
    sourceCodeAnalyzerName: (value: SourceCodeAnalyzerName) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: AnalyzerNameUnion, visitor: Visitor<T>) => T;
}
export interface S3Object {
  s3Bucket?: string;
  s3key?: string;
}
export declare const AntipatternReportStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly SUCCESS: "SUCCESS";
};
export type AntipatternReportStatus =
  (typeof AntipatternReportStatus)[keyof typeof AntipatternReportStatus];
export interface AntipatternReportResult {
  analyzerName?: AnalyzerNameUnion;
  antiPatternReportS3Object?: S3Object;
  antipatternReportStatus?: AntipatternReportStatus;
  antipatternReportStatusMessage?: string;
}
export declare const Severity: {
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly MEDIUM: "MEDIUM";
};
export type Severity = (typeof Severity)[keyof typeof Severity];
export interface AntipatternSeveritySummary {
  severity?: Severity;
  count?: number;
}
export declare const ApplicationComponentCriteria: {
  readonly ANALYSIS_STATUS: "ANALYSIS_STATUS";
  readonly APP_NAME: "APP_NAME";
  readonly APP_TYPE: "APP_TYPE";
  readonly DESTINATION: "DESTINATION";
  readonly ERROR_CATEGORY: "ERROR_CATEGORY";
  readonly NOT_DEFINED: "NOT_DEFINED";
  readonly SERVER_ID: "SERVER_ID";
  readonly STRATEGY: "STRATEGY";
};
export type ApplicationComponentCriteria =
  (typeof ApplicationComponentCriteria)[keyof typeof ApplicationComponentCriteria];
export declare const AppType: {
  readonly IIS: "IIS";
  readonly cassandra: "Cassandra";
  readonly db2: "DB2";
  readonly dotNetFramework: "DotNetFramework";
  readonly dotnet: "Dotnet";
  readonly dotnetcore: "DotnetCore";
  readonly java: "Java";
  readonly jboss: "JBoss";
  readonly mariadb: "Maria DB";
  readonly mongodb: "Mongo DB";
  readonly mysql: "MySQL";
  readonly oracle: "Oracle";
  readonly other: "Other";
  readonly postgresqlserver: "PostgreSQLServer";
  readonly spring: "Spring";
  readonly sqlServer: "SQLServer";
  readonly sybase: "Sybase";
  readonly tomcat: "Tomcat";
  readonly unknown: "Unknown";
  readonly visualbasic: "Visual Basic";
  readonly weblogic: "Oracle WebLogic";
  readonly websphere: "IBM WebSphere";
};
export type AppType = (typeof AppType)[keyof typeof AppType];
export declare const AppUnitErrorCategory: {
  readonly CONNECTIVITY_ERROR: "CONNECTIVITY_ERROR";
  readonly CREDENTIAL_ERROR: "CREDENTIAL_ERROR";
  readonly OTHER_ERROR: "OTHER_ERROR";
  readonly PERMISSION_ERROR: "PERMISSION_ERROR";
  readonly UNSUPPORTED_ERROR: "UNSUPPORTED_ERROR";
};
export type AppUnitErrorCategory =
  (typeof AppUnitErrorCategory)[keyof typeof AppUnitErrorCategory];
export interface AppUnitError {
  appUnitErrorCategory?: AppUnitErrorCategory;
}
export interface DatabaseConfigDetail {
  secretName?: string;
}
export declare const InclusionStatus: {
  readonly EXCLUDE_FROM_RECOMMENDATION: "excludeFromAssessment";
  readonly INCLUDE_IN_RECOMMENDATION: "includeInAssessment";
};
export type InclusionStatus =
  (typeof InclusionStatus)[keyof typeof InclusionStatus];
export declare const Strategy: {
  readonly REFACTOR: "Refactor";
  readonly REHOST: "Rehost";
  readonly RELOCATE: "Relocate";
  readonly REPLATFORM: "Replatform";
  readonly REPURCHASE: "Repurchase";
  readonly RETAIN: "Retain";
  readonly RETIREMENT: "Retirement";
};
export type Strategy = (typeof Strategy)[keyof typeof Strategy];
export declare const TargetDestination: {
  readonly AMAZON_DOCUMENTDB: "Amazon DocumentDB";
  readonly AMAZON_DYNAMODB: "Amazon DynamoDB";
  readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
  readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
  readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
  readonly AMAZON_RDS: "Amazon Relational Database Service";
  readonly AMAZON_RDS_MYSQL: "Amazon Relational Database Service on MySQL";
  readonly AMAZON_RDS_POSTGRESQL: "Amazon Relational Database Service on PostgreSQL";
  readonly AURORA_MYSQL: "Aurora MySQL";
  readonly AURORA_POSTGRESQL: "Aurora PostgreSQL";
  readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
  readonly AWS_FARGATE: "AWS Fargate";
  readonly BABELFISH_AURORA_POSTGRESQL: "Babelfish for Aurora PostgreSQL";
  readonly NONE_SPECIFIED: "None specified";
};
export type TargetDestination =
  (typeof TargetDestination)[keyof typeof TargetDestination];
export declare const TransformationToolName: {
  readonly APP2CONTAINER: "App2Container";
  readonly DMS: "Database Migration Service";
  readonly EMP: "End of Support Migration";
  readonly IN_PLACE_OS_UPGRADE: "In Place Operating System Upgrade";
  readonly MGN: "Application Migration Service";
  readonly NATIVE_SQL: "Native SQL Server Backup/Restore";
  readonly PORTING_ASSISTANT: "Porting Assistant For .NET";
  readonly SCT: "Schema Conversion Tool";
  readonly STRATEGY_RECOMMENDATION_SUPPORT: "Strategy Recommendation Support";
  readonly WWAMA: "Windows Web Application Migration Assistant";
};
export type TransformationToolName =
  (typeof TransformationToolName)[keyof typeof TransformationToolName];
export interface TransformationTool {
  name?: TransformationToolName;
  description?: string;
  tranformationToolInstallationLink?: string;
}
export interface RecommendationSet {
  transformationTool?: TransformationTool;
  targetDestination?: TargetDestination;
  strategy?: Strategy;
}
export declare const ResourceSubType: {
  readonly DATABASE: "Database";
  readonly DATABASE_PROCESS: "DatabaseProcess";
  readonly PROCESS: "Process";
};
export type ResourceSubType =
  (typeof ResourceSubType)[keyof typeof ResourceSubType];
export interface Result {
  analysisType?: AnalysisType;
  analysisStatus?: AnalysisStatusUnion;
  statusMessage?: string;
  antipatternReportResultList?: AntipatternReportResult[];
}
export interface SourceCodeRepository {
  repository?: string;
  branch?: string;
  versionControlType?: string;
  projectName?: string;
}
export interface ApplicationComponentDetail {
  id?: string;
  name?: string;
  recommendationSet?: RecommendationSet;
  analysisStatus?: SrcCodeOrDbAnalysisStatus;
  statusMessage?: string;
  listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
  databaseConfigDetail?: DatabaseConfigDetail;
  sourceCodeRepositories?: SourceCodeRepository[];
  appType?: AppType;
  resourceSubType?: ResourceSubType;
  inclusionStatus?: InclusionStatus;
  antipatternReportS3Object?: S3Object;
  antipatternReportStatus?: AntipatternReportStatus;
  antipatternReportStatusMessage?: string;
  osVersion?: string;
  osDriver?: string;
  lastAnalyzedTimestamp?: Date;
  associatedServerId?: string;
  moreServerAssociationExists?: boolean;
  runtimeStatus?: RuntimeAnalysisStatus;
  runtimeStatusMessage?: string;
  appUnitError?: AppUnitError;
  resultList?: Result[];
}
export interface ApplicationComponentStatusSummary {
  srcCodeOrDbAnalysisStatus?: SrcCodeOrDbAnalysisStatus;
  count?: number;
}
export declare const StrategyRecommendation: {
  readonly NOT_RECOMMENDED: "notRecommended";
  readonly POTENTIAL: "potential";
  readonly RECOMMENDED: "recommended";
  readonly VIABLE_OPTION: "viableOption";
};
export type StrategyRecommendation =
  (typeof StrategyRecommendation)[keyof typeof StrategyRecommendation];
export interface ApplicationComponentStrategy {
  recommendation?: RecommendationSet;
  status?: StrategyRecommendation;
  isPreferred?: boolean;
}
export interface ApplicationComponentSummary {
  appType?: AppType;
  count?: number;
}
export declare const ApplicationMode: {
  readonly ALL: "ALL";
  readonly KNOWN: "KNOWN";
  readonly UNKNOWN: "UNKNOWN";
};
export type ApplicationMode =
  (typeof ApplicationMode)[keyof typeof ApplicationMode];
export declare const AwsManagedTargetDestination: {
  readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
  readonly AWS_FARGATE: "AWS Fargate";
  readonly NONE_SPECIFIED: "None specified";
};
export type AwsManagedTargetDestination =
  (typeof AwsManagedTargetDestination)[keyof typeof AwsManagedTargetDestination];
export interface AwsManagedResources {
  targetDestination: AwsManagedTargetDestination[] | undefined;
}
export declare const NoPreferenceTargetDestination: {
  readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
  readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
  readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
  readonly AWS_ELASTIC_BEANSTALK: "AWS Elastic BeanStalk";
  readonly AWS_FARGATE: "AWS Fargate";
  readonly NONE_SPECIFIED: "None specified";
};
export type NoPreferenceTargetDestination =
  (typeof NoPreferenceTargetDestination)[keyof typeof NoPreferenceTargetDestination];
export interface NoManagementPreference {
  targetDestination: NoPreferenceTargetDestination[] | undefined;
}
export declare const SelfManageTargetDestination: {
  readonly AMAZON_ELASTIC_CLOUD_COMPUTE: "Amazon Elastic Cloud Compute (EC2)";
  readonly AMAZON_ELASTIC_CONTAINER_SERVICE: "Amazon Elastic Container Service (ECS)";
  readonly AMAZON_ELASTIC_KUBERNETES_SERVICE: "Amazon Elastic Kubernetes Service (EKS)";
  readonly NONE_SPECIFIED: "None specified";
};
export type SelfManageTargetDestination =
  (typeof SelfManageTargetDestination)[keyof typeof SelfManageTargetDestination];
export interface SelfManageResources {
  targetDestination: SelfManageTargetDestination[] | undefined;
}
export type ManagementPreference =
  | ManagementPreference.AwsManagedResourcesMember
  | ManagementPreference.NoPreferenceMember
  | ManagementPreference.SelfManageResourcesMember
  | ManagementPreference.$UnknownMember;
export declare namespace ManagementPreference {
  interface AwsManagedResourcesMember {
    awsManagedResources: AwsManagedResources;
    selfManageResources?: never;
    noPreference?: never;
    $unknown?: never;
  }
  interface SelfManageResourcesMember {
    awsManagedResources?: never;
    selfManageResources: SelfManageResources;
    noPreference?: never;
    $unknown?: never;
  }
  interface NoPreferenceMember {
    awsManagedResources?: never;
    selfManageResources?: never;
    noPreference: NoManagementPreference;
    $unknown?: never;
  }
  interface $UnknownMember {
    awsManagedResources?: never;
    selfManageResources?: never;
    noPreference?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    awsManagedResources: (value: AwsManagedResources) => T;
    selfManageResources: (value: SelfManageResources) => T;
    noPreference: (value: NoManagementPreference) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: ManagementPreference, visitor: Visitor<T>) => T;
}
export interface ApplicationPreferences {
  managementPreference?: ManagementPreference;
}
export declare const AssessmentDataSourceType: {
  readonly ADS: "ApplicationDiscoveryService";
  readonly MANUAL_IMPORT: "ManualImport";
  readonly SR_COLLECTOR: "StrategyRecommendationsApplicationDataCollector";
};
export type AssessmentDataSourceType =
  (typeof AssessmentDataSourceType)[keyof typeof AssessmentDataSourceType];
export declare const AssessmentStatus: {
  readonly COMPLETE: "COMPLETE";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly STOPPED: "STOPPED";
};
export type AssessmentStatus =
  (typeof AssessmentStatus)[keyof typeof AssessmentStatus];
export interface StrategySummary {
  strategy?: Strategy;
  count?: number;
}
export declare const RunTimeAssessmentStatus: {
  readonly DC_FAILED: "dataCollectionTaskFailed";
  readonly DC_PARTIAL_SUCCESS: "dataCollectionTaskPartialSuccess";
  readonly DC_REQ_SENT: "dataCollectionTaskScheduled";
  readonly DC_STARTED: "dataCollectionTaskStarted";
  readonly DC_STOPPED: "dataCollectionTaskStopped";
  readonly DC_SUCCESS: "dataCollectionTaskSuccess";
  readonly DC_TO_BE_SCHEDULED: "dataCollectionTaskToBeScheduled";
};
export type RunTimeAssessmentStatus =
  (typeof RunTimeAssessmentStatus)[keyof typeof RunTimeAssessmentStatus];
export interface ServerStatusSummary {
  runTimeAssessmentStatus?: RunTimeAssessmentStatus;
  count?: number;
}
export declare const ServerOsType: {
  readonly amazonLinux: "AmazonLinux";
  readonly endOfSupportWindowsServer: "EndOfSupportWindowsServer";
  readonly other: "Other";
  readonly redhat: "Redhat";
  readonly windowsServer: "WindowsServer";
};
export type ServerOsType = (typeof ServerOsType)[keyof typeof ServerOsType];
export interface ServerSummary {
  ServerOsType?: ServerOsType;
  count?: number;
}
export interface AssessmentSummary {
  listServerStrategySummary?: StrategySummary[];
  listApplicationComponentStrategySummary?: StrategySummary[];
  listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
  listApplicationComponentSummary?: ApplicationComponentSummary[];
  listServerSummary?: ServerSummary[];
  antipatternReportS3Object?: S3Object;
  antipatternReportStatus?: AntipatternReportStatus;
  antipatternReportStatusMessage?: string;
  lastAnalyzedTimestamp?: Date;
  listApplicationComponentStatusSummary?: ApplicationComponentStatusSummary[];
  listServerStatusSummary?: ServerStatusSummary[];
}
export declare const Condition: {
  readonly CONTAINS: "CONTAINS";
  readonly EQUALS: "EQUALS";
  readonly NOT_CONTAINS: "NOT_CONTAINS";
  readonly NOT_EQUALS: "NOT_EQUALS";
};
export type Condition = (typeof Condition)[keyof typeof Condition];
export interface AssessmentTarget {
  condition: Condition | undefined;
  name: string | undefined;
  values: string[] | undefined;
}
export interface AssociatedApplication {
  name?: string;
  id?: string;
}
export declare const AuthType: {
  readonly CERT: "CERT";
  readonly NTLM: "NTLM";
  readonly SSH: "SSH";
};
export type AuthType = (typeof AuthType)[keyof typeof AuthType];
export interface GetApplicationComponentDetailsRequest {
  applicationComponentId: string | undefined;
}
export interface GetApplicationComponentDetailsResponse {
  applicationComponentDetail?: ApplicationComponentDetail;
  associatedApplications?: AssociatedApplication[];
  moreApplicationResource?: boolean;
  associatedServerIds?: string[];
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export interface GetApplicationComponentStrategiesRequest {
  applicationComponentId: string | undefined;
}
export interface GetApplicationComponentStrategiesResponse {
  applicationComponentStrategies?: ApplicationComponentStrategy[];
}
export interface GetAssessmentRequest {
  id: string | undefined;
}
export interface DataCollectionDetails {
  status?: AssessmentStatus;
  servers?: number;
  failed?: number;
  success?: number;
  inProgress?: number;
  startTime?: Date;
  completionTime?: Date;
  statusMessage?: string;
}
export interface GetAssessmentResponse {
  id?: string;
  dataCollectionDetails?: DataCollectionDetails;
  assessmentTargets?: AssessmentTarget[];
}
export interface GetImportFileTaskRequest {
  id: string | undefined;
}
export declare const ImportFileTaskStatus: {
  readonly DELETE_FAILED: "DeleteFailed";
  readonly DELETE_IN_PROGRESS: "DeleteInProgress";
  readonly DELETE_PARTIAL_SUCCESS: "DeletePartialSuccess";
  readonly DELETE_SUCCESS: "DeleteSuccess";
  readonly IMPORT_FAILED: "ImportFailed";
  readonly IMPORT_IN_PROGRESS: "ImportInProgress";
  readonly IMPORT_PARTIAL_SUCCESS: "ImportPartialSuccess";
  readonly IMPORT_SUCCESS: "ImportSuccess";
};
export type ImportFileTaskStatus =
  (typeof ImportFileTaskStatus)[keyof typeof ImportFileTaskStatus];
export interface GetImportFileTaskResponse {
  id?: string;
  status?: ImportFileTaskStatus;
  startTime?: Date;
  inputS3Bucket?: string;
  inputS3Key?: string;
  statusReportS3Bucket?: string;
  statusReportS3Key?: string;
  completionTime?: Date;
  numberOfRecordsSuccess?: number;
  numberOfRecordsFailed?: number;
  importName?: string;
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export declare class DependencyException extends __BaseException {
  readonly name: "DependencyException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<DependencyException, __BaseException>
  );
}
export interface GetLatestAssessmentIdRequest {}
export interface GetLatestAssessmentIdResponse {
  id?: string;
}
export interface GetPortfolioPreferencesRequest {}
export declare const DatabaseManagementPreference: {
  readonly AWS_MANAGED: "AWS-managed";
  readonly NO_PREFERENCE: "No preference";
  readonly SELF_MANAGE: "Self-manage";
};
export type DatabaseManagementPreference =
  (typeof DatabaseManagementPreference)[keyof typeof DatabaseManagementPreference];
export declare const HeterogeneousTargetDatabaseEngine: {
  readonly AMAZON_AURORA: "Amazon Aurora";
  readonly AWS_POSTGRESQL: "AWS PostgreSQL";
  readonly DB2_LUW: "Db2 LUW";
  readonly MARIA_DB: "MariaDB";
  readonly MICROSOFT_SQL_SERVER: "Microsoft SQL Server";
  readonly MONGO_DB: "MongoDB";
  readonly MYSQL: "MySQL";
  readonly NONE_SPECIFIED: "None specified";
  readonly ORACLE_DATABASE: "Oracle Database";
  readonly SAP: "SAP";
};
export type HeterogeneousTargetDatabaseEngine =
  (typeof HeterogeneousTargetDatabaseEngine)[keyof typeof HeterogeneousTargetDatabaseEngine];
export interface Heterogeneous {
  targetDatabaseEngine: HeterogeneousTargetDatabaseEngine[] | undefined;
}
export declare const HomogeneousTargetDatabaseEngine: {
  readonly NONE_SPECIFIED: "None specified";
};
export type HomogeneousTargetDatabaseEngine =
  (typeof HomogeneousTargetDatabaseEngine)[keyof typeof HomogeneousTargetDatabaseEngine];
export interface Homogeneous {
  targetDatabaseEngine?: HomogeneousTargetDatabaseEngine[];
}
export declare const TargetDatabaseEngine: {
  readonly AMAZON_AURORA: "Amazon Aurora";
  readonly AWS_POSTGRESQL: "AWS PostgreSQL";
  readonly DB2_LUW: "Db2 LUW";
  readonly MARIA_DB: "MariaDB";
  readonly MICROSOFT_SQL_SERVER: "Microsoft SQL Server";
  readonly MONGO_DB: "MongoDB";
  readonly MYSQL: "MySQL";
  readonly NONE_SPECIFIED: "None specified";
  readonly ORACLE_DATABASE: "Oracle Database";
  readonly SAP: "SAP";
};
export type TargetDatabaseEngine =
  (typeof TargetDatabaseEngine)[keyof typeof TargetDatabaseEngine];
export interface NoDatabaseMigrationPreference {
  targetDatabaseEngine: TargetDatabaseEngine[] | undefined;
}
export type DatabaseMigrationPreference =
  | DatabaseMigrationPreference.HeterogeneousMember
  | DatabaseMigrationPreference.HomogeneousMember
  | DatabaseMigrationPreference.NoPreferenceMember
  | DatabaseMigrationPreference.$UnknownMember;
export declare namespace DatabaseMigrationPreference {
  interface HeterogeneousMember {
    heterogeneous: Heterogeneous;
    homogeneous?: never;
    noPreference?: never;
    $unknown?: never;
  }
  interface HomogeneousMember {
    heterogeneous?: never;
    homogeneous: Homogeneous;
    noPreference?: never;
    $unknown?: never;
  }
  interface NoPreferenceMember {
    heterogeneous?: never;
    homogeneous?: never;
    noPreference: NoDatabaseMigrationPreference;
    $unknown?: never;
  }
  interface $UnknownMember {
    heterogeneous?: never;
    homogeneous?: never;
    noPreference?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    heterogeneous: (value: Heterogeneous) => T;
    homogeneous: (value: Homogeneous) => T;
    noPreference: (value: NoDatabaseMigrationPreference) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: DatabaseMigrationPreference,
    visitor: Visitor<T>
  ) => T;
}
export interface DatabasePreferences {
  databaseManagementPreference?: DatabaseManagementPreference;
  databaseMigrationPreference?: DatabaseMigrationPreference;
}
export interface BusinessGoals {
  speedOfMigration?: number;
  reduceOperationalOverheadWithManagedServices?: number;
  modernizeInfrastructureWithCloudNativeTechnologies?: number;
  licenseCostReduction?: number;
}
export interface PrioritizeBusinessGoals {
  businessGoals?: BusinessGoals;
}
export interface GetPortfolioPreferencesResponse {
  prioritizeBusinessGoals?: PrioritizeBusinessGoals;
  applicationPreferences?: ApplicationPreferences;
  databasePreferences?: DatabasePreferences;
  applicationMode?: ApplicationMode;
}
export interface GetPortfolioSummaryRequest {}
export interface GetPortfolioSummaryResponse {
  assessmentSummary?: AssessmentSummary;
}
export interface GetRecommendationReportDetailsRequest {
  id: string | undefined;
}
export declare const RecommendationReportStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly SUCCESS: "SUCCESS";
};
export type RecommendationReportStatus =
  (typeof RecommendationReportStatus)[keyof typeof RecommendationReportStatus];
export interface RecommendationReportDetails {
  status?: RecommendationReportStatus;
  statusMessage?: string;
  startTime?: Date;
  completionTime?: Date;
  s3Bucket?: string;
  s3Keys?: string[];
}
export interface GetRecommendationReportDetailsResponse {
  id?: string;
  recommendationReportDetails?: RecommendationReportDetails;
}
export interface GetServerDetailsRequest {
  serverId: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export declare const ServerErrorCategory: {
  readonly ARCHITECTURE_ERROR: "ARCHITECTURE_ERROR";
  readonly CONNECTIVITY_ERROR: "CONNECTIVITY_ERROR";
  readonly CREDENTIAL_ERROR: "CREDENTIAL_ERROR";
  readonly OTHER_ERROR: "OTHER_ERROR";
  readonly PERMISSION_ERROR: "PERMISSION_ERROR";
};
export type ServerErrorCategory =
  (typeof ServerErrorCategory)[keyof typeof ServerErrorCategory];
export interface ServerError {
  serverErrorCategory?: ServerErrorCategory;
}
export interface NetworkInfo {
  interfaceName: string | undefined;
  ipAddress: string | undefined;
  macAddress: string | undefined;
  netMask: string | undefined;
}
export declare const OSType: {
  readonly LINUX: "LINUX";
  readonly WINDOWS: "WINDOWS";
};
export type OSType = (typeof OSType)[keyof typeof OSType];
export interface OSInfo {
  type?: OSType;
  version?: string;
}
export interface SystemInfo {
  osInfo?: OSInfo;
  fileSystemType?: string;
  networkInfoList?: NetworkInfo[];
  cpuArchitecture?: string;
}
export interface ServerDetail {
  id?: string;
  name?: string;
  recommendationSet?: RecommendationSet;
  dataCollectionStatus?: RunTimeAssessmentStatus;
  statusMessage?: string;
  listAntipatternSeveritySummary?: AntipatternSeveritySummary[];
  systemInfo?: SystemInfo;
  applicationComponentStrategySummary?: StrategySummary[];
  antipatternReportS3Object?: S3Object;
  antipatternReportStatus?: AntipatternReportStatus;
  antipatternReportStatusMessage?: string;
  serverType?: string;
  lastAnalyzedTimestamp?: Date;
  serverError?: ServerError;
}
export interface GetServerDetailsResponse {
  nextToken?: string;
  serverDetail?: ServerDetail;
  associatedApplications?: AssociatedApplication[];
}
export interface GetServerStrategiesRequest {
  serverId: string | undefined;
}
export interface ServerStrategy {
  recommendation?: RecommendationSet;
  status?: StrategyRecommendation;
  numberOfApplicationComponents?: number;
  isPreferred?: boolean;
}
export interface GetServerStrategiesResponse {
  serverStrategies?: ServerStrategy[];
}
export declare const SortOrder: {
  readonly ASC: "ASC";
  readonly DESC: "DESC";
};
export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];
export interface ListAnalyzableServersRequest {
  sort?: SortOrder;
  nextToken?: string;
  maxResults?: number;
}
export interface ListAnalyzableServersResponse {
  analyzableServers?: AnalyzableServerSummary[];
  nextToken?: string;
}
export declare const GroupName: {
  readonly EXTERNAL_ID: "ExternalId";
  readonly EXTERNAL_SOURCE_TYPE: "ExternalSourceType";
};
export type GroupName = (typeof GroupName)[keyof typeof GroupName];
export interface Group {
  name?: GroupName;
  value?: string;
}
export interface ListApplicationComponentsRequest {
  applicationComponentCriteria?: ApplicationComponentCriteria;
  filterValue?: string;
  sort?: SortOrder;
  groupIdFilter?: Group[];
  nextToken?: string;
  maxResults?: number;
}
export interface ListApplicationComponentsResponse {
  applicationComponentInfos?: ApplicationComponentDetail[];
  nextToken?: string;
}
export declare class ServiceLinkedRoleLockClientException extends __BaseException {
  readonly name: "ServiceLinkedRoleLockClientException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServiceLinkedRoleLockClientException,
      __BaseException
    >
  );
}
export interface ListCollectorsRequest {
  nextToken?: string;
  maxResults?: number;
}
export declare const CollectorHealth: {
  readonly COLLECTOR_HEALTHY: "COLLECTOR_HEALTHY";
  readonly COLLECTOR_UNHEALTHY: "COLLECTOR_UNHEALTHY";
};
export type CollectorHealth =
  (typeof CollectorHealth)[keyof typeof CollectorHealth];
export interface IPAddressBasedRemoteInfo {
  ipAddressConfigurationTimeStamp?: string;
  authType?: AuthType;
  osType?: OSType;
}
export declare const PipelineType: {
  readonly AZURE_DEVOPS: "AZURE_DEVOPS";
};
export type PipelineType = (typeof PipelineType)[keyof typeof PipelineType];
export interface PipelineInfo {
  pipelineType?: PipelineType;
  pipelineConfigurationTimeStamp?: string;
}
export interface RemoteSourceCodeAnalysisServerInfo {
  remoteSourceCodeAnalysisServerConfigurationTimestamp?: string;
}
export interface VcenterBasedRemoteInfo {
  vcenterConfigurationTimeStamp?: string;
  osType?: OSType;
}
export declare const VersionControlType: {
  readonly AZURE_DEVOPS_GIT: "AZURE_DEVOPS_GIT";
  readonly GITHUB: "GITHUB";
  readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
};
export type VersionControlType =
  (typeof VersionControlType)[keyof typeof VersionControlType];
export interface VersionControlInfo {
  versionControlType?: VersionControlType;
  versionControlConfigurationTimeStamp?: string;
}
export interface ConfigurationSummary {
  vcenterBasedRemoteInfoList?: VcenterBasedRemoteInfo[];
  ipAddressBasedRemoteInfoList?: IPAddressBasedRemoteInfo[];
  versionControlInfoList?: VersionControlInfo[];
  pipelineInfoList?: PipelineInfo[];
  remoteSourceCodeAnalysisServerInfo?: RemoteSourceCodeAnalysisServerInfo;
}
export interface Collector {
  collectorId?: string;
  ipAddress?: string;
  hostName?: string;
  collectorHealth?: CollectorHealth;
  collectorVersion?: string;
  registeredTimeStamp?: string;
  lastActivityTimeStamp?: string;
  configurationSummary?: ConfigurationSummary;
}
export interface ListCollectorsResponse {
  Collectors?: Collector[];
  nextToken?: string;
}
export interface ListImportFileTaskRequest {
  nextToken?: string;
  maxResults?: number;
}
export interface ImportFileTaskInformation {
  id?: string;
  status?: ImportFileTaskStatus;
  startTime?: Date;
  inputS3Bucket?: string;
  inputS3Key?: string;
  statusReportS3Bucket?: string;
  statusReportS3Key?: string;
  completionTime?: Date;
  numberOfRecordsSuccess?: number;
  numberOfRecordsFailed?: number;
  importName?: string;
}
export interface ListImportFileTaskResponse {
  taskInfos?: ImportFileTaskInformation[];
  nextToken?: string;
}
export declare const ServerCriteria: {
  readonly ANALYSIS_STATUS: "ANALYSIS_STATUS";
  readonly DESTINATION: "DESTINATION";
  readonly ERROR_CATEGORY: "ERROR_CATEGORY";
  readonly NOT_DEFINED: "NOT_DEFINED";
  readonly OS_NAME: "OS_NAME";
  readonly SERVER_ID: "SERVER_ID";
  readonly STRATEGY: "STRATEGY";
};
export type ServerCriteria =
  (typeof ServerCriteria)[keyof typeof ServerCriteria];
export interface ListServersRequest {
  serverCriteria?: ServerCriteria;
  filterValue?: string;
  sort?: SortOrder;
  groupIdFilter?: Group[];
  nextToken?: string;
  maxResults?: number;
}
export interface ListServersResponse {
  serverInfos?: ServerDetail[];
  nextToken?: string;
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface PutPortfolioPreferencesRequest {
  prioritizeBusinessGoals?: PrioritizeBusinessGoals;
  applicationPreferences?: ApplicationPreferences;
  databasePreferences?: DatabasePreferences;
  applicationMode?: ApplicationMode;
}
export interface PutPortfolioPreferencesResponse {}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export interface StartAssessmentRequest {
  s3bucketForAnalysisData?: string;
  s3bucketForReportData?: string;
  assessmentTargets?: AssessmentTarget[];
  assessmentDataSourceType?: AssessmentDataSourceType;
}
export interface StartAssessmentResponse {
  assessmentId?: string;
}
export declare const DataSourceType: {
  readonly ADS: "ApplicationDiscoveryService";
  readonly IMPORT: "Import";
  readonly MHSR_COLLECTOR: "StrategyRecommendationsApplicationDataCollector";
  readonly MPA: "MPA";
};
export type DataSourceType =
  (typeof DataSourceType)[keyof typeof DataSourceType];
export interface StartImportFileTaskRequest {
  name: string | undefined;
  S3Bucket: string | undefined;
  s3key: string | undefined;
  dataSourceType?: DataSourceType;
  groupId?: Group[];
  s3bucketForReportData?: string;
}
export interface StartImportFileTaskResponse {
  id?: string;
}
export declare const OutputFormat: {
  readonly Excel: "Excel";
  readonly Json: "Json";
};
export type OutputFormat = (typeof OutputFormat)[keyof typeof OutputFormat];
export interface StartRecommendationReportGenerationRequest {
  outputFormat?: OutputFormat;
  groupIdFilter?: Group[];
}
export interface StartRecommendationReportGenerationResponse {
  id?: string;
}
export interface StopAssessmentRequest {
  assessmentId: string | undefined;
}
export interface StopAssessmentResponse {}
export declare const VersionControl: {
  readonly AZURE_DEVOPS_GIT: "AZURE_DEVOPS_GIT";
  readonly GITHUB: "GITHUB";
  readonly GITHUB_ENTERPRISE: "GITHUB_ENTERPRISE";
};
export type VersionControl =
  (typeof VersionControl)[keyof typeof VersionControl];
export interface SourceCode {
  versionControl?: VersionControl;
  sourceVersion?: string;
  location?: string;
  projectName?: string;
}
export interface StrategyOption {
  strategy?: Strategy;
  toolName?: TransformationToolName;
  targetDestination?: TargetDestination;
  isPreferred?: boolean;
}
export interface UpdateApplicationComponentConfigRequest {
  applicationComponentId: string | undefined;
  inclusionStatus?: InclusionStatus;
  strategyOption?: StrategyOption;
  sourceCodeList?: SourceCode[];
  secretsManagerKey?: string;
  configureOnly?: boolean;
  appType?: AppType;
}
export interface UpdateApplicationComponentConfigResponse {}
export interface UpdateServerConfigRequest {
  serverId: string | undefined;
  strategyOption?: StrategyOption;
}
export interface UpdateServerConfigResponse {}
export declare const UpdateApplicationComponentConfigRequestFilterSensitiveLog: (
  obj: UpdateApplicationComponentConfigRequest
) => any;
