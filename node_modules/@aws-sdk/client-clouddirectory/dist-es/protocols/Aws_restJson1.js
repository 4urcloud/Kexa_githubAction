import { awsExpectUnion as __expectUnion } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { CloudDirectoryServiceException as __BaseException } from "../models/CloudDirectoryServiceException";
import { AccessDeniedException, BatchWriteException, CannotListParentOfRootException, DirectoryAlreadyExistsException, DirectoryDeletedException, DirectoryNotDisabledException, DirectoryNotEnabledException, FacetAlreadyExistsException, FacetInUseException, FacetNotFoundException, FacetValidationException, IncompatibleSchemaException, IndexedAttributeMissingException, InternalServiceException, InvalidArnException, InvalidAttachmentException, InvalidFacetUpdateException, InvalidNextTokenException, InvalidRuleException, InvalidSchemaDocException, InvalidTaggingRequestException, LimitExceededException, LinkNameAlreadyInUseException, NotIndexException, NotNodeException, NotPolicyException, ObjectAlreadyDetachedException, ObjectNotDetachedException, ResourceNotFoundException, RetryableConflictException, SchemaAlreadyExistsException, SchemaAlreadyPublishedException, StillContainsLinksException, TypedAttributeValue, UnsupportedIndexTypeException, ValidationException, } from "../models/models_0";
export const se_AddFacetToObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/facets");
    let body;
    body = JSON.stringify(take(input, {
        ObjectAttributeList: (_) => se_AttributeKeyAndValueList(_, context),
        ObjectReference: (_) => _json(_),
        SchemaFacet: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_ApplySchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema/apply");
    let body;
    body = JSON.stringify(take(input, {
        PublishedSchemaArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/attach");
    let body;
    body = JSON.stringify(take(input, {
        ChildReference: (_) => _json(_),
        LinkName: [],
        ParentReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/policy/attach");
    let body;
    body = JSON.stringify(take(input, {
        ObjectReference: (_) => _json(_),
        PolicyReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachToIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/index/attach");
    let body;
    body = JSON.stringify(take(input, {
        IndexReference: (_) => _json(_),
        TargetReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_AttachTypedLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/attach");
    let body;
    body = JSON.stringify(take(input, {
        Attributes: (_) => se_AttributeNameAndValueList(_, context),
        SourceObjectReference: (_) => _json(_),
        TargetObjectReference: (_) => _json(_),
        TypedLinkFacet: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_BatchReadCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/batchread");
    let body;
    body = JSON.stringify(take(input, {
        Operations: (_) => se_BatchReadOperationList(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_BatchWriteCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/batchwrite");
    let body;
    body = JSON.stringify(take(input, {
        Operations: (_) => se_BatchWriteOperationList(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateDirectoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/directory/create");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet/create");
    let body;
    body = JSON.stringify(take(input, {
        Attributes: (_) => se_FacetAttributeList(_, context),
        FacetStyle: [],
        Name: [],
        ObjectType: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/index");
    let body;
    body = JSON.stringify(take(input, {
        IsUnique: [],
        LinkName: [],
        OrderedIndexedAttributeList: (_) => _json(_),
        ParentReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object");
    let body;
    body = JSON.stringify(take(input, {
        LinkName: [],
        ObjectAttributeList: (_) => se_AttributeKeyAndValueList(_, context),
        ParentReference: (_) => _json(_),
        SchemaFacets: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/create");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateTypedLinkFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet/create");
    let body;
    body = JSON.stringify(take(input, {
        Facet: (_) => se_TypedLinkFacet(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteDirectoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/directory");
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet/delete");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/delete");
    let body;
    body = JSON.stringify(take(input, {
        ObjectReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema");
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteTypedLinkFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet/delete");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DetachFromIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/index/detach");
    let body;
    body = JSON.stringify(take(input, {
        IndexReference: (_) => _json(_),
        TargetReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DetachObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/detach");
    let body;
    body = JSON.stringify(take(input, {
        LinkName: [],
        ParentReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DetachPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/policy/detach");
    let body;
    body = JSON.stringify(take(input, {
        ObjectReference: (_) => _json(_),
        PolicyReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DetachTypedLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/detach");
    let body;
    body = JSON.stringify(take(input, {
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DisableDirectoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/directory/disable");
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_EnableDirectoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/directory/enable");
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_GetAppliedSchemaVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/getappliedschema");
    let body;
    body = JSON.stringify(take(input, {
        SchemaArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetDirectoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/directory/get");
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetLinkAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/attributes/get");
    let body;
    body = JSON.stringify(take(input, {
        AttributeNames: (_) => _json(_),
        ConsistencyLevel: [],
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetObjectAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/attributes/get");
    let body;
    body = JSON.stringify(take(input, {
        AttributeNames: (_) => _json(_),
        ObjectReference: (_) => _json(_),
        SchemaFacet: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetObjectInformationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/information");
    let body;
    body = JSON.stringify(take(input, {
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetSchemaAsJsonCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema/json");
    let body;
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTypedLinkFacetInformationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet/get");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAppliedSchemaArnsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/applied");
    let body;
    body = JSON.stringify(take(input, {
        DirectoryArn: [],
        MaxResults: [],
        NextToken: [],
        SchemaArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAttachedIndicesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/indices");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        TargetReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListDevelopmentSchemaArnsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/development");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListDirectoriesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/directory/list");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        state: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListFacetAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet/attributes");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        Name: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListFacetNamesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet/list");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIncomingTypedLinksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/incoming");
    let body;
    body = JSON.stringify(take(input, {
        ConsistencyLevel: [],
        FilterAttributeRanges: (_) => se_TypedLinkAttributeRangeList(_, context),
        FilterTypedLink: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListIndexCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/index/targets");
    let body;
    body = JSON.stringify(take(input, {
        IndexReference: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
        RangesOnIndexedValues: (_) => se_ObjectAttributeRangeList(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListManagedSchemaArnsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/managed");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        SchemaArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListObjectAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/attributes");
    let body;
    body = JSON.stringify(take(input, {
        FacetFilter: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListObjectChildrenCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/children");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListObjectParentPathsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/parentpaths");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListObjectParentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/parent");
    let body;
    body = JSON.stringify(take(input, {
        IncludeAllLinksToEachParent: [],
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListObjectPoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/policy");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListOutgoingTypedLinksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/outgoing");
    let body;
    body = JSON.stringify(take(input, {
        ConsistencyLevel: [],
        FilterAttributeRanges: (_) => se_TypedLinkAttributeRangeList(_, context),
        FilterTypedLink: (_) => _json(_),
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPolicyAttachmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
        [_xacl]: input[_CL],
    });
    b.bp("/amazonclouddirectory/2017-01-11/policy/attachment");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        PolicyReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPublishedSchemaArnsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/published");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        SchemaArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/tags");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        ResourceArn: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTypedLinkFacetAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet/attributes");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        Name: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTypedLinkFacetNamesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet/list");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_LookupPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/policy/lookup");
    let body;
    body = JSON.stringify(take(input, {
        MaxResults: [],
        NextToken: [],
        ObjectReference: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PublishSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DSA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema/publish");
    let body;
    body = JSON.stringify(take(input, {
        MinorVersion: [],
        Name: [],
        Version: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutSchemaFromJsonCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema/json");
    let body;
    body = JSON.stringify(take(input, {
        Document: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_RemoveFacetFromObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/facets/delete");
    let body;
    body = JSON.stringify(take(input, {
        ObjectReference: (_) => _json(_),
        SchemaFacet: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/tags/add");
    let body;
    body = JSON.stringify(take(input, {
        ResourceArn: [],
        Tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/tags/remove");
    let body;
    body = JSON.stringify(take(input, {
        ResourceArn: [],
        TagKeys: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/facet");
    let body;
    body = JSON.stringify(take(input, {
        AttributeUpdates: (_) => se_FacetAttributeUpdateList(_, context),
        Name: [],
        ObjectType: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateLinkAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/attributes/update");
    let body;
    body = JSON.stringify(take(input, {
        AttributeUpdates: (_) => se_LinkAttributeUpdateList(_, context),
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateObjectAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_DA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/object/update");
    let body;
    body = JSON.stringify(take(input, {
        AttributeUpdates: (_) => se_ObjectAttributeUpdateList(_, context),
        ObjectReference: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/schema/update");
    let body;
    body = JSON.stringify(take(input, {
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateTypedLinkFacetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        [_xadp]: input[_SA],
    });
    b.bp("/amazonclouddirectory/2017-01-11/typedlink/facet");
    let body;
    body = JSON.stringify(take(input, {
        AttributeUpdates: (_) => se_TypedLinkFacetAttributeUpdateList(_, context),
        IdentityAttributeOrder: (_) => _json(_),
        Name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpgradeAppliedSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/upgradeapplied");
    let body;
    body = JSON.stringify(take(input, {
        DirectoryArn: [],
        DryRun: [],
        PublishedSchemaArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpgradePublishedSchemaCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/amazonclouddirectory/2017-01-11/schema/upgradepublished");
    let body;
    body = JSON.stringify(take(input, {
        DevelopmentSchemaArn: [],
        DryRun: [],
        MinorVersion: [],
        PublishedSchemaArn: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_AddFacetToObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ApplySchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AppliedSchemaArn: __expectString,
        DirectoryArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AttachObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttachedObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AttachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AttachToIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttachedObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AttachTypedLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        TypedLinkSpecifier: (_) => de_TypedLinkSpecifier(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchReadCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Responses: (_) => de_BatchReadOperationResponseList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_BatchWriteCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Responses: (_) => de_BatchWriteOperationResponseList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDirectoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AppliedSchemaArn: __expectString,
        DirectoryArn: __expectString,
        Name: __expectString,
        ObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateTypedLinkFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDirectoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DirectoryArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteTypedLinkFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DetachFromIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DetachedObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DetachObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DetachedObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DetachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DetachTypedLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DisableDirectoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DirectoryArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_EnableDirectoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DirectoryArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAppliedSchemaVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AppliedSchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDirectoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Directory: (_) => de_Directory(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Facet: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetLinkAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetObjectAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetObjectInformationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ObjectIdentifier: __expectString,
        SchemaFacets: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSchemaAsJsonCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Document: __expectString,
        Name: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTypedLinkFacetInformationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        IdentityAttributeOrder: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAppliedSchemaArnsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SchemaArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAttachedIndicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        IndexAttachments: (_) => de_IndexAttachmentList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDevelopmentSchemaArnsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SchemaArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDirectoriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Directories: (_) => de_DirectoryList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFacetAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: (_) => de_FacetAttributeList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFacetNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FacetNames: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIncomingTypedLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LinkSpecifiers: (_) => de_TypedLinkSpecifierList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        IndexAttachments: (_) => de_IndexAttachmentList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListManagedSchemaArnsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SchemaArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListObjectAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListObjectChildrenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Children: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListObjectParentPathsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        PathToObjectIdentifiersList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListObjectParentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ParentLinks: _json,
        Parents: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListObjectPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttachedPolicyIds: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListOutgoingTypedLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        TypedLinkSpecifiers: (_) => de_TypedLinkSpecifierList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPolicyAttachmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ObjectIdentifiers: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPublishedSchemaArnsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SchemaArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTypedLinkFacetAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: (_) => de_TypedLinkAttributeDefinitionList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTypedLinkFacetNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        FacetNames: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_LookupPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        PolicyToPathList: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PublishSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        PublishedSchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutSchemaFromJsonCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveFacetFromObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateLinkAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateObjectAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ObjectIdentifier: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateTypedLinkFacetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpgradeAppliedSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DirectoryArn: __expectString,
        UpgradedSchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpgradePublishedSchemaCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        UpgradedSchemaArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.clouddirectory#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "DirectoryNotEnabledException":
        case "com.amazonaws.clouddirectory#DirectoryNotEnabledException":
            throw await de_DirectoryNotEnabledExceptionRes(parsedOutput, context);
        case "FacetValidationException":
        case "com.amazonaws.clouddirectory#FacetValidationException":
            throw await de_FacetValidationExceptionRes(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.clouddirectory#InternalServiceException":
            throw await de_InternalServiceExceptionRes(parsedOutput, context);
        case "InvalidArnException":
        case "com.amazonaws.clouddirectory#InvalidArnException":
            throw await de_InvalidArnExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.clouddirectory#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.clouddirectory#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "RetryableConflictException":
        case "com.amazonaws.clouddirectory#RetryableConflictException":
            throw await de_RetryableConflictExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.clouddirectory#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "InvalidAttachmentException":
        case "com.amazonaws.clouddirectory#InvalidAttachmentException":
            throw await de_InvalidAttachmentExceptionRes(parsedOutput, context);
        case "SchemaAlreadyExistsException":
        case "com.amazonaws.clouddirectory#SchemaAlreadyExistsException":
            throw await de_SchemaAlreadyExistsExceptionRes(parsedOutput, context);
        case "LinkNameAlreadyInUseException":
        case "com.amazonaws.clouddirectory#LinkNameAlreadyInUseException":
            throw await de_LinkNameAlreadyInUseExceptionRes(parsedOutput, context);
        case "NotPolicyException":
        case "com.amazonaws.clouddirectory#NotPolicyException":
            throw await de_NotPolicyExceptionRes(parsedOutput, context);
        case "IndexedAttributeMissingException":
        case "com.amazonaws.clouddirectory#IndexedAttributeMissingException":
            throw await de_IndexedAttributeMissingExceptionRes(parsedOutput, context);
        case "NotIndexException":
        case "com.amazonaws.clouddirectory#NotIndexException":
            throw await de_NotIndexExceptionRes(parsedOutput, context);
        case "BatchWriteException":
        case "com.amazonaws.clouddirectory#BatchWriteException":
            throw await de_BatchWriteExceptionRes(parsedOutput, context);
        case "DirectoryAlreadyExistsException":
        case "com.amazonaws.clouddirectory#DirectoryAlreadyExistsException":
            throw await de_DirectoryAlreadyExistsExceptionRes(parsedOutput, context);
        case "FacetAlreadyExistsException":
        case "com.amazonaws.clouddirectory#FacetAlreadyExistsException":
            throw await de_FacetAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidRuleException":
        case "com.amazonaws.clouddirectory#InvalidRuleException":
            throw await de_InvalidRuleExceptionRes(parsedOutput, context);
        case "UnsupportedIndexTypeException":
        case "com.amazonaws.clouddirectory#UnsupportedIndexTypeException":
            throw await de_UnsupportedIndexTypeExceptionRes(parsedOutput, context);
        case "DirectoryDeletedException":
        case "com.amazonaws.clouddirectory#DirectoryDeletedException":
            throw await de_DirectoryDeletedExceptionRes(parsedOutput, context);
        case "DirectoryNotDisabledException":
        case "com.amazonaws.clouddirectory#DirectoryNotDisabledException":
            throw await de_DirectoryNotDisabledExceptionRes(parsedOutput, context);
        case "FacetInUseException":
        case "com.amazonaws.clouddirectory#FacetInUseException":
            throw await de_FacetInUseExceptionRes(parsedOutput, context);
        case "FacetNotFoundException":
        case "com.amazonaws.clouddirectory#FacetNotFoundException":
            throw await de_FacetNotFoundExceptionRes(parsedOutput, context);
        case "ObjectNotDetachedException":
        case "com.amazonaws.clouddirectory#ObjectNotDetachedException":
            throw await de_ObjectNotDetachedExceptionRes(parsedOutput, context);
        case "StillContainsLinksException":
        case "com.amazonaws.clouddirectory#StillContainsLinksException":
            throw await de_StillContainsLinksExceptionRes(parsedOutput, context);
        case "ObjectAlreadyDetachedException":
        case "com.amazonaws.clouddirectory#ObjectAlreadyDetachedException":
            throw await de_ObjectAlreadyDetachedExceptionRes(parsedOutput, context);
        case "NotNodeException":
        case "com.amazonaws.clouddirectory#NotNodeException":
            throw await de_NotNodeExceptionRes(parsedOutput, context);
        case "InvalidNextTokenException":
        case "com.amazonaws.clouddirectory#InvalidNextTokenException":
            throw await de_InvalidNextTokenExceptionRes(parsedOutput, context);
        case "CannotListParentOfRootException":
        case "com.amazonaws.clouddirectory#CannotListParentOfRootException":
            throw await de_CannotListParentOfRootExceptionRes(parsedOutput, context);
        case "InvalidTaggingRequestException":
        case "com.amazonaws.clouddirectory#InvalidTaggingRequestException":
            throw await de_InvalidTaggingRequestExceptionRes(parsedOutput, context);
        case "SchemaAlreadyPublishedException":
        case "com.amazonaws.clouddirectory#SchemaAlreadyPublishedException":
            throw await de_SchemaAlreadyPublishedExceptionRes(parsedOutput, context);
        case "InvalidSchemaDocException":
        case "com.amazonaws.clouddirectory#InvalidSchemaDocException":
            throw await de_InvalidSchemaDocExceptionRes(parsedOutput, context);
        case "InvalidFacetUpdateException":
        case "com.amazonaws.clouddirectory#InvalidFacetUpdateException":
            throw await de_InvalidFacetUpdateExceptionRes(parsedOutput, context);
        case "IncompatibleSchemaException":
        case "com.amazonaws.clouddirectory#IncompatibleSchemaException":
            throw await de_IncompatibleSchemaExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BatchWriteExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Index: __expectInt32,
        Message: __expectString,
        Type: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BatchWriteException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_CannotListParentOfRootExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new CannotListParentOfRootException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DirectoryAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DirectoryAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DirectoryDeletedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DirectoryDeletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DirectoryNotDisabledExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DirectoryNotDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_DirectoryNotEnabledExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new DirectoryNotEnabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_FacetAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new FacetAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_FacetInUseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new FacetInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_FacetNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new FacetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_FacetValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new FacetValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_IncompatibleSchemaExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new IncompatibleSchemaException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_IndexedAttributeMissingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new IndexedAttributeMissingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServiceExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidArnExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidArnException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidAttachmentExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidAttachmentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidFacetUpdateExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidFacetUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidNextTokenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidNextTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRuleExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRuleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidSchemaDocExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidSchemaDocException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidTaggingRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidTaggingRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LinkNameAlreadyInUseExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LinkNameAlreadyInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotIndexExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotIndexException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotNodeExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotNodeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotPolicyExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ObjectAlreadyDetachedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ObjectAlreadyDetachedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ObjectNotDetachedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ObjectNotDetachedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_RetryableConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new RetryableConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_SchemaAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new SchemaAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_SchemaAlreadyPublishedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new SchemaAlreadyPublishedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_StillContainsLinksExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new StillContainsLinksException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnsupportedIndexTypeExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedIndexTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AttributeKeyAndValue = (input, context) => {
    return take(input, {
        Key: _json,
        Value: (_) => se_TypedAttributeValue(_, context),
    });
};
const se_AttributeKeyAndValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeKeyAndValue(entry, context);
    });
};
const se_AttributeNameAndValue = (input, context) => {
    return take(input, {
        AttributeName: [],
        Value: (_) => se_TypedAttributeValue(_, context),
    });
};
const se_AttributeNameAndValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AttributeNameAndValue(entry, context);
    });
};
const se_BatchAddFacetToObject = (input, context) => {
    return take(input, {
        ObjectAttributeList: (_) => se_AttributeKeyAndValueList(_, context),
        ObjectReference: _json,
        SchemaFacet: _json,
    });
};
const se_BatchAttachTypedLink = (input, context) => {
    return take(input, {
        Attributes: (_) => se_AttributeNameAndValueList(_, context),
        SourceObjectReference: _json,
        TargetObjectReference: _json,
        TypedLinkFacet: _json,
    });
};
const se_BatchCreateObject = (input, context) => {
    return take(input, {
        BatchReferenceName: [],
        LinkName: [],
        ObjectAttributeList: (_) => se_AttributeKeyAndValueList(_, context),
        ParentReference: _json,
        SchemaFacet: _json,
    });
};
const se_BatchDetachTypedLink = (input, context) => {
    return take(input, {
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    });
};
const se_BatchGetLinkAttributes = (input, context) => {
    return take(input, {
        AttributeNames: _json,
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    });
};
const se_BatchListIncomingTypedLinks = (input, context) => {
    return take(input, {
        FilterAttributeRanges: (_) => se_TypedLinkAttributeRangeList(_, context),
        FilterTypedLink: _json,
        MaxResults: [],
        NextToken: [],
        ObjectReference: _json,
    });
};
const se_BatchListIndex = (input, context) => {
    return take(input, {
        IndexReference: _json,
        MaxResults: [],
        NextToken: [],
        RangesOnIndexedValues: (_) => se_ObjectAttributeRangeList(_, context),
    });
};
const se_BatchListOutgoingTypedLinks = (input, context) => {
    return take(input, {
        FilterAttributeRanges: (_) => se_TypedLinkAttributeRangeList(_, context),
        FilterTypedLink: _json,
        MaxResults: [],
        NextToken: [],
        ObjectReference: _json,
    });
};
const se_BatchReadOperation = (input, context) => {
    return take(input, {
        GetLinkAttributes: (_) => se_BatchGetLinkAttributes(_, context),
        GetObjectAttributes: _json,
        GetObjectInformation: _json,
        ListAttachedIndices: _json,
        ListIncomingTypedLinks: (_) => se_BatchListIncomingTypedLinks(_, context),
        ListIndex: (_) => se_BatchListIndex(_, context),
        ListObjectAttributes: _json,
        ListObjectChildren: _json,
        ListObjectParentPaths: _json,
        ListObjectParents: _json,
        ListObjectPolicies: _json,
        ListOutgoingTypedLinks: (_) => se_BatchListOutgoingTypedLinks(_, context),
        ListPolicyAttachments: _json,
        LookupPolicy: _json,
    });
};
const se_BatchReadOperationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchReadOperation(entry, context);
    });
};
const se_BatchUpdateLinkAttributes = (input, context) => {
    return take(input, {
        AttributeUpdates: (_) => se_LinkAttributeUpdateList(_, context),
        TypedLinkSpecifier: (_) => se_TypedLinkSpecifier(_, context),
    });
};
const se_BatchUpdateObjectAttributes = (input, context) => {
    return take(input, {
        AttributeUpdates: (_) => se_ObjectAttributeUpdateList(_, context),
        ObjectReference: _json,
    });
};
const se_BatchWriteOperation = (input, context) => {
    return take(input, {
        AddFacetToObject: (_) => se_BatchAddFacetToObject(_, context),
        AttachObject: _json,
        AttachPolicy: _json,
        AttachToIndex: _json,
        AttachTypedLink: (_) => se_BatchAttachTypedLink(_, context),
        CreateIndex: _json,
        CreateObject: (_) => se_BatchCreateObject(_, context),
        DeleteObject: _json,
        DetachFromIndex: _json,
        DetachObject: _json,
        DetachPolicy: _json,
        DetachTypedLink: (_) => se_BatchDetachTypedLink(_, context),
        RemoveFacetFromObject: _json,
        UpdateLinkAttributes: (_) => se_BatchUpdateLinkAttributes(_, context),
        UpdateObjectAttributes: (_) => se_BatchUpdateObjectAttributes(_, context),
    });
};
const se_BatchWriteOperationList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_BatchWriteOperation(entry, context);
    });
};
const se_FacetAttribute = (input, context) => {
    return take(input, {
        AttributeDefinition: (_) => se_FacetAttributeDefinition(_, context),
        AttributeReference: _json,
        Name: [],
        RequiredBehavior: [],
    });
};
const se_FacetAttributeDefinition = (input, context) => {
    return take(input, {
        DefaultValue: (_) => se_TypedAttributeValue(_, context),
        IsImmutable: [],
        Rules: _json,
        Type: [],
    });
};
const se_FacetAttributeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_FacetAttribute(entry, context);
    });
};
const se_FacetAttributeUpdate = (input, context) => {
    return take(input, {
        Action: [],
        Attribute: (_) => se_FacetAttribute(_, context),
    });
};
const se_FacetAttributeUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_FacetAttributeUpdate(entry, context);
    });
};
const se_LinkAttributeAction = (input, context) => {
    return take(input, {
        AttributeActionType: [],
        AttributeUpdateValue: (_) => se_TypedAttributeValue(_, context),
    });
};
const se_LinkAttributeUpdate = (input, context) => {
    return take(input, {
        AttributeAction: (_) => se_LinkAttributeAction(_, context),
        AttributeKey: _json,
    });
};
const se_LinkAttributeUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_LinkAttributeUpdate(entry, context);
    });
};
const se_ObjectAttributeAction = (input, context) => {
    return take(input, {
        ObjectAttributeActionType: [],
        ObjectAttributeUpdateValue: (_) => se_TypedAttributeValue(_, context),
    });
};
const se_ObjectAttributeRange = (input, context) => {
    return take(input, {
        AttributeKey: _json,
        Range: (_) => se_TypedAttributeValueRange(_, context),
    });
};
const se_ObjectAttributeRangeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ObjectAttributeRange(entry, context);
    });
};
const se_ObjectAttributeUpdate = (input, context) => {
    return take(input, {
        ObjectAttributeAction: (_) => se_ObjectAttributeAction(_, context),
        ObjectAttributeKey: _json,
    });
};
const se_ObjectAttributeUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ObjectAttributeUpdate(entry, context);
    });
};
const se_TypedAttributeValue = (input, context) => {
    return TypedAttributeValue.visit(input, {
        BinaryValue: (value) => ({ BinaryValue: context.base64Encoder(value) }),
        BooleanValue: (value) => ({ BooleanValue: value }),
        DatetimeValue: (value) => ({ DatetimeValue: Math.round(value.getTime() / 1000) }),
        NumberValue: (value) => ({ NumberValue: value }),
        StringValue: (value) => ({ StringValue: value }),
        _: (name, value) => ({ name: value }),
    });
};
const se_TypedAttributeValueRange = (input, context) => {
    return take(input, {
        EndMode: [],
        EndValue: (_) => se_TypedAttributeValue(_, context),
        StartMode: [],
        StartValue: (_) => se_TypedAttributeValue(_, context),
    });
};
const se_TypedLinkAttributeDefinition = (input, context) => {
    return take(input, {
        DefaultValue: (_) => se_TypedAttributeValue(_, context),
        IsImmutable: [],
        Name: [],
        RequiredBehavior: [],
        Rules: _json,
        Type: [],
    });
};
const se_TypedLinkAttributeDefinitionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TypedLinkAttributeDefinition(entry, context);
    });
};
const se_TypedLinkAttributeRange = (input, context) => {
    return take(input, {
        AttributeName: [],
        Range: (_) => se_TypedAttributeValueRange(_, context),
    });
};
const se_TypedLinkAttributeRangeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TypedLinkAttributeRange(entry, context);
    });
};
const se_TypedLinkFacet = (input, context) => {
    return take(input, {
        Attributes: (_) => se_TypedLinkAttributeDefinitionList(_, context),
        IdentityAttributeOrder: _json,
        Name: [],
    });
};
const se_TypedLinkFacetAttributeUpdate = (input, context) => {
    return take(input, {
        Action: [],
        Attribute: (_) => se_TypedLinkAttributeDefinition(_, context),
    });
};
const se_TypedLinkFacetAttributeUpdateList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TypedLinkFacetAttributeUpdate(entry, context);
    });
};
const se_TypedLinkSpecifier = (input, context) => {
    return take(input, {
        IdentityAttributeValues: (_) => se_AttributeNameAndValueList(_, context),
        SourceObjectReference: _json,
        TargetObjectReference: _json,
        TypedLinkFacet: _json,
    });
};
const de_AttributeKeyAndValue = (output, context) => {
    return take(output, {
        Key: _json,
        Value: (_) => de_TypedAttributeValue(__expectUnion(_), context),
    });
};
const de_AttributeKeyAndValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeKeyAndValue(entry, context);
    });
    return retVal;
};
const de_AttributeNameAndValue = (output, context) => {
    return take(output, {
        AttributeName: __expectString,
        Value: (_) => de_TypedAttributeValue(__expectUnion(_), context),
    });
};
const de_AttributeNameAndValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttributeNameAndValue(entry, context);
    });
    return retVal;
};
const de_BatchAttachTypedLinkResponse = (output, context) => {
    return take(output, {
        TypedLinkSpecifier: (_) => de_TypedLinkSpecifier(_, context),
    });
};
const de_BatchGetLinkAttributesResponse = (output, context) => {
    return take(output, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
    });
};
const de_BatchGetObjectAttributesResponse = (output, context) => {
    return take(output, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
    });
};
const de_BatchListAttachedIndicesResponse = (output, context) => {
    return take(output, {
        IndexAttachments: (_) => de_IndexAttachmentList(_, context),
        NextToken: __expectString,
    });
};
const de_BatchListIncomingTypedLinksResponse = (output, context) => {
    return take(output, {
        LinkSpecifiers: (_) => de_TypedLinkSpecifierList(_, context),
        NextToken: __expectString,
    });
};
const de_BatchListIndexResponse = (output, context) => {
    return take(output, {
        IndexAttachments: (_) => de_IndexAttachmentList(_, context),
        NextToken: __expectString,
    });
};
const de_BatchListObjectAttributesResponse = (output, context) => {
    return take(output, {
        Attributes: (_) => de_AttributeKeyAndValueList(_, context),
        NextToken: __expectString,
    });
};
const de_BatchListOutgoingTypedLinksResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        TypedLinkSpecifiers: (_) => de_TypedLinkSpecifierList(_, context),
    });
};
const de_BatchReadOperationResponse = (output, context) => {
    return take(output, {
        ExceptionResponse: _json,
        SuccessfulResponse: (_) => de_BatchReadSuccessfulResponse(_, context),
    });
};
const de_BatchReadOperationResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchReadOperationResponse(entry, context);
    });
    return retVal;
};
const de_BatchReadSuccessfulResponse = (output, context) => {
    return take(output, {
        GetLinkAttributes: (_) => de_BatchGetLinkAttributesResponse(_, context),
        GetObjectAttributes: (_) => de_BatchGetObjectAttributesResponse(_, context),
        GetObjectInformation: _json,
        ListAttachedIndices: (_) => de_BatchListAttachedIndicesResponse(_, context),
        ListIncomingTypedLinks: (_) => de_BatchListIncomingTypedLinksResponse(_, context),
        ListIndex: (_) => de_BatchListIndexResponse(_, context),
        ListObjectAttributes: (_) => de_BatchListObjectAttributesResponse(_, context),
        ListObjectChildren: _json,
        ListObjectParentPaths: _json,
        ListObjectParents: _json,
        ListObjectPolicies: _json,
        ListOutgoingTypedLinks: (_) => de_BatchListOutgoingTypedLinksResponse(_, context),
        ListPolicyAttachments: _json,
        LookupPolicy: _json,
    });
};
const de_BatchWriteOperationResponse = (output, context) => {
    return take(output, {
        AddFacetToObject: _json,
        AttachObject: _json,
        AttachPolicy: _json,
        AttachToIndex: _json,
        AttachTypedLink: (_) => de_BatchAttachTypedLinkResponse(_, context),
        CreateIndex: _json,
        CreateObject: _json,
        DeleteObject: _json,
        DetachFromIndex: _json,
        DetachObject: _json,
        DetachPolicy: _json,
        DetachTypedLink: _json,
        RemoveFacetFromObject: _json,
        UpdateLinkAttributes: _json,
        UpdateObjectAttributes: _json,
    });
};
const de_BatchWriteOperationResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchWriteOperationResponse(entry, context);
    });
    return retVal;
};
const de_Directory = (output, context) => {
    return take(output, {
        CreationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DirectoryArn: __expectString,
        Name: __expectString,
        State: __expectString,
    });
};
const de_DirectoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Directory(entry, context);
    });
    return retVal;
};
const de_FacetAttribute = (output, context) => {
    return take(output, {
        AttributeDefinition: (_) => de_FacetAttributeDefinition(_, context),
        AttributeReference: _json,
        Name: __expectString,
        RequiredBehavior: __expectString,
    });
};
const de_FacetAttributeDefinition = (output, context) => {
    return take(output, {
        DefaultValue: (_) => de_TypedAttributeValue(__expectUnion(_), context),
        IsImmutable: __expectBoolean,
        Rules: _json,
        Type: __expectString,
    });
};
const de_FacetAttributeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FacetAttribute(entry, context);
    });
    return retVal;
};
const de_IndexAttachment = (output, context) => {
    return take(output, {
        IndexedAttributes: (_) => de_AttributeKeyAndValueList(_, context),
        ObjectIdentifier: __expectString,
    });
};
const de_IndexAttachmentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IndexAttachment(entry, context);
    });
    return retVal;
};
const de_TypedAttributeValue = (output, context) => {
    if (output.BinaryValue != null) {
        return {
            BinaryValue: context.base64Decoder(output.BinaryValue),
        };
    }
    if (__expectBoolean(output.BooleanValue) !== undefined) {
        return { BooleanValue: __expectBoolean(output.BooleanValue) };
    }
    if (output.DatetimeValue != null) {
        return {
            DatetimeValue: __expectNonNull(__parseEpochTimestamp(__expectNumber(output.DatetimeValue))),
        };
    }
    if (__expectString(output.NumberValue) !== undefined) {
        return { NumberValue: __expectString(output.NumberValue) };
    }
    if (__expectString(output.StringValue) !== undefined) {
        return { StringValue: __expectString(output.StringValue) };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_TypedLinkAttributeDefinition = (output, context) => {
    return take(output, {
        DefaultValue: (_) => de_TypedAttributeValue(__expectUnion(_), context),
        IsImmutable: __expectBoolean,
        Name: __expectString,
        RequiredBehavior: __expectString,
        Rules: _json,
        Type: __expectString,
    });
};
const de_TypedLinkAttributeDefinitionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TypedLinkAttributeDefinition(entry, context);
    });
    return retVal;
};
const de_TypedLinkSpecifier = (output, context) => {
    return take(output, {
        IdentityAttributeValues: (_) => de_AttributeNameAndValueList(_, context),
        SourceObjectReference: _json,
        TargetObjectReference: _json,
        TypedLinkFacet: _json,
    });
};
const de_TypedLinkSpecifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TypedLinkSpecifier(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _CL = "ConsistencyLevel";
const _DA = "DirectoryArn";
const _DSA = "DevelopmentSchemaArn";
const _SA = "SchemaArn";
const _xacl = "x-amz-consistency-level";
const _xadp = "x-amz-data-partition";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
