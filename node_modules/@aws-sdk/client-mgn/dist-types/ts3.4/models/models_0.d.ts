import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { MgnServiceException as __BaseException } from "./MgnServiceException";
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  code?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare const ActionCategory: {
  readonly BACKUP: "BACKUP";
  readonly CONFIGURATION: "CONFIGURATION";
  readonly DISASTER_RECOVERY: "DISASTER_RECOVERY";
  readonly LICENSE_AND_SUBSCRIPTION: "LICENSE_AND_SUBSCRIPTION";
  readonly NETWORKING: "NETWORKING";
  readonly OBSERVABILITY: "OBSERVABILITY";
  readonly OPERATING_SYSTEM: "OPERATING_SYSTEM";
  readonly OTHER: "OTHER";
  readonly SECURITY: "SECURITY";
  readonly VALIDATION: "VALIDATION";
};
export type ActionCategory =
  (typeof ActionCategory)[keyof typeof ActionCategory];
export declare const ApplicationHealthStatus: {
  readonly ERROR: "ERROR";
  readonly HEALTHY: "HEALTHY";
  readonly LAGGING: "LAGGING";
};
export type ApplicationHealthStatus =
  (typeof ApplicationHealthStatus)[keyof typeof ApplicationHealthStatus];
export declare const ApplicationProgressStatus: {
  readonly COMPLETED: "COMPLETED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly NOT_STARTED: "NOT_STARTED";
};
export type ApplicationProgressStatus =
  (typeof ApplicationProgressStatus)[keyof typeof ApplicationProgressStatus];
export interface ApplicationAggregatedStatus {
  lastUpdateDateTime?: string;
  healthStatus?: ApplicationHealthStatus;
  progressStatus?: ApplicationProgressStatus;
  totalSourceServers?: number;
}
export interface Application {
  applicationID?: string;
  arn?: string;
  name?: string;
  description?: string;
  isArchived?: boolean;
  applicationAggregatedStatus?: ApplicationAggregatedStatus;
  creationDateTime?: string;
  lastModifiedDateTime?: string;
  tags?: Record<string, string>;
  waveID?: string;
}
export interface ArchiveApplicationRequest {
  applicationID: string | undefined;
  accountID?: string;
}
export interface ErrorDetails {
  message?: string;
  code?: string;
  resourceId?: string;
  resourceType?: string;
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  code?: string;
  resourceId?: string;
  resourceType?: string;
  errors?: ErrorDetails[];
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  code?: string;
  resourceId?: string;
  resourceType?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  code?: string;
  resourceId?: string;
  resourceType?: string;
  serviceCode?: string;
  quotaCode?: string;
  quotaValue?: number;
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export declare class UninitializedAccountException extends __BaseException {
  readonly name: "UninitializedAccountException";
  readonly $fault: "client";
  code?: string;
  constructor(
    opts: __ExceptionOptionType<UninitializedAccountException, __BaseException>
  );
}
export interface AssociateSourceServersRequest {
  applicationID: string | undefined;
  sourceServerIDs: string[] | undefined;
  accountID?: string;
}
export interface AssociateSourceServersResponse {}
export interface CreateApplicationRequest {
  name: string | undefined;
  description?: string;
  tags?: Record<string, string>;
  accountID?: string;
}
export interface DeleteApplicationRequest {
  applicationID: string | undefined;
  accountID?: string;
}
export interface DeleteApplicationResponse {}
export interface DisassociateSourceServersRequest {
  applicationID: string | undefined;
  sourceServerIDs: string[] | undefined;
  accountID?: string;
}
export interface DisassociateSourceServersResponse {}
export interface ListApplicationsRequestFilters {
  applicationIDs?: string[];
  isArchived?: boolean;
  waveIDs?: string[];
}
export interface ListApplicationsRequest {
  filters?: ListApplicationsRequestFilters;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export interface ListApplicationsResponse {
  items?: Application[];
  nextToken?: string;
}
export interface UnarchiveApplicationRequest {
  applicationID: string | undefined;
  accountID?: string;
}
export interface UpdateApplicationRequest {
  applicationID: string | undefined;
  name?: string;
  description?: string;
  accountID?: string;
}
export interface ConnectorSsmCommandConfig {
  s3OutputEnabled: boolean | undefined;
  outputS3BucketName?: string;
  cloudWatchOutputEnabled: boolean | undefined;
  cloudWatchLogGroupName?: string;
}
export interface Connector {
  connectorID?: string;
  name?: string;
  ssmInstanceID?: string;
  arn?: string;
  tags?: Record<string, string>;
  ssmCommandConfig?: ConnectorSsmCommandConfig;
}
export interface CreateConnectorRequest {
  name: string | undefined;
  ssmInstanceID: string | undefined;
  tags?: Record<string, string>;
  ssmCommandConfig?: ConnectorSsmCommandConfig;
}
export interface ValidationExceptionField {
  name?: string;
  message?: string;
}
export declare const ValidationExceptionReason: {
  readonly CANNOT_PARSE: "cannotParse";
  readonly FIELD_VALIDATION_FAILED: "fieldValidationFailed";
  readonly OTHER: "other";
  readonly UNKNOWN_OPERATION: "unknownOperation";
};
export type ValidationExceptionReason =
  (typeof ValidationExceptionReason)[keyof typeof ValidationExceptionReason];
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  code?: string;
  reason?: ValidationExceptionReason;
  fieldList?: ValidationExceptionField[];
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface DeleteConnectorRequest {
  connectorID: string | undefined;
}
export interface ListConnectorsRequestFilters {
  connectorIDs?: string[];
}
export interface ListConnectorsRequest {
  filters?: ListConnectorsRequestFilters;
  maxResults?: number;
  nextToken?: string;
}
export interface ListConnectorsResponse {
  items?: Connector[];
  nextToken?: string;
}
export interface UpdateConnectorRequest {
  connectorID: string | undefined;
  name?: string;
  ssmCommandConfig?: ConnectorSsmCommandConfig;
}
export interface ListExportErrorsRequest {
  exportID: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ExportErrorData {
  rawError?: string;
}
export interface ExportTaskError {
  errorDateTime?: string;
  errorData?: ExportErrorData;
}
export interface ListExportErrorsResponse {
  items?: ExportTaskError[];
  nextToken?: string;
}
export interface ListExportsRequestFilters {
  exportIDs?: string[];
}
export interface ListExportsRequest {
  filters?: ListExportsRequestFilters;
  maxResults?: number;
  nextToken?: string;
}
export declare const ExportStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING: "PENDING";
  readonly STARTED: "STARTED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type ExportStatus = (typeof ExportStatus)[keyof typeof ExportStatus];
export interface ExportTaskSummary {
  serversCount?: number;
  applicationsCount?: number;
  wavesCount?: number;
}
export interface ExportTask {
  exportID?: string;
  s3Bucket?: string;
  s3Key?: string;
  s3BucketOwner?: string;
  creationDateTime?: string;
  endDateTime?: string;
  status?: ExportStatus;
  progressPercentage?: number;
  summary?: ExportTaskSummary;
}
export interface ListExportsResponse {
  items?: ExportTask[];
  nextToken?: string;
}
export interface StartExportRequest {
  s3Bucket: string | undefined;
  s3Key: string | undefined;
  s3BucketOwner?: string;
}
export interface StartExportResponse {
  exportTask?: ExportTask;
}
export interface ListImportErrorsRequest {
  importID: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ImportErrorData {
  sourceServerID?: string;
  applicationID?: string;
  waveID?: string;
  ec2LaunchTemplateID?: string;
  rowNumber?: number;
  rawError?: string;
  accountID?: string;
}
export declare const ImportErrorType: {
  readonly PROCESSING_ERROR: "PROCESSING_ERROR";
  readonly VALIDATION_ERROR: "VALIDATION_ERROR";
};
export type ImportErrorType =
  (typeof ImportErrorType)[keyof typeof ImportErrorType];
export interface ImportTaskError {
  errorDateTime?: string;
  errorType?: ImportErrorType;
  errorData?: ImportErrorData;
}
export interface ListImportErrorsResponse {
  items?: ImportTaskError[];
  nextToken?: string;
}
export interface ListImportsRequestFilters {
  importIDs?: string[];
}
export interface ListImportsRequest {
  filters?: ListImportsRequestFilters;
  maxResults?: number;
  nextToken?: string;
}
export interface S3BucketSource {
  s3Bucket: string | undefined;
  s3Key: string | undefined;
  s3BucketOwner?: string;
}
export declare const ImportStatus: {
  readonly FAILED: "FAILED";
  readonly PENDING: "PENDING";
  readonly STARTED: "STARTED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type ImportStatus = (typeof ImportStatus)[keyof typeof ImportStatus];
export interface ImportTaskSummaryApplications {
  createdCount?: number;
  modifiedCount?: number;
}
export interface ImportTaskSummaryServers {
  createdCount?: number;
  modifiedCount?: number;
}
export interface ImportTaskSummaryWaves {
  createdCount?: number;
  modifiedCount?: number;
}
export interface ImportTaskSummary {
  waves?: ImportTaskSummaryWaves;
  applications?: ImportTaskSummaryApplications;
  servers?: ImportTaskSummaryServers;
}
export interface ImportTask {
  importID?: string;
  s3BucketSource?: S3BucketSource;
  creationDateTime?: string;
  endDateTime?: string;
  status?: ImportStatus;
  progressPercentage?: number;
  summary?: ImportTaskSummary;
}
export interface ListImportsResponse {
  items?: ImportTask[];
  nextToken?: string;
}
export interface StartImportRequest {
  clientToken?: string;
  s3BucketSource: S3BucketSource | undefined;
}
export interface StartImportResponse {
  importTask?: ImportTask;
}
export interface InitializeServiceRequest {}
export interface InitializeServiceResponse {}
export interface DeleteJobRequest {
  jobID: string | undefined;
  accountID?: string;
}
export interface DeleteJobResponse {}
export interface DescribeJobLogItemsRequest {
  jobID: string | undefined;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export declare const JobLogEvent: {
  readonly CLEANUP_END: "CLEANUP_END";
  readonly CLEANUP_FAIL: "CLEANUP_FAIL";
  readonly CLEANUP_START: "CLEANUP_START";
  readonly CONVERSION_END: "CONVERSION_END";
  readonly CONVERSION_FAIL: "CONVERSION_FAIL";
  readonly CONVERSION_START: "CONVERSION_START";
  readonly JOB_CANCEL: "JOB_CANCEL";
  readonly JOB_END: "JOB_END";
  readonly JOB_START: "JOB_START";
  readonly LAUNCH_FAILED: "LAUNCH_FAILED";
  readonly LAUNCH_START: "LAUNCH_START";
  readonly SERVER_SKIPPED: "SERVER_SKIPPED";
  readonly SNAPSHOT_END: "SNAPSHOT_END";
  readonly SNAPSHOT_FAIL: "SNAPSHOT_FAIL";
  readonly SNAPSHOT_START: "SNAPSHOT_START";
  readonly USING_PREVIOUS_SNAPSHOT: "USING_PREVIOUS_SNAPSHOT";
};
export type JobLogEvent = (typeof JobLogEvent)[keyof typeof JobLogEvent];
export interface JobLogEventData {
  sourceServerID?: string;
  conversionServerID?: string;
  targetInstanceID?: string;
  rawError?: string;
}
export interface JobLog {
  logDateTime?: string;
  event?: JobLogEvent;
  eventData?: JobLogEventData;
}
export interface DescribeJobLogItemsResponse {
  items?: JobLog[];
  nextToken?: string;
}
export interface DescribeJobsRequestFilters {
  jobIDs?: string[];
  fromDate?: string;
  toDate?: string;
}
export interface DescribeJobsRequest {
  filters?: DescribeJobsRequestFilters;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export declare const InitiatedBy: {
  readonly DIAGNOSTIC: "DIAGNOSTIC";
  readonly START_CUTOVER: "START_CUTOVER";
  readonly START_TEST: "START_TEST";
  readonly TERMINATE: "TERMINATE";
};
export type InitiatedBy = (typeof InitiatedBy)[keyof typeof InitiatedBy];
export declare const LaunchStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly LAUNCHED: "LAUNCHED";
  readonly PENDING: "PENDING";
  readonly TERMINATED: "TERMINATED";
};
export type LaunchStatus = (typeof LaunchStatus)[keyof typeof LaunchStatus];
export declare const PostLaunchActionExecutionStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly SUCCESS: "SUCCESS";
};
export type PostLaunchActionExecutionStatus =
  (typeof PostLaunchActionExecutionStatus)[keyof typeof PostLaunchActionExecutionStatus];
export type SsmExternalParameter =
  | SsmExternalParameter.DynamicPathMember
  | SsmExternalParameter.$UnknownMember;
export declare namespace SsmExternalParameter {
  interface DynamicPathMember {
    dynamicPath: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    dynamicPath?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    dynamicPath: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: SsmExternalParameter, visitor: Visitor<T>) => T;
}
export declare const SsmParameterStoreParameterType: {
  readonly STRING: "STRING";
};
export type SsmParameterStoreParameterType =
  (typeof SsmParameterStoreParameterType)[keyof typeof SsmParameterStoreParameterType];
export interface SsmParameterStoreParameter {
  parameterType: SsmParameterStoreParameterType | undefined;
  parameterName: string | undefined;
}
export interface SsmDocument {
  actionName: string | undefined;
  ssmDocumentName: string | undefined;
  timeoutSeconds?: number;
  mustSucceedForCutover?: boolean;
  parameters?: Record<string, SsmParameterStoreParameter[]>;
  externalParameters?: Record<string, SsmExternalParameter>;
}
export declare const SsmDocumentType: {
  readonly AUTOMATION: "AUTOMATION";
  readonly COMMAND: "COMMAND";
};
export type SsmDocumentType =
  (typeof SsmDocumentType)[keyof typeof SsmDocumentType];
export interface JobPostLaunchActionsLaunchStatus {
  ssmDocument?: SsmDocument;
  ssmDocumentType?: SsmDocumentType;
  executionID?: string;
  executionStatus?: PostLaunchActionExecutionStatus;
  failureReason?: string;
}
export interface PostLaunchActionsStatus {
  ssmAgentDiscoveryDatetime?: string;
  postLaunchActionsLaunchStatusList?: JobPostLaunchActionsLaunchStatus[];
}
export interface ParticipatingServer {
  sourceServerID: string | undefined;
  launchStatus?: LaunchStatus;
  launchedEc2InstanceID?: string;
  postLaunchActionsStatus?: PostLaunchActionsStatus;
}
export declare const JobStatus: {
  readonly COMPLETED: "COMPLETED";
  readonly PENDING: "PENDING";
  readonly STARTED: "STARTED";
};
export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus];
export declare const JobType: {
  readonly LAUNCH: "LAUNCH";
  readonly TERMINATE: "TERMINATE";
};
export type JobType = (typeof JobType)[keyof typeof JobType];
export interface Job {
  jobID: string | undefined;
  arn?: string;
  type?: JobType;
  initiatedBy?: InitiatedBy;
  creationDateTime?: string;
  endDateTime?: string;
  status?: JobStatus;
  participatingServers?: ParticipatingServer[];
  tags?: Record<string, string>;
}
export interface DescribeJobsResponse {
  items?: Job[];
  nextToken?: string;
}
export declare const BootMode: {
  readonly LEGACY_BIOS: "LEGACY_BIOS";
  readonly UEFI: "UEFI";
};
export type BootMode = (typeof BootMode)[keyof typeof BootMode];
export declare const VolumeType: {
  readonly gp2: "gp2";
  readonly gp3: "gp3";
  readonly io1: "io1";
  readonly io2: "io2";
  readonly sc1: "sc1";
  readonly st1: "st1";
  readonly standard: "standard";
};
export type VolumeType = (typeof VolumeType)[keyof typeof VolumeType];
export interface LaunchTemplateDiskConf {
  volumeType?: VolumeType;
  iops?: number;
  throughput?: number;
}
export declare const LaunchDisposition: {
  readonly STARTED: "STARTED";
  readonly STOPPED: "STOPPED";
};
export type LaunchDisposition =
  (typeof LaunchDisposition)[keyof typeof LaunchDisposition];
export interface Licensing {
  osByol?: boolean;
}
export declare const PostLaunchActionsDeploymentType: {
  readonly CUTOVER_ONLY: "CUTOVER_ONLY";
  readonly TEST_AND_CUTOVER: "TEST_AND_CUTOVER";
  readonly TEST_ONLY: "TEST_ONLY";
};
export type PostLaunchActionsDeploymentType =
  (typeof PostLaunchActionsDeploymentType)[keyof typeof PostLaunchActionsDeploymentType];
export interface PostLaunchActions {
  deployment?: PostLaunchActionsDeploymentType;
  s3LogBucket?: string;
  s3OutputKeyPrefix?: string;
  cloudWatchLogGroupName?: string;
  ssmDocuments?: SsmDocument[];
}
export declare const TargetInstanceTypeRightSizingMethod: {
  readonly BASIC: "BASIC";
  readonly NONE: "NONE";
};
export type TargetInstanceTypeRightSizingMethod =
  (typeof TargetInstanceTypeRightSizingMethod)[keyof typeof TargetInstanceTypeRightSizingMethod];
export interface CreateLaunchConfigurationTemplateRequest {
  postLaunchActions?: PostLaunchActions;
  enableMapAutoTagging?: boolean;
  mapAutoTaggingMpeID?: string;
  tags?: Record<string, string>;
  launchDisposition?: LaunchDisposition;
  targetInstanceTypeRightSizingMethod?: TargetInstanceTypeRightSizingMethod;
  copyPrivateIp?: boolean;
  associatePublicIpAddress?: boolean;
  copyTags?: boolean;
  licensing?: Licensing;
  bootMode?: BootMode;
  smallVolumeMaxSize?: number;
  smallVolumeConf?: LaunchTemplateDiskConf;
  largeVolumeConf?: LaunchTemplateDiskConf;
}
export interface LaunchConfigurationTemplate {
  launchConfigurationTemplateID: string | undefined;
  arn?: string;
  postLaunchActions?: PostLaunchActions;
  enableMapAutoTagging?: boolean;
  mapAutoTaggingMpeID?: string;
  tags?: Record<string, string>;
  ec2LaunchTemplateID?: string;
  launchDisposition?: LaunchDisposition;
  targetInstanceTypeRightSizingMethod?: TargetInstanceTypeRightSizingMethod;
  copyPrivateIp?: boolean;
  associatePublicIpAddress?: boolean;
  copyTags?: boolean;
  licensing?: Licensing;
  bootMode?: BootMode;
  smallVolumeMaxSize?: number;
  smallVolumeConf?: LaunchTemplateDiskConf;
  largeVolumeConf?: LaunchTemplateDiskConf;
}
export interface DeleteLaunchConfigurationTemplateRequest {
  launchConfigurationTemplateID: string | undefined;
}
export interface DeleteLaunchConfigurationTemplateResponse {}
export interface DescribeLaunchConfigurationTemplatesRequest {
  launchConfigurationTemplateIDs?: string[];
  maxResults?: number;
  nextToken?: string;
}
export interface DescribeLaunchConfigurationTemplatesResponse {
  items?: LaunchConfigurationTemplate[];
  nextToken?: string;
}
export interface TemplateActionsRequestFilters {
  actionIDs?: string[];
}
export interface ListTemplateActionsRequest {
  launchConfigurationTemplateID: string | undefined;
  filters?: TemplateActionsRequestFilters;
  maxResults?: number;
  nextToken?: string;
}
export interface TemplateActionDocument {
  actionID?: string;
  actionName?: string;
  documentIdentifier?: string;
  order?: number;
  documentVersion?: string;
  active?: boolean;
  timeoutSeconds?: number;
  mustSucceedForCutover?: boolean;
  parameters?: Record<string, SsmParameterStoreParameter[]>;
  operatingSystem?: string;
  externalParameters?: Record<string, SsmExternalParameter>;
  description?: string;
  category?: ActionCategory;
}
export interface ListTemplateActionsResponse {
  items?: TemplateActionDocument[];
  nextToken?: string;
}
export interface PutTemplateActionRequest {
  launchConfigurationTemplateID: string | undefined;
  actionName: string | undefined;
  documentIdentifier: string | undefined;
  order: number | undefined;
  actionID: string | undefined;
  documentVersion?: string;
  active?: boolean;
  timeoutSeconds?: number;
  mustSucceedForCutover?: boolean;
  parameters?: Record<string, SsmParameterStoreParameter[]>;
  operatingSystem?: string;
  externalParameters?: Record<string, SsmExternalParameter>;
  description?: string;
  category?: ActionCategory;
}
export interface RemoveTemplateActionRequest {
  launchConfigurationTemplateID: string | undefined;
  actionID: string | undefined;
}
export interface RemoveTemplateActionResponse {}
export interface UpdateLaunchConfigurationTemplateRequest {
  launchConfigurationTemplateID: string | undefined;
  postLaunchActions?: PostLaunchActions;
  enableMapAutoTagging?: boolean;
  mapAutoTaggingMpeID?: string;
  launchDisposition?: LaunchDisposition;
  targetInstanceTypeRightSizingMethod?: TargetInstanceTypeRightSizingMethod;
  copyPrivateIp?: boolean;
  associatePublicIpAddress?: boolean;
  copyTags?: boolean;
  licensing?: Licensing;
  bootMode?: BootMode;
  smallVolumeMaxSize?: number;
  smallVolumeConf?: LaunchTemplateDiskConf;
  largeVolumeConf?: LaunchTemplateDiskConf;
}
export interface ListManagedAccountsRequest {
  maxResults?: number;
  nextToken?: string;
}
export interface ManagedAccount {
  accountId?: string;
}
export interface ListManagedAccountsResponse {
  items: ManagedAccount[] | undefined;
  nextToken?: string;
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  retryAfterSeconds?: number;
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Record<string, string>;
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  serviceCode?: string;
  quotaCode?: string;
  retryAfterSeconds?: string;
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export declare const ReplicationConfigurationDataPlaneRouting: {
  readonly PRIVATE_IP: "PRIVATE_IP";
  readonly PUBLIC_IP: "PUBLIC_IP";
};
export type ReplicationConfigurationDataPlaneRouting =
  (typeof ReplicationConfigurationDataPlaneRouting)[keyof typeof ReplicationConfigurationDataPlaneRouting];
export declare const ReplicationConfigurationDefaultLargeStagingDiskType: {
  readonly GP2: "GP2";
  readonly GP3: "GP3";
  readonly ST1: "ST1";
};
export type ReplicationConfigurationDefaultLargeStagingDiskType =
  (typeof ReplicationConfigurationDefaultLargeStagingDiskType)[keyof typeof ReplicationConfigurationDefaultLargeStagingDiskType];
export declare const ReplicationConfigurationEbsEncryption: {
  readonly CUSTOM: "CUSTOM";
  readonly DEFAULT: "DEFAULT";
};
export type ReplicationConfigurationEbsEncryption =
  (typeof ReplicationConfigurationEbsEncryption)[keyof typeof ReplicationConfigurationEbsEncryption];
export interface CreateReplicationConfigurationTemplateRequest {
  stagingAreaSubnetId: string | undefined;
  associateDefaultSecurityGroup: boolean | undefined;
  replicationServersSecurityGroupsIDs: string[] | undefined;
  replicationServerInstanceType: string | undefined;
  useDedicatedReplicationServer: boolean | undefined;
  defaultLargeStagingDiskType:
    | ReplicationConfigurationDefaultLargeStagingDiskType
    | undefined;
  ebsEncryption: ReplicationConfigurationEbsEncryption | undefined;
  ebsEncryptionKeyArn?: string;
  bandwidthThrottling: number | undefined;
  dataPlaneRouting: ReplicationConfigurationDataPlaneRouting | undefined;
  createPublicIP: boolean | undefined;
  stagingAreaTags: Record<string, string> | undefined;
  useFipsEndpoint?: boolean;
  tags?: Record<string, string>;
}
export interface ReplicationConfigurationTemplate {
  replicationConfigurationTemplateID: string | undefined;
  arn?: string;
  stagingAreaSubnetId?: string;
  associateDefaultSecurityGroup?: boolean;
  replicationServersSecurityGroupsIDs?: string[];
  replicationServerInstanceType?: string;
  useDedicatedReplicationServer?: boolean;
  defaultLargeStagingDiskType?: ReplicationConfigurationDefaultLargeStagingDiskType;
  ebsEncryption?: ReplicationConfigurationEbsEncryption;
  ebsEncryptionKeyArn?: string;
  bandwidthThrottling?: number;
  dataPlaneRouting?: ReplicationConfigurationDataPlaneRouting;
  createPublicIP?: boolean;
  stagingAreaTags?: Record<string, string>;
  useFipsEndpoint?: boolean;
  tags?: Record<string, string>;
}
export interface DeleteReplicationConfigurationTemplateRequest {
  replicationConfigurationTemplateID: string | undefined;
}
export interface DeleteReplicationConfigurationTemplateResponse {}
export interface DescribeReplicationConfigurationTemplatesRequest {
  replicationConfigurationTemplateIDs?: string[];
  maxResults?: number;
  nextToken?: string;
}
export interface DescribeReplicationConfigurationTemplatesResponse {
  items?: ReplicationConfigurationTemplate[];
  nextToken?: string;
}
export interface UpdateReplicationConfigurationTemplateRequest {
  replicationConfigurationTemplateID: string | undefined;
  arn?: string;
  stagingAreaSubnetId?: string;
  associateDefaultSecurityGroup?: boolean;
  replicationServersSecurityGroupsIDs?: string[];
  replicationServerInstanceType?: string;
  useDedicatedReplicationServer?: boolean;
  defaultLargeStagingDiskType?: ReplicationConfigurationDefaultLargeStagingDiskType;
  ebsEncryption?: ReplicationConfigurationEbsEncryption;
  ebsEncryptionKeyArn?: string;
  bandwidthThrottling?: number;
  dataPlaneRouting?: ReplicationConfigurationDataPlaneRouting;
  createPublicIP?: boolean;
  stagingAreaTags?: Record<string, string>;
  useFipsEndpoint?: boolean;
}
export declare const ChangeServerLifeCycleStateSourceServerLifecycleState: {
  readonly CUTOVER: "CUTOVER";
  readonly READY_FOR_CUTOVER: "READY_FOR_CUTOVER";
  readonly READY_FOR_TEST: "READY_FOR_TEST";
};
export type ChangeServerLifeCycleStateSourceServerLifecycleState =
  (typeof ChangeServerLifeCycleStateSourceServerLifecycleState)[keyof typeof ChangeServerLifeCycleStateSourceServerLifecycleState];
export interface ChangeServerLifeCycleStateSourceServerLifecycle {
  state: ChangeServerLifeCycleStateSourceServerLifecycleState | undefined;
}
export interface ChangeServerLifeCycleStateRequest {
  sourceServerID: string | undefined;
  lifeCycle: ChangeServerLifeCycleStateSourceServerLifecycle | undefined;
  accountID?: string;
}
export interface SourceServerConnectorAction {
  credentialsSecretArn?: string;
  connectorArn?: string;
}
export declare const DataReplicationErrorString: {
  readonly AGENT_NOT_SEEN: "AGENT_NOT_SEEN";
  readonly FAILED_TO_ATTACH_STAGING_DISKS: "FAILED_TO_ATTACH_STAGING_DISKS";
  readonly FAILED_TO_AUTHENTICATE_WITH_SERVICE: "FAILED_TO_AUTHENTICATE_WITH_SERVICE";
  readonly FAILED_TO_BOOT_REPLICATION_SERVER: "FAILED_TO_BOOT_REPLICATION_SERVER";
  readonly FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER: "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER";
  readonly FAILED_TO_CREATE_SECURITY_GROUP: "FAILED_TO_CREATE_SECURITY_GROUP";
  readonly FAILED_TO_CREATE_STAGING_DISKS: "FAILED_TO_CREATE_STAGING_DISKS";
  readonly FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE: "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE";
  readonly FAILED_TO_LAUNCH_REPLICATION_SERVER: "FAILED_TO_LAUNCH_REPLICATION_SERVER";
  readonly FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT: "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT";
  readonly FAILED_TO_START_DATA_TRANSFER: "FAILED_TO_START_DATA_TRANSFER";
  readonly LAST_SNAPSHOT_JOB_FAILED: "LAST_SNAPSHOT_JOB_FAILED";
  readonly NOT_CONVERGING: "NOT_CONVERGING";
  readonly SNAPSHOTS_FAILURE: "SNAPSHOTS_FAILURE";
  readonly UNSTABLE_NETWORK: "UNSTABLE_NETWORK";
  readonly UNSUPPORTED_VM_CONFIGURATION: "UNSUPPORTED_VM_CONFIGURATION";
};
export type DataReplicationErrorString =
  (typeof DataReplicationErrorString)[keyof typeof DataReplicationErrorString];
export interface DataReplicationError {
  error?: DataReplicationErrorString;
  rawError?: string;
}
export declare const DataReplicationInitiationStepName: {
  readonly ATTACH_STAGING_DISKS: "ATTACH_STAGING_DISKS";
  readonly AUTHENTICATE_WITH_SERVICE: "AUTHENTICATE_WITH_SERVICE";
  readonly BOOT_REPLICATION_SERVER: "BOOT_REPLICATION_SERVER";
  readonly CONNECT_AGENT_TO_REPLICATION_SERVER: "CONNECT_AGENT_TO_REPLICATION_SERVER";
  readonly CREATE_SECURITY_GROUP: "CREATE_SECURITY_GROUP";
  readonly CREATE_STAGING_DISKS: "CREATE_STAGING_DISKS";
  readonly DOWNLOAD_REPLICATION_SOFTWARE: "DOWNLOAD_REPLICATION_SOFTWARE";
  readonly LAUNCH_REPLICATION_SERVER: "LAUNCH_REPLICATION_SERVER";
  readonly PAIR_REPLICATION_SERVER_WITH_AGENT: "PAIR_REPLICATION_SERVER_WITH_AGENT";
  readonly START_DATA_TRANSFER: "START_DATA_TRANSFER";
  readonly WAIT: "WAIT";
};
export type DataReplicationInitiationStepName =
  (typeof DataReplicationInitiationStepName)[keyof typeof DataReplicationInitiationStepName];
export declare const DataReplicationInitiationStepStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly NOT_STARTED: "NOT_STARTED";
  readonly SKIPPED: "SKIPPED";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type DataReplicationInitiationStepStatus =
  (typeof DataReplicationInitiationStepStatus)[keyof typeof DataReplicationInitiationStepStatus];
export interface DataReplicationInitiationStep {
  name?: DataReplicationInitiationStepName;
  status?: DataReplicationInitiationStepStatus;
}
export interface DataReplicationInitiation {
  startDateTime?: string;
  nextAttemptDateTime?: string;
  steps?: DataReplicationInitiationStep[];
}
export declare const DataReplicationState: {
  readonly BACKLOG: "BACKLOG";
  readonly CONTINUOUS: "CONTINUOUS";
  readonly CREATING_SNAPSHOT: "CREATING_SNAPSHOT";
  readonly DISCONNECTED: "DISCONNECTED";
  readonly INITIAL_SYNC: "INITIAL_SYNC";
  readonly INITIATING: "INITIATING";
  readonly PAUSED: "PAUSED";
  readonly PENDING_SNAPSHOT_SHIPPING: "PENDING_SNAPSHOT_SHIPPING";
  readonly RESCAN: "RESCAN";
  readonly SHIPPING_SNAPSHOT: "SHIPPING_SNAPSHOT";
  readonly STALLED: "STALLED";
  readonly STOPPED: "STOPPED";
};
export type DataReplicationState =
  (typeof DataReplicationState)[keyof typeof DataReplicationState];
export interface DataReplicationInfoReplicatedDisk {
  deviceName?: string;
  totalStorageBytes?: number;
  replicatedStorageBytes?: number;
  rescannedStorageBytes?: number;
  backloggedStorageBytes?: number;
}
export interface DataReplicationInfo {
  lagDuration?: string;
  etaDateTime?: string;
  replicatedDisks?: DataReplicationInfoReplicatedDisk[];
  dataReplicationState?: DataReplicationState;
  dataReplicationInitiation?: DataReplicationInitiation;
  dataReplicationError?: DataReplicationError;
  lastSnapshotDateTime?: string;
}
export declare const FirstBoot: {
  readonly STOPPED: "STOPPED";
  readonly SUCCEEDED: "SUCCEEDED";
  readonly UNKNOWN: "UNKNOWN";
  readonly WAITING: "WAITING";
};
export type FirstBoot = (typeof FirstBoot)[keyof typeof FirstBoot];
export interface LaunchedInstance {
  ec2InstanceID?: string;
  jobID?: string;
  firstBoot?: FirstBoot;
}
export interface LifeCycleLastCutoverFinalized {
  apiCallDateTime?: string;
}
export interface LifeCycleLastCutoverInitiated {
  apiCallDateTime?: string;
  jobID?: string;
}
export interface LifeCycleLastCutoverReverted {
  apiCallDateTime?: string;
}
export interface LifeCycleLastCutover {
  initiated?: LifeCycleLastCutoverInitiated;
  reverted?: LifeCycleLastCutoverReverted;
  finalized?: LifeCycleLastCutoverFinalized;
}
export interface LifeCycleLastTestFinalized {
  apiCallDateTime?: string;
}
export interface LifeCycleLastTestInitiated {
  apiCallDateTime?: string;
  jobID?: string;
}
export interface LifeCycleLastTestReverted {
  apiCallDateTime?: string;
}
export interface LifeCycleLastTest {
  initiated?: LifeCycleLastTestInitiated;
  reverted?: LifeCycleLastTestReverted;
  finalized?: LifeCycleLastTestFinalized;
}
export declare const LifeCycleState: {
  readonly CUTOVER: "CUTOVER";
  readonly CUTTING_OVER: "CUTTING_OVER";
  readonly DISCONNECTED: "DISCONNECTED";
  readonly DISCOVERED: "DISCOVERED";
  readonly NOT_READY: "NOT_READY";
  readonly PENDING_INSTALLATION: "PENDING_INSTALLATION";
  readonly READY_FOR_CUTOVER: "READY_FOR_CUTOVER";
  readonly READY_FOR_TEST: "READY_FOR_TEST";
  readonly STOPPED: "STOPPED";
  readonly TESTING: "TESTING";
};
export type LifeCycleState =
  (typeof LifeCycleState)[keyof typeof LifeCycleState];
export interface LifeCycle {
  addedToServiceDateTime?: string;
  firstByteDateTime?: string;
  elapsedReplicationDuration?: string;
  lastSeenByServiceDateTime?: string;
  lastTest?: LifeCycleLastTest;
  lastCutover?: LifeCycleLastCutover;
  state?: LifeCycleState;
}
export declare const ReplicationType: {
  readonly AGENT_BASED: "AGENT_BASED";
  readonly SNAPSHOT_SHIPPING: "SNAPSHOT_SHIPPING";
};
export type ReplicationType =
  (typeof ReplicationType)[keyof typeof ReplicationType];
export interface CPU {
  cores?: number;
  modelName?: string;
}
export interface Disk {
  deviceName?: string;
  bytes?: number;
}
export interface IdentificationHints {
  fqdn?: string;
  hostname?: string;
  vmWareUuid?: string;
  awsInstanceID?: string;
  vmPath?: string;
}
export interface NetworkInterface {
  macAddress?: string;
  ips?: string[];
  isPrimary?: boolean;
}
export interface OS {
  fullString?: string;
}
export interface SourceProperties {
  lastUpdatedDateTime?: string;
  recommendedInstanceType?: string;
  identificationHints?: IdentificationHints;
  networkInterfaces?: NetworkInterface[];
  disks?: Disk[];
  cpus?: CPU[];
  ramBytes?: number;
  os?: OS;
}
export interface SourceServer {
  sourceServerID?: string;
  arn?: string;
  isArchived?: boolean;
  tags?: Record<string, string>;
  launchedInstance?: LaunchedInstance;
  dataReplicationInfo?: DataReplicationInfo;
  lifeCycle?: LifeCycle;
  sourceProperties?: SourceProperties;
  replicationType?: ReplicationType;
  vcenterClientID?: string;
  applicationID?: string;
  userProvidedID?: string;
  fqdnForActionFramework?: string;
  connectorAction?: SourceServerConnectorAction;
}
export interface DeleteSourceServerRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface DeleteSourceServerResponse {}
export interface DescribeSourceServersRequestFilters {
  sourceServerIDs?: string[];
  isArchived?: boolean;
  replicationTypes?: ReplicationType[];
  lifeCycleStates?: LifeCycleState[];
  applicationIDs?: string[];
}
export interface DescribeSourceServersRequest {
  filters?: DescribeSourceServersRequestFilters;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export interface DescribeSourceServersResponse {
  items?: SourceServer[];
  nextToken?: string;
}
export interface DisconnectFromServiceRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface FinalizeCutoverRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface GetLaunchConfigurationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface LaunchConfiguration {
  sourceServerID?: string;
  name?: string;
  ec2LaunchTemplateID?: string;
  launchDisposition?: LaunchDisposition;
  targetInstanceTypeRightSizingMethod?: TargetInstanceTypeRightSizingMethod;
  copyPrivateIp?: boolean;
  copyTags?: boolean;
  licensing?: Licensing;
  bootMode?: BootMode;
  postLaunchActions?: PostLaunchActions;
  enableMapAutoTagging?: boolean;
  mapAutoTaggingMpeID?: string;
}
export interface GetReplicationConfigurationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export declare const ReplicationConfigurationReplicatedDiskStagingDiskType: {
  readonly AUTO: "AUTO";
  readonly GP2: "GP2";
  readonly GP3: "GP3";
  readonly IO1: "IO1";
  readonly IO2: "IO2";
  readonly SC1: "SC1";
  readonly ST1: "ST1";
  readonly STANDARD: "STANDARD";
};
export type ReplicationConfigurationReplicatedDiskStagingDiskType =
  (typeof ReplicationConfigurationReplicatedDiskStagingDiskType)[keyof typeof ReplicationConfigurationReplicatedDiskStagingDiskType];
export interface ReplicationConfigurationReplicatedDisk {
  deviceName?: string;
  isBootDisk?: boolean;
  stagingDiskType?: ReplicationConfigurationReplicatedDiskStagingDiskType;
  iops?: number;
  throughput?: number;
}
export interface ReplicationConfiguration {
  sourceServerID?: string;
  name?: string;
  stagingAreaSubnetId?: string;
  associateDefaultSecurityGroup?: boolean;
  replicationServersSecurityGroupsIDs?: string[];
  replicationServerInstanceType?: string;
  useDedicatedReplicationServer?: boolean;
  defaultLargeStagingDiskType?: ReplicationConfigurationDefaultLargeStagingDiskType;
  replicatedDisks?: ReplicationConfigurationReplicatedDisk[];
  ebsEncryption?: ReplicationConfigurationEbsEncryption;
  ebsEncryptionKeyArn?: string;
  bandwidthThrottling?: number;
  dataPlaneRouting?: ReplicationConfigurationDataPlaneRouting;
  createPublicIP?: boolean;
  stagingAreaTags?: Record<string, string>;
  useFipsEndpoint?: boolean;
}
export interface SourceServerActionsRequestFilters {
  actionIDs?: string[];
}
export interface ListSourceServerActionsRequest {
  sourceServerID: string | undefined;
  filters?: SourceServerActionsRequestFilters;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export interface SourceServerActionDocument {
  actionID?: string;
  actionName?: string;
  documentIdentifier?: string;
  order?: number;
  documentVersion?: string;
  active?: boolean;
  timeoutSeconds?: number;
  mustSucceedForCutover?: boolean;
  parameters?: Record<string, SsmParameterStoreParameter[]>;
  externalParameters?: Record<string, SsmExternalParameter>;
  description?: string;
  category?: ActionCategory;
}
export interface ListSourceServerActionsResponse {
  items?: SourceServerActionDocument[];
  nextToken?: string;
}
export interface MarkAsArchivedRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface PauseReplicationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface PutSourceServerActionRequest {
  sourceServerID: string | undefined;
  actionName: string | undefined;
  documentIdentifier: string | undefined;
  order: number | undefined;
  actionID: string | undefined;
  documentVersion?: string;
  active?: boolean;
  timeoutSeconds?: number;
  mustSucceedForCutover?: boolean;
  parameters?: Record<string, SsmParameterStoreParameter[]>;
  externalParameters?: Record<string, SsmExternalParameter>;
  description?: string;
  category?: ActionCategory;
  accountID?: string;
}
export interface RemoveSourceServerActionRequest {
  sourceServerID: string | undefined;
  actionID: string | undefined;
  accountID?: string;
}
export interface RemoveSourceServerActionResponse {}
export interface ResumeReplicationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface RetryDataReplicationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface StartCutoverRequest {
  sourceServerIDs: string[] | undefined;
  tags?: Record<string, string>;
  accountID?: string;
}
export interface StartCutoverResponse {
  job?: Job;
}
export interface StartReplicationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface StartTestRequest {
  sourceServerIDs: string[] | undefined;
  tags?: Record<string, string>;
  accountID?: string;
}
export interface StartTestResponse {
  job?: Job;
}
export interface StopReplicationRequest {
  sourceServerID: string | undefined;
  accountID?: string;
}
export interface TerminateTargetInstancesRequest {
  sourceServerIDs: string[] | undefined;
  tags?: Record<string, string>;
  accountID?: string;
}
export interface TerminateTargetInstancesResponse {
  job?: Job;
}
export interface UpdateLaunchConfigurationRequest {
  sourceServerID: string | undefined;
  name?: string;
  launchDisposition?: LaunchDisposition;
  targetInstanceTypeRightSizingMethod?: TargetInstanceTypeRightSizingMethod;
  copyPrivateIp?: boolean;
  copyTags?: boolean;
  licensing?: Licensing;
  bootMode?: BootMode;
  postLaunchActions?: PostLaunchActions;
  enableMapAutoTagging?: boolean;
  mapAutoTaggingMpeID?: string;
  accountID?: string;
}
export interface UpdateReplicationConfigurationRequest {
  sourceServerID: string | undefined;
  name?: string;
  stagingAreaSubnetId?: string;
  associateDefaultSecurityGroup?: boolean;
  replicationServersSecurityGroupsIDs?: string[];
  replicationServerInstanceType?: string;
  useDedicatedReplicationServer?: boolean;
  defaultLargeStagingDiskType?: ReplicationConfigurationDefaultLargeStagingDiskType;
  replicatedDisks?: ReplicationConfigurationReplicatedDisk[];
  ebsEncryption?: ReplicationConfigurationEbsEncryption;
  ebsEncryptionKeyArn?: string;
  bandwidthThrottling?: number;
  dataPlaneRouting?: ReplicationConfigurationDataPlaneRouting;
  createPublicIP?: boolean;
  stagingAreaTags?: Record<string, string>;
  useFipsEndpoint?: boolean;
  accountID?: string;
}
export interface UpdateSourceServerRequest {
  accountID?: string;
  sourceServerID: string | undefined;
  connectorAction?: SourceServerConnectorAction;
}
export interface UpdateSourceServerReplicationTypeRequest {
  sourceServerID: string | undefined;
  replicationType: ReplicationType | undefined;
  accountID?: string;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface DeleteVcenterClientRequest {
  vcenterClientID: string | undefined;
}
export interface DescribeVcenterClientsRequest {
  maxResults?: number;
  nextToken?: string;
}
export interface VcenterClient {
  vcenterClientID?: string;
  arn?: string;
  hostname?: string;
  vcenterUUID?: string;
  datacenterName?: string;
  lastSeenDatetime?: string;
  sourceServerTags?: Record<string, string>;
  tags?: Record<string, string>;
}
export interface DescribeVcenterClientsResponse {
  items?: VcenterClient[];
  nextToken?: string;
}
export interface ArchiveWaveRequest {
  waveID: string | undefined;
  accountID?: string;
}
export declare const WaveHealthStatus: {
  readonly ERROR: "ERROR";
  readonly HEALTHY: "HEALTHY";
  readonly LAGGING: "LAGGING";
};
export type WaveHealthStatus =
  (typeof WaveHealthStatus)[keyof typeof WaveHealthStatus];
export declare const WaveProgressStatus: {
  readonly COMPLETED: "COMPLETED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly NOT_STARTED: "NOT_STARTED";
};
export type WaveProgressStatus =
  (typeof WaveProgressStatus)[keyof typeof WaveProgressStatus];
export interface WaveAggregatedStatus {
  lastUpdateDateTime?: string;
  replicationStartedDateTime?: string;
  healthStatus?: WaveHealthStatus;
  progressStatus?: WaveProgressStatus;
  totalApplications?: number;
}
export interface Wave {
  waveID?: string;
  arn?: string;
  name?: string;
  description?: string;
  isArchived?: boolean;
  waveAggregatedStatus?: WaveAggregatedStatus;
  creationDateTime?: string;
  lastModifiedDateTime?: string;
  tags?: Record<string, string>;
}
export interface AssociateApplicationsRequest {
  waveID: string | undefined;
  applicationIDs: string[] | undefined;
  accountID?: string;
}
export interface AssociateApplicationsResponse {}
export interface CreateWaveRequest {
  name: string | undefined;
  description?: string;
  tags?: Record<string, string>;
  accountID?: string;
}
export interface DeleteWaveRequest {
  waveID: string | undefined;
  accountID?: string;
}
export interface DeleteWaveResponse {}
export interface DisassociateApplicationsRequest {
  waveID: string | undefined;
  applicationIDs: string[] | undefined;
  accountID?: string;
}
export interface DisassociateApplicationsResponse {}
export interface ListWavesRequestFilters {
  waveIDs?: string[];
  isArchived?: boolean;
}
export interface ListWavesRequest {
  filters?: ListWavesRequestFilters;
  maxResults?: number;
  nextToken?: string;
  accountID?: string;
}
export interface ListWavesResponse {
  items?: Wave[];
  nextToken?: string;
}
export interface UnarchiveWaveRequest {
  waveID: string | undefined;
  accountID?: string;
}
export interface UpdateWaveRequest {
  waveID: string | undefined;
  name?: string;
  description?: string;
  accountID?: string;
}
export declare const ApplicationFilterSensitiveLog: (obj: Application) => any;
export declare const CreateApplicationRequestFilterSensitiveLog: (
  obj: CreateApplicationRequest
) => any;
export declare const ListApplicationsResponseFilterSensitiveLog: (
  obj: ListApplicationsResponse
) => any;
export declare const ConnectorFilterSensitiveLog: (obj: Connector) => any;
export declare const CreateConnectorRequestFilterSensitiveLog: (
  obj: CreateConnectorRequest
) => any;
export declare const ListConnectorsResponseFilterSensitiveLog: (
  obj: ListConnectorsResponse
) => any;
export declare const JobFilterSensitiveLog: (obj: Job) => any;
export declare const DescribeJobsResponseFilterSensitiveLog: (
  obj: DescribeJobsResponse
) => any;
export declare const CreateLaunchConfigurationTemplateRequestFilterSensitiveLog: (
  obj: CreateLaunchConfigurationTemplateRequest
) => any;
export declare const LaunchConfigurationTemplateFilterSensitiveLog: (
  obj: LaunchConfigurationTemplate
) => any;
export declare const DescribeLaunchConfigurationTemplatesResponseFilterSensitiveLog: (
  obj: DescribeLaunchConfigurationTemplatesResponse
) => any;
export declare const ListTagsForResourceResponseFilterSensitiveLog: (
  obj: ListTagsForResourceResponse
) => any;
export declare const CreateReplicationConfigurationTemplateRequestFilterSensitiveLog: (
  obj: CreateReplicationConfigurationTemplateRequest
) => any;
export declare const ReplicationConfigurationTemplateFilterSensitiveLog: (
  obj: ReplicationConfigurationTemplate
) => any;
export declare const DescribeReplicationConfigurationTemplatesResponseFilterSensitiveLog: (
  obj: DescribeReplicationConfigurationTemplatesResponse
) => any;
export declare const UpdateReplicationConfigurationTemplateRequestFilterSensitiveLog: (
  obj: UpdateReplicationConfigurationTemplateRequest
) => any;
export declare const SourceServerFilterSensitiveLog: (obj: SourceServer) => any;
export declare const DescribeSourceServersResponseFilterSensitiveLog: (
  obj: DescribeSourceServersResponse
) => any;
export declare const ReplicationConfigurationFilterSensitiveLog: (
  obj: ReplicationConfiguration
) => any;
export declare const StartCutoverRequestFilterSensitiveLog: (
  obj: StartCutoverRequest
) => any;
export declare const StartCutoverResponseFilterSensitiveLog: (
  obj: StartCutoverResponse
) => any;
export declare const StartTestRequestFilterSensitiveLog: (
  obj: StartTestRequest
) => any;
export declare const StartTestResponseFilterSensitiveLog: (
  obj: StartTestResponse
) => any;
export declare const TerminateTargetInstancesRequestFilterSensitiveLog: (
  obj: TerminateTargetInstancesRequest
) => any;
export declare const TerminateTargetInstancesResponseFilterSensitiveLog: (
  obj: TerminateTargetInstancesResponse
) => any;
export declare const UpdateReplicationConfigurationRequestFilterSensitiveLog: (
  obj: UpdateReplicationConfigurationRequest
) => any;
export declare const TagResourceRequestFilterSensitiveLog: (
  obj: TagResourceRequest
) => any;
export declare const UntagResourceRequestFilterSensitiveLog: (
  obj: UntagResourceRequest
) => any;
export declare const VcenterClientFilterSensitiveLog: (
  obj: VcenterClient
) => any;
export declare const DescribeVcenterClientsResponseFilterSensitiveLog: (
  obj: DescribeVcenterClientsResponse
) => any;
export declare const WaveFilterSensitiveLog: (obj: Wave) => any;
export declare const CreateWaveRequestFilterSensitiveLog: (
  obj: CreateWaveRequest
) => any;
export declare const ListWavesResponseFilterSensitiveLog: (
  obj: ListWavesResponse
) => any;
