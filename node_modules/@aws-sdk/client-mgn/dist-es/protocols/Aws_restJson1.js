import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, limitedParseFloat32 as __limitedParseFloat32, map, strictParseLong as __strictParseLong, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { MgnServiceException as __BaseException } from "../models/MgnServiceException";
import { AccessDeniedException, ConflictException, InternalServerException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, UninitializedAccountException, ValidationException, } from "../models/models_0";
export const se_ArchiveApplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ArchiveApplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ArchiveWaveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ArchiveWave");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AssociateApplicationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/AssociateApplications");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationIDs: (_) => _json(_),
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_AssociateSourceServersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/AssociateSourceServers");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
        sourceServerIDs: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ChangeServerLifeCycleStateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ChangeServerLifeCycleState");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        lifeCycle: (_) => _json(_),
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateApplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateApplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        description: [],
        name: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateConnectorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateConnector");
    let body;
    body = JSON.stringify(take(input, {
        name: [],
        ssmCommandConfig: (_) => _json(_),
        ssmInstanceID: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateLaunchConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateLaunchConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        associatePublicIpAddress: [],
        bootMode: [],
        copyPrivateIp: [],
        copyTags: [],
        enableMapAutoTagging: [],
        largeVolumeConf: (_) => _json(_),
        launchDisposition: [],
        licensing: (_) => _json(_),
        mapAutoTaggingMpeID: [],
        postLaunchActions: (_) => _json(_),
        smallVolumeConf: (_) => _json(_),
        smallVolumeMaxSize: [],
        tags: (_) => _json(_),
        targetInstanceTypeRightSizingMethod: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateReplicationConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateReplicationConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        associateDefaultSecurityGroup: [],
        bandwidthThrottling: [],
        createPublicIP: [],
        dataPlaneRouting: [],
        defaultLargeStagingDiskType: [],
        ebsEncryption: [],
        ebsEncryptionKeyArn: [],
        replicationServerInstanceType: [],
        replicationServersSecurityGroupsIDs: (_) => _json(_),
        stagingAreaSubnetId: [],
        stagingAreaTags: (_) => _json(_),
        tags: (_) => _json(_),
        useDedicatedReplicationServer: [],
        useFipsEndpoint: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateWaveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateWave");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        description: [],
        name: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteApplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteApplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteConnectorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteConnector");
    let body;
    body = JSON.stringify(take(input, {
        connectorID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteJob");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        jobID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteLaunchConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteLaunchConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        launchConfigurationTemplateID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteReplicationConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteReplicationConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        replicationConfigurationTemplateID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteSourceServerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteSourceServer");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteVcenterClientCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteVcenterClient");
    let body;
    body = JSON.stringify(take(input, {
        vcenterClientID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteWaveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteWave");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeJobLogItemsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeJobLogItems");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        jobID: [],
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeJobs");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeLaunchConfigurationTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeLaunchConfigurationTemplates");
    let body;
    body = JSON.stringify(take(input, {
        launchConfigurationTemplateIDs: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeReplicationConfigurationTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeReplicationConfigurationTemplates");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        replicationConfigurationTemplateIDs: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeSourceServersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DescribeSourceServers");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DescribeVcenterClientsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/DescribeVcenterClients");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_DisassociateApplicationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DisassociateApplications");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationIDs: (_) => _json(_),
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DisassociateSourceServersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DisassociateSourceServers");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
        sourceServerIDs: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DisconnectFromServiceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DisconnectFromService");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_FinalizeCutoverCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/FinalizeCutover");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetLaunchConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetLaunchConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetReplicationConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetReplicationConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_InitializeServiceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/InitializeService");
    let body;
    body = "";
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListApplicationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListApplications");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListConnectorsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListConnectors");
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListExportErrorsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListExportErrors");
    let body;
    body = JSON.stringify(take(input, {
        exportID: [],
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListExportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListExports");
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListImportErrorsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListImportErrors");
    let body;
    body = JSON.stringify(take(input, {
        importID: [],
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListImportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListImports");
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListManagedAccountsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListManagedAccounts");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSourceServerActionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListSourceServerActions");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListTemplateActionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListTemplateActions");
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        launchConfigurationTemplateID: [],
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListWavesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListWaves");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_MarkAsArchivedCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/MarkAsArchived");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PauseReplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PauseReplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutSourceServerActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PutSourceServerAction");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        actionID: [],
        actionName: [],
        active: [],
        category: [],
        description: [],
        documentIdentifier: [],
        documentVersion: [],
        externalParameters: (_) => _json(_),
        mustSucceedForCutover: [],
        order: [],
        parameters: (_) => _json(_),
        sourceServerID: [],
        timeoutSeconds: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutTemplateActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PutTemplateAction");
    let body;
    body = JSON.stringify(take(input, {
        actionID: [],
        actionName: [],
        active: [],
        category: [],
        description: [],
        documentIdentifier: [],
        documentVersion: [],
        externalParameters: (_) => _json(_),
        launchConfigurationTemplateID: [],
        mustSucceedForCutover: [],
        operatingSystem: [],
        order: [],
        parameters: (_) => _json(_),
        timeoutSeconds: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveSourceServerActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RemoveSourceServerAction");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        actionID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RemoveTemplateActionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RemoveTemplateAction");
    let body;
    body = JSON.stringify(take(input, {
        actionID: [],
        launchConfigurationTemplateID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ResumeReplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ResumeReplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_RetryDataReplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/RetryDataReplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartCutoverCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartCutover");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerIDs: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartExport");
    let body;
    body = JSON.stringify(take(input, {
        s3Bucket: [],
        s3BucketOwner: [],
        s3Key: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartImportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartImport");
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        s3BucketSource: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartReplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartReplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StartTestCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StartTest");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerIDs: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_StopReplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/StopReplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TerminateTargetInstancesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TerminateTargetInstances");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        sourceServerIDs: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UnarchiveApplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UnarchiveApplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UnarchiveWaveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UnarchiveWave");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateApplicationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateApplication");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        applicationID: [],
        description: [],
        name: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateConnectorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateConnector");
    let body;
    body = JSON.stringify(take(input, {
        connectorID: [],
        name: [],
        ssmCommandConfig: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateLaunchConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateLaunchConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        bootMode: [],
        copyPrivateIp: [],
        copyTags: [],
        enableMapAutoTagging: [],
        launchDisposition: [],
        licensing: (_) => _json(_),
        mapAutoTaggingMpeID: [],
        name: [],
        postLaunchActions: (_) => _json(_),
        sourceServerID: [],
        targetInstanceTypeRightSizingMethod: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateLaunchConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateLaunchConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        associatePublicIpAddress: [],
        bootMode: [],
        copyPrivateIp: [],
        copyTags: [],
        enableMapAutoTagging: [],
        largeVolumeConf: (_) => _json(_),
        launchConfigurationTemplateID: [],
        launchDisposition: [],
        licensing: (_) => _json(_),
        mapAutoTaggingMpeID: [],
        postLaunchActions: (_) => _json(_),
        smallVolumeConf: (_) => _json(_),
        smallVolumeMaxSize: [],
        targetInstanceTypeRightSizingMethod: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateReplicationConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateReplicationConfiguration");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        associateDefaultSecurityGroup: [],
        bandwidthThrottling: [],
        createPublicIP: [],
        dataPlaneRouting: [],
        defaultLargeStagingDiskType: [],
        ebsEncryption: [],
        ebsEncryptionKeyArn: [],
        name: [],
        replicatedDisks: (_) => _json(_),
        replicationServerInstanceType: [],
        replicationServersSecurityGroupsIDs: (_) => _json(_),
        sourceServerID: [],
        stagingAreaSubnetId: [],
        stagingAreaTags: (_) => _json(_),
        useDedicatedReplicationServer: [],
        useFipsEndpoint: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateReplicationConfigurationTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateReplicationConfigurationTemplate");
    let body;
    body = JSON.stringify(take(input, {
        arn: [],
        associateDefaultSecurityGroup: [],
        bandwidthThrottling: [],
        createPublicIP: [],
        dataPlaneRouting: [],
        defaultLargeStagingDiskType: [],
        ebsEncryption: [],
        ebsEncryptionKeyArn: [],
        replicationConfigurationTemplateID: [],
        replicationServerInstanceType: [],
        replicationServersSecurityGroupsIDs: (_) => _json(_),
        stagingAreaSubnetId: [],
        stagingAreaTags: (_) => _json(_),
        useDedicatedReplicationServer: [],
        useFipsEndpoint: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateSourceServerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateSourceServer");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        connectorAction: (_) => _json(_),
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateSourceServerReplicationTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateSourceServerReplicationType");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        replicationType: [],
        sourceServerID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateWaveCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateWave");
    let body;
    body = JSON.stringify(take(input, {
        accountID: [],
        description: [],
        name: [],
        waveID: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_ArchiveApplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationAggregatedStatus: _json,
        applicationID: __expectString,
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ArchiveWaveCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveAggregatedStatus: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_AssociateApplicationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_AssociateSourceServersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ChangeServerLifeCycleStateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateApplicationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationAggregatedStatus: _json,
        applicationID: __expectString,
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateConnectorCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        connectorID: __expectString,
        name: __expectString,
        ssmCommandConfig: _json,
        ssmInstanceID: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateLaunchConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        associatePublicIpAddress: __expectBoolean,
        bootMode: __expectString,
        copyPrivateIp: __expectBoolean,
        copyTags: __expectBoolean,
        ec2LaunchTemplateID: __expectString,
        enableMapAutoTagging: __expectBoolean,
        largeVolumeConf: _json,
        launchConfigurationTemplateID: __expectString,
        launchDisposition: __expectString,
        licensing: _json,
        mapAutoTaggingMpeID: __expectString,
        postLaunchActions: _json,
        smallVolumeConf: _json,
        smallVolumeMaxSize: __expectLong,
        tags: _json,
        targetInstanceTypeRightSizingMethod: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateReplicationConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        associateDefaultSecurityGroup: __expectBoolean,
        bandwidthThrottling: __expectLong,
        createPublicIP: __expectBoolean,
        dataPlaneRouting: __expectString,
        defaultLargeStagingDiskType: __expectString,
        ebsEncryption: __expectString,
        ebsEncryptionKeyArn: __expectString,
        replicationConfigurationTemplateID: __expectString,
        replicationServerInstanceType: __expectString,
        replicationServersSecurityGroupsIDs: _json,
        stagingAreaSubnetId: __expectString,
        stagingAreaTags: _json,
        tags: _json,
        useDedicatedReplicationServer: __expectBoolean,
        useFipsEndpoint: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateWaveCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveAggregatedStatus: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteApplicationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteConnectorCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteJobCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteLaunchConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteReplicationConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSourceServerCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteVcenterClientCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteWaveCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeJobLogItemsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: (_) => de_JobsList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeLaunchConfigurationTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeReplicationConfigurationTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeSourceServersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeVcenterClientsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DisassociateApplicationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DisassociateSourceServersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DisconnectFromServiceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_FinalizeCutoverCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        bootMode: __expectString,
        copyPrivateIp: __expectBoolean,
        copyTags: __expectBoolean,
        ec2LaunchTemplateID: __expectString,
        enableMapAutoTagging: __expectBoolean,
        launchDisposition: __expectString,
        licensing: _json,
        mapAutoTaggingMpeID: __expectString,
        name: __expectString,
        postLaunchActions: _json,
        sourceServerID: __expectString,
        targetInstanceTypeRightSizingMethod: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetReplicationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        associateDefaultSecurityGroup: __expectBoolean,
        bandwidthThrottling: __expectLong,
        createPublicIP: __expectBoolean,
        dataPlaneRouting: __expectString,
        defaultLargeStagingDiskType: __expectString,
        ebsEncryption: __expectString,
        ebsEncryptionKeyArn: __expectString,
        name: __expectString,
        replicatedDisks: _json,
        replicationServerInstanceType: __expectString,
        replicationServersSecurityGroupsIDs: _json,
        sourceServerID: __expectString,
        stagingAreaSubnetId: __expectString,
        stagingAreaTags: _json,
        useDedicatedReplicationServer: __expectBoolean,
        useFipsEndpoint: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_InitializeServiceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ListApplicationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListConnectorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListExportErrorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListExportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: (_) => de_ExportsList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListImportErrorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListImportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: (_) => de_ImportList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListManagedAccountsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSourceServerActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTemplateActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListWavesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_MarkAsArchivedCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PauseReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutSourceServerActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionID: __expectString,
        actionName: __expectString,
        active: __expectBoolean,
        category: __expectString,
        description: __expectString,
        documentIdentifier: __expectString,
        documentVersion: __expectString,
        externalParameters: _json,
        mustSucceedForCutover: __expectBoolean,
        order: __expectInt32,
        parameters: _json,
        timeoutSeconds: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutTemplateActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        actionID: __expectString,
        actionName: __expectString,
        active: __expectBoolean,
        category: __expectString,
        description: __expectString,
        documentIdentifier: __expectString,
        documentVersion: __expectString,
        externalParameters: _json,
        mustSucceedForCutover: __expectBoolean,
        operatingSystem: __expectString,
        order: __expectInt32,
        parameters: _json,
        timeoutSeconds: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RemoveSourceServerActionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_RemoveTemplateActionCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ResumeReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RetryDataReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartCutoverCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        job: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartExportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        exportTask: (_) => de_ExportTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartImportCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        importTask: (_) => de_ImportTask(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartTestCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        job: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StopReplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TerminateTargetInstancesCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        job: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UnarchiveApplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationAggregatedStatus: _json,
        applicationID: __expectString,
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UnarchiveWaveCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveAggregatedStatus: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateApplicationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationAggregatedStatus: _json,
        applicationID: __expectString,
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateConnectorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        connectorID: __expectString,
        name: __expectString,
        ssmCommandConfig: _json,
        ssmInstanceID: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateLaunchConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        bootMode: __expectString,
        copyPrivateIp: __expectBoolean,
        copyTags: __expectBoolean,
        ec2LaunchTemplateID: __expectString,
        enableMapAutoTagging: __expectBoolean,
        launchDisposition: __expectString,
        licensing: _json,
        mapAutoTaggingMpeID: __expectString,
        name: __expectString,
        postLaunchActions: _json,
        sourceServerID: __expectString,
        targetInstanceTypeRightSizingMethod: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateLaunchConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        associatePublicIpAddress: __expectBoolean,
        bootMode: __expectString,
        copyPrivateIp: __expectBoolean,
        copyTags: __expectBoolean,
        ec2LaunchTemplateID: __expectString,
        enableMapAutoTagging: __expectBoolean,
        largeVolumeConf: _json,
        launchConfigurationTemplateID: __expectString,
        launchDisposition: __expectString,
        licensing: _json,
        mapAutoTaggingMpeID: __expectString,
        postLaunchActions: _json,
        smallVolumeConf: _json,
        smallVolumeMaxSize: __expectLong,
        tags: _json,
        targetInstanceTypeRightSizingMethod: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateReplicationConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        associateDefaultSecurityGroup: __expectBoolean,
        bandwidthThrottling: __expectLong,
        createPublicIP: __expectBoolean,
        dataPlaneRouting: __expectString,
        defaultLargeStagingDiskType: __expectString,
        ebsEncryption: __expectString,
        ebsEncryptionKeyArn: __expectString,
        name: __expectString,
        replicatedDisks: _json,
        replicationServerInstanceType: __expectString,
        replicationServersSecurityGroupsIDs: _json,
        sourceServerID: __expectString,
        stagingAreaSubnetId: __expectString,
        stagingAreaTags: _json,
        useDedicatedReplicationServer: __expectBoolean,
        useFipsEndpoint: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateReplicationConfigurationTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        associateDefaultSecurityGroup: __expectBoolean,
        bandwidthThrottling: __expectLong,
        createPublicIP: __expectBoolean,
        dataPlaneRouting: __expectString,
        defaultLargeStagingDiskType: __expectString,
        ebsEncryption: __expectString,
        ebsEncryptionKeyArn: __expectString,
        replicationConfigurationTemplateID: __expectString,
        replicationServerInstanceType: __expectString,
        replicationServersSecurityGroupsIDs: _json,
        stagingAreaSubnetId: __expectString,
        stagingAreaTags: _json,
        tags: _json,
        useDedicatedReplicationServer: __expectBoolean,
        useFipsEndpoint: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSourceServerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSourceServerReplicationTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        applicationID: __expectString,
        arn: __expectString,
        connectorAction: _json,
        dataReplicationInfo: _json,
        fqdnForActionFramework: __expectString,
        isArchived: __expectBoolean,
        launchedInstance: _json,
        lifeCycle: _json,
        replicationType: __expectString,
        sourceProperties: _json,
        sourceServerID: __expectString,
        tags: _json,
        userProvidedID: __expectString,
        vcenterClientID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateWaveCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: __expectString,
        description: __expectString,
        isArchived: __expectBoolean,
        lastModifiedDateTime: __expectString,
        name: __expectString,
        tags: _json,
        waveAggregatedStatus: _json,
        waveID: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.mgn#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.mgn#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.mgn#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "UninitializedAccountException":
        case "com.amazonaws.mgn#UninitializedAccountException":
            throw await de_UninitializedAccountExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.mgn#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "AccessDeniedException":
        case "com.amazonaws.mgn#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.mgn#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.mgn#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        errors: _json,
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [() => void 0 !== parsedOutput.headers[_ra], () => __strictParseLong(parsedOutput.headers[_ra])],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
        quotaCode: __expectString,
        quotaValue: __expectInt32,
        resourceId: __expectString,
        resourceType: __expectString,
        serviceCode: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [, parsedOutput.headers[_ra]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        quotaCode: __expectString,
        serviceCode: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UninitializedAccountExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UninitializedAccountException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        code: __expectString,
        fieldList: _json,
        message: __expectString,
        reason: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ExportsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ExportTask(entry, context);
    });
    return retVal;
};
const de_ExportTask = (output, context) => {
    return take(output, {
        creationDateTime: __expectString,
        endDateTime: __expectString,
        exportID: __expectString,
        progressPercentage: __limitedParseFloat32,
        s3Bucket: __expectString,
        s3BucketOwner: __expectString,
        s3Key: __expectString,
        status: __expectString,
        summary: _json,
    });
};
const de_ImportList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ImportTask(entry, context);
    });
    return retVal;
};
const de_ImportTask = (output, context) => {
    return take(output, {
        creationDateTime: __expectString,
        endDateTime: __expectString,
        importID: __expectString,
        progressPercentage: __limitedParseFloat32,
        s3BucketSource: _json,
        status: __expectString,
        summary: _json,
    });
};
const de_JobsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return _json(entry);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _mR = "maxResults";
const _nT = "nextToken";
const _rAS = "retryAfterSeconds";
const _ra = "retry-after";
const _tK = "tagKeys";
