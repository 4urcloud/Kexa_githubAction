import { awsExpectUnion as __expectUnion } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { InvalidPolicyRevisionIdException, InvalidRequestException, LockoutPreventionException, MalformedPolicyDocumentException, PolicyCountLimitExceededException, PolicySizeLimitExceededException, ResourceNotFoundException, RuleLimitExceededException, ThrottledException, TooManyTagsException, } from "../models/models_0";
import { XRayServiceException as __BaseException } from "../models/XRayServiceException";
export const se_BatchGetTracesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/Traces");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
        TraceIds: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateGroup");
    let body;
    body = JSON.stringify(take(input, {
        FilterExpression: [],
        GroupName: [],
        InsightsConfiguration: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateSamplingRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/CreateSamplingRule");
    let body;
    body = JSON.stringify(take(input, {
        SamplingRule: (_) => se_SamplingRule(_, context),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteGroup");
    let body;
    body = JSON.stringify(take(input, {
        GroupARN: [],
        GroupName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteResourcePolicy");
    let body;
    body = JSON.stringify(take(input, {
        PolicyName: [],
        PolicyRevisionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteSamplingRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/DeleteSamplingRule");
    let body;
    body = JSON.stringify(take(input, {
        RuleARN: [],
        RuleName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetEncryptionConfigCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/EncryptionConfig");
    let body;
    body = "";
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetGroup");
    let body;
    body = JSON.stringify(take(input, {
        GroupARN: [],
        GroupName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/Groups");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetInsightCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/Insight");
    let body;
    body = JSON.stringify(take(input, {
        InsightId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetInsightEventsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/InsightEvents");
    let body;
    body = JSON.stringify(take(input, {
        InsightId: [],
        MaxResults: [],
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetInsightImpactGraphCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/InsightImpactGraph");
    let body;
    body = JSON.stringify(take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        InsightId: [],
        NextToken: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetInsightSummariesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/InsightSummaries");
    let body;
    body = JSON.stringify(take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        GroupARN: [],
        GroupName: [],
        MaxResults: [],
        NextToken: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
        States: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetSamplingRulesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/GetSamplingRules");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetSamplingStatisticSummariesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/SamplingStatisticSummaries");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetSamplingTargetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/SamplingTargets");
    let body;
    body = JSON.stringify(take(input, {
        SamplingStatisticsDocuments: (_) => se_SamplingStatisticsDocumentList(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetServiceGraphCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ServiceGraph");
    let body;
    body = JSON.stringify(take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        GroupARN: [],
        GroupName: [],
        NextToken: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTimeSeriesServiceStatisticsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TimeSeriesServiceStatistics");
    let body;
    body = JSON.stringify(take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        EntitySelectorExpression: [],
        ForecastStatistics: [],
        GroupARN: [],
        GroupName: [],
        NextToken: [],
        Period: [],
        StartTime: (_) => Math.round(_.getTime() / 1000),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTraceGraphCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TraceGraph");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
        TraceIds: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetTraceSummariesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TraceSummaries");
    let body;
    body = JSON.stringify(take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        FilterExpression: [],
        NextToken: [],
        Sampling: [],
        SamplingStrategy: (_) => se_SamplingStrategy(_, context),
        StartTime: (_) => Math.round(_.getTime() / 1000),
        TimeRangeType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListResourcePoliciesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListResourcePolicies");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/ListTagsForResource");
    let body;
    body = JSON.stringify(take(input, {
        NextToken: [],
        ResourceARN: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutEncryptionConfigCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PutEncryptionConfig");
    let body;
    body = JSON.stringify(take(input, {
        KeyId: [],
        Type: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutResourcePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/PutResourcePolicy");
    let body;
    body = JSON.stringify(take(input, {
        BypassPolicyLockoutCheck: [],
        PolicyDocument: [],
        PolicyName: [],
        PolicyRevisionId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutTelemetryRecordsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TelemetryRecords");
    let body;
    body = JSON.stringify(take(input, {
        EC2InstanceId: [],
        Hostname: [],
        ResourceARN: [],
        TelemetryRecords: (_) => se_TelemetryRecordList(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutTraceSegmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TraceSegments");
    let body;
    body = JSON.stringify(take(input, {
        TraceSegmentDocuments: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/TagResource");
    let body;
    body = JSON.stringify(take(input, {
        ResourceARN: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UntagResource");
    let body;
    body = JSON.stringify(take(input, {
        ResourceARN: [],
        TagKeys: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateGroup");
    let body;
    body = JSON.stringify(take(input, {
        FilterExpression: [],
        GroupARN: [],
        GroupName: [],
        InsightsConfiguration: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateSamplingRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/UpdateSamplingRule");
    let body;
    body = JSON.stringify(take(input, {
        SamplingRuleUpdate: (_) => se_SamplingRuleUpdate(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const de_BatchGetTracesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Traces: (_) => de_TraceList(_, context),
        UnprocessedTraceIds: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Group: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSamplingRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SamplingRuleRecord: (_) => de_SamplingRuleRecord(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSamplingRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SamplingRuleRecord: (_) => de_SamplingRuleRecord(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EncryptionConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Group: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Groups: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetInsightCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Insight: (_) => de_Insight(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetInsightEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        InsightEvents: (_) => de_InsightEventList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetInsightImpactGraphCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        InsightId: __expectString,
        NextToken: __expectString,
        ServiceGraphEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ServiceGraphStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Services: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetInsightSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        InsightSummaries: (_) => de_InsightSummaryList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSamplingRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SamplingRuleRecords: (_) => de_SamplingRuleRecordList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSamplingStatisticSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        SamplingStatisticSummaries: (_) => de_SamplingStatisticSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSamplingTargetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        LastRuleModification: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SamplingTargetDocuments: (_) => de_SamplingTargetDocumentList(_, context),
        UnprocessedStatistics: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetServiceGraphCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContainsOldGroupVersions: __expectBoolean,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        NextToken: __expectString,
        Services: (_) => de_ServiceList(_, context),
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTimeSeriesServiceStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ContainsOldGroupVersions: __expectBoolean,
        NextToken: __expectString,
        TimeSeriesServiceStatistics: (_) => de_TimeSeriesServiceStatisticsList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTraceGraphCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Services: (_) => de_ServiceList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTraceSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ApproximateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        NextToken: __expectString,
        TraceSummaries: (_) => de_TraceSummaryList(_, context),
        TracesProcessedCount: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListResourcePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        ResourcePolicies: (_) => de_ResourcePolicyList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutEncryptionConfigCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EncryptionConfig: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ResourcePolicy: (_) => de_ResourcePolicy(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutTelemetryRecordsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutTraceSegmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        UnprocessedTraceSegments: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Group: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSamplingRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        SamplingRuleRecord: (_) => de_SamplingRuleRecord(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.xray#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottledException":
        case "com.amazonaws.xray#ThrottledException":
            throw await de_ThrottledExceptionRes(parsedOutput, context);
        case "RuleLimitExceededException":
        case "com.amazonaws.xray#RuleLimitExceededException":
            throw await de_RuleLimitExceededExceptionRes(parsedOutput, context);
        case "InvalidPolicyRevisionIdException":
        case "com.amazonaws.xray#InvalidPolicyRevisionIdException":
            throw await de_InvalidPolicyRevisionIdExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.xray#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "LockoutPreventionException":
        case "com.amazonaws.xray#LockoutPreventionException":
            throw await de_LockoutPreventionExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocumentException":
        case "com.amazonaws.xray#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PolicyCountLimitExceededException":
        case "com.amazonaws.xray#PolicyCountLimitExceededException":
            throw await de_PolicyCountLimitExceededExceptionRes(parsedOutput, context);
        case "PolicySizeLimitExceededException":
        case "com.amazonaws.xray#PolicySizeLimitExceededException":
            throw await de_PolicySizeLimitExceededExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.xray#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_InvalidPolicyRevisionIdExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidPolicyRevisionIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LockoutPreventionExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LockoutPreventionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_PolicyCountLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new PolicyCountLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_PolicySizeLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new PolicySizeLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
        ResourceName: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_RuleLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new RuleLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottledExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
        ResourceName: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_SamplingRule = (input, context) => {
    return take(input, {
        Attributes: _json,
        FixedRate: __serializeFloat,
        HTTPMethod: [],
        Host: [],
        Priority: [],
        ReservoirSize: [],
        ResourceARN: [],
        RuleARN: [],
        RuleName: [],
        ServiceName: [],
        ServiceType: [],
        URLPath: [],
        Version: [],
    });
};
const se_SamplingRuleUpdate = (input, context) => {
    return take(input, {
        Attributes: _json,
        FixedRate: __serializeFloat,
        HTTPMethod: [],
        Host: [],
        Priority: [],
        ReservoirSize: [],
        ResourceARN: [],
        RuleARN: [],
        RuleName: [],
        ServiceName: [],
        ServiceType: [],
        URLPath: [],
    });
};
const se_SamplingStatisticsDocument = (input, context) => {
    return take(input, {
        BorrowCount: [],
        ClientID: [],
        RequestCount: [],
        RuleName: [],
        SampledCount: [],
        Timestamp: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_SamplingStatisticsDocumentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_SamplingStatisticsDocument(entry, context);
    });
};
const se_SamplingStrategy = (input, context) => {
    return take(input, {
        Name: [],
        Value: __serializeFloat,
    });
};
const se_TelemetryRecord = (input, context) => {
    return take(input, {
        BackendConnectionErrors: _json,
        SegmentsReceivedCount: [],
        SegmentsRejectedCount: [],
        SegmentsSentCount: [],
        SegmentsSpilloverCount: [],
        Timestamp: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_TelemetryRecordList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_TelemetryRecord(entry, context);
    });
};
const de_Annotations = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ValuesWithServiceIds(value, context);
        return acc;
    }, {});
};
const de_AnnotationValue = (output, context) => {
    if (__expectBoolean(output.BooleanValue) !== undefined) {
        return { BooleanValue: __expectBoolean(output.BooleanValue) };
    }
    if (__limitedParseDouble(output.NumberValue) !== undefined) {
        return { NumberValue: __limitedParseDouble(output.NumberValue) };
    }
    if (__expectString(output.StringValue) !== undefined) {
        return { StringValue: __expectString(output.StringValue) };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_Edge = (output, context) => {
    return take(output, {
        Aliases: _json,
        EdgeType: __expectString,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ReceivedEventAgeHistogram: (_) => de_Histogram(_, context),
        ReferenceId: __expectInt32,
        ResponseTimeHistogram: (_) => de_Histogram(_, context),
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SummaryStatistics: (_) => de_EdgeStatistics(_, context),
    });
};
const de_EdgeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Edge(entry, context);
    });
    return retVal;
};
const de_EdgeStatistics = (output, context) => {
    return take(output, {
        ErrorStatistics: _json,
        FaultStatistics: _json,
        OkCount: __expectLong,
        TotalCount: __expectLong,
        TotalResponseTime: __limitedParseDouble,
    });
};
const de_Histogram = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HistogramEntry(entry, context);
    });
    return retVal;
};
const de_HistogramEntry = (output, context) => {
    return take(output, {
        Count: __expectInt32,
        Value: __limitedParseDouble,
    });
};
const de_Insight = (output, context) => {
    return take(output, {
        Categories: _json,
        ClientRequestImpactStatistics: _json,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        GroupARN: __expectString,
        GroupName: __expectString,
        InsightId: __expectString,
        RootCauseServiceId: _json,
        RootCauseServiceRequestImpactStatistics: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        State: __expectString,
        Summary: __expectString,
        TopAnomalousServices: _json,
    });
};
const de_InsightEvent = (output, context) => {
    return take(output, {
        ClientRequestImpactStatistics: _json,
        EventTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RootCauseServiceRequestImpactStatistics: _json,
        Summary: __expectString,
        TopAnomalousServices: _json,
    });
};
const de_InsightEventList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightEvent(entry, context);
    });
    return retVal;
};
const de_InsightSummary = (output, context) => {
    return take(output, {
        Categories: _json,
        ClientRequestImpactStatistics: _json,
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        GroupARN: __expectString,
        GroupName: __expectString,
        InsightId: __expectString,
        LastUpdateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RootCauseServiceId: _json,
        RootCauseServiceRequestImpactStatistics: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        State: __expectString,
        Summary: __expectString,
        TopAnomalousServices: _json,
    });
};
const de_InsightSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InsightSummary(entry, context);
    });
    return retVal;
};
const de_ResourcePolicy = (output, context) => {
    return take(output, {
        LastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        PolicyDocument: __expectString,
        PolicyName: __expectString,
        PolicyRevisionId: __expectString,
    });
};
const de_ResourcePolicyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourcePolicy(entry, context);
    });
    return retVal;
};
const de_ResponseTimeRootCause = (output, context) => {
    return take(output, {
        ClientImpacting: __expectBoolean,
        Services: (_) => de_ResponseTimeRootCauseServices(_, context),
    });
};
const de_ResponseTimeRootCauseEntity = (output, context) => {
    return take(output, {
        Coverage: __limitedParseDouble,
        Name: __expectString,
        Remote: __expectBoolean,
    });
};
const de_ResponseTimeRootCauseEntityPath = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseTimeRootCauseEntity(entry, context);
    });
    return retVal;
};
const de_ResponseTimeRootCauses = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseTimeRootCause(entry, context);
    });
    return retVal;
};
const de_ResponseTimeRootCauseService = (output, context) => {
    return take(output, {
        AccountId: __expectString,
        EntityPath: (_) => de_ResponseTimeRootCauseEntityPath(_, context),
        Inferred: __expectBoolean,
        Name: __expectString,
        Names: _json,
        Type: __expectString,
    });
};
const de_ResponseTimeRootCauseServices = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResponseTimeRootCauseService(entry, context);
    });
    return retVal;
};
const de_SamplingRule = (output, context) => {
    return take(output, {
        Attributes: _json,
        FixedRate: __limitedParseDouble,
        HTTPMethod: __expectString,
        Host: __expectString,
        Priority: __expectInt32,
        ReservoirSize: __expectInt32,
        ResourceARN: __expectString,
        RuleARN: __expectString,
        RuleName: __expectString,
        ServiceName: __expectString,
        ServiceType: __expectString,
        URLPath: __expectString,
        Version: __expectInt32,
    });
};
const de_SamplingRuleRecord = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ModifiedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        SamplingRule: (_) => de_SamplingRule(_, context),
    });
};
const de_SamplingRuleRecordList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SamplingRuleRecord(entry, context);
    });
    return retVal;
};
const de_SamplingStatisticSummary = (output, context) => {
    return take(output, {
        BorrowCount: __expectInt32,
        RequestCount: __expectInt32,
        RuleName: __expectString,
        SampledCount: __expectInt32,
        Timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_SamplingStatisticSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SamplingStatisticSummary(entry, context);
    });
    return retVal;
};
const de_SamplingTargetDocument = (output, context) => {
    return take(output, {
        FixedRate: __limitedParseDouble,
        Interval: __expectInt32,
        ReservoirQuota: __expectInt32,
        ReservoirQuotaTTL: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RuleName: __expectString,
    });
};
const de_SamplingTargetDocumentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SamplingTargetDocument(entry, context);
    });
    return retVal;
};
const de_Service = (output, context) => {
    return take(output, {
        AccountId: __expectString,
        DurationHistogram: (_) => de_Histogram(_, context),
        Edges: (_) => de_EdgeList(_, context),
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Name: __expectString,
        Names: _json,
        ReferenceId: __expectInt32,
        ResponseTimeHistogram: (_) => de_Histogram(_, context),
        Root: __expectBoolean,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        State: __expectString,
        SummaryStatistics: (_) => de_ServiceStatistics(_, context),
        Type: __expectString,
    });
};
const de_ServiceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Service(entry, context);
    });
    return retVal;
};
const de_ServiceStatistics = (output, context) => {
    return take(output, {
        ErrorStatistics: _json,
        FaultStatistics: _json,
        OkCount: __expectLong,
        TotalCount: __expectLong,
        TotalResponseTime: __limitedParseDouble,
    });
};
const de_TimeSeriesServiceStatistics = (output, context) => {
    return take(output, {
        EdgeSummaryStatistics: (_) => de_EdgeStatistics(_, context),
        ResponseTimeHistogram: (_) => de_Histogram(_, context),
        ServiceForecastStatistics: _json,
        ServiceSummaryStatistics: (_) => de_ServiceStatistics(_, context),
        Timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_TimeSeriesServiceStatisticsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TimeSeriesServiceStatistics(entry, context);
    });
    return retVal;
};
const de_Trace = (output, context) => {
    return take(output, {
        Duration: __limitedParseDouble,
        Id: __expectString,
        LimitExceeded: __expectBoolean,
        Segments: _json,
    });
};
const de_TraceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Trace(entry, context);
    });
    return retVal;
};
const de_TraceSummary = (output, context) => {
    return take(output, {
        Annotations: (_) => de_Annotations(_, context),
        AvailabilityZones: _json,
        Duration: __limitedParseDouble,
        EntryPoint: _json,
        ErrorRootCauses: _json,
        FaultRootCauses: _json,
        HasError: __expectBoolean,
        HasFault: __expectBoolean,
        HasThrottle: __expectBoolean,
        Http: _json,
        Id: __expectString,
        InstanceIds: _json,
        IsPartial: __expectBoolean,
        MatchedEventTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ResourceARNs: _json,
        ResponseTime: __limitedParseDouble,
        ResponseTimeRootCauses: (_) => de_ResponseTimeRootCauses(_, context),
        Revision: __expectInt32,
        ServiceIds: _json,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Users: _json,
    });
};
const de_TraceSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TraceSummary(entry, context);
    });
    return retVal;
};
const de_ValuesWithServiceIds = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ValueWithServiceIds(entry, context);
    });
    return retVal;
};
const de_ValueWithServiceIds = (output, context) => {
    return take(output, {
        AnnotationValue: (_) => de_AnnotationValue(__expectUnion(_), context),
        ServiceIds: _json,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
