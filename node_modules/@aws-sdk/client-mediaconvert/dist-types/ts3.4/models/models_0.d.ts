export declare const RequiredFlag: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type RequiredFlag = (typeof RequiredFlag)[keyof typeof RequiredFlag];
export interface AllowedRenditionSize {
  Height?: number;
  Required?: RequiredFlag;
  Width?: number;
}
export declare const AudioChannelTag: {
  readonly C: "C";
  readonly CS: "CS";
  readonly HI: "HI";
  readonly L: "L";
  readonly LC: "LC";
  readonly LFE: "LFE";
  readonly LFE2: "LFE2";
  readonly LS: "LS";
  readonly LSD: "LSD";
  readonly LT: "LT";
  readonly LW: "LW";
  readonly M: "M";
  readonly NAR: "NAR";
  readonly R: "R";
  readonly RC: "RC";
  readonly RS: "RS";
  readonly RSD: "RSD";
  readonly RSL: "RSL";
  readonly RSR: "RSR";
  readonly RT: "RT";
  readonly RW: "RW";
  readonly TBC: "TBC";
  readonly TBL: "TBL";
  readonly TBR: "TBR";
  readonly TCS: "TCS";
  readonly VHC: "VHC";
  readonly VHL: "VHL";
  readonly VHR: "VHR";
};
export type AudioChannelTag =
  (typeof AudioChannelTag)[keyof typeof AudioChannelTag];
export interface AudioChannelTaggingSettings {
  ChannelTag?: AudioChannelTag;
  ChannelTags?: AudioChannelTag[];
}
export declare const AudioNormalizationAlgorithm: {
  readonly ITU_BS_1770_1: "ITU_BS_1770_1";
  readonly ITU_BS_1770_2: "ITU_BS_1770_2";
  readonly ITU_BS_1770_3: "ITU_BS_1770_3";
  readonly ITU_BS_1770_4: "ITU_BS_1770_4";
};
export type AudioNormalizationAlgorithm =
  (typeof AudioNormalizationAlgorithm)[keyof typeof AudioNormalizationAlgorithm];
export declare const AudioNormalizationAlgorithmControl: {
  readonly CORRECT_AUDIO: "CORRECT_AUDIO";
  readonly MEASURE_ONLY: "MEASURE_ONLY";
};
export type AudioNormalizationAlgorithmControl =
  (typeof AudioNormalizationAlgorithmControl)[keyof typeof AudioNormalizationAlgorithmControl];
export declare const AudioNormalizationLoudnessLogging: {
  readonly DONT_LOG: "DONT_LOG";
  readonly LOG: "LOG";
};
export type AudioNormalizationLoudnessLogging =
  (typeof AudioNormalizationLoudnessLogging)[keyof typeof AudioNormalizationLoudnessLogging];
export declare const AudioNormalizationPeakCalculation: {
  readonly NONE: "NONE";
  readonly TRUE_PEAK: "TRUE_PEAK";
};
export type AudioNormalizationPeakCalculation =
  (typeof AudioNormalizationPeakCalculation)[keyof typeof AudioNormalizationPeakCalculation];
export interface AudioNormalizationSettings {
  Algorithm?: AudioNormalizationAlgorithm;
  AlgorithmControl?: AudioNormalizationAlgorithmControl;
  CorrectionGateLevel?: number;
  LoudnessLogging?: AudioNormalizationLoudnessLogging;
  PeakCalculation?: AudioNormalizationPeakCalculation;
  TargetLkfs?: number;
  TruePeakLimiterThreshold?: number;
}
export declare const AudioTypeControl: {
  readonly FOLLOW_INPUT: "FOLLOW_INPUT";
  readonly USE_CONFIGURED: "USE_CONFIGURED";
};
export type AudioTypeControl =
  (typeof AudioTypeControl)[keyof typeof AudioTypeControl];
export declare const AacAudioDescriptionBroadcasterMix: {
  readonly BROADCASTER_MIXED_AD: "BROADCASTER_MIXED_AD";
  readonly NORMAL: "NORMAL";
};
export type AacAudioDescriptionBroadcasterMix =
  (typeof AacAudioDescriptionBroadcasterMix)[keyof typeof AacAudioDescriptionBroadcasterMix];
export declare const AacCodecProfile: {
  readonly HEV1: "HEV1";
  readonly HEV2: "HEV2";
  readonly LC: "LC";
};
export type AacCodecProfile =
  (typeof AacCodecProfile)[keyof typeof AacCodecProfile];
export declare const AacCodingMode: {
  readonly AD_RECEIVER_MIX: "AD_RECEIVER_MIX";
  readonly CODING_MODE_1_0: "CODING_MODE_1_0";
  readonly CODING_MODE_1_1: "CODING_MODE_1_1";
  readonly CODING_MODE_2_0: "CODING_MODE_2_0";
  readonly CODING_MODE_5_1: "CODING_MODE_5_1";
};
export type AacCodingMode = (typeof AacCodingMode)[keyof typeof AacCodingMode];
export declare const AacRateControlMode: {
  readonly CBR: "CBR";
  readonly VBR: "VBR";
};
export type AacRateControlMode =
  (typeof AacRateControlMode)[keyof typeof AacRateControlMode];
export declare const AacRawFormat: {
  readonly LATM_LOAS: "LATM_LOAS";
  readonly NONE: "NONE";
};
export type AacRawFormat = (typeof AacRawFormat)[keyof typeof AacRawFormat];
export declare const AacSpecification: {
  readonly MPEG2: "MPEG2";
  readonly MPEG4: "MPEG4";
};
export type AacSpecification =
  (typeof AacSpecification)[keyof typeof AacSpecification];
export declare const AacVbrQuality: {
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly MEDIUM_HIGH: "MEDIUM_HIGH";
  readonly MEDIUM_LOW: "MEDIUM_LOW";
};
export type AacVbrQuality = (typeof AacVbrQuality)[keyof typeof AacVbrQuality];
export interface AacSettings {
  AudioDescriptionBroadcasterMix?: AacAudioDescriptionBroadcasterMix;
  Bitrate?: number;
  CodecProfile?: AacCodecProfile;
  CodingMode?: AacCodingMode;
  RateControlMode?: AacRateControlMode;
  RawFormat?: AacRawFormat;
  SampleRate?: number;
  Specification?: AacSpecification;
  VbrQuality?: AacVbrQuality;
}
export declare const Ac3BitstreamMode: {
  readonly COMMENTARY: "COMMENTARY";
  readonly COMPLETE_MAIN: "COMPLETE_MAIN";
  readonly DIALOGUE: "DIALOGUE";
  readonly EMERGENCY: "EMERGENCY";
  readonly HEARING_IMPAIRED: "HEARING_IMPAIRED";
  readonly MUSIC_AND_EFFECTS: "MUSIC_AND_EFFECTS";
  readonly VISUALLY_IMPAIRED: "VISUALLY_IMPAIRED";
  readonly VOICE_OVER: "VOICE_OVER";
};
export type Ac3BitstreamMode =
  (typeof Ac3BitstreamMode)[keyof typeof Ac3BitstreamMode];
export declare const Ac3CodingMode: {
  readonly CODING_MODE_1_0: "CODING_MODE_1_0";
  readonly CODING_MODE_1_1: "CODING_MODE_1_1";
  readonly CODING_MODE_2_0: "CODING_MODE_2_0";
  readonly CODING_MODE_3_2_LFE: "CODING_MODE_3_2_LFE";
};
export type Ac3CodingMode = (typeof Ac3CodingMode)[keyof typeof Ac3CodingMode];
export declare const Ac3DynamicRangeCompressionLine: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Ac3DynamicRangeCompressionLine =
  (typeof Ac3DynamicRangeCompressionLine)[keyof typeof Ac3DynamicRangeCompressionLine];
export declare const Ac3DynamicRangeCompressionProfile: {
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly NONE: "NONE";
};
export type Ac3DynamicRangeCompressionProfile =
  (typeof Ac3DynamicRangeCompressionProfile)[keyof typeof Ac3DynamicRangeCompressionProfile];
export declare const Ac3DynamicRangeCompressionRf: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Ac3DynamicRangeCompressionRf =
  (typeof Ac3DynamicRangeCompressionRf)[keyof typeof Ac3DynamicRangeCompressionRf];
export declare const Ac3LfeFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type Ac3LfeFilter = (typeof Ac3LfeFilter)[keyof typeof Ac3LfeFilter];
export declare const Ac3MetadataControl: {
  readonly FOLLOW_INPUT: "FOLLOW_INPUT";
  readonly USE_CONFIGURED: "USE_CONFIGURED";
};
export type Ac3MetadataControl =
  (typeof Ac3MetadataControl)[keyof typeof Ac3MetadataControl];
export interface Ac3Settings {
  Bitrate?: number;
  BitstreamMode?: Ac3BitstreamMode;
  CodingMode?: Ac3CodingMode;
  Dialnorm?: number;
  DynamicRangeCompressionLine?: Ac3DynamicRangeCompressionLine;
  DynamicRangeCompressionProfile?: Ac3DynamicRangeCompressionProfile;
  DynamicRangeCompressionRf?: Ac3DynamicRangeCompressionRf;
  LfeFilter?: Ac3LfeFilter;
  MetadataControl?: Ac3MetadataControl;
  SampleRate?: number;
}
export interface AiffSettings {
  BitDepth?: number;
  Channels?: number;
  SampleRate?: number;
}
export declare const AudioCodec: {
  readonly AAC: "AAC";
  readonly AC3: "AC3";
  readonly AIFF: "AIFF";
  readonly EAC3: "EAC3";
  readonly EAC3_ATMOS: "EAC3_ATMOS";
  readonly FLAC: "FLAC";
  readonly MP2: "MP2";
  readonly MP3: "MP3";
  readonly OPUS: "OPUS";
  readonly PASSTHROUGH: "PASSTHROUGH";
  readonly VORBIS: "VORBIS";
  readonly WAV: "WAV";
};
export type AudioCodec = (typeof AudioCodec)[keyof typeof AudioCodec];
export declare const Eac3AtmosBitstreamMode: {
  readonly COMPLETE_MAIN: "COMPLETE_MAIN";
};
export type Eac3AtmosBitstreamMode =
  (typeof Eac3AtmosBitstreamMode)[keyof typeof Eac3AtmosBitstreamMode];
export declare const Eac3AtmosCodingMode: {
  readonly CODING_MODE_5_1_4: "CODING_MODE_5_1_4";
  readonly CODING_MODE_7_1_4: "CODING_MODE_7_1_4";
  readonly CODING_MODE_9_1_6: "CODING_MODE_9_1_6";
  readonly CODING_MODE_AUTO: "CODING_MODE_AUTO";
};
export type Eac3AtmosCodingMode =
  (typeof Eac3AtmosCodingMode)[keyof typeof Eac3AtmosCodingMode];
export declare const Eac3AtmosDialogueIntelligence: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type Eac3AtmosDialogueIntelligence =
  (typeof Eac3AtmosDialogueIntelligence)[keyof typeof Eac3AtmosDialogueIntelligence];
export declare const Eac3AtmosDownmixControl: {
  readonly INITIALIZE_FROM_SOURCE: "INITIALIZE_FROM_SOURCE";
  readonly SPECIFIED: "SPECIFIED";
};
export type Eac3AtmosDownmixControl =
  (typeof Eac3AtmosDownmixControl)[keyof typeof Eac3AtmosDownmixControl];
export declare const Eac3AtmosDynamicRangeCompressionLine: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Eac3AtmosDynamicRangeCompressionLine =
  (typeof Eac3AtmosDynamicRangeCompressionLine)[keyof typeof Eac3AtmosDynamicRangeCompressionLine];
export declare const Eac3AtmosDynamicRangeCompressionRf: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Eac3AtmosDynamicRangeCompressionRf =
  (typeof Eac3AtmosDynamicRangeCompressionRf)[keyof typeof Eac3AtmosDynamicRangeCompressionRf];
export declare const Eac3AtmosDynamicRangeControl: {
  readonly INITIALIZE_FROM_SOURCE: "INITIALIZE_FROM_SOURCE";
  readonly SPECIFIED: "SPECIFIED";
};
export type Eac3AtmosDynamicRangeControl =
  (typeof Eac3AtmosDynamicRangeControl)[keyof typeof Eac3AtmosDynamicRangeControl];
export declare const Eac3AtmosMeteringMode: {
  readonly ITU_BS_1770_1: "ITU_BS_1770_1";
  readonly ITU_BS_1770_2: "ITU_BS_1770_2";
  readonly ITU_BS_1770_3: "ITU_BS_1770_3";
  readonly ITU_BS_1770_4: "ITU_BS_1770_4";
  readonly LEQ_A: "LEQ_A";
};
export type Eac3AtmosMeteringMode =
  (typeof Eac3AtmosMeteringMode)[keyof typeof Eac3AtmosMeteringMode];
export declare const Eac3AtmosStereoDownmix: {
  readonly DPL2: "DPL2";
  readonly NOT_INDICATED: "NOT_INDICATED";
  readonly STEREO: "STEREO";
  readonly SURROUND: "SURROUND";
};
export type Eac3AtmosStereoDownmix =
  (typeof Eac3AtmosStereoDownmix)[keyof typeof Eac3AtmosStereoDownmix];
export declare const Eac3AtmosSurroundExMode: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly NOT_INDICATED: "NOT_INDICATED";
};
export type Eac3AtmosSurroundExMode =
  (typeof Eac3AtmosSurroundExMode)[keyof typeof Eac3AtmosSurroundExMode];
export interface Eac3AtmosSettings {
  Bitrate?: number;
  BitstreamMode?: Eac3AtmosBitstreamMode;
  CodingMode?: Eac3AtmosCodingMode;
  DialogueIntelligence?: Eac3AtmosDialogueIntelligence;
  DownmixControl?: Eac3AtmosDownmixControl;
  DynamicRangeCompressionLine?: Eac3AtmosDynamicRangeCompressionLine;
  DynamicRangeCompressionRf?: Eac3AtmosDynamicRangeCompressionRf;
  DynamicRangeControl?: Eac3AtmosDynamicRangeControl;
  LoRoCenterMixLevel?: number;
  LoRoSurroundMixLevel?: number;
  LtRtCenterMixLevel?: number;
  LtRtSurroundMixLevel?: number;
  MeteringMode?: Eac3AtmosMeteringMode;
  SampleRate?: number;
  SpeechThreshold?: number;
  StereoDownmix?: Eac3AtmosStereoDownmix;
  SurroundExMode?: Eac3AtmosSurroundExMode;
}
export declare const Eac3AttenuationControl: {
  readonly ATTENUATE_3_DB: "ATTENUATE_3_DB";
  readonly NONE: "NONE";
};
export type Eac3AttenuationControl =
  (typeof Eac3AttenuationControl)[keyof typeof Eac3AttenuationControl];
export declare const Eac3BitstreamMode: {
  readonly COMMENTARY: "COMMENTARY";
  readonly COMPLETE_MAIN: "COMPLETE_MAIN";
  readonly EMERGENCY: "EMERGENCY";
  readonly HEARING_IMPAIRED: "HEARING_IMPAIRED";
  readonly VISUALLY_IMPAIRED: "VISUALLY_IMPAIRED";
};
export type Eac3BitstreamMode =
  (typeof Eac3BitstreamMode)[keyof typeof Eac3BitstreamMode];
export declare const Eac3CodingMode: {
  readonly CODING_MODE_1_0: "CODING_MODE_1_0";
  readonly CODING_MODE_2_0: "CODING_MODE_2_0";
  readonly CODING_MODE_3_2: "CODING_MODE_3_2";
};
export type Eac3CodingMode =
  (typeof Eac3CodingMode)[keyof typeof Eac3CodingMode];
export declare const Eac3DcFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type Eac3DcFilter = (typeof Eac3DcFilter)[keyof typeof Eac3DcFilter];
export declare const Eac3DynamicRangeCompressionLine: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Eac3DynamicRangeCompressionLine =
  (typeof Eac3DynamicRangeCompressionLine)[keyof typeof Eac3DynamicRangeCompressionLine];
export declare const Eac3DynamicRangeCompressionRf: {
  readonly FILM_LIGHT: "FILM_LIGHT";
  readonly FILM_STANDARD: "FILM_STANDARD";
  readonly MUSIC_LIGHT: "MUSIC_LIGHT";
  readonly MUSIC_STANDARD: "MUSIC_STANDARD";
  readonly NONE: "NONE";
  readonly SPEECH: "SPEECH";
};
export type Eac3DynamicRangeCompressionRf =
  (typeof Eac3DynamicRangeCompressionRf)[keyof typeof Eac3DynamicRangeCompressionRf];
export declare const Eac3LfeControl: {
  readonly LFE: "LFE";
  readonly NO_LFE: "NO_LFE";
};
export type Eac3LfeControl =
  (typeof Eac3LfeControl)[keyof typeof Eac3LfeControl];
export declare const Eac3LfeFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type Eac3LfeFilter = (typeof Eac3LfeFilter)[keyof typeof Eac3LfeFilter];
export declare const Eac3MetadataControl: {
  readonly FOLLOW_INPUT: "FOLLOW_INPUT";
  readonly USE_CONFIGURED: "USE_CONFIGURED";
};
export type Eac3MetadataControl =
  (typeof Eac3MetadataControl)[keyof typeof Eac3MetadataControl];
export declare const Eac3PassthroughControl: {
  readonly NO_PASSTHROUGH: "NO_PASSTHROUGH";
  readonly WHEN_POSSIBLE: "WHEN_POSSIBLE";
};
export type Eac3PassthroughControl =
  (typeof Eac3PassthroughControl)[keyof typeof Eac3PassthroughControl];
export declare const Eac3PhaseControl: {
  readonly NO_SHIFT: "NO_SHIFT";
  readonly SHIFT_90_DEGREES: "SHIFT_90_DEGREES";
};
export type Eac3PhaseControl =
  (typeof Eac3PhaseControl)[keyof typeof Eac3PhaseControl];
export declare const Eac3StereoDownmix: {
  readonly DPL2: "DPL2";
  readonly LO_RO: "LO_RO";
  readonly LT_RT: "LT_RT";
  readonly NOT_INDICATED: "NOT_INDICATED";
};
export type Eac3StereoDownmix =
  (typeof Eac3StereoDownmix)[keyof typeof Eac3StereoDownmix];
export declare const Eac3SurroundExMode: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly NOT_INDICATED: "NOT_INDICATED";
};
export type Eac3SurroundExMode =
  (typeof Eac3SurroundExMode)[keyof typeof Eac3SurroundExMode];
export declare const Eac3SurroundMode: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly NOT_INDICATED: "NOT_INDICATED";
};
export type Eac3SurroundMode =
  (typeof Eac3SurroundMode)[keyof typeof Eac3SurroundMode];
export interface Eac3Settings {
  AttenuationControl?: Eac3AttenuationControl;
  Bitrate?: number;
  BitstreamMode?: Eac3BitstreamMode;
  CodingMode?: Eac3CodingMode;
  DcFilter?: Eac3DcFilter;
  Dialnorm?: number;
  DynamicRangeCompressionLine?: Eac3DynamicRangeCompressionLine;
  DynamicRangeCompressionRf?: Eac3DynamicRangeCompressionRf;
  LfeControl?: Eac3LfeControl;
  LfeFilter?: Eac3LfeFilter;
  LoRoCenterMixLevel?: number;
  LoRoSurroundMixLevel?: number;
  LtRtCenterMixLevel?: number;
  LtRtSurroundMixLevel?: number;
  MetadataControl?: Eac3MetadataControl;
  PassthroughControl?: Eac3PassthroughControl;
  PhaseControl?: Eac3PhaseControl;
  SampleRate?: number;
  StereoDownmix?: Eac3StereoDownmix;
  SurroundExMode?: Eac3SurroundExMode;
  SurroundMode?: Eac3SurroundMode;
}
export interface FlacSettings {
  BitDepth?: number;
  Channels?: number;
  SampleRate?: number;
}
export interface Mp2Settings {
  Bitrate?: number;
  Channels?: number;
  SampleRate?: number;
}
export declare const Mp3RateControlMode: {
  readonly CBR: "CBR";
  readonly VBR: "VBR";
};
export type Mp3RateControlMode =
  (typeof Mp3RateControlMode)[keyof typeof Mp3RateControlMode];
export interface Mp3Settings {
  Bitrate?: number;
  Channels?: number;
  RateControlMode?: Mp3RateControlMode;
  SampleRate?: number;
  VbrQuality?: number;
}
export interface OpusSettings {
  Bitrate?: number;
  Channels?: number;
  SampleRate?: number;
}
export interface VorbisSettings {
  Channels?: number;
  SampleRate?: number;
  VbrQuality?: number;
}
export declare const WavFormat: {
  readonly RF64: "RF64";
  readonly RIFF: "RIFF";
};
export type WavFormat = (typeof WavFormat)[keyof typeof WavFormat];
export interface WavSettings {
  BitDepth?: number;
  Channels?: number;
  Format?: WavFormat;
  SampleRate?: number;
}
export interface AudioCodecSettings {
  AacSettings?: AacSettings;
  Ac3Settings?: Ac3Settings;
  AiffSettings?: AiffSettings;
  Codec?: AudioCodec;
  Eac3AtmosSettings?: Eac3AtmosSettings;
  Eac3Settings?: Eac3Settings;
  FlacSettings?: FlacSettings;
  Mp2Settings?: Mp2Settings;
  Mp3Settings?: Mp3Settings;
  OpusSettings?: OpusSettings;
  VorbisSettings?: VorbisSettings;
  WavSettings?: WavSettings;
}
export declare const LanguageCode: {
  readonly AAR: "AAR";
  readonly ABK: "ABK";
  readonly AFR: "AFR";
  readonly AKA: "AKA";
  readonly AMH: "AMH";
  readonly ARA: "ARA";
  readonly ARG: "ARG";
  readonly ASM: "ASM";
  readonly AVA: "AVA";
  readonly AVE: "AVE";
  readonly AYM: "AYM";
  readonly AZE: "AZE";
  readonly BAK: "BAK";
  readonly BAM: "BAM";
  readonly BEL: "BEL";
  readonly BEN: "BEN";
  readonly BIH: "BIH";
  readonly BIS: "BIS";
  readonly BOD: "BOD";
  readonly BOS: "BOS";
  readonly BRE: "BRE";
  readonly BUL: "BUL";
  readonly CAT: "CAT";
  readonly CES: "CES";
  readonly CHA: "CHA";
  readonly CHE: "CHE";
  readonly CHU: "CHU";
  readonly CHV: "CHV";
  readonly COR: "COR";
  readonly COS: "COS";
  readonly CRE: "CRE";
  readonly CYM: "CYM";
  readonly DAN: "DAN";
  readonly DEU: "DEU";
  readonly DIV: "DIV";
  readonly DZO: "DZO";
  readonly ELL: "ELL";
  readonly ENG: "ENG";
  readonly ENM: "ENM";
  readonly EPO: "EPO";
  readonly EST: "EST";
  readonly EUS: "EUS";
  readonly EWE: "EWE";
  readonly FAO: "FAO";
  readonly FAS: "FAS";
  readonly FIJ: "FIJ";
  readonly FIN: "FIN";
  readonly FRA: "FRA";
  readonly FRM: "FRM";
  readonly FRY: "FRY";
  readonly FUL: "FUL";
  readonly GER: "GER";
  readonly GLA: "GLA";
  readonly GLE: "GLE";
  readonly GLG: "GLG";
  readonly GLV: "GLV";
  readonly GRN: "GRN";
  readonly GUJ: "GUJ";
  readonly HAT: "HAT";
  readonly HAU: "HAU";
  readonly HEB: "HEB";
  readonly HER: "HER";
  readonly HIN: "HIN";
  readonly HMO: "HMO";
  readonly HRV: "HRV";
  readonly HUN: "HUN";
  readonly HYE: "HYE";
  readonly IBO: "IBO";
  readonly IDO: "IDO";
  readonly III: "III";
  readonly IKU: "IKU";
  readonly ILE: "ILE";
  readonly INA: "INA";
  readonly IND: "IND";
  readonly IPK: "IPK";
  readonly ISL: "ISL";
  readonly ITA: "ITA";
  readonly JAV: "JAV";
  readonly JPN: "JPN";
  readonly KAL: "KAL";
  readonly KAN: "KAN";
  readonly KAS: "KAS";
  readonly KAT: "KAT";
  readonly KAU: "KAU";
  readonly KAZ: "KAZ";
  readonly KHM: "KHM";
  readonly KIK: "KIK";
  readonly KIN: "KIN";
  readonly KIR: "KIR";
  readonly KOM: "KOM";
  readonly KON: "KON";
  readonly KOR: "KOR";
  readonly KUA: "KUA";
  readonly KUR: "KUR";
  readonly LAO: "LAO";
  readonly LAT: "LAT";
  readonly LAV: "LAV";
  readonly LIM: "LIM";
  readonly LIN: "LIN";
  readonly LIT: "LIT";
  readonly LTZ: "LTZ";
  readonly LUB: "LUB";
  readonly LUG: "LUG";
  readonly MAH: "MAH";
  readonly MAL: "MAL";
  readonly MAR: "MAR";
  readonly MKD: "MKD";
  readonly MLG: "MLG";
  readonly MLT: "MLT";
  readonly MON: "MON";
  readonly MRI: "MRI";
  readonly MSA: "MSA";
  readonly MYA: "MYA";
  readonly NAU: "NAU";
  readonly NAV: "NAV";
  readonly NBL: "NBL";
  readonly NDE: "NDE";
  readonly NDO: "NDO";
  readonly NEP: "NEP";
  readonly NLD: "NLD";
  readonly NNO: "NNO";
  readonly NOB: "NOB";
  readonly NOR: "NOR";
  readonly NYA: "NYA";
  readonly OCI: "OCI";
  readonly OJI: "OJI";
  readonly ORI: "ORI";
  readonly ORJ: "ORJ";
  readonly ORM: "ORM";
  readonly OSS: "OSS";
  readonly PAN: "PAN";
  readonly PLI: "PLI";
  readonly POL: "POL";
  readonly POR: "POR";
  readonly PUS: "PUS";
  readonly QAA: "QAA";
  readonly QPC: "QPC";
  readonly QUE: "QUE";
  readonly ROH: "ROH";
  readonly RON: "RON";
  readonly RUN: "RUN";
  readonly RUS: "RUS";
  readonly SAG: "SAG";
  readonly SAN: "SAN";
  readonly SIN: "SIN";
  readonly SLK: "SLK";
  readonly SLV: "SLV";
  readonly SME: "SME";
  readonly SMO: "SMO";
  readonly SNA: "SNA";
  readonly SND: "SND";
  readonly SOM: "SOM";
  readonly SOT: "SOT";
  readonly SPA: "SPA";
  readonly SQI: "SQI";
  readonly SRB: "SRB";
  readonly SRD: "SRD";
  readonly SRP: "SRP";
  readonly SSW: "SSW";
  readonly SUN: "SUN";
  readonly SWA: "SWA";
  readonly SWE: "SWE";
  readonly TAH: "TAH";
  readonly TAM: "TAM";
  readonly TAT: "TAT";
  readonly TEL: "TEL";
  readonly TGK: "TGK";
  readonly TGL: "TGL";
  readonly THA: "THA";
  readonly TIR: "TIR";
  readonly TNG: "TNG";
  readonly TON: "TON";
  readonly TSN: "TSN";
  readonly TSO: "TSO";
  readonly TUK: "TUK";
  readonly TUR: "TUR";
  readonly TWI: "TWI";
  readonly UIG: "UIG";
  readonly UKR: "UKR";
  readonly URD: "URD";
  readonly UZB: "UZB";
  readonly VEN: "VEN";
  readonly VIE: "VIE";
  readonly VOL: "VOL";
  readonly WLN: "WLN";
  readonly WOL: "WOL";
  readonly XHO: "XHO";
  readonly YID: "YID";
  readonly YOR: "YOR";
  readonly ZHA: "ZHA";
  readonly ZHO: "ZHO";
  readonly ZUL: "ZUL";
};
export type LanguageCode = (typeof LanguageCode)[keyof typeof LanguageCode];
export declare const AudioLanguageCodeControl: {
  readonly FOLLOW_INPUT: "FOLLOW_INPUT";
  readonly USE_CONFIGURED: "USE_CONFIGURED";
};
export type AudioLanguageCodeControl =
  (typeof AudioLanguageCodeControl)[keyof typeof AudioLanguageCodeControl];
export interface OutputChannelMapping {
  InputChannels?: number[];
  InputChannelsFineTune?: number[];
}
export interface ChannelMapping {
  OutputChannels?: OutputChannelMapping[];
}
export interface RemixSettings {
  AudioDescriptionAudioChannel?: number;
  AudioDescriptionDataChannel?: number;
  ChannelMapping?: ChannelMapping;
  ChannelsIn?: number;
  ChannelsOut?: number;
}
export interface AudioDescription {
  AudioChannelTaggingSettings?: AudioChannelTaggingSettings;
  AudioNormalizationSettings?: AudioNormalizationSettings;
  AudioSourceName?: string;
  AudioType?: number;
  AudioTypeControl?: AudioTypeControl;
  CodecSettings?: AudioCodecSettings;
  CustomLanguageCode?: string;
  LanguageCode?: LanguageCode;
  LanguageCodeControl?: AudioLanguageCodeControl;
  RemixSettings?: RemixSettings;
  StreamName?: string;
}
export interface ForceIncludeRenditionSize {
  Height?: number;
  Width?: number;
}
export interface MinBottomRenditionSize {
  Height?: number;
  Width?: number;
}
export interface MinTopRenditionSize {
  Height?: number;
  Width?: number;
}
export declare const RuleType: {
  readonly ALLOWED_RENDITIONS: "ALLOWED_RENDITIONS";
  readonly FORCE_INCLUDE_RENDITIONS: "FORCE_INCLUDE_RENDITIONS";
  readonly MIN_BOTTOM_RENDITION_SIZE: "MIN_BOTTOM_RENDITION_SIZE";
  readonly MIN_TOP_RENDITION_SIZE: "MIN_TOP_RENDITION_SIZE";
};
export type RuleType = (typeof RuleType)[keyof typeof RuleType];
export interface AutomatedAbrRule {
  AllowedRenditions?: AllowedRenditionSize[];
  ForceIncludeRenditions?: ForceIncludeRenditionSize[];
  MinBottomRenditionSize?: MinBottomRenditionSize;
  MinTopRenditionSize?: MinTopRenditionSize;
  Type?: RuleType;
}
export declare const BurninSubtitleAlignment: {
  readonly AUTO: "AUTO";
  readonly CENTERED: "CENTERED";
  readonly LEFT: "LEFT";
};
export type BurninSubtitleAlignment =
  (typeof BurninSubtitleAlignment)[keyof typeof BurninSubtitleAlignment];
export declare const BurninSubtitleApplyFontColor: {
  readonly ALL_TEXT: "ALL_TEXT";
  readonly WHITE_TEXT_ONLY: "WHITE_TEXT_ONLY";
};
export type BurninSubtitleApplyFontColor =
  (typeof BurninSubtitleApplyFontColor)[keyof typeof BurninSubtitleApplyFontColor];
export declare const BurninSubtitleBackgroundColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly NONE: "NONE";
  readonly WHITE: "WHITE";
};
export type BurninSubtitleBackgroundColor =
  (typeof BurninSubtitleBackgroundColor)[keyof typeof BurninSubtitleBackgroundColor];
export declare const BurninSubtitleFallbackFont: {
  readonly BEST_MATCH: "BEST_MATCH";
  readonly MONOSPACED_SANSSERIF: "MONOSPACED_SANSSERIF";
  readonly MONOSPACED_SERIF: "MONOSPACED_SERIF";
  readonly PROPORTIONAL_SANSSERIF: "PROPORTIONAL_SANSSERIF";
  readonly PROPORTIONAL_SERIF: "PROPORTIONAL_SERIF";
};
export type BurninSubtitleFallbackFont =
  (typeof BurninSubtitleFallbackFont)[keyof typeof BurninSubtitleFallbackFont];
export declare const BurninSubtitleFontColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly BLUE: "BLUE";
  readonly GREEN: "GREEN";
  readonly HEX: "HEX";
  readonly RED: "RED";
  readonly WHITE: "WHITE";
  readonly YELLOW: "YELLOW";
};
export type BurninSubtitleFontColor =
  (typeof BurninSubtitleFontColor)[keyof typeof BurninSubtitleFontColor];
export declare const FontScript: {
  readonly AUTOMATIC: "AUTOMATIC";
  readonly HANS: "HANS";
  readonly HANT: "HANT";
};
export type FontScript = (typeof FontScript)[keyof typeof FontScript];
export declare const BurninSubtitleOutlineColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly BLUE: "BLUE";
  readonly GREEN: "GREEN";
  readonly RED: "RED";
  readonly WHITE: "WHITE";
  readonly YELLOW: "YELLOW";
};
export type BurninSubtitleOutlineColor =
  (typeof BurninSubtitleOutlineColor)[keyof typeof BurninSubtitleOutlineColor];
export declare const BurninSubtitleShadowColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly NONE: "NONE";
  readonly WHITE: "WHITE";
};
export type BurninSubtitleShadowColor =
  (typeof BurninSubtitleShadowColor)[keyof typeof BurninSubtitleShadowColor];
export declare const BurnInSubtitleStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type BurnInSubtitleStylePassthrough =
  (typeof BurnInSubtitleStylePassthrough)[keyof typeof BurnInSubtitleStylePassthrough];
export declare const BurninSubtitleTeletextSpacing: {
  readonly AUTO: "AUTO";
  readonly FIXED_GRID: "FIXED_GRID";
  readonly PROPORTIONAL: "PROPORTIONAL";
};
export type BurninSubtitleTeletextSpacing =
  (typeof BurninSubtitleTeletextSpacing)[keyof typeof BurninSubtitleTeletextSpacing];
export interface BurninDestinationSettings {
  Alignment?: BurninSubtitleAlignment;
  ApplyFontColor?: BurninSubtitleApplyFontColor;
  BackgroundColor?: BurninSubtitleBackgroundColor;
  BackgroundOpacity?: number;
  FallbackFont?: BurninSubtitleFallbackFont;
  FontColor?: BurninSubtitleFontColor;
  FontFileBold?: string;
  FontFileBoldItalic?: string;
  FontFileItalic?: string;
  FontFileRegular?: string;
  FontOpacity?: number;
  FontResolution?: number;
  FontScript?: FontScript;
  FontSize?: number;
  HexFontColor?: string;
  OutlineColor?: BurninSubtitleOutlineColor;
  OutlineSize?: number;
  ShadowColor?: BurninSubtitleShadowColor;
  ShadowOpacity?: number;
  ShadowXOffset?: number;
  ShadowYOffset?: number;
  StylePassthrough?: BurnInSubtitleStylePassthrough;
  TeletextSpacing?: BurninSubtitleTeletextSpacing;
  XPosition?: number;
  YPosition?: number;
}
export declare const CaptionDestinationType: {
  readonly BURN_IN: "BURN_IN";
  readonly DVB_SUB: "DVB_SUB";
  readonly EMBEDDED: "EMBEDDED";
  readonly EMBEDDED_PLUS_SCTE20: "EMBEDDED_PLUS_SCTE20";
  readonly IMSC: "IMSC";
  readonly SCC: "SCC";
  readonly SCTE20_PLUS_EMBEDDED: "SCTE20_PLUS_EMBEDDED";
  readonly SMI: "SMI";
  readonly SRT: "SRT";
  readonly TELETEXT: "TELETEXT";
  readonly TTML: "TTML";
  readonly WEBVTT: "WEBVTT";
};
export type CaptionDestinationType =
  (typeof CaptionDestinationType)[keyof typeof CaptionDestinationType];
export declare const DvbSubtitleAlignment: {
  readonly AUTO: "AUTO";
  readonly CENTERED: "CENTERED";
  readonly LEFT: "LEFT";
};
export type DvbSubtitleAlignment =
  (typeof DvbSubtitleAlignment)[keyof typeof DvbSubtitleAlignment];
export declare const DvbSubtitleApplyFontColor: {
  readonly ALL_TEXT: "ALL_TEXT";
  readonly WHITE_TEXT_ONLY: "WHITE_TEXT_ONLY";
};
export type DvbSubtitleApplyFontColor =
  (typeof DvbSubtitleApplyFontColor)[keyof typeof DvbSubtitleApplyFontColor];
export declare const DvbSubtitleBackgroundColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly NONE: "NONE";
  readonly WHITE: "WHITE";
};
export type DvbSubtitleBackgroundColor =
  (typeof DvbSubtitleBackgroundColor)[keyof typeof DvbSubtitleBackgroundColor];
export declare const DvbddsHandling: {
  readonly NONE: "NONE";
  readonly NO_DISPLAY_WINDOW: "NO_DISPLAY_WINDOW";
  readonly SPECIFIED: "SPECIFIED";
};
export type DvbddsHandling =
  (typeof DvbddsHandling)[keyof typeof DvbddsHandling];
export declare const DvbSubSubtitleFallbackFont: {
  readonly BEST_MATCH: "BEST_MATCH";
  readonly MONOSPACED_SANSSERIF: "MONOSPACED_SANSSERIF";
  readonly MONOSPACED_SERIF: "MONOSPACED_SERIF";
  readonly PROPORTIONAL_SANSSERIF: "PROPORTIONAL_SANSSERIF";
  readonly PROPORTIONAL_SERIF: "PROPORTIONAL_SERIF";
};
export type DvbSubSubtitleFallbackFont =
  (typeof DvbSubSubtitleFallbackFont)[keyof typeof DvbSubSubtitleFallbackFont];
export declare const DvbSubtitleFontColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly BLUE: "BLUE";
  readonly GREEN: "GREEN";
  readonly HEX: "HEX";
  readonly RED: "RED";
  readonly WHITE: "WHITE";
  readonly YELLOW: "YELLOW";
};
export type DvbSubtitleFontColor =
  (typeof DvbSubtitleFontColor)[keyof typeof DvbSubtitleFontColor];
export declare const DvbSubtitleOutlineColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly BLUE: "BLUE";
  readonly GREEN: "GREEN";
  readonly RED: "RED";
  readonly WHITE: "WHITE";
  readonly YELLOW: "YELLOW";
};
export type DvbSubtitleOutlineColor =
  (typeof DvbSubtitleOutlineColor)[keyof typeof DvbSubtitleOutlineColor];
export declare const DvbSubtitleShadowColor: {
  readonly AUTO: "AUTO";
  readonly BLACK: "BLACK";
  readonly NONE: "NONE";
  readonly WHITE: "WHITE";
};
export type DvbSubtitleShadowColor =
  (typeof DvbSubtitleShadowColor)[keyof typeof DvbSubtitleShadowColor];
export declare const DvbSubtitleStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type DvbSubtitleStylePassthrough =
  (typeof DvbSubtitleStylePassthrough)[keyof typeof DvbSubtitleStylePassthrough];
export declare const DvbSubtitlingType: {
  readonly HEARING_IMPAIRED: "HEARING_IMPAIRED";
  readonly STANDARD: "STANDARD";
};
export type DvbSubtitlingType =
  (typeof DvbSubtitlingType)[keyof typeof DvbSubtitlingType];
export declare const DvbSubtitleTeletextSpacing: {
  readonly AUTO: "AUTO";
  readonly FIXED_GRID: "FIXED_GRID";
  readonly PROPORTIONAL: "PROPORTIONAL";
};
export type DvbSubtitleTeletextSpacing =
  (typeof DvbSubtitleTeletextSpacing)[keyof typeof DvbSubtitleTeletextSpacing];
export interface DvbSubDestinationSettings {
  Alignment?: DvbSubtitleAlignment;
  ApplyFontColor?: DvbSubtitleApplyFontColor;
  BackgroundColor?: DvbSubtitleBackgroundColor;
  BackgroundOpacity?: number;
  DdsHandling?: DvbddsHandling;
  DdsXCoordinate?: number;
  DdsYCoordinate?: number;
  FallbackFont?: DvbSubSubtitleFallbackFont;
  FontColor?: DvbSubtitleFontColor;
  FontFileBold?: string;
  FontFileBoldItalic?: string;
  FontFileItalic?: string;
  FontFileRegular?: string;
  FontOpacity?: number;
  FontResolution?: number;
  FontScript?: FontScript;
  FontSize?: number;
  Height?: number;
  HexFontColor?: string;
  OutlineColor?: DvbSubtitleOutlineColor;
  OutlineSize?: number;
  ShadowColor?: DvbSubtitleShadowColor;
  ShadowOpacity?: number;
  ShadowXOffset?: number;
  ShadowYOffset?: number;
  StylePassthrough?: DvbSubtitleStylePassthrough;
  SubtitlingType?: DvbSubtitlingType;
  TeletextSpacing?: DvbSubtitleTeletextSpacing;
  Width?: number;
  XPosition?: number;
  YPosition?: number;
}
export interface EmbeddedDestinationSettings {
  Destination608ChannelNumber?: number;
  Destination708ServiceNumber?: number;
}
export declare const ImscAccessibilitySubs: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ImscAccessibilitySubs =
  (typeof ImscAccessibilitySubs)[keyof typeof ImscAccessibilitySubs];
export declare const ImscStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type ImscStylePassthrough =
  (typeof ImscStylePassthrough)[keyof typeof ImscStylePassthrough];
export interface ImscDestinationSettings {
  Accessibility?: ImscAccessibilitySubs;
  StylePassthrough?: ImscStylePassthrough;
}
export declare const SccDestinationFramerate: {
  readonly FRAMERATE_23_97: "FRAMERATE_23_97";
  readonly FRAMERATE_24: "FRAMERATE_24";
  readonly FRAMERATE_25: "FRAMERATE_25";
  readonly FRAMERATE_29_97_DROPFRAME: "FRAMERATE_29_97_DROPFRAME";
  readonly FRAMERATE_29_97_NON_DROPFRAME: "FRAMERATE_29_97_NON_DROPFRAME";
};
export type SccDestinationFramerate =
  (typeof SccDestinationFramerate)[keyof typeof SccDestinationFramerate];
export interface SccDestinationSettings {
  Framerate?: SccDestinationFramerate;
}
export declare const SrtStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type SrtStylePassthrough =
  (typeof SrtStylePassthrough)[keyof typeof SrtStylePassthrough];
export interface SrtDestinationSettings {
  StylePassthrough?: SrtStylePassthrough;
}
export declare const TeletextPageType: {
  readonly PAGE_TYPE_ADDL_INFO: "PAGE_TYPE_ADDL_INFO";
  readonly PAGE_TYPE_HEARING_IMPAIRED_SUBTITLE: "PAGE_TYPE_HEARING_IMPAIRED_SUBTITLE";
  readonly PAGE_TYPE_INITIAL: "PAGE_TYPE_INITIAL";
  readonly PAGE_TYPE_PROGRAM_SCHEDULE: "PAGE_TYPE_PROGRAM_SCHEDULE";
  readonly PAGE_TYPE_SUBTITLE: "PAGE_TYPE_SUBTITLE";
};
export type TeletextPageType =
  (typeof TeletextPageType)[keyof typeof TeletextPageType];
export interface TeletextDestinationSettings {
  PageNumber?: string;
  PageTypes?: TeletextPageType[];
}
export declare const TtmlStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type TtmlStylePassthrough =
  (typeof TtmlStylePassthrough)[keyof typeof TtmlStylePassthrough];
export interface TtmlDestinationSettings {
  StylePassthrough?: TtmlStylePassthrough;
}
export declare const WebvttAccessibilitySubs: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type WebvttAccessibilitySubs =
  (typeof WebvttAccessibilitySubs)[keyof typeof WebvttAccessibilitySubs];
export declare const WebvttStylePassthrough: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly STRICT: "STRICT";
};
export type WebvttStylePassthrough =
  (typeof WebvttStylePassthrough)[keyof typeof WebvttStylePassthrough];
export interface WebvttDestinationSettings {
  Accessibility?: WebvttAccessibilitySubs;
  StylePassthrough?: WebvttStylePassthrough;
}
export interface CaptionDestinationSettings {
  BurninDestinationSettings?: BurninDestinationSettings;
  DestinationType?: CaptionDestinationType;
  DvbSubDestinationSettings?: DvbSubDestinationSettings;
  EmbeddedDestinationSettings?: EmbeddedDestinationSettings;
  ImscDestinationSettings?: ImscDestinationSettings;
  SccDestinationSettings?: SccDestinationSettings;
  SrtDestinationSettings?: SrtDestinationSettings;
  TeletextDestinationSettings?: TeletextDestinationSettings;
  TtmlDestinationSettings?: TtmlDestinationSettings;
  WebvttDestinationSettings?: WebvttDestinationSettings;
}
export interface CaptionDescription {
  CaptionSelectorName?: string;
  CustomLanguageCode?: string;
  DestinationSettings?: CaptionDestinationSettings;
  LanguageCode?: LanguageCode;
  LanguageDescription?: string;
}
export interface CaptionDescriptionPreset {
  CustomLanguageCode?: string;
  DestinationSettings?: CaptionDestinationSettings;
  LanguageCode?: LanguageCode;
  LanguageDescription?: string;
}
export interface CmafAdditionalManifest {
  ManifestNameModifier?: string;
  SelectedOutputs?: string[];
}
export declare const ColorSpace: {
  readonly FOLLOW: "FOLLOW";
  readonly HDR10: "HDR10";
  readonly HLG_2020: "HLG_2020";
  readonly P3D65_HDR: "P3D65_HDR";
  readonly P3D65_SDR: "P3D65_SDR";
  readonly P3DCI: "P3DCI";
  readonly REC_601: "REC_601";
  readonly REC_709: "REC_709";
};
export type ColorSpace = (typeof ColorSpace)[keyof typeof ColorSpace];
export interface ColorConversion3DLUTSetting {
  FileInput?: string;
  InputColorSpace?: ColorSpace;
  InputMasteringLuminance?: number;
  OutputColorSpace?: ColorSpace;
  OutputMasteringLuminance?: number;
}
export interface DashAdditionalManifest {
  ManifestNameModifier?: string;
  SelectedOutputs?: string[];
}
export interface Endpoint {
  Url?: string;
}
export interface HlsAdditionalManifest {
  ManifestNameModifier?: string;
  SelectedOutputs?: string[];
}
export declare const HlsAdMarkers: {
  readonly ELEMENTAL: "ELEMENTAL";
  readonly ELEMENTAL_SCTE35: "ELEMENTAL_SCTE35";
};
export type HlsAdMarkers = (typeof HlsAdMarkers)[keyof typeof HlsAdMarkers];
export interface HlsCaptionLanguageMapping {
  CaptionChannel?: number;
  CustomLanguageCode?: string;
  LanguageCode?: LanguageCode;
  LanguageDescription?: string;
}
export interface HopDestination {
  Priority?: number;
  Queue?: string;
  WaitMinutes?: number;
}
export interface Id3Insertion {
  Id3?: string;
  Timecode?: string;
}
export declare const AdvancedInputFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type AdvancedInputFilter =
  (typeof AdvancedInputFilter)[keyof typeof AdvancedInputFilter];
export declare const AdvancedInputFilterAddTexture: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type AdvancedInputFilterAddTexture =
  (typeof AdvancedInputFilterAddTexture)[keyof typeof AdvancedInputFilterAddTexture];
export declare const AdvancedInputFilterSharpen: {
  readonly HIGH: "HIGH";
  readonly LOW: "LOW";
  readonly OFF: "OFF";
};
export type AdvancedInputFilterSharpen =
  (typeof AdvancedInputFilterSharpen)[keyof typeof AdvancedInputFilterSharpen];
export interface AdvancedInputFilterSettings {
  AddTexture?: AdvancedInputFilterAddTexture;
  Sharpening?: AdvancedInputFilterSharpen;
}
export interface AudioSelectorGroup {
  AudioSelectorNames?: string[];
}
export declare const AudioDurationCorrection: {
  readonly AUTO: "AUTO";
  readonly DISABLED: "DISABLED";
  readonly FRAME: "FRAME";
  readonly TRACK: "TRACK";
};
export type AudioDurationCorrection =
  (typeof AudioDurationCorrection)[keyof typeof AudioDurationCorrection];
export declare const AudioDefaultSelection: {
  readonly DEFAULT: "DEFAULT";
  readonly NOT_DEFAULT: "NOT_DEFAULT";
};
export type AudioDefaultSelection =
  (typeof AudioDefaultSelection)[keyof typeof AudioDefaultSelection];
export interface HlsRenditionGroupSettings {
  RenditionGroupId?: string;
  RenditionLanguageCode?: LanguageCode;
  RenditionName?: string;
}
export declare const AudioSelectorType: {
  readonly HLS_RENDITION_GROUP: "HLS_RENDITION_GROUP";
  readonly LANGUAGE_CODE: "LANGUAGE_CODE";
  readonly PID: "PID";
  readonly TRACK: "TRACK";
};
export type AudioSelectorType =
  (typeof AudioSelectorType)[keyof typeof AudioSelectorType];
export interface AudioSelector {
  AudioDurationCorrection?: AudioDurationCorrection;
  CustomLanguageCode?: string;
  DefaultSelection?: AudioDefaultSelection;
  ExternalAudioFileInput?: string;
  HlsRenditionGroupSettings?: HlsRenditionGroupSettings;
  LanguageCode?: LanguageCode;
  Offset?: number;
  Pids?: number[];
  ProgramSelection?: number;
  RemixSettings?: RemixSettings;
  SelectorType?: AudioSelectorType;
  Tracks?: number[];
}
export declare const AncillaryConvert608To708: {
  readonly DISABLED: "DISABLED";
  readonly UPCONVERT: "UPCONVERT";
};
export type AncillaryConvert608To708 =
  (typeof AncillaryConvert608To708)[keyof typeof AncillaryConvert608To708];
export declare const AncillaryTerminateCaptions: {
  readonly DISABLED: "DISABLED";
  readonly END_OF_INPUT: "END_OF_INPUT";
};
export type AncillaryTerminateCaptions =
  (typeof AncillaryTerminateCaptions)[keyof typeof AncillaryTerminateCaptions];
export interface AncillarySourceSettings {
  Convert608To708?: AncillaryConvert608To708;
  SourceAncillaryChannelNumber?: number;
  TerminateCaptions?: AncillaryTerminateCaptions;
}
export interface DvbSubSourceSettings {
  Pid?: number;
}
export declare const EmbeddedConvert608To708: {
  readonly DISABLED: "DISABLED";
  readonly UPCONVERT: "UPCONVERT";
};
export type EmbeddedConvert608To708 =
  (typeof EmbeddedConvert608To708)[keyof typeof EmbeddedConvert608To708];
export declare const EmbeddedTerminateCaptions: {
  readonly DISABLED: "DISABLED";
  readonly END_OF_INPUT: "END_OF_INPUT";
};
export type EmbeddedTerminateCaptions =
  (typeof EmbeddedTerminateCaptions)[keyof typeof EmbeddedTerminateCaptions];
export interface EmbeddedSourceSettings {
  Convert608To708?: EmbeddedConvert608To708;
  Source608ChannelNumber?: number;
  Source608TrackNumber?: number;
  TerminateCaptions?: EmbeddedTerminateCaptions;
}
export declare const FileSourceConvert608To708: {
  readonly DISABLED: "DISABLED";
  readonly UPCONVERT: "UPCONVERT";
};
export type FileSourceConvert608To708 =
  (typeof FileSourceConvert608To708)[keyof typeof FileSourceConvert608To708];
export declare const CaptionSourceConvertPaintOnToPopOn: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CaptionSourceConvertPaintOnToPopOn =
  (typeof CaptionSourceConvertPaintOnToPopOn)[keyof typeof CaptionSourceConvertPaintOnToPopOn];
export interface CaptionSourceFramerate {
  FramerateDenominator?: number;
  FramerateNumerator?: number;
}
export declare const FileSourceTimeDeltaUnits: {
  readonly MILLISECONDS: "MILLISECONDS";
  readonly SECONDS: "SECONDS";
};
export type FileSourceTimeDeltaUnits =
  (typeof FileSourceTimeDeltaUnits)[keyof typeof FileSourceTimeDeltaUnits];
export interface FileSourceSettings {
  Convert608To708?: FileSourceConvert608To708;
  ConvertPaintToPop?: CaptionSourceConvertPaintOnToPopOn;
  Framerate?: CaptionSourceFramerate;
  SourceFile?: string;
  TimeDelta?: number;
  TimeDeltaUnits?: FileSourceTimeDeltaUnits;
}
export declare const CaptionSourceType: {
  readonly ANCILLARY: "ANCILLARY";
  readonly DVB_SUB: "DVB_SUB";
  readonly EMBEDDED: "EMBEDDED";
  readonly IMSC: "IMSC";
  readonly NULL_SOURCE: "NULL_SOURCE";
  readonly SCC: "SCC";
  readonly SCTE20: "SCTE20";
  readonly SMI: "SMI";
  readonly SMPTE_TT: "SMPTE_TT";
  readonly SRT: "SRT";
  readonly STL: "STL";
  readonly TELETEXT: "TELETEXT";
  readonly TTML: "TTML";
  readonly WEBVTT: "WEBVTT";
};
export type CaptionSourceType =
  (typeof CaptionSourceType)[keyof typeof CaptionSourceType];
export interface TeletextSourceSettings {
  PageNumber?: string;
}
export interface TrackSourceSettings {
  TrackNumber?: number;
}
export interface WebvttHlsSourceSettings {
  RenditionGroupId?: string;
  RenditionLanguageCode?: LanguageCode;
  RenditionName?: string;
}
export interface CaptionSourceSettings {
  AncillarySourceSettings?: AncillarySourceSettings;
  DvbSubSourceSettings?: DvbSubSourceSettings;
  EmbeddedSourceSettings?: EmbeddedSourceSettings;
  FileSourceSettings?: FileSourceSettings;
  SourceType?: CaptionSourceType;
  TeletextSourceSettings?: TeletextSourceSettings;
  TrackSourceSettings?: TrackSourceSettings;
  WebvttHlsSourceSettings?: WebvttHlsSourceSettings;
}
export interface CaptionSelector {
  CustomLanguageCode?: string;
  LanguageCode?: LanguageCode;
  SourceSettings?: CaptionSourceSettings;
}
export interface Rectangle {
  Height?: number;
  Width?: number;
  X?: number;
  Y?: number;
}
export declare const InputDeblockFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type InputDeblockFilter =
  (typeof InputDeblockFilter)[keyof typeof InputDeblockFilter];
export declare const DecryptionMode: {
  readonly AES_CBC: "AES_CBC";
  readonly AES_CTR: "AES_CTR";
  readonly AES_GCM: "AES_GCM";
};
export type DecryptionMode =
  (typeof DecryptionMode)[keyof typeof DecryptionMode];
export interface InputDecryptionSettings {
  DecryptionMode?: DecryptionMode;
  EncryptedDecryptionKey?: string;
  InitializationVector?: string;
  KmsKeyRegion?: string;
}
export declare const InputDenoiseFilter: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type InputDenoiseFilter =
  (typeof InputDenoiseFilter)[keyof typeof InputDenoiseFilter];
export declare const InputFilterEnable: {
  readonly AUTO: "AUTO";
  readonly DISABLE: "DISABLE";
  readonly FORCE: "FORCE";
};
export type InputFilterEnable =
  (typeof InputFilterEnable)[keyof typeof InputFilterEnable];
export interface InsertableImage {
  Duration?: number;
  FadeIn?: number;
  FadeOut?: number;
  Height?: number;
  ImageInserterInput?: string;
  ImageX?: number;
  ImageY?: number;
  Layer?: number;
  Opacity?: number;
  StartTime?: string;
  Width?: number;
}
export interface ImageInserter {
  InsertableImages?: InsertableImage[];
  SdrReferenceWhiteLevel?: number;
}
export interface InputClipping {
  EndTimecode?: string;
  StartTimecode?: string;
}
export declare const InputScanType: {
  readonly AUTO: "AUTO";
  readonly PSF: "PSF";
};
export type InputScanType = (typeof InputScanType)[keyof typeof InputScanType];
export declare const InputPsiControl: {
  readonly IGNORE_PSI: "IGNORE_PSI";
  readonly USE_PSI: "USE_PSI";
};
export type InputPsiControl =
  (typeof InputPsiControl)[keyof typeof InputPsiControl];
export declare const InputTimecodeSource: {
  readonly EMBEDDED: "EMBEDDED";
  readonly SPECIFIEDSTART: "SPECIFIEDSTART";
  readonly ZEROBASED: "ZEROBASED";
};
export type InputTimecodeSource =
  (typeof InputTimecodeSource)[keyof typeof InputTimecodeSource];
export interface InputVideoGenerator {
  Duration?: number;
}
export interface VideoOverlayInputClipping {
  EndTimecode?: string;
  StartTimecode?: string;
}
export interface VideoOverlayInput {
  FileInput?: string;
  InputClippings?: VideoOverlayInputClipping[];
  TimecodeSource?: InputTimecodeSource;
  TimecodeStart?: string;
}
export interface VideoOverlay {
  EndTimecode?: string;
  Input?: VideoOverlayInput;
  StartTimecode?: string;
}
export declare const AlphaBehavior: {
  readonly DISCARD: "DISCARD";
  readonly REMAP_TO_LUMA: "REMAP_TO_LUMA";
};
export type AlphaBehavior = (typeof AlphaBehavior)[keyof typeof AlphaBehavior];
export declare const ColorSpaceUsage: {
  readonly FALLBACK: "FALLBACK";
  readonly FORCE: "FORCE";
};
export type ColorSpaceUsage =
  (typeof ColorSpaceUsage)[keyof typeof ColorSpaceUsage];
export declare const EmbeddedTimecodeOverride: {
  readonly NONE: "NONE";
  readonly USE_MDPM: "USE_MDPM";
};
export type EmbeddedTimecodeOverride =
  (typeof EmbeddedTimecodeOverride)[keyof typeof EmbeddedTimecodeOverride];
export interface Hdr10Metadata {
  BluePrimaryX?: number;
  BluePrimaryY?: number;
  GreenPrimaryX?: number;
  GreenPrimaryY?: number;
  MaxContentLightLevel?: number;
  MaxFrameAverageLightLevel?: number;
  MaxLuminance?: number;
  MinLuminance?: number;
  RedPrimaryX?: number;
  RedPrimaryY?: number;
  WhitePointX?: number;
  WhitePointY?: number;
}
export declare const PadVideo: {
  readonly BLACK: "BLACK";
  readonly DISABLED: "DISABLED";
};
export type PadVideo = (typeof PadVideo)[keyof typeof PadVideo];
export declare const InputRotate: {
  readonly AUTO: "AUTO";
  readonly DEGREES_180: "DEGREES_180";
  readonly DEGREES_270: "DEGREES_270";
  readonly DEGREES_90: "DEGREES_90";
  readonly DEGREE_0: "DEGREE_0";
};
export type InputRotate = (typeof InputRotate)[keyof typeof InputRotate];
export declare const InputSampleRange: {
  readonly FOLLOW: "FOLLOW";
  readonly FULL_RANGE: "FULL_RANGE";
  readonly LIMITED_RANGE: "LIMITED_RANGE";
};
export type InputSampleRange =
  (typeof InputSampleRange)[keyof typeof InputSampleRange];
export interface VideoSelector {
  AlphaBehavior?: AlphaBehavior;
  ColorSpace?: ColorSpace;
  ColorSpaceUsage?: ColorSpaceUsage;
  EmbeddedTimecodeOverride?: EmbeddedTimecodeOverride;
  Hdr10Metadata?: Hdr10Metadata;
  MaxLuminance?: number;
  PadVideo?: PadVideo;
  Pid?: number;
  ProgramNumber?: number;
  Rotate?: InputRotate;
  SampleRange?: InputSampleRange;
}
export interface Input {
  AdvancedInputFilter?: AdvancedInputFilter;
  AdvancedInputFilterSettings?: AdvancedInputFilterSettings;
  AudioSelectorGroups?: Record<string, AudioSelectorGroup>;
  AudioSelectors?: Record<string, AudioSelector>;
  CaptionSelectors?: Record<string, CaptionSelector>;
  Crop?: Rectangle;
  DeblockFilter?: InputDeblockFilter;
  DecryptionSettings?: InputDecryptionSettings;
  DenoiseFilter?: InputDenoiseFilter;
  DolbyVisionMetadataXml?: string;
  FileInput?: string;
  FilterEnable?: InputFilterEnable;
  FilterStrength?: number;
  ImageInserter?: ImageInserter;
  InputClippings?: InputClipping[];
  InputScanType?: InputScanType;
  Position?: Rectangle;
  ProgramNumber?: number;
  PsiControl?: InputPsiControl;
  SupplementalImps?: string[];
  TimecodeSource?: InputTimecodeSource;
  TimecodeStart?: string;
  VideoGenerator?: InputVideoGenerator;
  VideoOverlays?: VideoOverlay[];
  VideoSelector?: VideoSelector;
}
export interface InputTemplate {
  AdvancedInputFilter?: AdvancedInputFilter;
  AdvancedInputFilterSettings?: AdvancedInputFilterSettings;
  AudioSelectorGroups?: Record<string, AudioSelectorGroup>;
  AudioSelectors?: Record<string, AudioSelector>;
  CaptionSelectors?: Record<string, CaptionSelector>;
  Crop?: Rectangle;
  DeblockFilter?: InputDeblockFilter;
  DenoiseFilter?: InputDenoiseFilter;
  DolbyVisionMetadataXml?: string;
  FilterEnable?: InputFilterEnable;
  FilterStrength?: number;
  ImageInserter?: ImageInserter;
  InputClippings?: InputClipping[];
  InputScanType?: InputScanType;
  Position?: Rectangle;
  ProgramNumber?: number;
  PsiControl?: InputPsiControl;
  TimecodeSource?: InputTimecodeSource;
  TimecodeStart?: string;
  VideoOverlays?: VideoOverlay[];
  VideoSelector?: VideoSelector;
}
export declare const AccelerationMode: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
  readonly PREFERRED: "PREFERRED";
};
export type AccelerationMode =
  (typeof AccelerationMode)[keyof typeof AccelerationMode];
export interface AccelerationSettings {
  Mode: AccelerationMode | undefined;
}
export declare const AccelerationStatus: {
  readonly ACCELERATED: "ACCELERATED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly NOT_ACCELERATED: "NOT_ACCELERATED";
  readonly NOT_APPLICABLE: "NOT_APPLICABLE";
};
export type AccelerationStatus =
  (typeof AccelerationStatus)[keyof typeof AccelerationStatus];
export declare const BillingTagsSource: {
  readonly JOB: "JOB";
  readonly JOB_TEMPLATE: "JOB_TEMPLATE";
  readonly PRESET: "PRESET";
  readonly QUEUE: "QUEUE";
};
export type BillingTagsSource =
  (typeof BillingTagsSource)[keyof typeof BillingTagsSource];
export declare const JobPhase: {
  readonly PROBING: "PROBING";
  readonly TRANSCODING: "TRANSCODING";
  readonly UPLOADING: "UPLOADING";
};
export type JobPhase = (typeof JobPhase)[keyof typeof JobPhase];
export interface JobMessages {
  Info?: string[];
  Warning?: string[];
}
export interface VideoDetail {
  HeightInPx?: number;
  WidthInPx?: number;
}
export interface OutputDetail {
  DurationInMs?: number;
  VideoDetails?: VideoDetail;
}
export interface OutputGroupDetail {
  OutputDetails?: OutputDetail[];
}
export interface QueueTransition {
  DestinationQueue?: string;
  SourceQueue?: string;
  Timestamp?: Date;
}
export interface AvailBlanking {
  AvailBlankingImage?: string;
}
export interface EsamManifestConfirmConditionNotification {
  MccXml?: string;
}
export interface EsamSignalProcessingNotification {
  SccXml?: string;
}
export interface EsamSettings {
  ManifestConfirmConditionNotification?: EsamManifestConfirmConditionNotification;
  ResponseSignalPreroll?: number;
  SignalProcessingNotification?: EsamSignalProcessingNotification;
}
export declare const CopyProtectionAction: {
  readonly PASSTHROUGH: "PASSTHROUGH";
  readonly STRIP: "STRIP";
};
export type CopyProtectionAction =
  (typeof CopyProtectionAction)[keyof typeof CopyProtectionAction];
export declare const VchipAction: {
  readonly PASSTHROUGH: "PASSTHROUGH";
  readonly STRIP: "STRIP";
};
export type VchipAction = (typeof VchipAction)[keyof typeof VchipAction];
export interface ExtendedDataServices {
  CopyProtectionAction?: CopyProtectionAction;
  VchipAction?: VchipAction;
}
export interface KantarWatermarkSettings {
  ChannelName?: string;
  ContentReference?: string;
  CredentialsSecretName?: string;
  FileOffset?: number;
  KantarLicenseId?: number;
  KantarServerUrl?: string;
  LogDestination?: string;
  Metadata3?: string;
  Metadata4?: string;
  Metadata5?: string;
  Metadata6?: string;
  Metadata7?: string;
  Metadata8?: string;
}
export interface MotionImageInsertionFramerate {
  FramerateDenominator?: number;
  FramerateNumerator?: number;
}
export declare const MotionImageInsertionMode: {
  readonly MOV: "MOV";
  readonly PNG: "PNG";
};
export type MotionImageInsertionMode =
  (typeof MotionImageInsertionMode)[keyof typeof MotionImageInsertionMode];
export interface MotionImageInsertionOffset {
  ImageX?: number;
  ImageY?: number;
}
export declare const MotionImagePlayback: {
  readonly ONCE: "ONCE";
  readonly REPEAT: "REPEAT";
};
export type MotionImagePlayback =
  (typeof MotionImagePlayback)[keyof typeof MotionImagePlayback];
export interface MotionImageInserter {
  Framerate?: MotionImageInsertionFramerate;
  Input?: string;
  InsertionMode?: MotionImageInsertionMode;
  Offset?: MotionImageInsertionOffset;
  Playback?: MotionImagePlayback;
  StartTime?: string;
}
export interface NielsenConfiguration {
  BreakoutCode?: number;
  DistributorId?: string;
}
export declare const NielsenActiveWatermarkProcessType: {
  readonly CBET: "CBET";
  readonly NAES2_AND_NW: "NAES2_AND_NW";
  readonly NAES2_AND_NW_AND_CBET: "NAES2_AND_NW_AND_CBET";
};
export type NielsenActiveWatermarkProcessType =
  (typeof NielsenActiveWatermarkProcessType)[keyof typeof NielsenActiveWatermarkProcessType];
export declare const NielsenSourceWatermarkStatusType: {
  readonly CLEAN: "CLEAN";
  readonly WATERMARKED: "WATERMARKED";
};
export type NielsenSourceWatermarkStatusType =
  (typeof NielsenSourceWatermarkStatusType)[keyof typeof NielsenSourceWatermarkStatusType];
export declare const NielsenUniqueTicPerAudioTrackType: {
  readonly RESERVE_UNIQUE_TICS_PER_TRACK: "RESERVE_UNIQUE_TICS_PER_TRACK";
  readonly SAME_TICS_PER_TRACK: "SAME_TICS_PER_TRACK";
};
export type NielsenUniqueTicPerAudioTrackType =
  (typeof NielsenUniqueTicPerAudioTrackType)[keyof typeof NielsenUniqueTicPerAudioTrackType];
export interface NielsenNonLinearWatermarkSettings {
  ActiveWatermarkProcess?: NielsenActiveWatermarkProcessType;
  AdiFilename?: string;
  AssetId?: string;
  AssetName?: string;
  CbetSourceId?: string;
  EpisodeId?: string;
  MetadataDestination?: string;
  SourceId?: number;
  SourceWatermarkStatus?: NielsenSourceWatermarkStatusType;
  TicServerUrl?: string;
  UniqueTicPerAudioTrack?: NielsenUniqueTicPerAudioTrackType;
}
export interface AutomatedAbrSettings {
  MaxAbrBitrate?: number;
  MaxRenditions?: number;
  MinAbrBitrate?: number;
  Rules?: AutomatedAbrRule[];
}
export interface AutomatedEncodingSettings {
  AbrSettings?: AutomatedAbrSettings;
}
export declare const CmafClientCache: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CmafClientCache =
  (typeof CmafClientCache)[keyof typeof CmafClientCache];
export declare const CmafCodecSpecification: {
  readonly RFC_4281: "RFC_4281";
  readonly RFC_6381: "RFC_6381";
};
export type CmafCodecSpecification =
  (typeof CmafCodecSpecification)[keyof typeof CmafCodecSpecification];
export declare const DashManifestStyle: {
  readonly BASIC: "BASIC";
  readonly COMPACT: "COMPACT";
  readonly DISTINCT: "DISTINCT";
};
export type DashManifestStyle =
  (typeof DashManifestStyle)[keyof typeof DashManifestStyle];
export declare const S3ObjectCannedAcl: {
  readonly AUTHENTICATED_READ: "AUTHENTICATED_READ";
  readonly BUCKET_OWNER_FULL_CONTROL: "BUCKET_OWNER_FULL_CONTROL";
  readonly BUCKET_OWNER_READ: "BUCKET_OWNER_READ";
  readonly PUBLIC_READ: "PUBLIC_READ";
};
export type S3ObjectCannedAcl =
  (typeof S3ObjectCannedAcl)[keyof typeof S3ObjectCannedAcl];
export interface S3DestinationAccessControl {
  CannedAcl?: S3ObjectCannedAcl;
}
export declare const S3ServerSideEncryptionType: {
  readonly SERVER_SIDE_ENCRYPTION_KMS: "SERVER_SIDE_ENCRYPTION_KMS";
  readonly SERVER_SIDE_ENCRYPTION_S3: "SERVER_SIDE_ENCRYPTION_S3";
};
export type S3ServerSideEncryptionType =
  (typeof S3ServerSideEncryptionType)[keyof typeof S3ServerSideEncryptionType];
export interface S3EncryptionSettings {
  EncryptionType?: S3ServerSideEncryptionType;
  KmsEncryptionContext?: string;
  KmsKeyArn?: string;
}
export declare const S3StorageClass: {
  readonly DEEP_ARCHIVE: "DEEP_ARCHIVE";
  readonly GLACIER: "GLACIER";
  readonly INTELLIGENT_TIERING: "INTELLIGENT_TIERING";
  readonly ONEZONE_IA: "ONEZONE_IA";
  readonly REDUCED_REDUNDANCY: "REDUCED_REDUNDANCY";
  readonly STANDARD: "STANDARD";
  readonly STANDARD_IA: "STANDARD_IA";
};
export type S3StorageClass =
  (typeof S3StorageClass)[keyof typeof S3StorageClass];
export interface S3DestinationSettings {
  AccessControl?: S3DestinationAccessControl;
  Encryption?: S3EncryptionSettings;
  StorageClass?: S3StorageClass;
}
export interface DestinationSettings {
  S3Settings?: S3DestinationSettings;
}
export declare const CmafEncryptionType: {
  readonly AES_CTR: "AES_CTR";
  readonly SAMPLE_AES: "SAMPLE_AES";
};
export type CmafEncryptionType =
  (typeof CmafEncryptionType)[keyof typeof CmafEncryptionType];
export declare const CmafInitializationVectorInManifest: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type CmafInitializationVectorInManifest =
  (typeof CmafInitializationVectorInManifest)[keyof typeof CmafInitializationVectorInManifest];
export interface SpekeKeyProviderCmaf {
  CertificateArn?: string;
  DashSignaledSystemIds?: string[];
  HlsSignaledSystemIds?: string[];
  ResourceId?: string;
  Url?: string;
}
export interface StaticKeyProvider {
  KeyFormat?: string;
  KeyFormatVersions?: string;
  StaticKeyValue?: string;
  Url?: string;
}
export declare const CmafKeyProviderType: {
  readonly SPEKE: "SPEKE";
  readonly STATIC_KEY: "STATIC_KEY";
};
export type CmafKeyProviderType =
  (typeof CmafKeyProviderType)[keyof typeof CmafKeyProviderType];
export interface CmafEncryptionSettings {
  ConstantInitializationVector?: string;
  EncryptionMethod?: CmafEncryptionType;
  InitializationVectorInManifest?: CmafInitializationVectorInManifest;
  SpekeKeyProvider?: SpekeKeyProviderCmaf;
  StaticKeyProvider?: StaticKeyProvider;
  Type?: CmafKeyProviderType;
}
export declare const CmafImageBasedTrickPlay: {
  readonly ADVANCED: "ADVANCED";
  readonly NONE: "NONE";
  readonly THUMBNAIL: "THUMBNAIL";
  readonly THUMBNAIL_AND_FULLFRAME: "THUMBNAIL_AND_FULLFRAME";
};
export type CmafImageBasedTrickPlay =
  (typeof CmafImageBasedTrickPlay)[keyof typeof CmafImageBasedTrickPlay];
export declare const CmafIntervalCadence: {
  readonly FOLLOW_CUSTOM: "FOLLOW_CUSTOM";
  readonly FOLLOW_IFRAME: "FOLLOW_IFRAME";
};
export type CmafIntervalCadence =
  (typeof CmafIntervalCadence)[keyof typeof CmafIntervalCadence];
export interface CmafImageBasedTrickPlaySettings {
  IntervalCadence?: CmafIntervalCadence;
  ThumbnailHeight?: number;
  ThumbnailInterval?: number;
  ThumbnailWidth?: number;
  TileHeight?: number;
  TileWidth?: number;
}
export declare const CmafManifestCompression: {
  readonly GZIP: "GZIP";
  readonly NONE: "NONE";
};
export type CmafManifestCompression =
  (typeof CmafManifestCompression)[keyof typeof CmafManifestCompression];
export declare const CmafManifestDurationFormat: {
  readonly FLOATING_POINT: "FLOATING_POINT";
  readonly INTEGER: "INTEGER";
};
export type CmafManifestDurationFormat =
  (typeof CmafManifestDurationFormat)[keyof typeof CmafManifestDurationFormat];
export declare const CmafMpdManifestBandwidthType: {
  readonly AVERAGE: "AVERAGE";
  readonly MAX: "MAX";
};
export type CmafMpdManifestBandwidthType =
  (typeof CmafMpdManifestBandwidthType)[keyof typeof CmafMpdManifestBandwidthType];
export declare const CmafMpdProfile: {
  readonly MAIN_PROFILE: "MAIN_PROFILE";
  readonly ON_DEMAND_PROFILE: "ON_DEMAND_PROFILE";
};
export type CmafMpdProfile =
  (typeof CmafMpdProfile)[keyof typeof CmafMpdProfile];
export declare const CmafPtsOffsetHandlingForBFrames: {
  readonly MATCH_INITIAL_PTS: "MATCH_INITIAL_PTS";
  readonly ZERO_BASED: "ZERO_BASED";
};
export type CmafPtsOffsetHandlingForBFrames =
  (typeof CmafPtsOffsetHandlingForBFrames)[keyof typeof CmafPtsOffsetHandlingForBFrames];
export declare const CmafSegmentControl: {
  readonly SEGMENTED_FILES: "SEGMENTED_FILES";
  readonly SINGLE_FILE: "SINGLE_FILE";
};
export type CmafSegmentControl =
  (typeof CmafSegmentControl)[keyof typeof CmafSegmentControl];
export declare const CmafSegmentLengthControl: {
  readonly EXACT: "EXACT";
  readonly GOP_MULTIPLE: "GOP_MULTIPLE";
};
export type CmafSegmentLengthControl =
  (typeof CmafSegmentLengthControl)[keyof typeof CmafSegmentLengthControl];
export declare const CmafStreamInfResolution: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type CmafStreamInfResolution =
  (typeof CmafStreamInfResolution)[keyof typeof CmafStreamInfResolution];
export declare const CmafTargetDurationCompatibilityMode: {
  readonly LEGACY: "LEGACY";
  readonly SPEC_COMPLIANT: "SPEC_COMPLIANT";
};
export type CmafTargetDurationCompatibilityMode =
  (typeof CmafTargetDurationCompatibilityMode)[keyof typeof CmafTargetDurationCompatibilityMode];
export declare const CmafVideoCompositionOffsets: {
  readonly SIGNED: "SIGNED";
  readonly UNSIGNED: "UNSIGNED";
};
export type CmafVideoCompositionOffsets =
  (typeof CmafVideoCompositionOffsets)[keyof typeof CmafVideoCompositionOffsets];
export declare const CmafWriteDASHManifest: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CmafWriteDASHManifest =
  (typeof CmafWriteDASHManifest)[keyof typeof CmafWriteDASHManifest];
export declare const CmafWriteHLSManifest: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CmafWriteHLSManifest =
  (typeof CmafWriteHLSManifest)[keyof typeof CmafWriteHLSManifest];
export declare const CmafWriteSegmentTimelineInRepresentation: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CmafWriteSegmentTimelineInRepresentation =
  (typeof CmafWriteSegmentTimelineInRepresentation)[keyof typeof CmafWriteSegmentTimelineInRepresentation];
export interface CmafGroupSettings {
  AdditionalManifests?: CmafAdditionalManifest[];
  BaseUrl?: string;
  ClientCache?: CmafClientCache;
  CodecSpecification?: CmafCodecSpecification;
  DashManifestStyle?: DashManifestStyle;
  Destination?: string;
  DestinationSettings?: DestinationSettings;
  Encryption?: CmafEncryptionSettings;
  FragmentLength?: number;
  ImageBasedTrickPlay?: CmafImageBasedTrickPlay;
  ImageBasedTrickPlaySettings?: CmafImageBasedTrickPlaySettings;
  ManifestCompression?: CmafManifestCompression;
  ManifestDurationFormat?: CmafManifestDurationFormat;
  MinBufferTime?: number;
  MinFinalSegmentLength?: number;
  MpdManifestBandwidthType?: CmafMpdManifestBandwidthType;
  MpdProfile?: CmafMpdProfile;
  PtsOffsetHandlingForBFrames?: CmafPtsOffsetHandlingForBFrames;
  SegmentControl?: CmafSegmentControl;
  SegmentLength?: number;
  SegmentLengthControl?: CmafSegmentLengthControl;
  StreamInfResolution?: CmafStreamInfResolution;
  TargetDurationCompatibilityMode?: CmafTargetDurationCompatibilityMode;
  VideoCompositionOffsets?: CmafVideoCompositionOffsets;
  WriteDashManifest?: CmafWriteDASHManifest;
  WriteHlsManifest?: CmafWriteHLSManifest;
  WriteSegmentTimelineInRepresentation?: CmafWriteSegmentTimelineInRepresentation;
}
export declare const DashIsoGroupAudioChannelConfigSchemeIdUri: {
  readonly DOLBY_CHANNEL_CONFIGURATION: "DOLBY_CHANNEL_CONFIGURATION";
  readonly MPEG_CHANNEL_CONFIGURATION: "MPEG_CHANNEL_CONFIGURATION";
};
export type DashIsoGroupAudioChannelConfigSchemeIdUri =
  (typeof DashIsoGroupAudioChannelConfigSchemeIdUri)[keyof typeof DashIsoGroupAudioChannelConfigSchemeIdUri];
export declare const DashIsoPlaybackDeviceCompatibility: {
  readonly CENC_V1: "CENC_V1";
  readonly UNENCRYPTED_SEI: "UNENCRYPTED_SEI";
};
export type DashIsoPlaybackDeviceCompatibility =
  (typeof DashIsoPlaybackDeviceCompatibility)[keyof typeof DashIsoPlaybackDeviceCompatibility];
export interface SpekeKeyProvider {
  CertificateArn?: string;
  ResourceId?: string;
  SystemIds?: string[];
  Url?: string;
}
export interface DashIsoEncryptionSettings {
  PlaybackDeviceCompatibility?: DashIsoPlaybackDeviceCompatibility;
  SpekeKeyProvider?: SpekeKeyProvider;
}
export declare const DashIsoHbbtvCompliance: {
  readonly HBBTV_1_5: "HBBTV_1_5";
  readonly NONE: "NONE";
};
export type DashIsoHbbtvCompliance =
  (typeof DashIsoHbbtvCompliance)[keyof typeof DashIsoHbbtvCompliance];
export declare const DashIsoImageBasedTrickPlay: {
  readonly ADVANCED: "ADVANCED";
  readonly NONE: "NONE";
  readonly THUMBNAIL: "THUMBNAIL";
  readonly THUMBNAIL_AND_FULLFRAME: "THUMBNAIL_AND_FULLFRAME";
};
export type DashIsoImageBasedTrickPlay =
  (typeof DashIsoImageBasedTrickPlay)[keyof typeof DashIsoImageBasedTrickPlay];
export declare const DashIsoIntervalCadence: {
  readonly FOLLOW_CUSTOM: "FOLLOW_CUSTOM";
  readonly FOLLOW_IFRAME: "FOLLOW_IFRAME";
};
export type DashIsoIntervalCadence =
  (typeof DashIsoIntervalCadence)[keyof typeof DashIsoIntervalCadence];
export interface DashIsoImageBasedTrickPlaySettings {
  IntervalCadence?: DashIsoIntervalCadence;
  ThumbnailHeight?: number;
  ThumbnailInterval?: number;
  ThumbnailWidth?: number;
  TileHeight?: number;
  TileWidth?: number;
}
export declare const DashIsoMpdManifestBandwidthType: {
  readonly AVERAGE: "AVERAGE";
  readonly MAX: "MAX";
};
export type DashIsoMpdManifestBandwidthType =
  (typeof DashIsoMpdManifestBandwidthType)[keyof typeof DashIsoMpdManifestBandwidthType];
export declare const DashIsoMpdProfile: {
  readonly MAIN_PROFILE: "MAIN_PROFILE";
  readonly ON_DEMAND_PROFILE: "ON_DEMAND_PROFILE";
};
export type DashIsoMpdProfile =
  (typeof DashIsoMpdProfile)[keyof typeof DashIsoMpdProfile];
export declare const DashIsoPtsOffsetHandlingForBFrames: {
  readonly MATCH_INITIAL_PTS: "MATCH_INITIAL_PTS";
  readonly ZERO_BASED: "ZERO_BASED";
};
export type DashIsoPtsOffsetHandlingForBFrames =
  (typeof DashIsoPtsOffsetHandlingForBFrames)[keyof typeof DashIsoPtsOffsetHandlingForBFrames];
export declare const DashIsoSegmentControl: {
  readonly SEGMENTED_FILES: "SEGMENTED_FILES";
  readonly SINGLE_FILE: "SINGLE_FILE";
};
export type DashIsoSegmentControl =
  (typeof DashIsoSegmentControl)[keyof typeof DashIsoSegmentControl];
export declare const DashIsoSegmentLengthControl: {
  readonly EXACT: "EXACT";
  readonly GOP_MULTIPLE: "GOP_MULTIPLE";
};
export type DashIsoSegmentLengthControl =
  (typeof DashIsoSegmentLengthControl)[keyof typeof DashIsoSegmentLengthControl];
export declare const DashIsoVideoCompositionOffsets: {
  readonly SIGNED: "SIGNED";
  readonly UNSIGNED: "UNSIGNED";
};
export type DashIsoVideoCompositionOffsets =
  (typeof DashIsoVideoCompositionOffsets)[keyof typeof DashIsoVideoCompositionOffsets];
export declare const DashIsoWriteSegmentTimelineInRepresentation: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type DashIsoWriteSegmentTimelineInRepresentation =
  (typeof DashIsoWriteSegmentTimelineInRepresentation)[keyof typeof DashIsoWriteSegmentTimelineInRepresentation];
export interface DashIsoGroupSettings {
  AdditionalManifests?: DashAdditionalManifest[];
  AudioChannelConfigSchemeIdUri?: DashIsoGroupAudioChannelConfigSchemeIdUri;
  BaseUrl?: string;
  DashManifestStyle?: DashManifestStyle;
  Destination?: string;
  DestinationSettings?: DestinationSettings;
  Encryption?: DashIsoEncryptionSettings;
  FragmentLength?: number;
  HbbtvCompliance?: DashIsoHbbtvCompliance;
  ImageBasedTrickPlay?: DashIsoImageBasedTrickPlay;
  ImageBasedTrickPlaySettings?: DashIsoImageBasedTrickPlaySettings;
  MinBufferTime?: number;
  MinFinalSegmentLength?: number;
  MpdManifestBandwidthType?: DashIsoMpdManifestBandwidthType;
  MpdProfile?: DashIsoMpdProfile;
  PtsOffsetHandlingForBFrames?: DashIsoPtsOffsetHandlingForBFrames;
  SegmentControl?: DashIsoSegmentControl;
  SegmentLength?: number;
  SegmentLengthControl?: DashIsoSegmentLengthControl;
  VideoCompositionOffsets?: DashIsoVideoCompositionOffsets;
  WriteSegmentTimelineInRepresentation?: DashIsoWriteSegmentTimelineInRepresentation;
}
export interface FileGroupSettings {
  Destination?: string;
  DestinationSettings?: DestinationSettings;
}
export declare const HlsAudioOnlyHeader: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsAudioOnlyHeader =
  (typeof HlsAudioOnlyHeader)[keyof typeof HlsAudioOnlyHeader];
export declare const HlsCaptionLanguageSetting: {
  readonly INSERT: "INSERT";
  readonly NONE: "NONE";
  readonly OMIT: "OMIT";
};
export type HlsCaptionLanguageSetting =
  (typeof HlsCaptionLanguageSetting)[keyof typeof HlsCaptionLanguageSetting];
export declare const HlsCaptionSegmentLengthControl: {
  readonly LARGE_SEGMENTS: "LARGE_SEGMENTS";
  readonly MATCH_VIDEO: "MATCH_VIDEO";
};
export type HlsCaptionSegmentLengthControl =
  (typeof HlsCaptionSegmentLengthControl)[keyof typeof HlsCaptionSegmentLengthControl];
export declare const HlsClientCache: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsClientCache =
  (typeof HlsClientCache)[keyof typeof HlsClientCache];
export declare const HlsCodecSpecification: {
  readonly RFC_4281: "RFC_4281";
  readonly RFC_6381: "RFC_6381";
};
export type HlsCodecSpecification =
  (typeof HlsCodecSpecification)[keyof typeof HlsCodecSpecification];
export declare const HlsDirectoryStructure: {
  readonly SINGLE_DIRECTORY: "SINGLE_DIRECTORY";
  readonly SUBDIRECTORY_PER_STREAM: "SUBDIRECTORY_PER_STREAM";
};
export type HlsDirectoryStructure =
  (typeof HlsDirectoryStructure)[keyof typeof HlsDirectoryStructure];
export declare const HlsEncryptionType: {
  readonly AES128: "AES128";
  readonly SAMPLE_AES: "SAMPLE_AES";
};
export type HlsEncryptionType =
  (typeof HlsEncryptionType)[keyof typeof HlsEncryptionType];
export declare const HlsInitializationVectorInManifest: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsInitializationVectorInManifest =
  (typeof HlsInitializationVectorInManifest)[keyof typeof HlsInitializationVectorInManifest];
export declare const HlsOfflineEncrypted: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsOfflineEncrypted =
  (typeof HlsOfflineEncrypted)[keyof typeof HlsOfflineEncrypted];
export declare const HlsKeyProviderType: {
  readonly SPEKE: "SPEKE";
  readonly STATIC_KEY: "STATIC_KEY";
};
export type HlsKeyProviderType =
  (typeof HlsKeyProviderType)[keyof typeof HlsKeyProviderType];
export interface HlsEncryptionSettings {
  ConstantInitializationVector?: string;
  EncryptionMethod?: HlsEncryptionType;
  InitializationVectorInManifest?: HlsInitializationVectorInManifest;
  OfflineEncrypted?: HlsOfflineEncrypted;
  SpekeKeyProvider?: SpekeKeyProvider;
  StaticKeyProvider?: StaticKeyProvider;
  Type?: HlsKeyProviderType;
}
export declare const HlsImageBasedTrickPlay: {
  readonly ADVANCED: "ADVANCED";
  readonly NONE: "NONE";
  readonly THUMBNAIL: "THUMBNAIL";
  readonly THUMBNAIL_AND_FULLFRAME: "THUMBNAIL_AND_FULLFRAME";
};
export type HlsImageBasedTrickPlay =
  (typeof HlsImageBasedTrickPlay)[keyof typeof HlsImageBasedTrickPlay];
export declare const HlsIntervalCadence: {
  readonly FOLLOW_CUSTOM: "FOLLOW_CUSTOM";
  readonly FOLLOW_IFRAME: "FOLLOW_IFRAME";
};
export type HlsIntervalCadence =
  (typeof HlsIntervalCadence)[keyof typeof HlsIntervalCadence];
export interface HlsImageBasedTrickPlaySettings {
  IntervalCadence?: HlsIntervalCadence;
  ThumbnailHeight?: number;
  ThumbnailInterval?: number;
  ThumbnailWidth?: number;
  TileHeight?: number;
  TileWidth?: number;
}
export declare const HlsManifestCompression: {
  readonly GZIP: "GZIP";
  readonly NONE: "NONE";
};
export type HlsManifestCompression =
  (typeof HlsManifestCompression)[keyof typeof HlsManifestCompression];
export declare const HlsManifestDurationFormat: {
  readonly FLOATING_POINT: "FLOATING_POINT";
  readonly INTEGER: "INTEGER";
};
export type HlsManifestDurationFormat =
  (typeof HlsManifestDurationFormat)[keyof typeof HlsManifestDurationFormat];
export declare const HlsOutputSelection: {
  readonly MANIFESTS_AND_SEGMENTS: "MANIFESTS_AND_SEGMENTS";
  readonly SEGMENTS_ONLY: "SEGMENTS_ONLY";
};
export type HlsOutputSelection =
  (typeof HlsOutputSelection)[keyof typeof HlsOutputSelection];
export declare const HlsProgramDateTime: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsProgramDateTime =
  (typeof HlsProgramDateTime)[keyof typeof HlsProgramDateTime];
export declare const HlsProgressiveWriteHlsManifest: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type HlsProgressiveWriteHlsManifest =
  (typeof HlsProgressiveWriteHlsManifest)[keyof typeof HlsProgressiveWriteHlsManifest];
export declare const HlsSegmentControl: {
  readonly SEGMENTED_FILES: "SEGMENTED_FILES";
  readonly SINGLE_FILE: "SINGLE_FILE";
};
export type HlsSegmentControl =
  (typeof HlsSegmentControl)[keyof typeof HlsSegmentControl];
export declare const HlsSegmentLengthControl: {
  readonly EXACT: "EXACT";
  readonly GOP_MULTIPLE: "GOP_MULTIPLE";
};
export type HlsSegmentLengthControl =
  (typeof HlsSegmentLengthControl)[keyof typeof HlsSegmentLengthControl];
export declare const HlsStreamInfResolution: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type HlsStreamInfResolution =
  (typeof HlsStreamInfResolution)[keyof typeof HlsStreamInfResolution];
export declare const HlsTargetDurationCompatibilityMode: {
  readonly LEGACY: "LEGACY";
  readonly SPEC_COMPLIANT: "SPEC_COMPLIANT";
};
export type HlsTargetDurationCompatibilityMode =
  (typeof HlsTargetDurationCompatibilityMode)[keyof typeof HlsTargetDurationCompatibilityMode];
export declare const HlsTimedMetadataId3Frame: {
  readonly NONE: "NONE";
  readonly PRIV: "PRIV";
  readonly TDRL: "TDRL";
};
export type HlsTimedMetadataId3Frame =
  (typeof HlsTimedMetadataId3Frame)[keyof typeof HlsTimedMetadataId3Frame];
export interface HlsGroupSettings {
  AdMarkers?: HlsAdMarkers[];
  AdditionalManifests?: HlsAdditionalManifest[];
  AudioOnlyHeader?: HlsAudioOnlyHeader;
  BaseUrl?: string;
  CaptionLanguageMappings?: HlsCaptionLanguageMapping[];
  CaptionLanguageSetting?: HlsCaptionLanguageSetting;
  CaptionSegmentLengthControl?: HlsCaptionSegmentLengthControl;
  ClientCache?: HlsClientCache;
  CodecSpecification?: HlsCodecSpecification;
  Destination?: string;
  DestinationSettings?: DestinationSettings;
  DirectoryStructure?: HlsDirectoryStructure;
  Encryption?: HlsEncryptionSettings;
  ImageBasedTrickPlay?: HlsImageBasedTrickPlay;
  ImageBasedTrickPlaySettings?: HlsImageBasedTrickPlaySettings;
  ManifestCompression?: HlsManifestCompression;
  ManifestDurationFormat?: HlsManifestDurationFormat;
  MinFinalSegmentLength?: number;
  MinSegmentLength?: number;
  OutputSelection?: HlsOutputSelection;
  ProgramDateTime?: HlsProgramDateTime;
  ProgramDateTimePeriod?: number;
  ProgressiveWriteHlsManifest?: HlsProgressiveWriteHlsManifest;
  SegmentControl?: HlsSegmentControl;
  SegmentLength?: number;
  SegmentLengthControl?: HlsSegmentLengthControl;
  SegmentsPerSubdirectory?: number;
  StreamInfResolution?: HlsStreamInfResolution;
  TargetDurationCompatibilityMode?: HlsTargetDurationCompatibilityMode;
  TimedMetadataId3Frame?: HlsTimedMetadataId3Frame;
  TimedMetadataId3Period?: number;
  TimestampDeltaMilliseconds?: number;
}
export interface MsSmoothAdditionalManifest {
  ManifestNameModifier?: string;
  SelectedOutputs?: string[];
}
export declare const MsSmoothAudioDeduplication: {
  readonly COMBINE_DUPLICATE_STREAMS: "COMBINE_DUPLICATE_STREAMS";
  readonly NONE: "NONE";
};
export type MsSmoothAudioDeduplication =
  (typeof MsSmoothAudioDeduplication)[keyof typeof MsSmoothAudioDeduplication];
export interface MsSmoothEncryptionSettings {
  SpekeKeyProvider?: SpekeKeyProvider;
}
export declare const MsSmoothFragmentLengthControl: {
  readonly EXACT: "EXACT";
  readonly GOP_MULTIPLE: "GOP_MULTIPLE";
};
export type MsSmoothFragmentLengthControl =
  (typeof MsSmoothFragmentLengthControl)[keyof typeof MsSmoothFragmentLengthControl];
export declare const MsSmoothManifestEncoding: {
  readonly UTF16: "UTF16";
  readonly UTF8: "UTF8";
};
export type MsSmoothManifestEncoding =
  (typeof MsSmoothManifestEncoding)[keyof typeof MsSmoothManifestEncoding];
export interface MsSmoothGroupSettings {
  AdditionalManifests?: MsSmoothAdditionalManifest[];
  AudioDeduplication?: MsSmoothAudioDeduplication;
  Destination?: string;
  DestinationSettings?: DestinationSettings;
  Encryption?: MsSmoothEncryptionSettings;
  FragmentLength?: number;
  FragmentLengthControl?: MsSmoothFragmentLengthControl;
  ManifestEncoding?: MsSmoothManifestEncoding;
}
export declare const OutputGroupType: {
  readonly CMAF_GROUP_SETTINGS: "CMAF_GROUP_SETTINGS";
  readonly DASH_ISO_GROUP_SETTINGS: "DASH_ISO_GROUP_SETTINGS";
  readonly FILE_GROUP_SETTINGS: "FILE_GROUP_SETTINGS";
  readonly HLS_GROUP_SETTINGS: "HLS_GROUP_SETTINGS";
  readonly MS_SMOOTH_GROUP_SETTINGS: "MS_SMOOTH_GROUP_SETTINGS";
};
export type OutputGroupType =
  (typeof OutputGroupType)[keyof typeof OutputGroupType];
export interface OutputGroupSettings {
  CmafGroupSettings?: CmafGroupSettings;
  DashIsoGroupSettings?: DashIsoGroupSettings;
  FileGroupSettings?: FileGroupSettings;
  HlsGroupSettings?: HlsGroupSettings;
  MsSmoothGroupSettings?: MsSmoothGroupSettings;
  Type?: OutputGroupType;
}
export declare const CmfcAudioDuration: {
  readonly DEFAULT_CODEC_DURATION: "DEFAULT_CODEC_DURATION";
  readonly MATCH_VIDEO_DURATION: "MATCH_VIDEO_DURATION";
};
export type CmfcAudioDuration =
  (typeof CmfcAudioDuration)[keyof typeof CmfcAudioDuration];
export declare const CmfcAudioTrackType: {
  readonly ALTERNATE_AUDIO_AUTO_SELECT: "ALTERNATE_AUDIO_AUTO_SELECT";
  readonly ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT: "ALTERNATE_AUDIO_AUTO_SELECT_DEFAULT";
  readonly ALTERNATE_AUDIO_NOT_AUTO_SELECT: "ALTERNATE_AUDIO_NOT_AUTO_SELECT";
  readonly AUDIO_ONLY_VARIANT_STREAM: "AUDIO_ONLY_VARIANT_STREAM";
};
export type CmfcAudioTrackType =
  (typeof CmfcAudioTrackType)[keyof typeof CmfcAudioTrackType];
export declare const CmfcDescriptiveVideoServiceFlag: {
  readonly DONT_FLAG: "DONT_FLAG";
  readonly FLAG: "FLAG";
};
export type CmfcDescriptiveVideoServiceFlag =
  (typeof CmfcDescriptiveVideoServiceFlag)[keyof typeof CmfcDescriptiveVideoServiceFlag];
export declare const CmfcIFrameOnlyManifest: {
  readonly EXCLUDE: "EXCLUDE";
  readonly INCLUDE: "INCLUDE";
};
export type CmfcIFrameOnlyManifest =
  (typeof CmfcIFrameOnlyManifest)[keyof typeof CmfcIFrameOnlyManifest];
export declare const CmfcKlvMetadata: {
  readonly NONE: "NONE";
  readonly PASSTHROUGH: "PASSTHROUGH";
};
export type CmfcKlvMetadata =
  (typeof CmfcKlvMetadata)[keyof typeof CmfcKlvMetadata];
export declare const CmfcManifestMetadataSignaling: {
  readonly DISABLED: "DISABLED";
  readonly ENABLED: "ENABLED";
};
export type CmfcManifestMetadataSignaling =
  (typeof CmfcManifestMetadataSignaling)[keyof typeof CmfcManifestMetadataSignaling];
export declare const CmfcScte35Esam: {
  readonly INSERT: "INSERT";
  readonly NONE: "NONE";
};
export type CmfcScte35Esam =
  (typeof CmfcScte35Esam)[keyof typeof CmfcScte35Esam];
