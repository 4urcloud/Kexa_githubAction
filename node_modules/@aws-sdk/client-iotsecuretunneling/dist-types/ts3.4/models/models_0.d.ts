import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { IoTSecureTunnelingServiceException as __BaseException } from "./IoTSecureTunnelingServiceException";
export declare const ClientMode: {
  readonly ALL: "ALL";
  readonly DESTINATION: "DESTINATION";
  readonly SOURCE: "SOURCE";
};
export type ClientMode = (typeof ClientMode)[keyof typeof ClientMode];
export interface CloseTunnelRequest {
  tunnelId: string | undefined;
  delete?: boolean;
}
export interface CloseTunnelResponse {}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare const ConnectionStatus: {
  readonly CONNECTED: "CONNECTED";
  readonly DISCONNECTED: "DISCONNECTED";
};
export type ConnectionStatus =
  (typeof ConnectionStatus)[keyof typeof ConnectionStatus];
export interface ConnectionState {
  status?: ConnectionStatus;
  lastUpdatedAt?: Date;
}
export interface DescribeTunnelRequest {
  tunnelId: string | undefined;
}
export interface DestinationConfig {
  thingName?: string;
  services: string[] | undefined;
}
export declare const TunnelStatus: {
  readonly CLOSED: "CLOSED";
  readonly OPEN: "OPEN";
};
export type TunnelStatus = (typeof TunnelStatus)[keyof typeof TunnelStatus];
export interface Tag {
  key: string | undefined;
  value: string | undefined;
}
export interface TimeoutConfig {
  maxLifetimeTimeoutMinutes?: number;
}
export interface Tunnel {
  tunnelId?: string;
  tunnelArn?: string;
  status?: TunnelStatus;
  sourceConnectionState?: ConnectionState;
  destinationConnectionState?: ConnectionState;
  description?: string;
  destinationConfig?: DestinationConfig;
  timeoutConfig?: TimeoutConfig;
  tags?: Tag[];
  createdAt?: Date;
  lastUpdatedAt?: Date;
}
export interface DescribeTunnelResponse {
  tunnel?: Tunnel;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Tag[];
}
export interface ListTunnelsRequest {
  thingName?: string;
  maxResults?: number;
  nextToken?: string;
}
export interface TunnelSummary {
  tunnelId?: string;
  tunnelArn?: string;
  status?: TunnelStatus;
  description?: string;
  createdAt?: Date;
  lastUpdatedAt?: Date;
}
export interface ListTunnelsResponse {
  tunnelSummaries?: TunnelSummary[];
  nextToken?: string;
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export interface OpenTunnelRequest {
  description?: string;
  tags?: Tag[];
  destinationConfig?: DestinationConfig;
  timeoutConfig?: TimeoutConfig;
}
export interface OpenTunnelResponse {
  tunnelId?: string;
  tunnelArn?: string;
  sourceAccessToken?: string;
  destinationAccessToken?: string;
}
export interface RotateTunnelAccessTokenRequest {
  tunnelId: string | undefined;
  clientMode: ClientMode | undefined;
  destinationConfig?: DestinationConfig;
}
export interface RotateTunnelAccessTokenResponse {
  tunnelArn?: string;
  sourceAccessToken?: string;
  destinationAccessToken?: string;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Tag[] | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export declare const OpenTunnelResponseFilterSensitiveLog: (
  obj: OpenTunnelResponse
) => any;
export declare const RotateTunnelAccessTokenResponseFilterSensitiveLog: (
  obj: RotateTunnelAccessTokenResponse
) => any;
