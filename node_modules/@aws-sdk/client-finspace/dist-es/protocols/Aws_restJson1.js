import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { FinspaceServiceException as __BaseException } from "../models/FinspaceServiceException";
import { AccessDeniedException, ConflictException, InternalServerException, InvalidRequestException, LimitExceededException, ResourceAlreadyExistsException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, ValidationException, } from "../models/models_0";
export const se_CreateEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/environment");
    let body;
    body = JSON.stringify(take(input, {
        dataBundles: (_) => _json(_),
        description: [],
        federationMode: [],
        federationParameters: (_) => _json(_),
        kmsKeyId: [],
        name: [],
        superuserParameters: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxChangesetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/changesets");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    let body;
    body = JSON.stringify(take(input, {
        changeRequests: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxClusterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/clusters");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        autoScalingConfiguration: (_) => se_AutoScalingConfiguration(_, context),
        availabilityZoneId: [],
        azMode: [],
        cacheStorageConfigurations: (_) => _json(_),
        capacityConfiguration: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        clusterDescription: [],
        clusterName: [],
        clusterType: [],
        code: (_) => _json(_),
        commandLineArguments: (_) => _json(_),
        databases: (_) => _json(_),
        executionRole: [],
        initializationScript: [],
        releaseLabel: [],
        savedownStorageConfiguration: (_) => _json(_),
        scalingGroupConfiguration: (_) => se_KxScalingGroupConfiguration(_, context),
        tags: (_) => _json(_),
        tickerplantLogConfiguration: (_) => _json(_),
        vpcConfiguration: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxDatabaseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/databases");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        databaseName: [],
        description: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxDataviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/dataviews");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    let body;
    body = JSON.stringify(take(input, {
        autoUpdate: [],
        availabilityZoneId: [],
        azMode: [],
        changesetId: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        dataviewName: [],
        description: [],
        segmentConfigurations: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments");
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        kmsKeyId: [],
        name: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxScalingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/scalingGroups");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        availabilityZoneId: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        hostType: [],
        scalingGroupName: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/users");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        iamRole: [],
        tags: (_) => _json(_),
        userName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateKxVolumeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/kxvolumes");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        availabilityZoneIds: (_) => _json(_),
        azMode: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        nas1Configuration: (_) => _json(_),
        tags: (_) => _json(_),
        volumeName: [],
        volumeType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environment/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteKxClusterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/clusters/{clusterName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("clusterName", () => input.clusterName, "{clusterName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxDatabaseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    const query = map({
        [_cT]: [, __expectNonNull(input[_cT], `clientToken`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxDataviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    b.p("dataviewName", () => input.dataviewName, "{dataviewName}", false);
    const query = map({
        [_cT]: [, __expectNonNull(input[_cT], `clientToken`)],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxScalingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/scalingGroups/{scalingGroupName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("scalingGroupName", () => input.scalingGroupName, "{scalingGroupName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/users/{userName}");
    b.p("userName", () => input.userName, "{userName}", false);
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteKxVolumeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/kxvolumes/{volumeName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("volumeName", () => input.volumeName, "{volumeName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environment/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxChangesetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/changesets/{changesetId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    b.p("changesetId", () => input.changesetId, "{changesetId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxClusterCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/clusters/{clusterName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("clusterName", () => input.clusterName, "{clusterName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxConnectionStringCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/connectionString");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_uA]: [, __expectNonNull(input[_uA], `userArn`)],
        [_cN]: [, __expectNonNull(input[_cN], `clusterName`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetKxDatabaseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxDataviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    b.p("dataviewName", () => input.dataviewName, "{dataviewName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxScalingGroupCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/scalingGroups/{scalingGroupName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("scalingGroupName", () => input.scalingGroupName, "{scalingGroupName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/users/{userName}");
    b.p("userName", () => input.userName, "{userName}", false);
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetKxVolumeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/kxvolumes/{volumeName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("volumeName", () => input.volumeName, "{volumeName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListEnvironmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environment");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxChangesetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/changesets");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxClusterNodesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/clusters/{clusterName}/nodes");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("clusterName", () => input.clusterName, "{clusterName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxClustersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/clusters");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_cTl]: [, input[_cTl]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxDatabasesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxDataviewsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/dataviews");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxEnvironmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxScalingGroupsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/scalingGroups");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxUsersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/users");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListKxVolumesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/kx/environments/{environmentId}/kxvolumes");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
        [_vT]: [, input[_vT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/environment/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        federationMode: [],
        federationParameters: (_) => _json(_),
        name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxClusterCodeConfigurationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/clusters/{clusterName}/configuration/code");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("clusterName", () => input.clusterName, "{clusterName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        code: (_) => _json(_),
        commandLineArguments: (_) => _json(_),
        deploymentConfiguration: (_) => _json(_),
        initializationScript: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxClusterDatabasesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/clusters/{clusterName}/configuration/databases");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("clusterName", () => input.clusterName, "{clusterName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        databases: (_) => _json(_),
        deploymentConfiguration: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxDatabaseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxDataviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/databases/{databaseName}/dataviews/{dataviewName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("databaseName", () => input.databaseName, "{databaseName}", false);
    b.p("dataviewName", () => input.dataviewName, "{dataviewName}", false);
    let body;
    body = JSON.stringify(take(input, {
        changesetId: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        segmentConfigurations: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        name: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxEnvironmentNetworkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/network");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        customDNSConfiguration: (_) => _json(_),
        transitGatewayConfiguration: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxUserCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/users/{userName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("userName", () => input.userName, "{userName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        iamRole: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateKxVolumeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/kx/environments/{environmentId}/kxvolumes/{volumeName}");
    b.p("environmentId", () => input.environmentId, "{environmentId}", false);
    b.p("volumeName", () => input.volumeName, "{volumeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        description: [],
        nas1Configuration: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const de_CreateEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environmentArn: __expectString,
        environmentId: __expectString,
        environmentUrl: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxChangesetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        changeRequests: _json,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        environmentId: __expectString,
        errorInfo: _json,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        autoScalingConfiguration: (_) => de_AutoScalingConfiguration(_, context),
        availabilityZoneId: __expectString,
        azMode: __expectString,
        cacheStorageConfigurations: _json,
        capacityConfiguration: _json,
        clusterDescription: __expectString,
        clusterName: __expectString,
        clusterType: __expectString,
        code: _json,
        commandLineArguments: _json,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databases: _json,
        environmentId: __expectString,
        executionRole: __expectString,
        initializationScript: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        releaseLabel: __expectString,
        savedownStorageConfiguration: _json,
        scalingGroupConfiguration: (_) => de_KxScalingGroupConfiguration(_, context),
        status: __expectString,
        statusReason: __expectString,
        tickerplantLogConfiguration: _json,
        volumes: _json,
        vpcConfiguration: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxDatabaseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseArn: __expectString,
        databaseName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxDataviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        autoUpdate: __expectBoolean,
        availabilityZoneId: __expectString,
        azMode: __expectString,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        dataviewName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        segmentConfigurations: _json,
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        creationTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        environmentArn: __expectString,
        environmentId: __expectString,
        kmsKeyId: __expectString,
        name: __expectString,
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxScalingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        environmentId: __expectString,
        hostType: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        scalingGroupName: __expectString,
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environmentId: __expectString,
        iamRole: __expectString,
        userArn: __expectString,
        userName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateKxVolumeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneIds: _json,
        azMode: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        environmentId: __expectString,
        nas1Configuration: _json,
        status: __expectString,
        statusReason: __expectString,
        volumeArn: __expectString,
        volumeName: __expectString,
        volumeType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxDatabaseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxDataviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxScalingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteKxVolumeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environment: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxChangesetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        activeFromTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        changeRequests: _json,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        environmentId: __expectString,
        errorInfo: _json,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxClusterCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        autoScalingConfiguration: (_) => de_AutoScalingConfiguration(_, context),
        availabilityZoneId: __expectString,
        azMode: __expectString,
        cacheStorageConfigurations: _json,
        capacityConfiguration: _json,
        clusterDescription: __expectString,
        clusterName: __expectString,
        clusterType: __expectString,
        code: _json,
        commandLineArguments: _json,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databases: _json,
        executionRole: __expectString,
        initializationScript: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        releaseLabel: __expectString,
        savedownStorageConfiguration: _json,
        scalingGroupConfiguration: (_) => de_KxScalingGroupConfiguration(_, context),
        status: __expectString,
        statusReason: __expectString,
        tickerplantLogConfiguration: _json,
        volumes: _json,
        vpcConfiguration: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxConnectionStringCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        signedConnectionString: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxDatabaseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseArn: __expectString,
        databaseName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastCompletedChangesetId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        numBytes: __expectLong,
        numChangesets: __expectInt32,
        numFiles: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxDataviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        activeVersions: (_) => de_KxDataviewActiveVersionList(_, context),
        autoUpdate: __expectBoolean,
        availabilityZoneId: __expectString,
        azMode: __expectString,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        dataviewName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        segmentConfigurations: _json,
        status: __expectString,
        statusReason: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneIds: _json,
        awsAccountId: __expectString,
        certificateAuthorityArn: __expectString,
        creationTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customDNSConfiguration: _json,
        dedicatedServiceAccountId: __expectString,
        description: __expectString,
        dnsStatus: __expectString,
        environmentArn: __expectString,
        environmentId: __expectString,
        errorMessage: __expectString,
        kmsKeyId: __expectString,
        name: __expectString,
        status: __expectString,
        tgwStatus: __expectString,
        transitGatewayConfiguration: _json,
        updateTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxScalingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneId: __expectString,
        clusters: _json,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        hostType: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        scalingGroupArn: __expectString,
        scalingGroupName: __expectString,
        status: __expectString,
        statusReason: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environmentId: __expectString,
        iamRole: __expectString,
        userArn: __expectString,
        userName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetKxVolumeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        attachedClusters: _json,
        availabilityZoneIds: _json,
        azMode: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        nas1Configuration: _json,
        status: __expectString,
        statusReason: __expectString,
        volumeArn: __expectString,
        volumeName: __expectString,
        volumeType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEnvironmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environments: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxChangesetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        kxChangesets: (_) => de_KxChangesets(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxClusterNodesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        nodes: (_) => de_KxNodeSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxClustersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        kxClusterSummaries: (_) => de_KxClusters(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxDatabasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        kxDatabases: (_) => de_KxDatabases(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxDataviewsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        kxDataviews: (_) => de_KxDataviews(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxEnvironmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environments: (_) => de_KxEnvironmentList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxScalingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        scalingGroups: (_) => de_KxScalingGroupList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxUsersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        users: (_) => de_KxUserList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListKxVolumesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        kxVolumeSummaries: (_) => de_KxVolumes(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environment: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxClusterCodeConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateKxClusterDatabasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateKxDatabaseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        databaseName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxDataviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        activeVersions: (_) => de_KxDataviewActiveVersionList(_, context),
        autoUpdate: __expectBoolean,
        availabilityZoneId: __expectString,
        azMode: __expectString,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        dataviewName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        segmentConfigurations: _json,
        status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneIds: _json,
        awsAccountId: __expectString,
        creationTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customDNSConfiguration: _json,
        dedicatedServiceAccountId: __expectString,
        description: __expectString,
        dnsStatus: __expectString,
        environmentArn: __expectString,
        environmentId: __expectString,
        errorMessage: __expectString,
        kmsKeyId: __expectString,
        name: __expectString,
        status: __expectString,
        tgwStatus: __expectString,
        transitGatewayConfiguration: _json,
        updateTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxEnvironmentNetworkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        availabilityZoneIds: _json,
        awsAccountId: __expectString,
        creationTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customDNSConfiguration: _json,
        dedicatedServiceAccountId: __expectString,
        description: __expectString,
        dnsStatus: __expectString,
        environmentArn: __expectString,
        environmentId: __expectString,
        errorMessage: __expectString,
        kmsKeyId: __expectString,
        name: __expectString,
        status: __expectString,
        tgwStatus: __expectString,
        transitGatewayConfiguration: _json,
        updateTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxUserCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        environmentId: __expectString,
        iamRole: __expectString,
        userArn: __expectString,
        userName: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateKxVolumeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        attachedClusters: _json,
        availabilityZoneIds: _json,
        azMode: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        nas1Configuration: _json,
        status: __expectString,
        statusReason: __expectString,
        volumeArn: __expectString,
        volumeName: __expectString,
        volumeType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.finspace#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.finspace#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.finspace#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.finspace#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.finspace#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.finspace#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.finspace#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.finspace#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.finspace#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.finspace#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        reason: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AutoScalingConfiguration = (input, context) => {
    return take(input, {
        autoScalingMetric: [],
        maxNodeCount: [],
        metricTarget: __serializeFloat,
        minNodeCount: [],
        scaleInCooldownSeconds: __serializeFloat,
        scaleOutCooldownSeconds: __serializeFloat,
    });
};
const se_KxScalingGroupConfiguration = (input, context) => {
    return take(input, {
        cpu: __serializeFloat,
        memoryLimit: [],
        memoryReservation: [],
        nodeCount: [],
        scalingGroupName: [],
    });
};
const de_AutoScalingConfiguration = (output, context) => {
    return take(output, {
        autoScalingMetric: __expectString,
        maxNodeCount: __expectInt32,
        metricTarget: __limitedParseDouble,
        minNodeCount: __expectInt32,
        scaleInCooldownSeconds: __limitedParseDouble,
        scaleOutCooldownSeconds: __limitedParseDouble,
    });
};
const de_KxChangesetListEntry = (output, context) => {
    return take(output, {
        activeFromTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
    });
};
const de_KxChangesets = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxChangesetListEntry(entry, context);
    });
    return retVal;
};
const de_KxCluster = (output, context) => {
    return take(output, {
        availabilityZoneId: __expectString,
        azMode: __expectString,
        clusterDescription: __expectString,
        clusterName: __expectString,
        clusterType: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        executionRole: __expectString,
        initializationScript: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        releaseLabel: __expectString,
        status: __expectString,
        statusReason: __expectString,
        volumes: _json,
    });
};
const de_KxClusters = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxCluster(entry, context);
    });
    return retVal;
};
const de_KxDatabaseListEntry = (output, context) => {
    return take(output, {
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_KxDatabases = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxDatabaseListEntry(entry, context);
    });
    return retVal;
};
const de_KxDataviewActiveVersion = (output, context) => {
    return take(output, {
        attachedClusters: _json,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        segmentConfigurations: _json,
        versionId: __expectString,
    });
};
const de_KxDataviewActiveVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxDataviewActiveVersion(entry, context);
    });
    return retVal;
};
const de_KxDataviewListEntry = (output, context) => {
    return take(output, {
        activeVersions: (_) => de_KxDataviewActiveVersionList(_, context),
        autoUpdate: __expectBoolean,
        availabilityZoneId: __expectString,
        azMode: __expectString,
        changesetId: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        databaseName: __expectString,
        dataviewName: __expectString,
        description: __expectString,
        environmentId: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        segmentConfigurations: _json,
        status: __expectString,
        statusReason: __expectString,
    });
};
const de_KxDataviews = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxDataviewListEntry(entry, context);
    });
    return retVal;
};
const de_KxEnvironment = (output, context) => {
    return take(output, {
        availabilityZoneIds: _json,
        awsAccountId: __expectString,
        certificateAuthorityArn: __expectString,
        creationTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customDNSConfiguration: _json,
        dedicatedServiceAccountId: __expectString,
        description: __expectString,
        dnsStatus: __expectString,
        environmentArn: __expectString,
        environmentId: __expectString,
        errorMessage: __expectString,
        kmsKeyId: __expectString,
        name: __expectString,
        status: __expectString,
        tgwStatus: __expectString,
        transitGatewayConfiguration: _json,
        updateTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_KxEnvironmentList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxEnvironment(entry, context);
    });
    return retVal;
};
const de_KxNode = (output, context) => {
    return take(output, {
        availabilityZoneId: __expectString,
        launchTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        nodeId: __expectString,
    });
};
const de_KxNodeSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxNode(entry, context);
    });
    return retVal;
};
const de_KxScalingGroup = (output, context) => {
    return take(output, {
        availabilityZoneId: __expectString,
        clusters: _json,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        hostType: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        scalingGroupName: __expectString,
        status: __expectString,
        statusReason: __expectString,
    });
};
const de_KxScalingGroupConfiguration = (output, context) => {
    return take(output, {
        cpu: __limitedParseDouble,
        memoryLimit: __expectInt32,
        memoryReservation: __expectInt32,
        nodeCount: __expectInt32,
        scalingGroupName: __expectString,
    });
};
const de_KxScalingGroupList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxScalingGroup(entry, context);
    });
    return retVal;
};
const de_KxUser = (output, context) => {
    return take(output, {
        createTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        iamRole: __expectString,
        updateTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        userArn: __expectString,
        userName: __expectString,
    });
};
const de_KxUserList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxUser(entry, context);
    });
    return retVal;
};
const de_KxVolume = (output, context) => {
    return take(output, {
        availabilityZoneIds: _json,
        azMode: __expectString,
        createdTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        lastModifiedTimestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: __expectString,
        statusReason: __expectString,
        volumeName: __expectString,
        volumeType: __expectString,
    });
};
const de_KxVolumes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_KxVolume(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _cN = "clusterName";
const _cT = "clientToken";
const _cTl = "clusterType";
const _mR = "maxResults";
const _nT = "nextToken";
const _tK = "tagKeys";
const _uA = "userArn";
const _vT = "volumeType";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
