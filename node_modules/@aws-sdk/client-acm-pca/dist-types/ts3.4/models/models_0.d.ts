import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ACMPCAServiceException as __BaseException } from "./ACMPCAServiceException";
export interface CustomAttribute {
  ObjectIdentifier: string | undefined;
  Value: string | undefined;
}
export interface ASN1Subject {
  Country?: string;
  Organization?: string;
  OrganizationalUnit?: string;
  DistinguishedNameQualifier?: string;
  State?: string;
  CommonName?: string;
  SerialNumber?: string;
  Locality?: string;
  Title?: string;
  Surname?: string;
  GivenName?: string;
  Initials?: string;
  Pseudonym?: string;
  GenerationQualifier?: string;
  CustomAttributes?: CustomAttribute[];
}
export interface EdiPartyName {
  PartyName: string | undefined;
  NameAssigner?: string;
}
export interface OtherName {
  TypeId: string | undefined;
  Value: string | undefined;
}
export interface GeneralName {
  OtherName?: OtherName;
  Rfc822Name?: string;
  DnsName?: string;
  DirectoryName?: ASN1Subject;
  EdiPartyName?: EdiPartyName;
  UniformResourceIdentifier?: string;
  IpAddress?: string;
  RegisteredId?: string;
}
export declare const AccessMethodType: {
  readonly CA_REPOSITORY: "CA_REPOSITORY";
  readonly RESOURCE_PKI_MANIFEST: "RESOURCE_PKI_MANIFEST";
  readonly RESOURCE_PKI_NOTIFY: "RESOURCE_PKI_NOTIFY";
};
export type AccessMethodType =
  (typeof AccessMethodType)[keyof typeof AccessMethodType];
export interface AccessMethod {
  CustomObjectIdentifier?: string;
  AccessMethodType?: AccessMethodType;
}
export interface AccessDescription {
  AccessMethod: AccessMethod | undefined;
  AccessLocation: GeneralName | undefined;
}
export interface KeyUsage {
  DigitalSignature?: boolean;
  NonRepudiation?: boolean;
  KeyEncipherment?: boolean;
  DataEncipherment?: boolean;
  KeyAgreement?: boolean;
  KeyCertSign?: boolean;
  CRLSign?: boolean;
  EncipherOnly?: boolean;
  DecipherOnly?: boolean;
}
export interface CsrExtensions {
  KeyUsage?: KeyUsage;
  SubjectInformationAccess?: AccessDescription[];
}
export declare const KeyAlgorithm: {
  readonly EC_prime256v1: "EC_prime256v1";
  readonly EC_secp384r1: "EC_secp384r1";
  readonly RSA_2048: "RSA_2048";
  readonly RSA_4096: "RSA_4096";
};
export type KeyAlgorithm = (typeof KeyAlgorithm)[keyof typeof KeyAlgorithm];
export declare const SigningAlgorithm: {
  readonly SHA256WITHECDSA: "SHA256WITHECDSA";
  readonly SHA256WITHRSA: "SHA256WITHRSA";
  readonly SHA384WITHECDSA: "SHA384WITHECDSA";
  readonly SHA384WITHRSA: "SHA384WITHRSA";
  readonly SHA512WITHECDSA: "SHA512WITHECDSA";
  readonly SHA512WITHRSA: "SHA512WITHRSA";
};
export type SigningAlgorithm =
  (typeof SigningAlgorithm)[keyof typeof SigningAlgorithm];
export interface CertificateAuthorityConfiguration {
  KeyAlgorithm: KeyAlgorithm | undefined;
  SigningAlgorithm: SigningAlgorithm | undefined;
  Subject: ASN1Subject | undefined;
  CsrExtensions?: CsrExtensions;
}
export declare const CertificateAuthorityType: {
  readonly ROOT: "ROOT";
  readonly SUBORDINATE: "SUBORDINATE";
};
export type CertificateAuthorityType =
  (typeof CertificateAuthorityType)[keyof typeof CertificateAuthorityType];
export declare const KeyStorageSecurityStandard: {
  readonly FIPS_140_2_LEVEL_2_OR_HIGHER: "FIPS_140_2_LEVEL_2_OR_HIGHER";
  readonly FIPS_140_2_LEVEL_3_OR_HIGHER: "FIPS_140_2_LEVEL_3_OR_HIGHER";
};
export type KeyStorageSecurityStandard =
  (typeof KeyStorageSecurityStandard)[keyof typeof KeyStorageSecurityStandard];
export interface CrlDistributionPointExtensionConfiguration {
  OmitExtension: boolean | undefined;
}
export declare const S3ObjectAcl: {
  readonly BUCKET_OWNER_FULL_CONTROL: "BUCKET_OWNER_FULL_CONTROL";
  readonly PUBLIC_READ: "PUBLIC_READ";
};
export type S3ObjectAcl = (typeof S3ObjectAcl)[keyof typeof S3ObjectAcl];
export interface CrlConfiguration {
  Enabled: boolean | undefined;
  ExpirationInDays?: number;
  CustomCname?: string;
  S3BucketName?: string;
  S3ObjectAcl?: S3ObjectAcl;
  CrlDistributionPointExtensionConfiguration?: CrlDistributionPointExtensionConfiguration;
}
export interface OcspConfiguration {
  Enabled: boolean | undefined;
  OcspCustomCname?: string;
}
export interface RevocationConfiguration {
  CrlConfiguration?: CrlConfiguration;
  OcspConfiguration?: OcspConfiguration;
}
export interface Tag {
  Key: string | undefined;
  Value?: string;
}
export declare const CertificateAuthorityUsageMode: {
  readonly GENERAL_PURPOSE: "GENERAL_PURPOSE";
  readonly SHORT_LIVED_CERTIFICATE: "SHORT_LIVED_CERTIFICATE";
};
export type CertificateAuthorityUsageMode =
  (typeof CertificateAuthorityUsageMode)[keyof typeof CertificateAuthorityUsageMode];
export interface CreateCertificateAuthorityRequest {
  CertificateAuthorityConfiguration:
    | CertificateAuthorityConfiguration
    | undefined;
  RevocationConfiguration?: RevocationConfiguration;
  CertificateAuthorityType: CertificateAuthorityType | undefined;
  IdempotencyToken?: string;
  KeyStorageSecurityStandard?: KeyStorageSecurityStandard;
  Tags?: Tag[];
  UsageMode?: CertificateAuthorityUsageMode;
}
export interface CreateCertificateAuthorityResponse {
  CertificateAuthorityArn?: string;
}
export declare class InvalidArgsException extends __BaseException {
  readonly name: "InvalidArgsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidArgsException, __BaseException>
  );
}
export declare class InvalidPolicyException extends __BaseException {
  readonly name: "InvalidPolicyException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidPolicyException, __BaseException>
  );
}
export declare class InvalidTagException extends __BaseException {
  readonly name: "InvalidTagException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidTagException, __BaseException>
  );
}
export declare class LimitExceededException extends __BaseException {
  readonly name: "LimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LimitExceededException, __BaseException>
  );
}
export declare const AuditReportResponseFormat: {
  readonly CSV: "CSV";
  readonly JSON: "JSON";
};
export type AuditReportResponseFormat =
  (typeof AuditReportResponseFormat)[keyof typeof AuditReportResponseFormat];
export interface CreateCertificateAuthorityAuditReportRequest {
  CertificateAuthorityArn: string | undefined;
  S3BucketName: string | undefined;
  AuditReportResponseFormat: AuditReportResponseFormat | undefined;
}
export interface CreateCertificateAuthorityAuditReportResponse {
  AuditReportId?: string;
  S3Key?: string;
}
export declare class InvalidArnException extends __BaseException {
  readonly name: "InvalidArnException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidArnException, __BaseException>
  );
}
export declare class InvalidStateException extends __BaseException {
  readonly name: "InvalidStateException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidStateException, __BaseException>
  );
}
export declare class RequestFailedException extends __BaseException {
  readonly name: "RequestFailedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RequestFailedException, __BaseException>
  );
}
export declare class RequestInProgressException extends __BaseException {
  readonly name: "RequestInProgressException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<RequestInProgressException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare const ActionType: {
  readonly GetCertificate: "GetCertificate";
  readonly IssueCertificate: "IssueCertificate";
  readonly ListPermissions: "ListPermissions";
};
export type ActionType = (typeof ActionType)[keyof typeof ActionType];
export interface CreatePermissionRequest {
  CertificateAuthorityArn: string | undefined;
  Principal: string | undefined;
  SourceAccount?: string;
  Actions: ActionType[] | undefined;
}
export declare class PermissionAlreadyExistsException extends __BaseException {
  readonly name: "PermissionAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      PermissionAlreadyExistsException,
      __BaseException
    >
  );
}
export declare class ConcurrentModificationException extends __BaseException {
  readonly name: "ConcurrentModificationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ConcurrentModificationException,
      __BaseException
    >
  );
}
export interface DeleteCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
  PermanentDeletionTimeInDays?: number;
}
export interface DeletePermissionRequest {
  CertificateAuthorityArn: string | undefined;
  Principal: string | undefined;
  SourceAccount?: string;
}
export interface DeletePolicyRequest {
  ResourceArn: string | undefined;
}
export declare class LockoutPreventedException extends __BaseException {
  readonly name: "LockoutPreventedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<LockoutPreventedException, __BaseException>
  );
}
export interface DescribeCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
}
export declare const FailureReason: {
  readonly OTHER: "OTHER";
  readonly REQUEST_TIMED_OUT: "REQUEST_TIMED_OUT";
  readonly UNSUPPORTED_ALGORITHM: "UNSUPPORTED_ALGORITHM";
};
export type FailureReason = (typeof FailureReason)[keyof typeof FailureReason];
export declare const CertificateAuthorityStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly CREATING: "CREATING";
  readonly DELETED: "DELETED";
  readonly DISABLED: "DISABLED";
  readonly EXPIRED: "EXPIRED";
  readonly FAILED: "FAILED";
  readonly PENDING_CERTIFICATE: "PENDING_CERTIFICATE";
};
export type CertificateAuthorityStatus =
  (typeof CertificateAuthorityStatus)[keyof typeof CertificateAuthorityStatus];
export interface CertificateAuthority {
  Arn?: string;
  OwnerAccount?: string;
  CreatedAt?: Date;
  LastStateChangeAt?: Date;
  Type?: CertificateAuthorityType;
  Serial?: string;
  Status?: CertificateAuthorityStatus;
  NotBefore?: Date;
  NotAfter?: Date;
  FailureReason?: FailureReason;
  CertificateAuthorityConfiguration?: CertificateAuthorityConfiguration;
  RevocationConfiguration?: RevocationConfiguration;
  RestorableUntil?: Date;
  KeyStorageSecurityStandard?: KeyStorageSecurityStandard;
  UsageMode?: CertificateAuthorityUsageMode;
}
export interface DescribeCertificateAuthorityResponse {
  CertificateAuthority?: CertificateAuthority;
}
export interface DescribeCertificateAuthorityAuditReportRequest {
  CertificateAuthorityArn: string | undefined;
  AuditReportId: string | undefined;
}
export declare const AuditReportStatus: {
  readonly CREATING: "CREATING";
  readonly FAILED: "FAILED";
  readonly SUCCESS: "SUCCESS";
};
export type AuditReportStatus =
  (typeof AuditReportStatus)[keyof typeof AuditReportStatus];
export interface DescribeCertificateAuthorityAuditReportResponse {
  AuditReportStatus?: AuditReportStatus;
  S3BucketName?: string;
  S3Key?: string;
  CreatedAt?: Date;
}
export interface GetCertificateRequest {
  CertificateAuthorityArn: string | undefined;
  CertificateArn: string | undefined;
}
export interface GetCertificateResponse {
  Certificate?: string;
  CertificateChain?: string;
}
export interface GetCertificateAuthorityCertificateRequest {
  CertificateAuthorityArn: string | undefined;
}
export interface GetCertificateAuthorityCertificateResponse {
  Certificate?: string;
  CertificateChain?: string;
}
export interface GetCertificateAuthorityCsrRequest {
  CertificateAuthorityArn: string | undefined;
}
export interface GetCertificateAuthorityCsrResponse {
  Csr?: string;
}
export interface GetPolicyRequest {
  ResourceArn: string | undefined;
}
export interface GetPolicyResponse {
  Policy?: string;
}
export declare class CertificateMismatchException extends __BaseException {
  readonly name: "CertificateMismatchException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<CertificateMismatchException, __BaseException>
  );
}
export interface ImportCertificateAuthorityCertificateRequest {
  CertificateAuthorityArn: string | undefined;
  Certificate: Uint8Array | undefined;
  CertificateChain?: Uint8Array;
}
export declare class InvalidRequestException extends __BaseException {
  readonly name: "InvalidRequestException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidRequestException, __BaseException>
  );
}
export declare class MalformedCertificateException extends __BaseException {
  readonly name: "MalformedCertificateException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<MalformedCertificateException, __BaseException>
  );
}
export declare const PolicyQualifierId: {
  readonly CPS: "CPS";
};
export type PolicyQualifierId =
  (typeof PolicyQualifierId)[keyof typeof PolicyQualifierId];
export interface Qualifier {
  CpsUri: string | undefined;
}
export interface PolicyQualifierInfo {
  PolicyQualifierId: PolicyQualifierId | undefined;
  Qualifier: Qualifier | undefined;
}
export interface PolicyInformation {
  CertPolicyId: string | undefined;
  PolicyQualifiers?: PolicyQualifierInfo[];
}
export interface CustomExtension {
  ObjectIdentifier: string | undefined;
  Value: string | undefined;
  Critical?: boolean;
}
export declare const ExtendedKeyUsageType: {
  readonly CERTIFICATE_TRANSPARENCY: "CERTIFICATE_TRANSPARENCY";
  readonly CLIENT_AUTH: "CLIENT_AUTH";
  readonly CODE_SIGNING: "CODE_SIGNING";
  readonly DOCUMENT_SIGNING: "DOCUMENT_SIGNING";
  readonly EMAIL_PROTECTION: "EMAIL_PROTECTION";
  readonly OCSP_SIGNING: "OCSP_SIGNING";
  readonly SERVER_AUTH: "SERVER_AUTH";
  readonly SMART_CARD_LOGIN: "SMART_CARD_LOGIN";
  readonly TIME_STAMPING: "TIME_STAMPING";
};
export type ExtendedKeyUsageType =
  (typeof ExtendedKeyUsageType)[keyof typeof ExtendedKeyUsageType];
export interface ExtendedKeyUsage {
  ExtendedKeyUsageType?: ExtendedKeyUsageType;
  ExtendedKeyUsageObjectIdentifier?: string;
}
export interface Extensions {
  CertificatePolicies?: PolicyInformation[];
  ExtendedKeyUsage?: ExtendedKeyUsage[];
  KeyUsage?: KeyUsage;
  SubjectAlternativeNames?: GeneralName[];
  CustomExtensions?: CustomExtension[];
}
export interface ApiPassthrough {
  Extensions?: Extensions;
  Subject?: ASN1Subject;
}
export declare const ValidityPeriodType: {
  readonly ABSOLUTE: "ABSOLUTE";
  readonly DAYS: "DAYS";
  readonly END_DATE: "END_DATE";
  readonly MONTHS: "MONTHS";
  readonly YEARS: "YEARS";
};
export type ValidityPeriodType =
  (typeof ValidityPeriodType)[keyof typeof ValidityPeriodType];
export interface Validity {
  Value: number | undefined;
  Type: ValidityPeriodType | undefined;
}
export interface IssueCertificateRequest {
  ApiPassthrough?: ApiPassthrough;
  CertificateAuthorityArn: string | undefined;
  Csr: Uint8Array | undefined;
  SigningAlgorithm: SigningAlgorithm | undefined;
  TemplateArn?: string;
  Validity: Validity | undefined;
  ValidityNotBefore?: Validity;
  IdempotencyToken?: string;
}
export interface IssueCertificateResponse {
  CertificateArn?: string;
}
export declare class MalformedCSRException extends __BaseException {
  readonly name: "MalformedCSRException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<MalformedCSRException, __BaseException>
  );
}
export declare class InvalidNextTokenException extends __BaseException {
  readonly name: "InvalidNextTokenException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidNextTokenException, __BaseException>
  );
}
export declare const ResourceOwner: {
  readonly OTHER_ACCOUNTS: "OTHER_ACCOUNTS";
  readonly SELF: "SELF";
};
export type ResourceOwner = (typeof ResourceOwner)[keyof typeof ResourceOwner];
export interface ListCertificateAuthoritiesRequest {
  NextToken?: string;
  MaxResults?: number;
  ResourceOwner?: ResourceOwner;
}
export interface ListCertificateAuthoritiesResponse {
  CertificateAuthorities?: CertificateAuthority[];
  NextToken?: string;
}
export interface ListPermissionsRequest {
  CertificateAuthorityArn: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface Permission {
  CertificateAuthorityArn?: string;
  CreatedAt?: Date;
  Principal?: string;
  SourceAccount?: string;
  Actions?: ActionType[];
  Policy?: string;
}
export interface ListPermissionsResponse {
  Permissions?: Permission[];
  NextToken?: string;
}
export interface ListTagsRequest {
  CertificateAuthorityArn: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface ListTagsResponse {
  Tags?: Tag[];
  NextToken?: string;
}
export interface PutPolicyRequest {
  ResourceArn: string | undefined;
  Policy: string | undefined;
}
export interface RestoreCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
}
export declare class RequestAlreadyProcessedException extends __BaseException {
  readonly name: "RequestAlreadyProcessedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      RequestAlreadyProcessedException,
      __BaseException
    >
  );
}
export declare const RevocationReason: {
  readonly AFFILIATION_CHANGED: "AFFILIATION_CHANGED";
  readonly A_A_COMPROMISE: "A_A_COMPROMISE";
  readonly CERTIFICATE_AUTHORITY_COMPROMISE: "CERTIFICATE_AUTHORITY_COMPROMISE";
  readonly CESSATION_OF_OPERATION: "CESSATION_OF_OPERATION";
  readonly KEY_COMPROMISE: "KEY_COMPROMISE";
  readonly PRIVILEGE_WITHDRAWN: "PRIVILEGE_WITHDRAWN";
  readonly SUPERSEDED: "SUPERSEDED";
  readonly UNSPECIFIED: "UNSPECIFIED";
};
export type RevocationReason =
  (typeof RevocationReason)[keyof typeof RevocationReason];
export interface RevokeCertificateRequest {
  CertificateAuthorityArn: string | undefined;
  CertificateSerial: string | undefined;
  RevocationReason: RevocationReason | undefined;
}
export interface TagCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
  Tags: Tag[] | undefined;
}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export interface UntagCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
  Tags: Tag[] | undefined;
}
export interface UpdateCertificateAuthorityRequest {
  CertificateAuthorityArn: string | undefined;
  RevocationConfiguration?: RevocationConfiguration;
  Status?: CertificateAuthorityStatus;
}
