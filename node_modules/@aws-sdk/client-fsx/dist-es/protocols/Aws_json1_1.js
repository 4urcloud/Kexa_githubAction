import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { FSxServiceException as __BaseException } from "../models/FSxServiceException";
import { ActiveDirectoryError, BackupBeingCopied, BackupInProgress, BackupNotFound, BackupRestoring, BadRequest, DataRepositoryAssociationNotFound, DataRepositoryTaskEnded, DataRepositoryTaskExecuting, DataRepositoryTaskNotFound, FileCacheNotFound, FileSystemNotFound, IncompatibleParameterError, IncompatibleRegionForMultiAZ, InternalServerError, InvalidDataRepositoryType, InvalidDestinationKmsKey, InvalidExportPath, InvalidImportPath, InvalidNetworkSettings, InvalidPerUnitStorageThroughput, InvalidRegion, InvalidSourceKmsKey, MissingFileCacheConfiguration, MissingFileSystemConfiguration, MissingVolumeConfiguration, NotServiceResourceError, ResourceDoesNotSupportTagging, ResourceNotFound, ServiceLimitExceeded, SnapshotNotFound, SourceBackupUnavailable, StorageVirtualMachineNotFound, UnsupportedOperation, VolumeNotFound, } from "../models/models_0";
export const se_AssociateFileSystemAliasesCommand = async (input, context) => {
    const headers = sharedHeaders("AssociateFileSystemAliases");
    let body;
    body = JSON.stringify(se_AssociateFileSystemAliasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CancelDataRepositoryTaskCommand = async (input, context) => {
    const headers = sharedHeaders("CancelDataRepositoryTask");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopyBackupCommand = async (input, context) => {
    const headers = sharedHeaders("CopyBackup");
    let body;
    body = JSON.stringify(se_CopyBackupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CopySnapshotAndUpdateVolumeCommand = async (input, context) => {
    const headers = sharedHeaders("CopySnapshotAndUpdateVolume");
    let body;
    body = JSON.stringify(se_CopySnapshotAndUpdateVolumeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateBackupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateBackup");
    let body;
    body = JSON.stringify(se_CreateBackupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDataRepositoryAssociationCommand = async (input, context) => {
    const headers = sharedHeaders("CreateDataRepositoryAssociation");
    let body;
    body = JSON.stringify(se_CreateDataRepositoryAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateDataRepositoryTaskCommand = async (input, context) => {
    const headers = sharedHeaders("CreateDataRepositoryTask");
    let body;
    body = JSON.stringify(se_CreateDataRepositoryTaskRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFileCacheCommand = async (input, context) => {
    const headers = sharedHeaders("CreateFileCache");
    let body;
    body = JSON.stringify(se_CreateFileCacheRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFileSystemCommand = async (input, context) => {
    const headers = sharedHeaders("CreateFileSystem");
    let body;
    body = JSON.stringify(se_CreateFileSystemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateFileSystemFromBackupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateFileSystemFromBackup");
    let body;
    body = JSON.stringify(se_CreateFileSystemFromBackupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("CreateSnapshot");
    let body;
    body = JSON.stringify(se_CreateSnapshotRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateStorageVirtualMachineCommand = async (input, context) => {
    const headers = sharedHeaders("CreateStorageVirtualMachine");
    let body;
    body = JSON.stringify(se_CreateStorageVirtualMachineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVolumeCommand = async (input, context) => {
    const headers = sharedHeaders("CreateVolume");
    let body;
    body = JSON.stringify(se_CreateVolumeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVolumeFromBackupCommand = async (input, context) => {
    const headers = sharedHeaders("CreateVolumeFromBackup");
    let body;
    body = JSON.stringify(se_CreateVolumeFromBackupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteBackupCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteBackup");
    let body;
    body = JSON.stringify(se_DeleteBackupRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteDataRepositoryAssociationCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteDataRepositoryAssociation");
    let body;
    body = JSON.stringify(se_DeleteDataRepositoryAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteFileCacheCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteFileCache");
    let body;
    body = JSON.stringify(se_DeleteFileCacheRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteFileSystemCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteFileSystem");
    let body;
    body = JSON.stringify(se_DeleteFileSystemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteSnapshot");
    let body;
    body = JSON.stringify(se_DeleteSnapshotRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteStorageVirtualMachineCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteStorageVirtualMachine");
    let body;
    body = JSON.stringify(se_DeleteStorageVirtualMachineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVolumeCommand = async (input, context) => {
    const headers = sharedHeaders("DeleteVolume");
    let body;
    body = JSON.stringify(se_DeleteVolumeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeBackupsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeBackups");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDataRepositoryAssociationsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeDataRepositoryAssociations");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeDataRepositoryTasksCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeDataRepositoryTasks");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFileCachesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeFileCaches");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFileSystemAliasesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeFileSystemAliases");
    let body;
    body = JSON.stringify(se_DescribeFileSystemAliasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeFileSystemsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeFileSystems");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSharedVpcConfigurationCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeSharedVpcConfiguration");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeSnapshotsCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeSnapshots");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeStorageVirtualMachinesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeStorageVirtualMachines");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DescribeVolumesCommand = async (input, context) => {
    const headers = sharedHeaders("DescribeVolumes");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DisassociateFileSystemAliasesCommand = async (input, context) => {
    const headers = sharedHeaders("DisassociateFileSystemAliases");
    let body;
    body = JSON.stringify(se_DisassociateFileSystemAliasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ReleaseFileSystemNfsV3LocksCommand = async (input, context) => {
    const headers = sharedHeaders("ReleaseFileSystemNfsV3Locks");
    let body;
    body = JSON.stringify(se_ReleaseFileSystemNfsV3LocksRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RestoreVolumeFromSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("RestoreVolumeFromSnapshot");
    let body;
    body = JSON.stringify(se_RestoreVolumeFromSnapshotRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_StartMisconfiguredStateRecoveryCommand = async (input, context) => {
    const headers = sharedHeaders("StartMisconfiguredStateRecovery");
    let body;
    body = JSON.stringify(se_StartMisconfiguredStateRecoveryRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagResourceCommand = async (input, context) => {
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify(_json(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateDataRepositoryAssociationCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateDataRepositoryAssociation");
    let body;
    body = JSON.stringify(se_UpdateDataRepositoryAssociationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateFileCacheCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateFileCache");
    let body;
    body = JSON.stringify(se_UpdateFileCacheRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateFileSystemCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateFileSystem");
    let body;
    body = JSON.stringify(se_UpdateFileSystemRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSharedVpcConfigurationCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateSharedVpcConfiguration");
    let body;
    body = JSON.stringify(se_UpdateSharedVpcConfigurationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSnapshotCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateSnapshot");
    let body;
    body = JSON.stringify(se_UpdateSnapshotRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateStorageVirtualMachineCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateStorageVirtualMachine");
    let body;
    body = JSON.stringify(se_UpdateStorageVirtualMachineRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateVolumeCommand = async (input, context) => {
    const headers = sharedHeaders("UpdateVolume");
    let body;
    body = JSON.stringify(se_UpdateVolumeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AssociateFileSystemAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CancelDataRepositoryTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopyBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopyBackupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CopySnapshotAndUpdateVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CopySnapshotAndUpdateVolumeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateBackupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDataRepositoryAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDataRepositoryAssociationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateDataRepositoryTaskCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateDataRepositoryTaskResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFileCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFileCacheResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFileSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFileSystemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateFileSystemFromBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateFileSystemFromBackupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateStorageVirtualMachineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateStorageVirtualMachineResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVolumeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_CreateVolumeFromBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVolumeFromBackupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteBackupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteDataRepositoryAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteFileCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteFileSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteStorageVirtualMachineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DeleteVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeBackupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeBackupsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDataRepositoryAssociationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDataRepositoryAssociationsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeDataRepositoryTasksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeDataRepositoryTasksResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFileCachesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFileCachesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFileSystemAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeFileSystemsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeFileSystemsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSharedVpcConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeSnapshotsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSnapshotsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeStorageVirtualMachinesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeStorageVirtualMachinesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DescribeVolumesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeVolumesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_DisassociateFileSystemAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_ReleaseFileSystemNfsV3LocksCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ReleaseFileSystemNfsV3LocksResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_RestoreVolumeFromSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RestoreVolumeFromSnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_StartMisconfiguredStateRecoveryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartMisconfiguredStateRecoveryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateDataRepositoryAssociationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateDataRepositoryAssociationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateFileCacheCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateFileCacheResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateFileSystemCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateFileSystemResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateSharedVpcConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = _json(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateSnapshotCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSnapshotResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateStorageVirtualMachineCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateStorageVirtualMachineResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
export const de_UpdateVolumeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateVolumeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequest":
        case "com.amazonaws.fsx#BadRequest":
            throw await de_BadRequestRes(parsedOutput, context);
        case "FileSystemNotFound":
        case "com.amazonaws.fsx#FileSystemNotFound":
            throw await de_FileSystemNotFoundRes(parsedOutput, context);
        case "InternalServerError":
        case "com.amazonaws.fsx#InternalServerError":
            throw await de_InternalServerErrorRes(parsedOutput, context);
        case "DataRepositoryTaskEnded":
        case "com.amazonaws.fsx#DataRepositoryTaskEnded":
            throw await de_DataRepositoryTaskEndedRes(parsedOutput, context);
        case "DataRepositoryTaskNotFound":
        case "com.amazonaws.fsx#DataRepositoryTaskNotFound":
            throw await de_DataRepositoryTaskNotFoundRes(parsedOutput, context);
        case "UnsupportedOperation":
        case "com.amazonaws.fsx#UnsupportedOperation":
            throw await de_UnsupportedOperationRes(parsedOutput, context);
        case "BackupNotFound":
        case "com.amazonaws.fsx#BackupNotFound":
            throw await de_BackupNotFoundRes(parsedOutput, context);
        case "IncompatibleParameterError":
        case "com.amazonaws.fsx#IncompatibleParameterError":
            throw await de_IncompatibleParameterErrorRes(parsedOutput, context);
        case "IncompatibleRegionForMultiAZ":
        case "com.amazonaws.fsx#IncompatibleRegionForMultiAZ":
            throw await de_IncompatibleRegionForMultiAZRes(parsedOutput, context);
        case "InvalidDestinationKmsKey":
        case "com.amazonaws.fsx#InvalidDestinationKmsKey":
            throw await de_InvalidDestinationKmsKeyRes(parsedOutput, context);
        case "InvalidRegion":
        case "com.amazonaws.fsx#InvalidRegion":
            throw await de_InvalidRegionRes(parsedOutput, context);
        case "InvalidSourceKmsKey":
        case "com.amazonaws.fsx#InvalidSourceKmsKey":
            throw await de_InvalidSourceKmsKeyRes(parsedOutput, context);
        case "ServiceLimitExceeded":
        case "com.amazonaws.fsx#ServiceLimitExceeded":
            throw await de_ServiceLimitExceededRes(parsedOutput, context);
        case "SourceBackupUnavailable":
        case "com.amazonaws.fsx#SourceBackupUnavailable":
            throw await de_SourceBackupUnavailableRes(parsedOutput, context);
        case "BackupInProgress":
        case "com.amazonaws.fsx#BackupInProgress":
            throw await de_BackupInProgressRes(parsedOutput, context);
        case "VolumeNotFound":
        case "com.amazonaws.fsx#VolumeNotFound":
            throw await de_VolumeNotFoundRes(parsedOutput, context);
        case "DataRepositoryTaskExecuting":
        case "com.amazonaws.fsx#DataRepositoryTaskExecuting":
            throw await de_DataRepositoryTaskExecutingRes(parsedOutput, context);
        case "InvalidNetworkSettings":
        case "com.amazonaws.fsx#InvalidNetworkSettings":
            throw await de_InvalidNetworkSettingsRes(parsedOutput, context);
        case "InvalidPerUnitStorageThroughput":
        case "com.amazonaws.fsx#InvalidPerUnitStorageThroughput":
            throw await de_InvalidPerUnitStorageThroughputRes(parsedOutput, context);
        case "MissingFileCacheConfiguration":
        case "com.amazonaws.fsx#MissingFileCacheConfiguration":
            throw await de_MissingFileCacheConfigurationRes(parsedOutput, context);
        case "ActiveDirectoryError":
        case "com.amazonaws.fsx#ActiveDirectoryError":
            throw await de_ActiveDirectoryErrorRes(parsedOutput, context);
        case "InvalidExportPath":
        case "com.amazonaws.fsx#InvalidExportPath":
            throw await de_InvalidExportPathRes(parsedOutput, context);
        case "InvalidImportPath":
        case "com.amazonaws.fsx#InvalidImportPath":
            throw await de_InvalidImportPathRes(parsedOutput, context);
        case "MissingFileSystemConfiguration":
        case "com.amazonaws.fsx#MissingFileSystemConfiguration":
            throw await de_MissingFileSystemConfigurationRes(parsedOutput, context);
        case "MissingVolumeConfiguration":
        case "com.amazonaws.fsx#MissingVolumeConfiguration":
            throw await de_MissingVolumeConfigurationRes(parsedOutput, context);
        case "StorageVirtualMachineNotFound":
        case "com.amazonaws.fsx#StorageVirtualMachineNotFound":
            throw await de_StorageVirtualMachineNotFoundRes(parsedOutput, context);
        case "BackupBeingCopied":
        case "com.amazonaws.fsx#BackupBeingCopied":
            throw await de_BackupBeingCopiedRes(parsedOutput, context);
        case "BackupRestoring":
        case "com.amazonaws.fsx#BackupRestoring":
            throw await de_BackupRestoringRes(parsedOutput, context);
        case "DataRepositoryAssociationNotFound":
        case "com.amazonaws.fsx#DataRepositoryAssociationNotFound":
            throw await de_DataRepositoryAssociationNotFoundRes(parsedOutput, context);
        case "FileCacheNotFound":
        case "com.amazonaws.fsx#FileCacheNotFound":
            throw await de_FileCacheNotFoundRes(parsedOutput, context);
        case "SnapshotNotFound":
        case "com.amazonaws.fsx#SnapshotNotFound":
            throw await de_SnapshotNotFoundRes(parsedOutput, context);
        case "InvalidDataRepositoryType":
        case "com.amazonaws.fsx#InvalidDataRepositoryType":
            throw await de_InvalidDataRepositoryTypeRes(parsedOutput, context);
        case "NotServiceResourceError":
        case "com.amazonaws.fsx#NotServiceResourceError":
            throw await de_NotServiceResourceErrorRes(parsedOutput, context);
        case "ResourceDoesNotSupportTagging":
        case "com.amazonaws.fsx#ResourceDoesNotSupportTagging":
            throw await de_ResourceDoesNotSupportTaggingRes(parsedOutput, context);
        case "ResourceNotFound":
        case "com.amazonaws.fsx#ResourceNotFound":
            throw await de_ResourceNotFoundRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ActiveDirectoryErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ActiveDirectoryError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BackupBeingCopiedRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BackupBeingCopied({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BackupInProgressRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BackupInProgress({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BackupNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BackupNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BackupRestoringRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BackupRestoring({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_BadRequestRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new BadRequest({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DataRepositoryAssociationNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DataRepositoryAssociationNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DataRepositoryTaskEndedRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DataRepositoryTaskEnded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DataRepositoryTaskExecutingRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DataRepositoryTaskExecuting({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DataRepositoryTaskNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new DataRepositoryTaskNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_FileCacheNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new FileCacheNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_FileSystemNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new FileSystemNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IncompatibleParameterErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new IncompatibleParameterError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_IncompatibleRegionForMultiAZRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new IncompatibleRegionForMultiAZ({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InternalServerErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InternalServerError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDataRepositoryTypeRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidDataRepositoryType({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidDestinationKmsKeyRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidDestinationKmsKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidExportPathRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidExportPath({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidImportPathRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidImportPath({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidNetworkSettingsRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidNetworkSettings({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPerUnitStorageThroughputRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidPerUnitStorageThroughput({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidRegionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidRegion({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidSourceKmsKeyRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new InvalidSourceKmsKey({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingFileCacheConfigurationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new MissingFileCacheConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingFileSystemConfigurationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new MissingFileSystemConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MissingVolumeConfigurationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new MissingVolumeConfiguration({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NotServiceResourceErrorRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new NotServiceResourceError({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceDoesNotSupportTaggingRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ResourceDoesNotSupportTagging({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ResourceNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ResourceNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceLimitExceededRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new ServiceLimitExceeded({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SnapshotNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SnapshotNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_SourceBackupUnavailableRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new SourceBackupUnavailable({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_StorageVirtualMachineNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new StorageVirtualMachineNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnsupportedOperationRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new UnsupportedOperation({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_VolumeNotFoundRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = _json(body);
    const exception = new VolumeNotFound({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_AssociateFileSystemAliasesRequest = (input, context) => {
    return take(input, {
        Aliases: _json,
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
    });
};
const se_CopyBackupRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        CopyTags: [],
        KmsKeyId: [],
        SourceBackupId: [],
        SourceRegion: [],
        Tags: _json,
    });
};
const se_CopySnapshotAndUpdateVolumeRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        CopyStrategy: [],
        Options: _json,
        SourceSnapshotARN: [],
        VolumeId: [],
    });
};
const se_CreateBackupRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        Tags: _json,
        VolumeId: [],
    });
};
const se_CreateDataRepositoryAssociationRequest = (input, context) => {
    return take(input, {
        BatchImportMetaDataOnCreate: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        DataRepositoryPath: [],
        FileSystemId: [],
        FileSystemPath: [],
        ImportedFileChunkSize: [],
        S3: _json,
        Tags: _json,
    });
};
const se_CreateDataRepositoryTaskRequest = (input, context) => {
    return take(input, {
        CapacityToRelease: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        Paths: _json,
        ReleaseConfiguration: _json,
        Report: _json,
        Tags: _json,
        Type: [],
    });
};
const se_CreateFileCacheRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        CopyTagsToDataRepositoryAssociations: [],
        DataRepositoryAssociations: _json,
        FileCacheType: [],
        FileCacheTypeVersion: [],
        KmsKeyId: [],
        LustreConfiguration: _json,
        SecurityGroupIds: _json,
        StorageCapacity: [],
        SubnetIds: _json,
        Tags: _json,
    });
};
const se_CreateFileSystemFromBackupRequest = (input, context) => {
    return take(input, {
        BackupId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemTypeVersion: [],
        KmsKeyId: [],
        LustreConfiguration: _json,
        OpenZFSConfiguration: _json,
        SecurityGroupIds: _json,
        StorageCapacity: [],
        StorageType: [],
        SubnetIds: _json,
        Tags: _json,
        WindowsConfiguration: _json,
    });
};
const se_CreateFileSystemRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemType: [],
        FileSystemTypeVersion: [],
        KmsKeyId: [],
        LustreConfiguration: _json,
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        SecurityGroupIds: _json,
        StorageCapacity: [],
        StorageType: [],
        SubnetIds: _json,
        Tags: _json,
        WindowsConfiguration: _json,
    });
};
const se_CreateSnapshotRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Name: [],
        Tags: _json,
        VolumeId: [],
    });
};
const se_CreateStorageVirtualMachineRequest = (input, context) => {
    return take(input, {
        ActiveDirectoryConfiguration: _json,
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        Name: [],
        RootVolumeSecurityStyle: [],
        SvmAdminPassword: [],
        Tags: _json,
    });
};
const se_CreateVolumeFromBackupRequest = (input, context) => {
    return take(input, {
        BackupId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Name: [],
        OntapConfiguration: _json,
        Tags: _json,
    });
};
const se_CreateVolumeRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Name: [],
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        Tags: _json,
        VolumeType: [],
    });
};
const se_DeleteBackupRequest = (input, context) => {
    return take(input, {
        BackupId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
    });
};
const se_DeleteDataRepositoryAssociationRequest = (input, context) => {
    return take(input, {
        AssociationId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        DeleteDataInFileSystem: [],
    });
};
const se_DeleteFileCacheRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileCacheId: [],
    });
};
const se_DeleteFileSystemRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        LustreConfiguration: _json,
        OpenZFSConfiguration: _json,
        WindowsConfiguration: _json,
    });
};
const se_DeleteSnapshotRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        SnapshotId: [],
    });
};
const se_DeleteStorageVirtualMachineRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        StorageVirtualMachineId: [],
    });
};
const se_DeleteVolumeRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        VolumeId: [],
    });
};
const se_DescribeFileSystemAliasesRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        MaxResults: [],
        NextToken: [],
    });
};
const se_DisassociateFileSystemAliasesRequest = (input, context) => {
    return take(input, {
        Aliases: _json,
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
    });
};
const se_ReleaseFileSystemNfsV3LocksRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
    });
};
const se_RestoreVolumeFromSnapshotRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Options: _json,
        SnapshotId: [],
        VolumeId: [],
    });
};
const se_StartMisconfiguredStateRecoveryRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
    });
};
const se_UpdateDataRepositoryAssociationRequest = (input, context) => {
    return take(input, {
        AssociationId: [],
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ImportedFileChunkSize: [],
        S3: _json,
    });
};
const se_UpdateFileCacheRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileCacheId: [],
        LustreConfiguration: _json,
    });
};
const se_UpdateFileSystemRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        FileSystemId: [],
        LustreConfiguration: _json,
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        StorageCapacity: [],
        StorageType: [],
        WindowsConfiguration: _json,
    });
};
const se_UpdateSharedVpcConfigurationRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        EnableFsxRouteTableUpdatesFromParticipantAccounts: [],
    });
};
const se_UpdateSnapshotRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Name: [],
        SnapshotId: [],
    });
};
const se_UpdateStorageVirtualMachineRequest = (input, context) => {
    return take(input, {
        ActiveDirectoryConfiguration: _json,
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        StorageVirtualMachineId: [],
        SvmAdminPassword: [],
    });
};
const se_UpdateVolumeRequest = (input, context) => {
    return take(input, {
        ClientRequestToken: [true, (_) => _ ?? generateIdempotencyToken()],
        Name: [],
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        VolumeId: [],
    });
};
const de_AdministrativeAction = (output, context) => {
    return take(output, {
        AdministrativeActionType: __expectString,
        FailureDetails: _json,
        ProgressPercent: __expectInt32,
        RemainingTransferBytes: __expectLong,
        RequestTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        TargetFileSystemValues: (_) => de_FileSystem(_, context),
        TargetSnapshotValues: (_) => de_Snapshot(_, context),
        TargetVolumeValues: (_) => de_Volume(_, context),
        TotalTransferBytes: __expectLong,
    });
};
const de_AdministrativeActions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AdministrativeAction(entry, context);
    });
    return retVal;
};
const de_Backup = (output, context) => {
    return take(output, {
        BackupId: __expectString,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DirectoryInformation: _json,
        FailureDetails: _json,
        FileSystem: (_) => de_FileSystem(_, context),
        KmsKeyId: __expectString,
        Lifecycle: __expectString,
        OwnerId: __expectString,
        ProgressPercent: __expectInt32,
        ResourceARN: __expectString,
        ResourceType: __expectString,
        SourceBackupId: __expectString,
        SourceBackupRegion: __expectString,
        Tags: _json,
        Type: __expectString,
        Volume: (_) => de_Volume(_, context),
    });
};
const de_Backups = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Backup(entry, context);
    });
    return retVal;
};
const de_CopyBackupResponse = (output, context) => {
    return take(output, {
        Backup: (_) => de_Backup(_, context),
    });
};
const de_CopySnapshotAndUpdateVolumeResponse = (output, context) => {
    return take(output, {
        AdministrativeActions: (_) => de_AdministrativeActions(_, context),
        Lifecycle: __expectString,
        VolumeId: __expectString,
    });
};
const de_CreateBackupResponse = (output, context) => {
    return take(output, {
        Backup: (_) => de_Backup(_, context),
    });
};
const de_CreateDataRepositoryAssociationResponse = (output, context) => {
    return take(output, {
        Association: (_) => de_DataRepositoryAssociation(_, context),
    });
};
const de_CreateDataRepositoryTaskResponse = (output, context) => {
    return take(output, {
        DataRepositoryTask: (_) => de_DataRepositoryTask(_, context),
    });
};
const de_CreateFileCacheResponse = (output, context) => {
    return take(output, {
        FileCache: (_) => de_FileCacheCreating(_, context),
    });
};
const de_CreateFileSystemFromBackupResponse = (output, context) => {
    return take(output, {
        FileSystem: (_) => de_FileSystem(_, context),
    });
};
const de_CreateFileSystemResponse = (output, context) => {
    return take(output, {
        FileSystem: (_) => de_FileSystem(_, context),
    });
};
const de_CreateSnapshotResponse = (output, context) => {
    return take(output, {
        Snapshot: (_) => de_Snapshot(_, context),
    });
};
const de_CreateStorageVirtualMachineResponse = (output, context) => {
    return take(output, {
        StorageVirtualMachine: (_) => de_StorageVirtualMachine(_, context),
    });
};
const de_CreateVolumeFromBackupResponse = (output, context) => {
    return take(output, {
        Volume: (_) => de_Volume(_, context),
    });
};
const de_CreateVolumeResponse = (output, context) => {
    return take(output, {
        Volume: (_) => de_Volume(_, context),
    });
};
const de_DataRepositoryAssociation = (output, context) => {
    return take(output, {
        AssociationId: __expectString,
        BatchImportMetaDataOnCreate: __expectBoolean,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DataRepositoryPath: __expectString,
        DataRepositorySubdirectories: _json,
        FailureDetails: _json,
        FileCacheId: __expectString,
        FileCachePath: __expectString,
        FileSystemId: __expectString,
        FileSystemPath: __expectString,
        ImportedFileChunkSize: __expectInt32,
        Lifecycle: __expectString,
        NFS: _json,
        ResourceARN: __expectString,
        S3: _json,
        Tags: _json,
    });
};
const de_DataRepositoryAssociations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataRepositoryAssociation(entry, context);
    });
    return retVal;
};
const de_DataRepositoryTask = (output, context) => {
    return take(output, {
        CapacityToRelease: __expectLong,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        EndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FailureDetails: _json,
        FileCacheId: __expectString,
        FileSystemId: __expectString,
        Lifecycle: __expectString,
        Paths: _json,
        ReleaseConfiguration: _json,
        Report: _json,
        ResourceARN: __expectString,
        StartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: (_) => de_DataRepositoryTaskStatus(_, context),
        Tags: _json,
        TaskId: __expectString,
        Type: __expectString,
    });
};
const de_DataRepositoryTasks = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataRepositoryTask(entry, context);
    });
    return retVal;
};
const de_DataRepositoryTaskStatus = (output, context) => {
    return take(output, {
        FailedCount: __expectLong,
        LastUpdatedTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ReleasedCapacity: __expectLong,
        SucceededCount: __expectLong,
        TotalCount: __expectLong,
    });
};
const de_DescribeBackupsResponse = (output, context) => {
    return take(output, {
        Backups: (_) => de_Backups(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeDataRepositoryAssociationsResponse = (output, context) => {
    return take(output, {
        Associations: (_) => de_DataRepositoryAssociations(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeDataRepositoryTasksResponse = (output, context) => {
    return take(output, {
        DataRepositoryTasks: (_) => de_DataRepositoryTasks(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeFileCachesResponse = (output, context) => {
    return take(output, {
        FileCaches: (_) => de_FileCaches(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeFileSystemsResponse = (output, context) => {
    return take(output, {
        FileSystems: (_) => de_FileSystems(_, context),
        NextToken: __expectString,
    });
};
const de_DescribeSnapshotsResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        Snapshots: (_) => de_Snapshots(_, context),
    });
};
const de_DescribeStorageVirtualMachinesResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        StorageVirtualMachines: (_) => de_StorageVirtualMachines(_, context),
    });
};
const de_DescribeVolumesResponse = (output, context) => {
    return take(output, {
        NextToken: __expectString,
        Volumes: (_) => de_Volumes(_, context),
    });
};
const de_FileCache = (output, context) => {
    return take(output, {
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DNSName: __expectString,
        DataRepositoryAssociationIds: _json,
        FailureDetails: _json,
        FileCacheId: __expectString,
        FileCacheType: __expectString,
        FileCacheTypeVersion: __expectString,
        KmsKeyId: __expectString,
        Lifecycle: __expectString,
        LustreConfiguration: _json,
        NetworkInterfaceIds: _json,
        OwnerId: __expectString,
        ResourceARN: __expectString,
        StorageCapacity: __expectInt32,
        SubnetIds: _json,
        VpcId: __expectString,
    });
};
const de_FileCacheCreating = (output, context) => {
    return take(output, {
        CopyTagsToDataRepositoryAssociations: __expectBoolean,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DNSName: __expectString,
        DataRepositoryAssociationIds: _json,
        FailureDetails: _json,
        FileCacheId: __expectString,
        FileCacheType: __expectString,
        FileCacheTypeVersion: __expectString,
        KmsKeyId: __expectString,
        Lifecycle: __expectString,
        LustreConfiguration: _json,
        NetworkInterfaceIds: _json,
        OwnerId: __expectString,
        ResourceARN: __expectString,
        StorageCapacity: __expectInt32,
        SubnetIds: _json,
        Tags: _json,
        VpcId: __expectString,
    });
};
const de_FileCaches = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FileCache(entry, context);
    });
    return retVal;
};
const de_FileSystem = (output, context) => {
    return take(output, {
        AdministrativeActions: (_) => de_AdministrativeActions(_, context),
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DNSName: __expectString,
        FailureDetails: _json,
        FileSystemId: __expectString,
        FileSystemType: __expectString,
        FileSystemTypeVersion: __expectString,
        KmsKeyId: __expectString,
        Lifecycle: __expectString,
        LustreConfiguration: _json,
        NetworkInterfaceIds: _json,
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        OwnerId: __expectString,
        ResourceARN: __expectString,
        StorageCapacity: __expectInt32,
        StorageType: __expectString,
        SubnetIds: _json,
        Tags: _json,
        VpcId: __expectString,
        WindowsConfiguration: _json,
    });
};
const de_FileSystems = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FileSystem(entry, context);
    });
    return retVal;
};
const de_ReleaseFileSystemNfsV3LocksResponse = (output, context) => {
    return take(output, {
        FileSystem: (_) => de_FileSystem(_, context),
    });
};
const de_RestoreVolumeFromSnapshotResponse = (output, context) => {
    return take(output, {
        AdministrativeActions: (_) => de_AdministrativeActions(_, context),
        Lifecycle: __expectString,
        VolumeId: __expectString,
    });
};
const de_Snapshot = (output, context) => {
    return take(output, {
        AdministrativeActions: (_) => de_AdministrativeActions(_, context),
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Lifecycle: __expectString,
        LifecycleTransitionReason: _json,
        Name: __expectString,
        ResourceARN: __expectString,
        SnapshotId: __expectString,
        Tags: _json,
        VolumeId: __expectString,
    });
};
const de_Snapshots = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Snapshot(entry, context);
    });
    return retVal;
};
const de_StartMisconfiguredStateRecoveryResponse = (output, context) => {
    return take(output, {
        FileSystem: (_) => de_FileSystem(_, context),
    });
};
const de_StorageVirtualMachine = (output, context) => {
    return take(output, {
        ActiveDirectoryConfiguration: _json,
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Endpoints: _json,
        FileSystemId: __expectString,
        Lifecycle: __expectString,
        LifecycleTransitionReason: _json,
        Name: __expectString,
        ResourceARN: __expectString,
        RootVolumeSecurityStyle: __expectString,
        StorageVirtualMachineId: __expectString,
        Subtype: __expectString,
        Tags: _json,
        UUID: __expectString,
    });
};
const de_StorageVirtualMachines = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_StorageVirtualMachine(entry, context);
    });
    return retVal;
};
const de_UpdateDataRepositoryAssociationResponse = (output, context) => {
    return take(output, {
        Association: (_) => de_DataRepositoryAssociation(_, context),
    });
};
const de_UpdateFileCacheResponse = (output, context) => {
    return take(output, {
        FileCache: (_) => de_FileCache(_, context),
    });
};
const de_UpdateFileSystemResponse = (output, context) => {
    return take(output, {
        FileSystem: (_) => de_FileSystem(_, context),
    });
};
const de_UpdateSnapshotResponse = (output, context) => {
    return take(output, {
        Snapshot: (_) => de_Snapshot(_, context),
    });
};
const de_UpdateStorageVirtualMachineResponse = (output, context) => {
    return take(output, {
        StorageVirtualMachine: (_) => de_StorageVirtualMachine(_, context),
    });
};
const de_UpdateVolumeResponse = (output, context) => {
    return take(output, {
        Volume: (_) => de_Volume(_, context),
    });
};
const de_Volume = (output, context) => {
    return take(output, {
        AdministrativeActions: (_) => de_AdministrativeActions(_, context),
        CreationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FileSystemId: __expectString,
        Lifecycle: __expectString,
        LifecycleTransitionReason: _json,
        Name: __expectString,
        OntapConfiguration: _json,
        OpenZFSConfiguration: _json,
        ResourceARN: __expectString,
        Tags: _json,
        VolumeId: __expectString,
        VolumeType: __expectString,
    });
};
const de_Volumes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Volume(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `AWSSimbaAPIService_v20180301.${operation}`,
    };
}
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
