import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { LicenseManagerServiceException as __BaseException } from "./LicenseManagerServiceException";
export interface AcceptGrantRequest {
  GrantArn: string | undefined;
}
export declare const GrantStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly DISABLED: "DISABLED";
  readonly FAILED_WORKFLOW: "FAILED_WORKFLOW";
  readonly PENDING_ACCEPT: "PENDING_ACCEPT";
  readonly PENDING_DELETE: "PENDING_DELETE";
  readonly PENDING_WORKFLOW: "PENDING_WORKFLOW";
  readonly REJECTED: "REJECTED";
  readonly WORKFLOW_COMPLETED: "WORKFLOW_COMPLETED";
};
export type GrantStatus = (typeof GrantStatus)[keyof typeof GrantStatus];
export interface AcceptGrantResponse {
  GrantArn?: string;
  Status?: GrantStatus;
  Version?: string;
}
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare class AuthorizationException extends __BaseException {
  readonly name: "AuthorizationException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AuthorizationException, __BaseException>
  );
}
export declare class InvalidParameterValueException extends __BaseException {
  readonly name: "InvalidParameterValueException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidParameterValueException, __BaseException>
  );
}
export declare class RateLimitExceededException extends __BaseException {
  readonly name: "RateLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<RateLimitExceededException, __BaseException>
  );
}
export declare class ResourceLimitExceededException extends __BaseException {
  readonly name: "ResourceLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceLimitExceededException, __BaseException>
  );
}
export declare class ServerInternalException extends __BaseException {
  readonly name: "ServerInternalException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ServerInternalException, __BaseException>
  );
}
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export declare const ActivationOverrideBehavior: {
  readonly ALL_GRANTS_PERMITTED_BY_ISSUER: "ALL_GRANTS_PERMITTED_BY_ISSUER";
  readonly DISTRIBUTED_GRANTS_ONLY: "DISTRIBUTED_GRANTS_ONLY";
};
export type ActivationOverrideBehavior =
  (typeof ActivationOverrideBehavior)[keyof typeof ActivationOverrideBehavior];
export declare const AllowedOperation: {
  readonly CHECKOUT_BORROW_LICENSE: "CheckoutBorrowLicense";
  readonly CHECKOUT_LICENSE: "CheckoutLicense";
  readonly CHECK_IN_LICENSE: "CheckInLicense";
  readonly CREATE_GRANT: "CreateGrant";
  readonly CREATE_TOKEN: "CreateToken";
  readonly EXTEND_CONSUMPTION_LICENSE: "ExtendConsumptionLicense";
  readonly LIST_PURCHASED_LICENSES: "ListPurchasedLicenses";
};
export type AllowedOperation =
  (typeof AllowedOperation)[keyof typeof AllowedOperation];
export interface AutomatedDiscoveryInformation {
  LastRunTime?: Date;
}
export interface CheckInLicenseRequest {
  LicenseConsumptionToken: string | undefined;
  Beneficiary?: string;
}
export interface CheckInLicenseResponse {}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  Message?: string;
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export interface Metadata {
  Name?: string;
  Value?: string;
}
export declare const DigitalSignatureMethod: {
  readonly JWT_PS384: "JWT_PS384";
};
export type DigitalSignatureMethod =
  (typeof DigitalSignatureMethod)[keyof typeof DigitalSignatureMethod];
export declare const EntitlementDataUnit: {
  readonly BITS: "Bits";
  readonly BITS_PER_SECOND: "Bits/Second";
  readonly BYTES: "Bytes";
  readonly BYTES_PER_SECOND: "Bytes/Second";
  readonly COUNT: "Count";
  readonly COUNT_PER_SECOND: "Count/Second";
  readonly GIGABITS: "Gigabits";
  readonly GIGABITS_PER_SECOND: "Gigabits/Second";
  readonly GIGABYTES: "Gigabytes";
  readonly GIGABYTES_PER_SECOND: "Gigabytes/Second";
  readonly KILOBITS: "Kilobits";
  readonly KILOBITS_PER_SECOND: "Kilobits/Second";
  readonly KILOBYTES: "Kilobytes";
  readonly KILOBYTES_PER_SECOND: "Kilobytes/Second";
  readonly MEGABITS: "Megabits";
  readonly MEGABITS_PER_SECOND: "Megabits/Second";
  readonly MEGABYTES: "Megabytes";
  readonly MEGABYTES_PER_SECOND: "Megabytes/Second";
  readonly MICROSECONDS: "Microseconds";
  readonly MILLISECONDS: "Milliseconds";
  readonly NONE: "None";
  readonly PERCENT: "Percent";
  readonly SECONDS: "Seconds";
  readonly TERABITS: "Terabits";
  readonly TERABITS_PER_SECOND: "Terabits/Second";
  readonly TERABYTES: "Terabytes";
  readonly TERABYTES_PER_SECOND: "Terabytes/Second";
};
export type EntitlementDataUnit =
  (typeof EntitlementDataUnit)[keyof typeof EntitlementDataUnit];
export interface EntitlementData {
  Name: string | undefined;
  Value?: string;
  Unit: EntitlementDataUnit | undefined;
}
export interface CheckoutBorrowLicenseRequest {
  LicenseArn: string | undefined;
  Entitlements: EntitlementData[] | undefined;
  DigitalSignatureMethod: DigitalSignatureMethod | undefined;
  NodeId?: string;
  CheckoutMetadata?: Metadata[];
  ClientToken: string | undefined;
}
export interface CheckoutBorrowLicenseResponse {
  LicenseArn?: string;
  LicenseConsumptionToken?: string;
  EntitlementsAllowed?: EntitlementData[];
  NodeId?: string;
  SignedToken?: string;
  IssuedAt?: string;
  Expiration?: string;
  CheckoutMetadata?: Metadata[];
}
export declare class EntitlementNotAllowedException extends __BaseException {
  readonly name: "EntitlementNotAllowedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<EntitlementNotAllowedException, __BaseException>
  );
}
export declare class NoEntitlementsAllowedException extends __BaseException {
  readonly name: "NoEntitlementsAllowedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<NoEntitlementsAllowedException, __BaseException>
  );
}
export declare class RedirectException extends __BaseException {
  readonly name: "RedirectException";
  readonly $fault: "client";
  Location?: string;
  Message?: string;
  constructor(opts: __ExceptionOptionType<RedirectException, __BaseException>);
}
export declare class UnsupportedDigitalSignatureMethodException extends __BaseException {
  readonly name: "UnsupportedDigitalSignatureMethodException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      UnsupportedDigitalSignatureMethodException,
      __BaseException
    >
  );
}
export declare const CheckoutType: {
  readonly PERPETUAL: "PERPETUAL";
  readonly PROVISIONAL: "PROVISIONAL";
};
export type CheckoutType = (typeof CheckoutType)[keyof typeof CheckoutType];
export interface CheckoutLicenseRequest {
  ProductSKU: string | undefined;
  CheckoutType: CheckoutType | undefined;
  KeyFingerprint: string | undefined;
  Entitlements: EntitlementData[] | undefined;
  ClientToken: string | undefined;
  Beneficiary?: string;
  NodeId?: string;
}
export interface CheckoutLicenseResponse {
  CheckoutType?: CheckoutType;
  LicenseConsumptionToken?: string;
  EntitlementsAllowed?: EntitlementData[];
  SignedToken?: string;
  NodeId?: string;
  IssuedAt?: string;
  Expiration?: string;
  LicenseArn?: string;
}
export interface CreateGrantRequest {
  ClientToken: string | undefined;
  GrantName: string | undefined;
  LicenseArn: string | undefined;
  Principals: string[] | undefined;
  HomeRegion: string | undefined;
  AllowedOperations: AllowedOperation[] | undefined;
}
export interface CreateGrantResponse {
  GrantArn?: string;
  Status?: GrantStatus;
  Version?: string;
}
export interface Options {
  ActivationOverrideBehavior?: ActivationOverrideBehavior;
}
export interface CreateGrantVersionRequest {
  ClientToken: string | undefined;
  GrantArn: string | undefined;
  GrantName?: string;
  AllowedOperations?: AllowedOperation[];
  Status?: GrantStatus;
  StatusReason?: string;
  SourceVersion?: string;
  Options?: Options;
}
export interface CreateGrantVersionResponse {
  GrantArn?: string;
  Status?: GrantStatus;
  Version?: string;
}
export interface BorrowConfiguration {
  AllowEarlyCheckIn: boolean | undefined;
  MaxTimeToLiveInMinutes: number | undefined;
}
export interface ProvisionalConfiguration {
  MaxTimeToLiveInMinutes: number | undefined;
}
export declare const RenewType: {
  readonly MONTHLY: "Monthly";
  readonly NONE: "None";
  readonly WEEKLY: "Weekly";
};
export type RenewType = (typeof RenewType)[keyof typeof RenewType];
export interface ConsumptionConfiguration {
  RenewType?: RenewType;
  ProvisionalConfiguration?: ProvisionalConfiguration;
  BorrowConfiguration?: BorrowConfiguration;
}
export declare const EntitlementUnit: {
  readonly BITS: "Bits";
  readonly BITS_PER_SECOND: "Bits/Second";
  readonly BYTES: "Bytes";
  readonly BYTES_PER_SECOND: "Bytes/Second";
  readonly COUNT: "Count";
  readonly COUNT_PER_SECOND: "Count/Second";
  readonly GIGABITS: "Gigabits";
  readonly GIGABITS_PER_SECOND: "Gigabits/Second";
  readonly GIGABYTES: "Gigabytes";
  readonly GIGABYTES_PER_SECOND: "Gigabytes/Second";
  readonly KILOBITS: "Kilobits";
  readonly KILOBITS_PER_SECOND: "Kilobits/Second";
  readonly KILOBYTES: "Kilobytes";
  readonly KILOBYTES_PER_SECOND: "Kilobytes/Second";
  readonly MEGABITS: "Megabits";
  readonly MEGABITS_PER_SECOND: "Megabits/Second";
  readonly MEGABYTES: "Megabytes";
  readonly MEGABYTES_PER_SECOND: "Megabytes/Second";
  readonly MICROSECONDS: "Microseconds";
  readonly MILLISECONDS: "Milliseconds";
  readonly NONE: "None";
  readonly PERCENT: "Percent";
  readonly SECONDS: "Seconds";
  readonly TERABITS: "Terabits";
  readonly TERABITS_PER_SECOND: "Terabits/Second";
  readonly TERABYTES: "Terabytes";
  readonly TERABYTES_PER_SECOND: "Terabytes/Second";
};
export type EntitlementUnit =
  (typeof EntitlementUnit)[keyof typeof EntitlementUnit];
export interface Entitlement {
  Name: string | undefined;
  Value?: string;
  MaxCount?: number;
  Overage?: boolean;
  Unit: EntitlementUnit | undefined;
  AllowCheckIn?: boolean;
}
export interface Issuer {
  Name: string | undefined;
  SignKey?: string;
}
export interface DatetimeRange {
  Begin: string | undefined;
  End?: string;
}
export interface CreateLicenseRequest {
  LicenseName: string | undefined;
  ProductName: string | undefined;
  ProductSKU: string | undefined;
  Issuer: Issuer | undefined;
  HomeRegion: string | undefined;
  Validity: DatetimeRange | undefined;
  Entitlements: Entitlement[] | undefined;
  Beneficiary: string | undefined;
  ConsumptionConfiguration: ConsumptionConfiguration | undefined;
  LicenseMetadata?: Metadata[];
  ClientToken: string | undefined;
}
export declare const LicenseStatus: {
  readonly AVAILABLE: "AVAILABLE";
  readonly DEACTIVATED: "DEACTIVATED";
  readonly DELETED: "DELETED";
  readonly EXPIRED: "EXPIRED";
  readonly PENDING_AVAILABLE: "PENDING_AVAILABLE";
  readonly PENDING_DELETE: "PENDING_DELETE";
  readonly SUSPENDED: "SUSPENDED";
};
export type LicenseStatus = (typeof LicenseStatus)[keyof typeof LicenseStatus];
export interface CreateLicenseResponse {
  LicenseArn?: string;
  Status?: LicenseStatus;
  Version?: string;
}
export declare const LicenseCountingType: {
  readonly CORE: "Core";
  readonly INSTANCE: "Instance";
  readonly SOCKET: "Socket";
  readonly VCPU: "vCPU";
};
export type LicenseCountingType =
  (typeof LicenseCountingType)[keyof typeof LicenseCountingType];
export interface ProductInformationFilter {
  ProductInformationFilterName: string | undefined;
  ProductInformationFilterValue?: string[];
  ProductInformationFilterComparator: string | undefined;
}
export interface ProductInformation {
  ResourceType: string | undefined;
  ProductInformationFilterList: ProductInformationFilter[] | undefined;
}
export interface Tag {
  Key?: string;
  Value?: string;
}
export interface CreateLicenseConfigurationRequest {
  Name: string | undefined;
  Description?: string;
  LicenseCountingType: LicenseCountingType | undefined;
  LicenseCount?: number;
  LicenseCountHardLimit?: boolean;
  LicenseRules?: string[];
  Tags?: Tag[];
  DisassociateWhenNotFound?: boolean;
  ProductInformationList?: ProductInformation[];
}
export interface CreateLicenseConfigurationResponse {
  LicenseConfigurationArn?: string;
}
export interface LicenseConversionContext {
  UsageOperation?: string;
}
export interface CreateLicenseConversionTaskForResourceRequest {
  ResourceArn: string | undefined;
  SourceLicenseContext: LicenseConversionContext | undefined;
  DestinationLicenseContext: LicenseConversionContext | undefined;
}
export interface CreateLicenseConversionTaskForResourceResponse {
  LicenseConversionTaskId?: string;
}
export interface ReportContext {
  licenseConfigurationArns: string[] | undefined;
}
export declare const ReportFrequencyType: {
  readonly DAY: "DAY";
  readonly MONTH: "MONTH";
  readonly WEEK: "WEEK";
};
export type ReportFrequencyType =
  (typeof ReportFrequencyType)[keyof typeof ReportFrequencyType];
export interface ReportFrequency {
  value?: number;
  period?: ReportFrequencyType;
}
export declare const ReportType: {
  readonly LICENSE_CONFIGURATION_SUMMARY_REPORT: "LicenseConfigurationSummaryReport";
  readonly LICENSE_CONFIGURATION_USAGE_REPORT: "LicenseConfigurationUsageReport";
};
export type ReportType = (typeof ReportType)[keyof typeof ReportType];
export interface CreateLicenseManagerReportGeneratorRequest {
  ReportGeneratorName: string | undefined;
  Type: ReportType[] | undefined;
  ReportContext: ReportContext | undefined;
  ReportFrequency: ReportFrequency | undefined;
  ClientToken: string | undefined;
  Description?: string;
  Tags?: Tag[];
}
export interface CreateLicenseManagerReportGeneratorResponse {
  LicenseManagerReportGeneratorArn?: string;
}
export interface CreateLicenseVersionRequest {
  LicenseArn: string | undefined;
  LicenseName: string | undefined;
  ProductName: string | undefined;
  Issuer: Issuer | undefined;
  HomeRegion: string | undefined;
  Validity: DatetimeRange | undefined;
  LicenseMetadata?: Metadata[];
  Entitlements: Entitlement[] | undefined;
  ConsumptionConfiguration: ConsumptionConfiguration | undefined;
  Status: LicenseStatus | undefined;
  ClientToken: string | undefined;
  SourceVersion?: string;
}
export interface CreateLicenseVersionResponse {
  LicenseArn?: string;
  Version?: string;
  Status?: LicenseStatus;
}
export interface CreateTokenRequest {
  LicenseArn: string | undefined;
  RoleArns?: string[];
  ExpirationInDays?: number;
  TokenProperties?: string[];
  ClientToken: string | undefined;
}
export declare const TokenType: {
  readonly REFRESH_TOKEN: "REFRESH_TOKEN";
};
export type TokenType = (typeof TokenType)[keyof typeof TokenType];
export interface CreateTokenResponse {
  TokenId?: string;
  TokenType?: TokenType;
  Token?: string;
}
export interface DeleteGrantRequest {
  GrantArn: string | undefined;
  StatusReason?: string;
  Version: string | undefined;
}
export interface DeleteGrantResponse {
  GrantArn?: string;
  Status?: GrantStatus;
  Version?: string;
}
export interface DeleteLicenseRequest {
  LicenseArn: string | undefined;
  SourceVersion: string | undefined;
}
export declare const LicenseDeletionStatus: {
  readonly DELETED: "DELETED";
  readonly PENDING_DELETE: "PENDING_DELETE";
};
export type LicenseDeletionStatus =
  (typeof LicenseDeletionStatus)[keyof typeof LicenseDeletionStatus];
export interface DeleteLicenseResponse {
  Status?: LicenseDeletionStatus;
  DeletionDate?: string;
}
export interface DeleteLicenseConfigurationRequest {
  LicenseConfigurationArn: string | undefined;
}
export interface DeleteLicenseConfigurationResponse {}
export interface DeleteLicenseManagerReportGeneratorRequest {
  LicenseManagerReportGeneratorArn: string | undefined;
}
export interface DeleteLicenseManagerReportGeneratorResponse {}
export interface DeleteTokenRequest {
  TokenId: string | undefined;
}
export interface DeleteTokenResponse {}
export interface ExtendLicenseConsumptionRequest {
  LicenseConsumptionToken: string | undefined;
  DryRun?: boolean;
}
export interface ExtendLicenseConsumptionResponse {
  LicenseConsumptionToken?: string;
  Expiration?: string;
}
export interface GetAccessTokenRequest {
  Token: string | undefined;
  TokenProperties?: string[];
}
export interface GetAccessTokenResponse {
  AccessToken?: string;
}
export interface GetGrantRequest {
  GrantArn: string | undefined;
  Version?: string;
}
export interface Grant {
  GrantArn: string | undefined;
  GrantName: string | undefined;
  ParentArn: string | undefined;
  LicenseArn: string | undefined;
  GranteePrincipalArn: string | undefined;
  HomeRegion: string | undefined;
  GrantStatus: GrantStatus | undefined;
  StatusReason?: string;
  Version: string | undefined;
  GrantedOperations: AllowedOperation[] | undefined;
  Options?: Options;
}
export interface GetGrantResponse {
  Grant?: Grant;
}
export interface GetLicenseRequest {
  LicenseArn: string | undefined;
  Version?: string;
}
export interface IssuerDetails {
  Name?: string;
  SignKey?: string;
  KeyFingerprint?: string;
}
export interface License {
  LicenseArn?: string;
  LicenseName?: string;
  ProductName?: string;
  ProductSKU?: string;
  Issuer?: IssuerDetails;
  HomeRegion?: string;
  Status?: LicenseStatus;
  Validity?: DatetimeRange;
  Beneficiary?: string;
  Entitlements?: Entitlement[];
  ConsumptionConfiguration?: ConsumptionConfiguration;
  LicenseMetadata?: Metadata[];
  CreateTime?: string;
  Version?: string;
}
export interface GetLicenseResponse {
  License?: License;
}
export interface GetLicenseConfigurationRequest {
  LicenseConfigurationArn: string | undefined;
}
export declare const ResourceType: {
  readonly EC2_AMI: "EC2_AMI";
  readonly EC2_HOST: "EC2_HOST";
  readonly EC2_INSTANCE: "EC2_INSTANCE";
  readonly RDS: "RDS";
  readonly SYSTEMS_MANAGER_MANAGED_INSTANCE: "SYSTEMS_MANAGER_MANAGED_INSTANCE";
};
export type ResourceType = (typeof ResourceType)[keyof typeof ResourceType];
export interface ConsumedLicenseSummary {
  ResourceType?: ResourceType;
  ConsumedLicenses?: number;
}
export interface ManagedResourceSummary {
  ResourceType?: ResourceType;
  AssociationCount?: number;
}
export interface GetLicenseConfigurationResponse {
  LicenseConfigurationId?: string;
  LicenseConfigurationArn?: string;
  Name?: string;
  Description?: string;
  LicenseCountingType?: LicenseCountingType;
  LicenseRules?: string[];
  LicenseCount?: number;
  LicenseCountHardLimit?: boolean;
  ConsumedLicenses?: number;
  Status?: string;
  OwnerAccountId?: string;
  ConsumedLicenseSummaryList?: ConsumedLicenseSummary[];
  ManagedResourceSummaryList?: ManagedResourceSummary[];
  Tags?: Tag[];
  ProductInformationList?: ProductInformation[];
  AutomatedDiscoveryInformation?: AutomatedDiscoveryInformation;
  DisassociateWhenNotFound?: boolean;
}
export interface GetLicenseConversionTaskRequest {
  LicenseConversionTaskId: string | undefined;
}
export declare const LicenseConversionTaskStatus: {
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type LicenseConversionTaskStatus =
  (typeof LicenseConversionTaskStatus)[keyof typeof LicenseConversionTaskStatus];
export interface GetLicenseConversionTaskResponse {
  LicenseConversionTaskId?: string;
  ResourceArn?: string;
  SourceLicenseContext?: LicenseConversionContext;
  DestinationLicenseContext?: LicenseConversionContext;
  StatusMessage?: string;
  Status?: LicenseConversionTaskStatus;
  StartTime?: Date;
  LicenseConversionTime?: Date;
  EndTime?: Date;
}
export interface GetLicenseManagerReportGeneratorRequest {
  LicenseManagerReportGeneratorArn: string | undefined;
}
export interface S3Location {
  bucket?: string;
  keyPrefix?: string;
}
export interface ReportGenerator {
  ReportGeneratorName?: string;
  ReportType?: ReportType[];
  ReportContext?: ReportContext;
  ReportFrequency?: ReportFrequency;
  LicenseManagerReportGeneratorArn?: string;
  LastRunStatus?: string;
  LastRunFailureReason?: string;
  LastReportGenerationTime?: string;
  ReportCreatorAccount?: string;
  Description?: string;
  S3Location?: S3Location;
  CreateTime?: string;
  Tags?: Tag[];
}
export interface GetLicenseManagerReportGeneratorResponse {
  ReportGenerator?: ReportGenerator;
}
export interface GetLicenseUsageRequest {
  LicenseArn: string | undefined;
}
export interface EntitlementUsage {
  Name: string | undefined;
  ConsumedValue: string | undefined;
  MaxCount?: string;
  Unit: EntitlementDataUnit | undefined;
}
export interface LicenseUsage {
  EntitlementUsages?: EntitlementUsage[];
}
export interface GetLicenseUsageResponse {
  LicenseUsage?: LicenseUsage;
}
export interface GetServiceSettingsRequest {}
export interface OrganizationConfiguration {
  EnableIntegration: boolean | undefined;
}
export interface GetServiceSettingsResponse {
  S3BucketArn?: string;
  SnsTopicArn?: string;
  OrganizationConfiguration?: OrganizationConfiguration;
  EnableCrossAccountsDiscovery?: boolean;
  LicenseManagerResourceShareArn?: string;
}
export declare class FilterLimitExceededException extends __BaseException {
  readonly name: "FilterLimitExceededException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<FilterLimitExceededException, __BaseException>
  );
}
export interface ListAssociationsForLicenseConfigurationRequest {
  LicenseConfigurationArn: string | undefined;
  MaxResults?: number;
  NextToken?: string;
}
export interface LicenseConfigurationAssociation {
  ResourceArn?: string;
  ResourceType?: ResourceType;
  ResourceOwnerId?: string;
  AssociationTime?: Date;
  AmiAssociationScope?: string;
}
export interface ListAssociationsForLicenseConfigurationResponse {
  LicenseConfigurationAssociations?: LicenseConfigurationAssociation[];
  NextToken?: string;
}
export interface Filter {
  Name?: string;
  Values?: string[];
}
export interface ListDistributedGrantsRequest {
  GrantArns?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListDistributedGrantsResponse {
  Grants?: Grant[];
  NextToken?: string;
}
export interface ListFailuresForLicenseConfigurationOperationsRequest {
  LicenseConfigurationArn: string | undefined;
  MaxResults?: number;
  NextToken?: string;
}
export interface LicenseOperationFailure {
  ResourceArn?: string;
  ResourceType?: ResourceType;
  ErrorMessage?: string;
  FailureTime?: Date;
  OperationName?: string;
  ResourceOwnerId?: string;
  OperationRequestedBy?: string;
  MetadataList?: Metadata[];
}
export interface ListFailuresForLicenseConfigurationOperationsResponse {
  LicenseOperationFailureList?: LicenseOperationFailure[];
  NextToken?: string;
}
export interface ListLicenseConfigurationsRequest {
  LicenseConfigurationArns?: string[];
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
}
export interface LicenseConfiguration {
  LicenseConfigurationId?: string;
  LicenseConfigurationArn?: string;
  Name?: string;
  Description?: string;
  LicenseCountingType?: LicenseCountingType;
  LicenseRules?: string[];
  LicenseCount?: number;
  LicenseCountHardLimit?: boolean;
  DisassociateWhenNotFound?: boolean;
  ConsumedLicenses?: number;
  Status?: string;
  OwnerAccountId?: string;
  ConsumedLicenseSummaryList?: ConsumedLicenseSummary[];
  ManagedResourceSummaryList?: ManagedResourceSummary[];
  ProductInformationList?: ProductInformation[];
  AutomatedDiscoveryInformation?: AutomatedDiscoveryInformation;
}
export interface ListLicenseConfigurationsResponse {
  LicenseConfigurations?: LicenseConfiguration[];
  NextToken?: string;
}
export interface ListLicenseConversionTasksRequest {
  NextToken?: string;
  MaxResults?: number;
  Filters?: Filter[];
}
export interface LicenseConversionTask {
  LicenseConversionTaskId?: string;
  ResourceArn?: string;
  SourceLicenseContext?: LicenseConversionContext;
  DestinationLicenseContext?: LicenseConversionContext;
  Status?: LicenseConversionTaskStatus;
  StatusMessage?: string;
  StartTime?: Date;
  LicenseConversionTime?: Date;
  EndTime?: Date;
}
export interface ListLicenseConversionTasksResponse {
  LicenseConversionTasks?: LicenseConversionTask[];
  NextToken?: string;
}
export interface ListLicenseManagerReportGeneratorsRequest {
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListLicenseManagerReportGeneratorsResponse {
  ReportGenerators?: ReportGenerator[];
  NextToken?: string;
}
export interface ListLicensesRequest {
  LicenseArns?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListLicensesResponse {
  Licenses?: License[];
  NextToken?: string;
}
export interface ListLicenseSpecificationsForResourceRequest {
  ResourceArn: string | undefined;
  MaxResults?: number;
  NextToken?: string;
}
export interface LicenseSpecification {
  LicenseConfigurationArn: string | undefined;
  AmiAssociationScope?: string;
}
export interface ListLicenseSpecificationsForResourceResponse {
  LicenseSpecifications?: LicenseSpecification[];
  NextToken?: string;
}
export interface ListLicenseVersionsRequest {
  LicenseArn: string | undefined;
  NextToken?: string;
  MaxResults?: number;
}
export interface ListLicenseVersionsResponse {
  Licenses?: License[];
  NextToken?: string;
}
export interface ListReceivedGrantsRequest {
  GrantArns?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListReceivedGrantsResponse {
  Grants?: Grant[];
  NextToken?: string;
}
export interface ListReceivedGrantsForOrganizationRequest {
  LicenseArn: string | undefined;
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListReceivedGrantsForOrganizationResponse {
  Grants?: Grant[];
  NextToken?: string;
}
export interface ListReceivedLicensesRequest {
  LicenseArns?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export declare const ReceivedStatus: {
  readonly ACTIVE: "ACTIVE";
  readonly DELETED: "DELETED";
  readonly DISABLED: "DISABLED";
  readonly FAILED_WORKFLOW: "FAILED_WORKFLOW";
  readonly PENDING_ACCEPT: "PENDING_ACCEPT";
  readonly PENDING_WORKFLOW: "PENDING_WORKFLOW";
  readonly REJECTED: "REJECTED";
  readonly WORKFLOW_COMPLETED: "WORKFLOW_COMPLETED";
};
export type ReceivedStatus =
  (typeof ReceivedStatus)[keyof typeof ReceivedStatus];
export interface ReceivedMetadata {
  ReceivedStatus?: ReceivedStatus;
  ReceivedStatusReason?: string;
  AllowedOperations?: AllowedOperation[];
}
export interface GrantedLicense {
  LicenseArn?: string;
  LicenseName?: string;
  ProductName?: string;
  ProductSKU?: string;
  Issuer?: IssuerDetails;
  HomeRegion?: string;
  Status?: LicenseStatus;
  Validity?: DatetimeRange;
  Beneficiary?: string;
  Entitlements?: Entitlement[];
  ConsumptionConfiguration?: ConsumptionConfiguration;
  LicenseMetadata?: Metadata[];
  CreateTime?: string;
  Version?: string;
  ReceivedMetadata?: ReceivedMetadata;
}
export interface ListReceivedLicensesResponse {
  Licenses?: GrantedLicense[];
  NextToken?: string;
}
export interface ListReceivedLicensesForOrganizationRequest {
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface ListReceivedLicensesForOrganizationResponse {
  Licenses?: GrantedLicense[];
  NextToken?: string;
}
export declare class FailedDependencyException extends __BaseException {
  readonly name: "FailedDependencyException";
  readonly $fault: "client";
  Message?: string;
  ErrorCode?: string;
  constructor(
    opts: __ExceptionOptionType<FailedDependencyException, __BaseException>
  );
}
export declare const InventoryFilterCondition: {
  readonly BEGINS_WITH: "BEGINS_WITH";
  readonly CONTAINS: "CONTAINS";
  readonly EQUALS: "EQUALS";
  readonly NOT_EQUALS: "NOT_EQUALS";
};
export type InventoryFilterCondition =
  (typeof InventoryFilterCondition)[keyof typeof InventoryFilterCondition];
export interface InventoryFilter {
  Name: string | undefined;
  Condition: InventoryFilterCondition | undefined;
  Value?: string;
}
export interface ListResourceInventoryRequest {
  MaxResults?: number;
  NextToken?: string;
  Filters?: InventoryFilter[];
}
export interface ResourceInventory {
  ResourceId?: string;
  ResourceType?: ResourceType;
  ResourceArn?: string;
  Platform?: string;
  PlatformVersion?: string;
  ResourceOwningAccountId?: string;
}
export interface ListResourceInventoryResponse {
  ResourceInventoryList?: ResourceInventory[];
  NextToken?: string;
}
export interface ListTagsForResourceRequest {
  ResourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  Tags?: Tag[];
}
export interface ListTokensRequest {
  TokenIds?: string[];
  Filters?: Filter[];
  NextToken?: string;
  MaxResults?: number;
}
export interface TokenData {
  TokenId?: string;
  TokenType?: string;
  LicenseArn?: string;
  ExpirationTime?: string;
  TokenProperties?: string[];
  RoleArns?: string[];
  Status?: string;
}
export interface ListTokensResponse {
  Tokens?: TokenData[];
  NextToken?: string;
}
export interface ListUsageForLicenseConfigurationRequest {
  LicenseConfigurationArn: string | undefined;
  MaxResults?: number;
  NextToken?: string;
  Filters?: Filter[];
}
export interface LicenseConfigurationUsage {
  ResourceArn?: string;
  ResourceType?: ResourceType;
  ResourceStatus?: string;
  ResourceOwnerId?: string;
  AssociationTime?: Date;
  ConsumedLicenses?: number;
}
export interface ListUsageForLicenseConfigurationResponse {
  LicenseConfigurationUsageList?: LicenseConfigurationUsage[];
  NextToken?: string;
}
export interface RejectGrantRequest {
  GrantArn: string | undefined;
}
export interface RejectGrantResponse {
  GrantArn?: string;
  Status?: GrantStatus;
  Version?: string;
}
export interface TagResourceRequest {
  ResourceArn: string | undefined;
  Tags: Tag[] | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  ResourceArn: string | undefined;
  TagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export declare const LicenseConfigurationStatus: {
  readonly AVAILABLE: "AVAILABLE";
  readonly DISABLED: "DISABLED";
};
export type LicenseConfigurationStatus =
  (typeof LicenseConfigurationStatus)[keyof typeof LicenseConfigurationStatus];
export interface UpdateLicenseConfigurationRequest {
  LicenseConfigurationArn: string | undefined;
  LicenseConfigurationStatus?: LicenseConfigurationStatus;
  LicenseRules?: string[];
  LicenseCount?: number;
  LicenseCountHardLimit?: boolean;
  Name?: string;
  Description?: string;
  ProductInformationList?: ProductInformation[];
  DisassociateWhenNotFound?: boolean;
}
export interface UpdateLicenseConfigurationResponse {}
export interface UpdateLicenseManagerReportGeneratorRequest {
  LicenseManagerReportGeneratorArn: string | undefined;
  ReportGeneratorName: string | undefined;
  Type: ReportType[] | undefined;
  ReportContext: ReportContext | undefined;
  ReportFrequency: ReportFrequency | undefined;
  ClientToken: string | undefined;
  Description?: string;
}
export interface UpdateLicenseManagerReportGeneratorResponse {}
export declare class InvalidResourceStateException extends __BaseException {
  readonly name: "InvalidResourceStateException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidResourceStateException, __BaseException>
  );
}
export declare class LicenseUsageException extends __BaseException {
  readonly name: "LicenseUsageException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<LicenseUsageException, __BaseException>
  );
}
export interface UpdateLicenseSpecificationsForResourceRequest {
  ResourceArn: string | undefined;
  AddLicenseSpecifications?: LicenseSpecification[];
  RemoveLicenseSpecifications?: LicenseSpecification[];
}
export interface UpdateLicenseSpecificationsForResourceResponse {}
export interface UpdateServiceSettingsRequest {
  S3BucketArn?: string;
  SnsTopicArn?: string;
  OrganizationConfiguration?: OrganizationConfiguration;
  EnableCrossAccountsDiscovery?: boolean;
}
export interface UpdateServiceSettingsResponse {}
