import { requestBuilder as rb } from "@smithy/core";
import { isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { AccessDeniedException, InternalServerException, ResourceNotFoundException, ValidationException, } from "../models/models_0";
import { MWAAServiceException as __BaseException } from "../models/MWAAServiceException";
export const se_CreateCliTokenCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/clitoken/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "env." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/environments/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = JSON.stringify(take(input, {
        AirflowConfigurationOptions: (_) => _json(_),
        AirflowVersion: [],
        DagS3Path: [],
        EndpointManagement: [],
        EnvironmentClass: [],
        ExecutionRoleArn: [],
        KmsKey: [],
        LoggingConfiguration: (_) => _json(_),
        MaxWorkers: [],
        MinWorkers: [],
        NetworkConfiguration: (_) => _json(_),
        PluginsS3ObjectVersion: [],
        PluginsS3Path: [],
        RequirementsS3ObjectVersion: [],
        RequirementsS3Path: [],
        Schedulers: [],
        SourceBucketArn: [],
        StartupScriptS3ObjectVersion: [],
        StartupScriptS3Path: [],
        Tags: (_) => _json(_),
        WebserverAccessMode: [],
        WeeklyMaintenanceWindowStart: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateWebLoginTokenCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/webtoken/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "env." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environments/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_GetEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environments/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListEnvironmentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/environments");
    const query = map({
        [_NT]: [, input[_NT]],
        [_MR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_PublishMetricsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/metrics/environments/{EnvironmentName}");
    b.p("EnvironmentName", () => input.EnvironmentName, "{EnvironmentName}", false);
    let body;
    body = JSON.stringify(take(input, {
        MetricData: (_) => se_MetricData(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "ops." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        Tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateEnvironmentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/environments/{Name}");
    b.p("Name", () => input.Name, "{Name}", false);
    let body;
    body = JSON.stringify(take(input, {
        AirflowConfigurationOptions: (_) => _json(_),
        AirflowVersion: [],
        DagS3Path: [],
        EnvironmentClass: [],
        ExecutionRoleArn: [],
        LoggingConfiguration: (_) => _json(_),
        MaxWorkers: [],
        MinWorkers: [],
        NetworkConfiguration: (_) => _json(_),
        PluginsS3ObjectVersion: [],
        PluginsS3Path: [],
        RequirementsS3ObjectVersion: [],
        RequirementsS3Path: [],
        Schedulers: [],
        SourceBucketArn: [],
        StartupScriptS3ObjectVersion: [],
        StartupScriptS3Path: [],
        WebserverAccessMode: [],
        WeeklyMaintenanceWindowStart: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const de_CreateCliTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CliToken: __expectString,
        WebServerHostname: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateWebLoginTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AirflowIdentity: __expectString,
        IamIdentity: __expectString,
        WebServerHostname: __expectString,
        WebToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Environment: (_) => de_Environment(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEnvironmentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Environments: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PublishMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateEnvironmentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceNotFoundException":
        case "com.amazonaws.mwaa#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.mwaa#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.mwaa#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "AccessDeniedException":
        case "com.amazonaws.mwaa#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_MetricData = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_MetricDatum(entry, context);
    });
};
const se_MetricDatum = (input, context) => {
    return take(input, {
        Dimensions: _json,
        MetricName: [],
        StatisticValues: (_) => se_StatisticSet(_, context),
        Timestamp: (_) => Math.round(_.getTime() / 1000),
        Unit: [],
        Value: __serializeFloat,
    });
};
const se_StatisticSet = (input, context) => {
    return take(input, {
        Maximum: __serializeFloat,
        Minimum: __serializeFloat,
        SampleCount: [],
        Sum: __serializeFloat,
    });
};
const de_Environment = (output, context) => {
    return take(output, {
        AirflowConfigurationOptions: _json,
        AirflowVersion: __expectString,
        Arn: __expectString,
        CeleryExecutorQueue: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DagS3Path: __expectString,
        DatabaseVpcEndpointService: __expectString,
        EndpointManagement: __expectString,
        EnvironmentClass: __expectString,
        ExecutionRoleArn: __expectString,
        KmsKey: __expectString,
        LastUpdate: (_) => de_LastUpdate(_, context),
        LoggingConfiguration: _json,
        MaxWorkers: __expectInt32,
        MinWorkers: __expectInt32,
        Name: __expectString,
        NetworkConfiguration: _json,
        PluginsS3ObjectVersion: __expectString,
        PluginsS3Path: __expectString,
        RequirementsS3ObjectVersion: __expectString,
        RequirementsS3Path: __expectString,
        Schedulers: __expectInt32,
        ServiceRoleArn: __expectString,
        SourceBucketArn: __expectString,
        StartupScriptS3ObjectVersion: __expectString,
        StartupScriptS3Path: __expectString,
        Status: __expectString,
        Tags: _json,
        WebserverAccessMode: __expectString,
        WebserverUrl: __expectString,
        WebserverVpcEndpointService: __expectString,
        WeeklyMaintenanceWindowStart: __expectString,
    });
};
const de_LastUpdate = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Error: _json,
        Source: __expectString,
        Status: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _MR = "MaxResults";
const _NT = "NextToken";
const _tK = "tagKeys";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
