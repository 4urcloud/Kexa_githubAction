import { ExceptionOptionType as __ExceptionOptionType } from "@aws-sdk/smithy-client";
import { RedshiftServerlessServiceException as __BaseException } from "./RedshiftServerlessServiceException";
/**
 * <p>You do not have sufficient access to perform this action.</p>
 */
export declare class AccessDeniedException extends __BaseException {
    readonly name: "AccessDeniedException";
    readonly $fault: "client";
    code?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<AccessDeniedException, __BaseException>);
}
/**
 * <p>An array of key-value pairs to set for advanced control over Amazon Redshift Serverless.</p>
 */
export interface ConfigParameter {
    /**
     * <p>The key of the parameter. The
     *          options are <code>datestyle</code>, <code>enable_user_activity_logging</code>,
     *          <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
     */
    parameterKey?: string;
    /**
     * <p>The value of the parameter to set.</p>
     */
    parameterValue?: string;
}
export declare namespace ConfigParameter {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ConfigParameter) => any;
}
/**
 * <p>The submitted action has conflicts.</p>
 */
export declare class ConflictException extends __BaseException {
    readonly name: "ConflictException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface ConvertRecoveryPointToSnapshotRequest {
    /**
     * <p>The unique identifier of the recovery point.</p>
     */
    recoveryPointId: string | undefined;
    /**
     * <p>The name of the snapshot.</p>
     */
    snapshotName: string | undefined;
    /**
     * <p>How long to retain the snapshot.</p>
     */
    retentionPeriod?: number;
}
export declare namespace ConvertRecoveryPointToSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ConvertRecoveryPointToSnapshotRequest) => any;
}
export declare enum SnapshotStatus {
    AVAILABLE = "AVAILABLE",
    CANCELLED = "CANCELLED",
    COPYING = "COPYING",
    CREATING = "CREATING",
    DELETED = "DELETED",
    FAILED = "FAILED"
}
/**
 * <p>A snapshot object that contains databases.</p>
 */
export interface Snapshot {
    /**
     * <p>The name of the namepsace.</p>
     */
    namespaceName?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the namespace the snapshot was created from.</p>
     */
    namespaceArn?: string;
    /**
     * <p>The name of the snapshot.</p>
     */
    snapshotName?: string;
    /**
     * <p>The timestamp of when the snapshot was created.</p>
     */
    snapshotCreateTime?: Date;
    /**
     * <p>The username of the database within a snapshot.</p>
     */
    adminUsername?: string;
    /**
     * <p>The status of the snapshot.</p>
     */
    status?: SnapshotStatus | string;
    /**
     * <p>The unique identifier of the KMS key used to encrypt the snapshot.</p>
     */
    kmsKeyId?: string;
    /**
     * <p>The owner Amazon Web Services; account of the snapshot.</p>
     */
    ownerAccount?: string;
    /**
     * <p>The total size, in megabytes, of how big the snapshot is.</p>
     */
    totalBackupSizeInMegaBytes?: number;
    /**
     * <p>The size of the incremental backup in megabytes.</p>
     */
    actualIncrementalBackupSizeInMegaBytes?: number;
    /**
     * <p>The size in megabytes of the data that has been backed up to a snapshot.</p>
     */
    backupProgressInMegaBytes?: number;
    /**
     * <p>The rate at which data is backed up into a snapshot in megabytes per second.</p>
     */
    currentBackupRateInMegaBytesPerSecond?: number;
    /**
     * <p>The estimated amount of seconds until the snapshot completes backup.</p>
     */
    estimatedSecondsToCompletion?: number;
    /**
     * <p>The amount of time it took to back up data into a snapshot.</p>
     */
    elapsedTimeInSeconds?: number;
    /**
     * <p>The period of time, in days, of how long the snapshot is retained.</p>
     */
    snapshotRetentionPeriod?: number;
    /**
     * <p>The amount of days until the snapshot is deleted.</p>
     */
    snapshotRemainingDays?: number;
    /**
     * <p>The timestamp of when data within the snapshot started getting retained.</p>
     */
    snapshotRetentionStartTime?: Date;
    /**
     * <p>The Amazon Resource Name (ARN) of the snapshot.</p>
     */
    snapshotArn?: string;
    /**
     * <p>All of the Amazon Web Services accounts that have access to
     *          restore a snapshot to a namespace.</p>
     */
    accountsWithRestoreAccess?: string[];
    /**
     * <p>All of the Amazon Web Services accounts that have access to restore a snapshot to a provisioned cluster.</p>
     */
    accountsWithProvisionedRestoreAccess?: string[];
}
export declare namespace Snapshot {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: Snapshot) => any;
}
export interface ConvertRecoveryPointToSnapshotResponse {
    /**
     * <p>The snapshot converted from the recovery point.</p>
     */
    snapshot?: Snapshot;
}
export declare namespace ConvertRecoveryPointToSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ConvertRecoveryPointToSnapshotResponse) => any;
}
/**
 * <p>The request processing has failed because of an unknown error, exception or failure.</p>
 */
export declare class InternalServerException extends __BaseException {
    readonly name: "InternalServerException";
    readonly $fault: "server";
    $retryable: {};
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InternalServerException, __BaseException>);
}
/**
 * <p>The resource could not be found.</p>
 */
export declare class ResourceNotFoundException extends __BaseException {
    readonly name: "ResourceNotFoundException";
    readonly $fault: "client";
    /**
     * <p>The name of the resource that could not be found.</p>
     */
    resourceName?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>);
}
/**
 * <p>The service limit was exceeded.</p>
 */
export declare class ServiceQuotaExceededException extends __BaseException {
    readonly name: "ServiceQuotaExceededException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>);
}
/**
 * <p>The input failed to satisfy the constraints specified by an AWS service.</p>
 */
export declare class ValidationException extends __BaseException {
    readonly name: "ValidationException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ValidationException, __BaseException>);
}
export interface CreateEndpointAccessRequest {
    /**
     * <p>The name of the VPC endpoint. An endpoint name must contain 1-30 characters.
     *          Valid characters are A-Z, a-z, 0-9, and hyphen(-). The first character must be a letter.
     *          The name can't contain two consecutive hyphens or end with a hyphen.</p>
     */
    endpointName: string | undefined;
    /**
     * <p>The unique identifers of subnets from which
     *          Amazon Redshift Serverless chooses one to deploy a VPC endpoint.</p>
     */
    subnetIds: string[] | undefined;
    /**
     * <p>The name of the workgroup to associate with the VPC endpoint.</p>
     */
    workgroupName: string | undefined;
    /**
     * <p>The unique identifiers of the security group that defines the ports,
     *          protocols, and sources for inbound traffic that you are authorizing into your endpoint.</p>
     */
    vpcSecurityGroupIds?: string[];
}
export declare namespace CreateEndpointAccessRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateEndpointAccessRequest) => any;
}
/**
 * <p>Contains information about a network interface
 *          in an Amazon Redshift Serverless managed VPC endpoint.
 *       </p>
 */
export interface NetworkInterface {
    /**
     * <p>The unique identifier of the network interface.</p>
     */
    networkInterfaceId?: string;
    /**
     * <p>The unique identifier of the subnet.</p>
     */
    subnetId?: string;
    /**
     * <p>The IPv4 address of the network interface within the subnet.</p>
     */
    privateIpAddress?: string;
    /**
     * <p>The availability Zone.</p>
     */
    availabilityZone?: string;
}
export declare namespace NetworkInterface {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: NetworkInterface) => any;
}
/**
 * <p>The connection endpoint for connecting to Amazon Redshift Serverless through the proxy.</p>
 */
export interface VpcEndpoint {
    /**
     * <p>The connection endpoint ID for connecting to Amazon Redshift Serverless.</p>
     */
    vpcEndpointId?: string;
    /**
     * <p>The VPC identifier that the endpoint is associated with.</p>
     */
    vpcId?: string;
    /**
     * <p>One or more network interfaces of the endpoint. Also known as an interface endpoint.</p>
     */
    networkInterfaces?: NetworkInterface[];
}
export declare namespace VpcEndpoint {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: VpcEndpoint) => any;
}
/**
 * <p>Describes the members of a VPC security group.</p>
 */
export interface VpcSecurityGroupMembership {
    /**
     * <p>The unique identifier of the VPC security group.</p>
     */
    vpcSecurityGroupId?: string;
    /**
     * <p>The status of the VPC security group.</p>
     */
    status?: string;
}
export declare namespace VpcSecurityGroupMembership {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: VpcSecurityGroupMembership) => any;
}
/**
 * <p>Information about an Amazon Redshift Serverless VPC endpoint.</p>
 */
export interface EndpointAccess {
    /**
     * <p>The name of the VPC endpoint.</p>
     */
    endpointName?: string;
    /**
     * <p>The status of the VPC endpoint.</p>
     */
    endpointStatus?: string;
    /**
     * <p>The name of the workgroup associated with the endpoint.</p>
     */
    workgroupName?: string;
    /**
     * <p>The time that the endpoint was created.</p>
     */
    endpointCreateTime?: Date;
    /**
     * <p>The port number on which Amazon Redshift Serverless accepts incoming connections.</p>
     */
    port?: number;
    /**
     * <p>The DNS address of the endpoint.</p>
     */
    address?: string;
    /**
     * <p>The unique identifier of subnets
     *          where Amazon Redshift Serverless choose to deploy the VPC endpoint.</p>
     */
    subnetIds?: string[];
    /**
     * <p>The security groups associated with the endpoint.</p>
     */
    vpcSecurityGroups?: VpcSecurityGroupMembership[];
    /**
     * <p>The connection endpoint for connecting to Amazon Redshift Serverless.</p>
     */
    vpcEndpoint?: VpcEndpoint;
    /**
     * <p>The Amazon Resource Name (ARN) of the VPC endpoint.</p>
     */
    endpointArn?: string;
}
export declare namespace EndpointAccess {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: EndpointAccess) => any;
}
export interface CreateEndpointAccessResponse {
    /**
     * <p>The created VPC endpoint.</p>
     */
    endpoint?: EndpointAccess;
}
export declare namespace CreateEndpointAccessResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateEndpointAccessResponse) => any;
}
export declare enum LogExport {
    CONNECTION_LOG = "connectionlog",
    USER_ACTIVITY_LOG = "useractivitylog",
    USER_LOG = "userlog"
}
/**
 * <p>A map of key-value pairs.</p>
 */
export interface Tag {
    /**
     * <p>The key to use in the tag.</p>
     */
    key: string | undefined;
    /**
     * <p>The value of the tag.</p>
     */
    value: string | undefined;
}
export declare namespace Tag {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: Tag) => any;
}
export interface CreateNamespaceRequest {
    /**
     * <p>The name of the namespace.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The username of the administrator for the first database created in the namespace.</p>
     */
    adminUsername?: string;
    /**
     * <p>The password of the administrator for the first database created in the namespace.</p>
     */
    adminUserPassword?: string;
    /**
     * <p>The name of the first database created in the namespace.</p>
     */
    dbName?: string;
    /**
     * <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
     */
    kmsKeyId?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
     */
    defaultIamRoleArn?: string;
    /**
     * <p>A list of IAM roles to associate with the namespace.</p>
     */
    iamRoles?: string[];
    /**
     * <p>The types of logs the namespace can export.
     *          Available export types are <code>userlog</code>, <code>connectionlog</code>, and <code>useractivitylog</code>.</p>
     */
    logExports?: (LogExport | string)[];
    /**
     * <p>A list of tag instances.</p>
     */
    tags?: Tag[];
}
export declare namespace CreateNamespaceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateNamespaceRequest) => any;
}
export declare enum NamespaceStatus {
    AVAILABLE = "AVAILABLE",
    DELETING = "DELETING",
    MODIFYING = "MODIFYING"
}
/**
 * <p>A collection of database objects and users.</p>
 */
export interface Namespace {
    /**
     * <p>The Amazon Resource Name (ARN) associated with a namespace.</p>
     */
    namespaceArn?: string;
    /**
     * <p>The unique identifier of a namespace.</p>
     */
    namespaceId?: string;
    /**
     * <p>The name of the namespace.
     *       Must be between 3-64 alphanumeric characters in lowercase,
     *       and it cannot be a reserved word. A list of reserved words can be found
     *       in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words</a> in the Amazon Redshift Database Developer Guide.</p>
     */
    namespaceName?: string;
    /**
     * <p>The username of the administrator for the first database created in the namespace.</p>
     */
    adminUsername?: string;
    /**
     * <p>The name of the first database created in the namespace.</p>
     */
    dbName?: string;
    /**
     * <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
     */
    kmsKeyId?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
     */
    defaultIamRoleArn?: string;
    /**
     * <p>A list of IAM roles to associate with the namespace.</p>
     */
    iamRoles?: string[];
    /**
     * <p>The types of logs the namespace can export. Available export types are User log, Connection log, and User activity log.</p>
     */
    logExports?: (LogExport | string)[];
    /**
     * <p>The status of the namespace.</p>
     */
    status?: NamespaceStatus | string;
    /**
     * <p>The date of when the namespace was created.</p>
     */
    creationDate?: Date;
}
export declare namespace Namespace {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: Namespace) => any;
}
export interface CreateNamespaceResponse {
    /**
     * <p>The created namespace object.</p>
     */
    namespace?: Namespace;
}
export declare namespace CreateNamespaceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateNamespaceResponse) => any;
}
/**
 * <p>The request exceeded the number of tags allowed for a resource.</p>
 */
export declare class TooManyTagsException extends __BaseException {
    readonly name: "TooManyTagsException";
    readonly $fault: "client";
    /**
     * <p>The name of the resource that exceeded the number of tags allowed for a resource.</p>
     */
    resourceName?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<TooManyTagsException, __BaseException>);
}
export interface CreateSnapshotRequest {
    /**
     * <p>The namespace to create a snapshot for.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The name of the snapshot.</p>
     */
    snapshotName: string | undefined;
    /**
     * <p>How long to retain the created snapshot.</p>
     */
    retentionPeriod?: number;
}
export declare namespace CreateSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateSnapshotRequest) => any;
}
export interface CreateSnapshotResponse {
    /**
     * <p>The created snapshot object.</p>
     */
    snapshot?: Snapshot;
}
export declare namespace CreateSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateSnapshotResponse) => any;
}
export declare enum UsageLimitBreachAction {
    DEACTIVATE = "deactivate",
    EMIT_METRIC = "emit-metric",
    LOG = "log"
}
export declare enum UsageLimitPeriod {
    DAILY = "daily",
    MONTHLY = "monthly",
    WEEKLY = "weekly"
}
export declare enum UsageLimitUsageType {
    CROSS_REGION_DATASHARING = "cross-region-datasharing",
    SERVERLESS_COMPUTE = "serverless-compute"
}
export interface CreateUsageLimitRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the Amazon Redshift Serverless resource to create the usage limit for.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>The type of Amazon Redshift Serverless usage to create a usage limit for.</p>
     */
    usageType: UsageLimitUsageType | string | undefined;
    /**
     * <p>The limit amount. If time-based, this amount is in Redshift Processing Units (RPU) consumed per hour. If data-based, this amount is in terabytes (TB) of data
     *          transferred between Regions in cross-account sharing. The value must be a positive number.</p>
     */
    amount: number | undefined;
    /**
     * <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
     */
    period?: UsageLimitPeriod | string;
    /**
     * <p>The action that Amazon Redshift Serverless takes when the limit is reached. The default is log.</p>
     */
    breachAction?: UsageLimitBreachAction | string;
}
export declare namespace CreateUsageLimitRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateUsageLimitRequest) => any;
}
/**
 * <p>The usage limit object.</p>
 */
export interface UsageLimit {
    /**
     * <p>The identifier of the usage limit.</p>
     */
    usageLimitId?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the resource associated with the usage limit.</p>
     */
    usageLimitArn?: string;
    /**
     * <p>The Amazon Resource Name (ARN) that identifies the Amazon Redshift Serverless resource.</p>
     */
    resourceArn?: string;
    /**
     * <p>The Amazon Redshift Serverless feature to limit.</p>
     */
    usageType?: UsageLimitUsageType | string;
    /**
     * <p>The limit amount. If time-based, this amount is in RPUs consumed per hour. If data-based, this amount is in terabytes (TB). The value must be a positive number.</p>
     */
    amount?: number;
    /**
     * <p>The time period that the amount applies to. A weekly period begins on Sunday. The default is monthly.</p>
     */
    period?: UsageLimitPeriod | string;
    /**
     * <p>The action that Amazon Redshift Serverless takes when the limit is reached.</p>
     */
    breachAction?: UsageLimitBreachAction | string;
}
export declare namespace UsageLimit {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UsageLimit) => any;
}
export interface CreateUsageLimitResponse {
    /**
     * <p>The returned usage limit object.</p>
     */
    usageLimit?: UsageLimit;
}
export declare namespace CreateUsageLimitResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateUsageLimitResponse) => any;
}
export interface CreateWorkgroupRequest {
    /**
     * <p>The name of the created workgroup.</p>
     */
    workgroupName: string | undefined;
    /**
     * <p>The name of the namespace to associate with the workgroup.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
     */
    baseCapacity?: number;
    /**
     * <p>The value that specifies whether to turn on enhanced virtual
     *          private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC instead of over the internet.</p>
     */
    enhancedVpcRouting?: boolean;
    /**
     * <p>An array of parameters to set for more control over a serverless database. The
     *          options are <code>datestyle</code>, <code>enable_user_activity_logging</code>,
     *          <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
     */
    configParameters?: ConfigParameter[];
    /**
     * <p>An array of security group IDs to associate with the workgroup.</p>
     */
    securityGroupIds?: string[];
    /**
     * <p>An array of VPC subnet IDs to associate with the workgroup.</p>
     */
    subnetIds?: string[];
    /**
     * <p>A value that specifies whether the workgroup can be accessed from a public network.</p>
     */
    publiclyAccessible?: boolean;
    /**
     * <p>A array of tag instances.</p>
     */
    tags?: Tag[];
}
export declare namespace CreateWorkgroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateWorkgroupRequest) => any;
}
/**
 * <p>The VPC endpoint object.</p>
 */
export interface Endpoint {
    /**
     * <p>The DNS address of the VPC endpoint.</p>
     */
    address?: string;
    /**
     * <p>The port that Amazon Redshift Serverless listens on.</p>
     */
    port?: number;
    /**
     * <p>An array of <code>VpcEndpoint</code> objects.</p>
     */
    vpcEndpoints?: VpcEndpoint[];
}
export declare namespace Endpoint {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: Endpoint) => any;
}
export declare enum WorkgroupStatus {
    AVAILABLE = "AVAILABLE",
    CREATING = "CREATING",
    DELETING = "DELETING",
    MODIFYING = "MODIFYING"
}
/**
 * <p>The collection of computing resources from which an endpoint is created.</p>
 */
export interface Workgroup {
    /**
     * <p>The unique identifier of the workgroup.</p>
     */
    workgroupId?: string;
    /**
     * <p>The Amazon Resource Name (ARN) that links to the workgroup.</p>
     */
    workgroupArn?: string;
    /**
     * <p>The name of the workgroup.</p>
     */
    workgroupName?: string;
    /**
     * <p>The namespace the workgroup is associated with.</p>
     */
    namespaceName?: string;
    /**
     * <p>The base data warehouse capacity of the workgroup in Redshift Processing Units (RPUs).</p>
     */
    baseCapacity?: number;
    /**
     * <p>The value that specifies whether to enable enhanced virtual
     *       private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
     */
    enhancedVpcRouting?: boolean;
    /**
     * <p>An array of parameters to set for finer control over a database. The
     *       options are <code>datestyle</code>, <code>enable_user_activity_logging</code>,
     *       <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
     */
    configParameters?: ConfigParameter[];
    /**
     * <p>An array of security group IDs to associate with the workgroup.</p>
     */
    securityGroupIds?: string[];
    /**
     * <p>An array of subnet IDs the workgroup is associated with.</p>
     */
    subnetIds?: string[];
    /**
     * <p>The status of the workgroup.</p>
     */
    status?: WorkgroupStatus | string;
    /**
     * <p>The endpoint that is created from the workgroup.</p>
     */
    endpoint?: Endpoint;
    /**
     * <p>A value that specifies whether the workgroup
     *       can be accessible from a public network</p>
     */
    publiclyAccessible?: boolean;
    /**
     * <p>The creation date of the workgroup.</p>
     */
    creationDate?: Date;
}
export declare namespace Workgroup {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: Workgroup) => any;
}
export interface CreateWorkgroupResponse {
    /**
     * <p>The created workgroup object.</p>
     */
    workgroup?: Workgroup;
}
export declare namespace CreateWorkgroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: CreateWorkgroupResponse) => any;
}
/**
 * <p>There is an insufficient capacity to perform the action.</p>
 */
export declare class InsufficientCapacityException extends __BaseException {
    readonly name: "InsufficientCapacityException";
    readonly $fault: "client";
    $retryable: {};
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InsufficientCapacityException, __BaseException>);
}
export interface DeleteEndpointAccessRequest {
    /**
     * <p>The name of the VPC endpoint to delete.</p>
     */
    endpointName: string | undefined;
}
export declare namespace DeleteEndpointAccessRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteEndpointAccessRequest) => any;
}
export interface DeleteEndpointAccessResponse {
    /**
     * <p>The deleted VPC endpoint.</p>
     */
    endpoint?: EndpointAccess;
}
export declare namespace DeleteEndpointAccessResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteEndpointAccessResponse) => any;
}
export interface GetEndpointAccessRequest {
    /**
     * <p>The name of the VPC endpoint to return information for.</p>
     */
    endpointName: string | undefined;
}
export declare namespace GetEndpointAccessRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetEndpointAccessRequest) => any;
}
export interface GetEndpointAccessResponse {
    /**
     * <p>The returned VPC endpoint.</p>
     */
    endpoint?: EndpointAccess;
}
export declare namespace GetEndpointAccessResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetEndpointAccessResponse) => any;
}
export interface ListEndpointAccessRequest {
    /**
     * <p>If your initial <code>ListEndpointAccess</code> operation returns a <code>nextToken</code>,
     *          you can include the returned <code>nextToken</code> in subsequent <code>ListEndpointAccess</code> operations,
     *          which returns results in the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results.</p>
     */
    maxResults?: number;
    /**
     * <p>The name of the workgroup associated with the VPC endpoint to return.</p>
     */
    workgroupName?: string;
    /**
     * <p>The unique identifier of the virtual private cloud with access to Amazon Redshift Serverless.</p>
     */
    vpcId?: string;
}
export declare namespace ListEndpointAccessRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListEndpointAccessRequest) => any;
}
export interface ListEndpointAccessResponse {
    /**
     * <p>When <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>The returned VPC endpoints.</p>
     */
    endpoints: EndpointAccess[] | undefined;
}
export declare namespace ListEndpointAccessResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListEndpointAccessResponse) => any;
}
export interface UpdateEndpointAccessRequest {
    /**
     * <p>The name of the VPC endpoint to update.</p>
     */
    endpointName: string | undefined;
    /**
     * <p>The list of VPC security groups associated with the endpoint after the endpoint is modified.</p>
     */
    vpcSecurityGroupIds?: string[];
}
export declare namespace UpdateEndpointAccessRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateEndpointAccessRequest) => any;
}
export interface UpdateEndpointAccessResponse {
    /**
     * <p>The updated VPC endpoint.</p>
     */
    endpoint?: EndpointAccess;
}
export declare namespace UpdateEndpointAccessResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateEndpointAccessResponse) => any;
}
export interface DeleteNamespaceRequest {
    /**
     * <p>The name of the namespace to delete.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The name of the snapshot to be created before the namespace is deleted.</p>
     */
    finalSnapshotName?: string;
    /**
     * <p>How long to retain the final snapshot.</p>
     */
    finalSnapshotRetentionPeriod?: number;
}
export declare namespace DeleteNamespaceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteNamespaceRequest) => any;
}
export interface DeleteNamespaceResponse {
    /**
     * <p>The deleted namespace object.</p>
     */
    namespace: Namespace | undefined;
}
export declare namespace DeleteNamespaceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteNamespaceResponse) => any;
}
export interface DeleteResourcePolicyRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the policy to delete.</p>
     */
    resourceArn: string | undefined;
}
export declare namespace DeleteResourcePolicyRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteResourcePolicyRequest) => any;
}
export interface DeleteResourcePolicyResponse {
}
export declare namespace DeleteResourcePolicyResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteResourcePolicyResponse) => any;
}
export interface DeleteSnapshotRequest {
    /**
     * <p>The name of the snapshot to be deleted.</p>
     */
    snapshotName: string | undefined;
}
export declare namespace DeleteSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteSnapshotRequest) => any;
}
export interface DeleteSnapshotResponse {
    /**
     * <p>The deleted snapshot object.</p>
     */
    snapshot?: Snapshot;
}
export declare namespace DeleteSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteSnapshotResponse) => any;
}
export interface DeleteUsageLimitRequest {
    /**
     * <p>The unique identifier of the usage limit to delete.</p>
     */
    usageLimitId: string | undefined;
}
export declare namespace DeleteUsageLimitRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteUsageLimitRequest) => any;
}
export interface DeleteUsageLimitResponse {
    /**
     * <p>The deleted usage limit object.</p>
     */
    usageLimit?: UsageLimit;
}
export declare namespace DeleteUsageLimitResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteUsageLimitResponse) => any;
}
export interface DeleteWorkgroupRequest {
    /**
     * <p>The name of the workgroup to be deleted.</p>
     */
    workgroupName: string | undefined;
}
export declare namespace DeleteWorkgroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteWorkgroupRequest) => any;
}
export interface DeleteWorkgroupResponse {
    /**
     * <p>The deleted workgroup object.</p>
     */
    workgroup: Workgroup | undefined;
}
export declare namespace DeleteWorkgroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: DeleteWorkgroupResponse) => any;
}
export interface GetCredentialsRequest {
    /**
     * <p>The name of the workgroup associated with the database.</p>
     */
    workgroupName: string | undefined;
    /**
     * <p>The name of the database to get temporary authorization to log on to.</p>
     *          <p>Constraints:</p>
     *          <ul>
     *             <li>
     *                <p>Must be 1 to 64 alphanumeric characters or hyphens.</p>
     *             </li>
     *             <li>
     *                <p>Must contain only lowercase letters, numbers, underscore, plus sign, period (dot), at symbol (@), or hyphen.</p>
     *             </li>
     *             <li>
     *                <p>The first character must be a letter.</p>
     *             </li>
     *             <li>
     *                <p>Must not contain a colon ( : ) or slash ( / ).</p>
     *             </li>
     *             <li>
     *                <p>Cannot be a reserved word. A list of reserved words can be found
     *                in <a href="https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html">Reserved Words </a>
     *                in the Amazon Redshift Database Developer Guide</p>
     *             </li>
     *          </ul>
     */
    dbName?: string;
    /**
     * <p>The number of seconds until the returned temporary password expires.
     *          The minimum is 900 seconds, and the maximum is 3600 seconds.</p>
     */
    durationSeconds?: number;
}
export declare namespace GetCredentialsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetCredentialsRequest) => any;
}
export interface GetCredentialsResponse {
    /**
     * <p>A database user name that is authorized to log on to the database <code>DbName</code>
     *          using the password <code>DbPassword</code>. If the specified <code>DbUser</code> exists in the database,
     *          the new user name has the same database privileges as the the user named in
     *          <code>DbUser</code>. By default, the user is added to PUBLIC.</p>
     */
    dbUser?: string;
    /**
     * <p>A temporary password that authorizes the user name returned by
     *          <code>DbUser</code> to log on to the database <code>DbName</code>.</p>
     */
    dbPassword?: string;
    /**
     * <p>The date and time the password in <code>DbPassword</code> expires.</p>
     */
    expiration?: Date;
    /**
     * <p>The date and time of when the <code>DbUser</code> and <code>DbPassword</code>
     *          authorization refreshes.</p>
     */
    nextRefreshTime?: Date;
}
export declare namespace GetCredentialsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetCredentialsResponse) => any;
}
export interface GetNamespaceRequest {
    /**
     * <p>The name of the namespace to retrieve information for.</p>
     */
    namespaceName: string | undefined;
}
export declare namespace GetNamespaceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetNamespaceRequest) => any;
}
export interface GetNamespaceResponse {
    /**
     * <p>The returned namespace object.</p>
     */
    namespace: Namespace | undefined;
}
export declare namespace GetNamespaceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetNamespaceResponse) => any;
}
export interface GetRecoveryPointRequest {
    /**
     * <p>The unique identifier of the recovery point to return information for.</p>
     */
    recoveryPointId: string | undefined;
}
export declare namespace GetRecoveryPointRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetRecoveryPointRequest) => any;
}
/**
 * <p>The automatically created recovery point of a namespace.
 *          Recovery points are created every 30 minutes and kept for 24 hours.</p>
 */
export interface RecoveryPoint {
    /**
     * <p>The unique identifier of the recovery point.</p>
     */
    recoveryPointId?: string;
    /**
     * <p>The time the recovery point is created.</p>
     */
    recoveryPointCreateTime?: Date;
    /**
     * <p>The total size of the data in the recovery point in megabytes.</p>
     */
    totalSizeInMegaBytes?: number;
    /**
     * <p>The name of the namespace the recovery point is associated with.</p>
     */
    namespaceName?: string;
    /**
     * <p>The name of the workgroup the recovery point is associated with.</p>
     */
    workgroupName?: string;
}
export declare namespace RecoveryPoint {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RecoveryPoint) => any;
}
export interface GetRecoveryPointResponse {
    /**
     * <p>The returned recovery point object.</p>
     */
    recoveryPoint?: RecoveryPoint;
}
export declare namespace GetRecoveryPointResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetRecoveryPointResponse) => any;
}
export interface GetResourcePolicyRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the resource to return.</p>
     */
    resourceArn: string | undefined;
}
export declare namespace GetResourcePolicyRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetResourcePolicyRequest) => any;
}
/**
 * <p>The resource policy object. Currently, you can use policies to share snapshots across Amazon Web Services accounts.</p>
 */
export interface ResourcePolicy {
    /**
     * <p>The Amazon Resource Name (ARN) of the policy.</p>
     */
    resourceArn?: string;
    /**
     * <p>The resource policy.</p>
     */
    policy?: string;
}
export declare namespace ResourcePolicy {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ResourcePolicy) => any;
}
export interface GetResourcePolicyResponse {
    /**
     * <p>The returned resource policy.</p>
     */
    resourcePolicy?: ResourcePolicy;
}
export declare namespace GetResourcePolicyResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetResourcePolicyResponse) => any;
}
export interface GetSnapshotRequest {
    /**
     * <p>The name of the snapshot to return.</p>
     */
    snapshotName?: string;
    /**
     * <p>The owner Amazon Web Services account of a snapshot shared with another user.</p>
     */
    ownerAccount?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the snapshot to return.</p>
     */
    snapshotArn?: string;
}
export declare namespace GetSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetSnapshotRequest) => any;
}
export interface GetSnapshotResponse {
    /**
     * <p>The returned snapshot object.</p>
     */
    snapshot?: Snapshot;
}
export declare namespace GetSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetSnapshotResponse) => any;
}
export interface GetUsageLimitRequest {
    /**
     * <p>The unique identifier of the usage limit to return information for.</p>
     */
    usageLimitId: string | undefined;
}
export declare namespace GetUsageLimitRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetUsageLimitRequest) => any;
}
export interface GetUsageLimitResponse {
    /**
     * <p>The returned usage limit object.</p>
     */
    usageLimit?: UsageLimit;
}
export declare namespace GetUsageLimitResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetUsageLimitResponse) => any;
}
export interface GetWorkgroupRequest {
    /**
     * <p>The name of the workgroup to return information for.</p>
     */
    workgroupName: string | undefined;
}
export declare namespace GetWorkgroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetWorkgroupRequest) => any;
}
export interface GetWorkgroupResponse {
    /**
     * <p>The returned workgroup object.</p>
     */
    workgroup: Workgroup | undefined;
}
export declare namespace GetWorkgroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: GetWorkgroupResponse) => any;
}
/**
 * <p>The provided pagination token is invalid.</p>
 */
export declare class InvalidPaginationException extends __BaseException {
    readonly name: "InvalidPaginationException";
    readonly $fault: "client";
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<InvalidPaginationException, __BaseException>);
}
export interface ListNamespacesRequest {
    /**
     * <p>If your initial <code>ListNamespaces</code> operation returns a <code>nextToken</code>,
     *          you can include the returned <code>nextToken</code> in subsequent <code>ListNamespaces</code> operations,
     *          which returns results in the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results.</p>
     */
    maxResults?: number;
}
export declare namespace ListNamespacesRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListNamespacesRequest) => any;
}
export interface ListNamespacesResponse {
    /**
     * <p>When <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>The list of returned namespaces.</p>
     */
    namespaces: Namespace[] | undefined;
}
export declare namespace ListNamespacesResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListNamespacesResponse) => any;
}
export interface ListRecoveryPointsRequest {
    /**
     * <p>If your initial <code>ListRecoveryPoints</code> operation returns a <code>nextToken</code>,
     *          you can include the returned <code>nextToken</code> in subsequent <code>ListRecoveryPoints</code> operations,
     *          which returns results in the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results.</p>
     */
    maxResults?: number;
    /**
     * <p>The time when the recovery point's creation was initiated.</p>
     */
    startTime?: Date;
    /**
     * <p>The time when creation of the recovery point finished.</p>
     */
    endTime?: Date;
    /**
     * <p>The name of the namespace to list recovery points for.</p>
     */
    namespaceName?: string;
}
export declare namespace ListRecoveryPointsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListRecoveryPointsRequest) => any;
}
export interface ListRecoveryPointsResponse {
    /**
     * <p>The returned recovery point objects.</p>
     */
    recoveryPoints?: RecoveryPoint[];
    /**
     * <p>If <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
}
export declare namespace ListRecoveryPointsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListRecoveryPointsResponse) => any;
}
export interface ListSnapshotsRequest {
    /**
     * <p>If <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results.</p>
     */
    maxResults?: number;
    /**
     * <p>The namespace from which to list all snapshots.</p>
     */
    namespaceName?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the namespace from which to list all snapshots.</p>
     */
    namespaceArn?: string;
    /**
     * <p>The owner Amazon Web Services account of the snapshot.</p>
     */
    ownerAccount?: string;
    /**
     * <p>The time when the creation of the snapshot was initiated.</p>
     */
    startTime?: Date;
    /**
     * <p>The timestamp showing when the snapshot creation finished.</p>
     */
    endTime?: Date;
}
export declare namespace ListSnapshotsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListSnapshotsRequest) => any;
}
export interface ListSnapshotsResponse {
    /**
     * <p>If <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>All of the returned snapshot objects.</p>
     */
    snapshots?: Snapshot[];
}
export declare namespace ListSnapshotsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListSnapshotsResponse) => any;
}
export interface ListTagsForResourceRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the resource to list tags for.</p>
     */
    resourceArn: string | undefined;
}
export declare namespace ListTagsForResourceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTagsForResourceRequest) => any;
}
export interface ListTagsForResourceResponse {
    /**
     * <p>A map of the key-value pairs assigned to the resource.</p>
     */
    tags?: Tag[];
}
export declare namespace ListTagsForResourceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListTagsForResourceResponse) => any;
}
/**
 * <p>The request was denied due to request throttling.</p>
 */
export declare class ThrottlingException extends __BaseException {
    readonly name: "ThrottlingException";
    readonly $fault: "client";
    $retryable: {};
    code?: string;
    /**
     * @internal
     */
    constructor(opts: __ExceptionOptionType<ThrottlingException, __BaseException>);
}
export interface ListUsageLimitsRequest {
    /**
     * <p>The Amazon Resource Name (ARN) associated with the resource whose usage limits you want to list.</p>
     */
    resourceArn?: string;
    /**
     * <p>The Amazon Redshift Serverless feature whose limits you want to see.</p>
     */
    usageType?: UsageLimitUsageType | string;
    /**
     * <p>If your initial <code>ListUsageLimits</code> operation returns a <code>nextToken</code>,
     *          you can include the returned <code>nextToken</code> in subsequent <code>ListUsageLimits</code> operations,
     *          which returns results in the next page.
     *       </p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results. The default is 100.</p>
     */
    maxResults?: number;
}
export declare namespace ListUsageLimitsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListUsageLimitsRequest) => any;
}
export interface ListUsageLimitsResponse {
    /**
     * <p>An array of returned usage limit objects.</p>
     */
    usageLimits?: UsageLimit[];
    /**
     * <p>When <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          Make the call again using the returned token to retrieve the next page.</p>
     */
    nextToken?: string;
}
export declare namespace ListUsageLimitsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListUsageLimitsResponse) => any;
}
export interface ListWorkgroupsRequest {
    /**
     * <p>If your initial ListWorkgroups operation returns a <code>nextToken</code>,
     *          you can include the returned <code>nextToken</code> in subsequent ListNamespaces operations,
     *          which returns results in the next page.</p>
     */
    nextToken?: string;
    /**
     * <p>An optional parameter that specifies the maximum number of results to return.
     *          You can use <code>nextToken</code> to get the next page of results.</p>
     */
    maxResults?: number;
}
export declare namespace ListWorkgroupsRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListWorkgroupsRequest) => any;
}
export interface ListWorkgroupsResponse {
    /**
     * <p>
     *          If <code>nextToken</code> is returned, there are more results available.
     *          The value of <code>nextToken</code> is a unique pagination token for each page.
     *          To retrieve the next page, make the call again using the returned token.</p>
     */
    nextToken?: string;
    /**
     * <p>The returned array of workgroups.</p>
     */
    workgroups: Workgroup[] | undefined;
}
export declare namespace ListWorkgroupsResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: ListWorkgroupsResponse) => any;
}
export interface UpdateNamespaceRequest {
    /**
     * <p>The name of the namespace.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The password of the administrator for the first database created in the namespace.</p>
     */
    adminUserPassword?: string;
    /**
     * <p>The username of the administrator for the first database created in the namespace.</p>
     */
    adminUsername?: string;
    /**
     * <p>The ID of the Amazon Web Services Key Management Service key used to encrypt your data.</p>
     */
    kmsKeyId?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the IAM role to set as a default in the namespace.</p>
     */
    defaultIamRoleArn?: string;
    /**
     * <p>A list of IAM roles to associate with the namespace.</p>
     */
    iamRoles?: string[];
    /**
     * <p>The types of logs the namespace can export. The export types are <code>userlog</code>, <code>connectionlog</code>, and <code>useractivitylog</code>.</p>
     */
    logExports?: (LogExport | string)[];
}
export declare namespace UpdateNamespaceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateNamespaceRequest) => any;
}
export interface UpdateNamespaceResponse {
    /**
     * <p>A list of tag instances.</p>
     */
    namespace: Namespace | undefined;
}
export declare namespace UpdateNamespaceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateNamespaceResponse) => any;
}
export interface PutResourcePolicyRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the account to create or update a resource policy for.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>The policy to create or update. For example, the following policy grants a user authorization to restore a snapshot.</p>
     *          <p>
     *             <code>"{\"Version\": \"2012-10-17\", \"Statement\" :
     *             [{ \"Sid\": \"AllowUserRestoreFromSnapshot\", \"Principal\":{\"AWS\":
     *             [\"739247239426\"]}, \"Action\": [\"redshift-serverless:RestoreFromSnapshot\"]
     *             , \"Effect\": \"Allow\" }]}"</code>
     *          </p>
     */
    policy: string | undefined;
}
export declare namespace PutResourcePolicyRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: PutResourcePolicyRequest) => any;
}
export interface PutResourcePolicyResponse {
    /**
     * <p>The policy that was created or updated.</p>
     */
    resourcePolicy?: ResourcePolicy;
}
export declare namespace PutResourcePolicyResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: PutResourcePolicyResponse) => any;
}
export interface RestoreFromRecoveryPointRequest {
    /**
     * <p>The unique identifier of the recovery point to restore from.</p>
     */
    recoveryPointId: string | undefined;
    /**
     * <p>The name of the namespace to restore data into.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The name of the workgroup used to restore data.</p>
     */
    workgroupName: string | undefined;
}
export declare namespace RestoreFromRecoveryPointRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RestoreFromRecoveryPointRequest) => any;
}
export interface RestoreFromRecoveryPointResponse {
    /**
     * <p>The unique identifier of the recovery point used for the restore.</p>
     */
    recoveryPointId?: string;
    /**
     * <p>The namespace that data was restored into.</p>
     */
    namespace?: Namespace;
}
export declare namespace RestoreFromRecoveryPointResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RestoreFromRecoveryPointResponse) => any;
}
export interface RestoreFromSnapshotRequest {
    /**
     * <p>The name of the namespace to restore the snapshot to.</p>
     */
    namespaceName: string | undefined;
    /**
     * <p>The name of the workgroup used to restore the snapshot.</p>
     */
    workgroupName: string | undefined;
    /**
     * <p>The name of the snapshot to restore from.</p>
     */
    snapshotName?: string;
    /**
     * <p>The Amazon Resource Name (ARN) of the snapshot to restore from.</p>
     */
    snapshotArn?: string;
    /**
     * <p>The Amazon Web Services account that owns the snapshot.</p>
     */
    ownerAccount?: string;
}
export declare namespace RestoreFromSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RestoreFromSnapshotRequest) => any;
}
export interface RestoreFromSnapshotResponse {
    /**
     * <p>The name of the snapshot used to restore the namespace.</p>
     */
    snapshotName?: string;
    /**
     * <p>The owner Amazon Web Services; account of the snapshot that was restored.</p>
     */
    ownerAccount?: string;
    /**
     * <p>A collection of database objects and users.</p>
     */
    namespace?: Namespace;
}
export declare namespace RestoreFromSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: RestoreFromSnapshotResponse) => any;
}
export interface UpdateSnapshotRequest {
    /**
     * <p>The name of the snapshot.</p>
     */
    snapshotName: string | undefined;
    /**
     * <p>The new retention period of the snapshot.</p>
     */
    retentionPeriod?: number;
}
export declare namespace UpdateSnapshotRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateSnapshotRequest) => any;
}
export interface UpdateSnapshotResponse {
    /**
     * <p>The updated snapshot object.</p>
     */
    snapshot?: Snapshot;
}
export declare namespace UpdateSnapshotResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateSnapshotResponse) => any;
}
export interface TagResourceRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the resource to tag.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>The map of the key-value pairs used to tag the resource.</p>
     */
    tags: Tag[] | undefined;
}
export declare namespace TagResourceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TagResourceRequest) => any;
}
export interface TagResourceResponse {
}
export declare namespace TagResourceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: TagResourceResponse) => any;
}
export interface UntagResourceRequest {
    /**
     * <p>The Amazon Resource Name (ARN) of the resource to remove tags from.</p>
     */
    resourceArn: string | undefined;
    /**
     * <p>The tag or set of tags to remove from the resource.</p>
     */
    tagKeys: string[] | undefined;
}
export declare namespace UntagResourceRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UntagResourceRequest) => any;
}
export interface UntagResourceResponse {
}
export declare namespace UntagResourceResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UntagResourceResponse) => any;
}
export interface UpdateUsageLimitRequest {
    /**
     * <p>The identifier of the usage limit to update.</p>
     */
    usageLimitId: string | undefined;
    /**
     * <p>The new limit amount. For more information about this parameter.</p>
     */
    amount?: number;
    /**
     * <p>The new action that Amazon Redshift Serverless takes when the limit is reached.</p>
     */
    breachAction?: UsageLimitBreachAction | string;
}
export declare namespace UpdateUsageLimitRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateUsageLimitRequest) => any;
}
export interface UpdateUsageLimitResponse {
    /**
     * <p>The updated usage limit object.</p>
     */
    usageLimit?: UsageLimit;
}
export declare namespace UpdateUsageLimitResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateUsageLimitResponse) => any;
}
export interface UpdateWorkgroupRequest {
    /**
     * <p>The name of the workgroup to update.</p>
     */
    workgroupName: string | undefined;
    /**
     * <p>The new base data warehouse capacity in Redshift Processing Units (RPUs).</p>
     */
    baseCapacity?: number;
    /**
     * <p>The value that specifies whether to turn on enhanced virtual
     *          private cloud (VPC) routing, which forces Amazon Redshift Serverless to route traffic through your VPC.</p>
     */
    enhancedVpcRouting?: boolean;
    /**
     * <p>An array of parameters to set for advanced control over a database. The
     *          options are <code>datestyle</code>, <code>enable_user_activity_logging</code>,
     *          <code>query_group</code>, <code>search_path</code>, and <code>max_query_execution_time</code>.</p>
     */
    configParameters?: ConfigParameter[];
    /**
     * <p>A value that specifies whether the workgroup can be accessible from a public network.</p>
     */
    publiclyAccessible?: boolean;
    /**
     * <p>An array of VPC subnet IDs to associate with the workgroup.</p>
     */
    subnetIds?: string[];
    /**
     * <p>An array of security group IDs to associate with the workgroup.</p>
     */
    securityGroupIds?: string[];
}
export declare namespace UpdateWorkgroupRequest {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateWorkgroupRequest) => any;
}
export interface UpdateWorkgroupResponse {
    /**
     * <p>The updated workgroup object.</p>
     */
    workgroup: Workgroup | undefined;
}
export declare namespace UpdateWorkgroupResponse {
    /**
     * @internal
     */
    const filterSensitiveLog: (obj: UpdateWorkgroupResponse) => any;
}
