import { awsExpectUnion as __expectUnion } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, map, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, strictParseInt32 as __strictParseInt32, take, withBaseException, } from "@smithy/smithy-client";
import { v4 as generateIdempotencyToken } from "uuid";
import { AccessAnalyzerServiceException as __BaseException } from "../models/AccessAnalyzerServiceException";
import { AccessDeniedException, ConflictException, InternalServerException, InvalidParameterException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, UnprocessableEntityException, ValidationException, } from "../models/models_0";
export const se_ApplyArchiveRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/archive-rule");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ruleName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CancelPolicyGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/generation/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CheckAccessNotGrantedCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/check-access-not-granted");
    let body;
    body = JSON.stringify(take(input, {
        access: (_) => _json(_),
        policyDocument: [],
        policyType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CheckNoNewAccessCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/check-no-new-access");
    let body;
    body = JSON.stringify(take(input, {
        existingPolicyDocument: [],
        newPolicyDocument: [],
        policyType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAccessPreviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/access-preview");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        configurations: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateAnalyzerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/analyzer");
    let body;
    body = JSON.stringify(take(input, {
        analyzerName: [],
        archiveRules: (_) => _json(_),
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        configuration: (_) => _json(_),
        tags: (_) => _json(_),
        type: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateArchiveRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/analyzer/{analyzerName}/archive-rule");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        filter: (_) => _json(_),
        ruleName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_DeleteAnalyzerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer/{analyzerName}");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteArchiveRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer/{analyzerName}/archive-rule/{ruleName}");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    const query = map({
        [_cT]: [, input[_cT] ?? generateIdempotencyToken()],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAccessPreviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/access-preview/{accessPreviewId}");
    b.p("accessPreviewId", () => input.accessPreviewId, "{accessPreviewId}", false);
    const query = map({
        [_aA]: [, __expectNonNull(input[_aA], `analyzerArn`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAnalyzedResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzed-resource");
    const query = map({
        [_aA]: [, __expectNonNull(input[_aA], `analyzerArn`)],
        [_rA]: [, __expectNonNull(input[_rA], `resourceArn`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAnalyzerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer/{analyzerName}");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetArchiveRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer/{analyzerName}/archive-rule/{ruleName}");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetFindingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/finding/{id}");
    b.p("id", () => input.id, "{id}", false);
    const query = map({
        [_aA]: [, __expectNonNull(input[_aA], `analyzerArn`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetFindingV2Command = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/findingv2/{id}");
    b.p("id", () => input.id, "{id}", false);
    const query = map({
        [_aA]: [, __expectNonNull(input[_aA], `analyzerArn`)],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetGeneratedPolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/generation/{jobId}");
    b.p("jobId", () => input.jobId, "{jobId}", false);
    const query = map({
        [_iRP]: [() => input.includeResourcePlaceholders !== void 0, () => input[_iRP].toString()],
        [_iSLT]: [() => input.includeServiceLevelTemplate !== void 0, () => input[_iSLT].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAccessPreviewFindingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/access-preview/{accessPreviewId}");
    b.p("accessPreviewId", () => input.accessPreviewId, "{accessPreviewId}", false);
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        filter: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAccessPreviewsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/access-preview");
    const query = map({
        [_aA]: [, __expectNonNull(input[_aA], `analyzerArn`)],
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAnalyzedResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/analyzed-resource");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        maxResults: [],
        nextToken: [],
        resourceType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListAnalyzersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer");
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_t]: [, input[_t]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListArchiveRulesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/analyzer/{analyzerName}/archive-rule");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    const query = map({
        [_nT]: [, input[_nT]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListFindingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/finding");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        filter: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sort: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListFindingsV2Command = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/findingv2");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        filter: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sort: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPolicyGenerationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/policy/generation");
    const query = map({
        [_pA]: [, input[_pA]],
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_StartPolicyGenerationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/generation");
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        cloudTrailDetails: (_) => se_CloudTrailDetails(_, context),
        policyGenerationDetails: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_StartResourceScanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/resource/scan");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        resourceArn: [],
        resourceOwnerAccount: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateArchiveRuleCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/analyzer/{analyzerName}/archive-rule/{ruleName}");
    b.p("analyzerName", () => input.analyzerName, "{analyzerName}", false);
    b.p("ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    body = JSON.stringify(take(input, {
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        filter: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateFindingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/finding");
    let body;
    body = JSON.stringify(take(input, {
        analyzerArn: [],
        clientToken: [true, (_) => _ ?? generateIdempotencyToken()],
        ids: (_) => _json(_),
        resourceArn: [],
        status: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_ValidatePolicyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/policy/validation");
    const query = map({
        [_mR]: [() => input.maxResults !== void 0, () => input[_mR].toString()],
        [_nT]: [, input[_nT]],
    });
    let body;
    body = JSON.stringify(take(input, {
        locale: [],
        policyDocument: [],
        policyType: [],
        validatePolicyResourceType: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const de_ApplyArchiveRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CancelPolicyGenerationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CheckAccessNotGrantedCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        message: __expectString,
        reasons: _json,
        result: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CheckNoNewAccessCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        message: __expectString,
        reasons: _json,
        result: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAccessPreviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAnalyzerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateArchiveRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteAnalyzerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteArchiveRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetAccessPreviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessPreview: (_) => de_AccessPreview(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAnalyzedResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        resource: (_) => de_AnalyzedResource(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAnalyzerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        analyzer: (_) => de_AnalyzerSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetArchiveRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        archiveRule: (_) => de_ArchiveRuleSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        finding: (_) => de_Finding(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetFindingV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        analyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        findingDetails: (_) => de_FindingDetailsList(_, context),
        findingType: __expectString,
        id: __expectString,
        nextToken: __expectString,
        resource: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        status: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetGeneratedPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        generatedPolicyResult: (_) => de_GeneratedPolicyResult(_, context),
        jobDetails: (_) => de_JobDetails(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAccessPreviewFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        findings: (_) => de_AccessPreviewFindingsList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAccessPreviewsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessPreviews: (_) => de_AccessPreviewsList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAnalyzedResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        analyzedResources: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAnalyzersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        analyzers: (_) => de_AnalyzersList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListArchiveRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        archiveRules: (_) => de_ArchiveRulesList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        findings: (_) => de_FindingsList(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListFindingsV2Command = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        findings: (_) => de_FindingsListV2(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPolicyGenerationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        policyGenerations: (_) => de_PolicyGenerationList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartPolicyGenerationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        jobId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_StartResourceScanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateArchiveRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_ValidatePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        findings: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.accessanalyzer#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.accessanalyzer#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.accessanalyzer#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.accessanalyzer#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.accessanalyzer#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.accessanalyzer#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "UnprocessableEntityException":
        case "com.amazonaws.accessanalyzer#UnprocessableEntityException":
            throw await de_UnprocessableEntityExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.accessanalyzer#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.accessanalyzer#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [() => void 0 !== parsedOutput.headers[_ra], () => __strictParseInt32(parsedOutput.headers[_ra])],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [() => void 0 !== parsedOutput.headers[_ra], () => __strictParseInt32(parsedOutput.headers[_ra])],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnprocessableEntityExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnprocessableEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        fieldList: _json,
        message: __expectString,
        reason: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_CloudTrailDetails = (input, context) => {
    return take(input, {
        accessRole: [],
        endTime: (_) => _.toISOString().split(".")[0] + "Z",
        startTime: (_) => _.toISOString().split(".")[0] + "Z",
        trails: _json,
    });
};
const de_AccessPreview = (output, context) => {
    return take(output, {
        analyzerArn: __expectString,
        configurations: _json,
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        id: __expectString,
        status: __expectString,
        statusReason: _json,
    });
};
const de_AccessPreviewFinding = (output, context) => {
    return take(output, {
        action: _json,
        changeType: __expectString,
        condition: _json,
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        existingFindingId: __expectString,
        existingFindingStatus: __expectString,
        id: __expectString,
        isPublic: __expectBoolean,
        principal: _json,
        resource: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        sources: _json,
        status: __expectString,
    });
};
const de_AccessPreviewFindingsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessPreviewFinding(entry, context);
    });
    return retVal;
};
const de_AccessPreviewsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessPreviewSummary(entry, context);
    });
    return retVal;
};
const de_AccessPreviewSummary = (output, context) => {
    return take(output, {
        analyzerArn: __expectString,
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        id: __expectString,
        status: __expectString,
        statusReason: _json,
    });
};
const de_AnalyzedResource = (output, context) => {
    return take(output, {
        actions: _json,
        analyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        isPublic: __expectBoolean,
        resourceArn: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        sharedVia: _json,
        status: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_AnalyzersList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AnalyzerSummary(entry, context);
    });
    return retVal;
};
const de_AnalyzerSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        configuration: (_) => _json(__expectUnion(_)),
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        lastResourceAnalyzed: __expectString,
        lastResourceAnalyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        name: __expectString,
        status: __expectString,
        statusReason: _json,
        tags: _json,
        type: __expectString,
    });
};
const de_ArchiveRulesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ArchiveRuleSummary(entry, context);
    });
    return retVal;
};
const de_ArchiveRuleSummary = (output, context) => {
    return take(output, {
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        filter: _json,
        ruleName: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_CloudTrailProperties = (output, context) => {
    return take(output, {
        endTime: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        startTime: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        trailProperties: _json,
    });
};
const de_Finding = (output, context) => {
    return take(output, {
        action: _json,
        analyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        condition: _json,
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        id: __expectString,
        isPublic: __expectBoolean,
        principal: _json,
        resource: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        sources: _json,
        status: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_FindingDetails = (output, context) => {
    if (output.externalAccessDetails != null) {
        return {
            externalAccessDetails: _json(output.externalAccessDetails),
        };
    }
    if (output.unusedIamRoleDetails != null) {
        return {
            unusedIamRoleDetails: de_UnusedIamRoleDetails(output.unusedIamRoleDetails, context),
        };
    }
    if (output.unusedIamUserAccessKeyDetails != null) {
        return {
            unusedIamUserAccessKeyDetails: de_UnusedIamUserAccessKeyDetails(output.unusedIamUserAccessKeyDetails, context),
        };
    }
    if (output.unusedIamUserPasswordDetails != null) {
        return {
            unusedIamUserPasswordDetails: de_UnusedIamUserPasswordDetails(output.unusedIamUserPasswordDetails, context),
        };
    }
    if (output.unusedPermissionDetails != null) {
        return {
            unusedPermissionDetails: de_UnusedPermissionDetails(output.unusedPermissionDetails, context),
        };
    }
    return { $unknown: Object.entries(output)[0] };
};
const de_FindingDetailsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FindingDetails(__expectUnion(entry), context);
    });
    return retVal;
};
const de_FindingsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FindingSummary(entry, context);
    });
    return retVal;
};
const de_FindingsListV2 = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_FindingSummaryV2(entry, context);
    });
    return retVal;
};
const de_FindingSummary = (output, context) => {
    return take(output, {
        action: _json,
        analyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        condition: _json,
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        id: __expectString,
        isPublic: __expectBoolean,
        principal: _json,
        resource: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        sources: _json,
        status: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_FindingSummaryV2 = (output, context) => {
    return take(output, {
        analyzedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        createdAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        error: __expectString,
        findingType: __expectString,
        id: __expectString,
        resource: __expectString,
        resourceOwnerAccount: __expectString,
        resourceType: __expectString,
        status: __expectString,
        updatedAt: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_GeneratedPolicyProperties = (output, context) => {
    return take(output, {
        cloudTrailProperties: (_) => de_CloudTrailProperties(_, context),
        isComplete: __expectBoolean,
        principalArn: __expectString,
    });
};
const de_GeneratedPolicyResult = (output, context) => {
    return take(output, {
        generatedPolicies: _json,
        properties: (_) => de_GeneratedPolicyProperties(_, context),
    });
};
const de_JobDetails = (output, context) => {
    return take(output, {
        completedOn: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        jobError: _json,
        jobId: __expectString,
        startedOn: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        status: __expectString,
    });
};
const de_PolicyGeneration = (output, context) => {
    return take(output, {
        completedOn: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        jobId: __expectString,
        principalArn: __expectString,
        startedOn: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        status: __expectString,
    });
};
const de_PolicyGenerationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGeneration(entry, context);
    });
    return retVal;
};
const de_UnusedAction = (output, context) => {
    return take(output, {
        action: __expectString,
        lastAccessed: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_UnusedActionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UnusedAction(entry, context);
    });
    return retVal;
};
const de_UnusedIamRoleDetails = (output, context) => {
    return take(output, {
        lastAccessed: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_UnusedIamUserAccessKeyDetails = (output, context) => {
    return take(output, {
        accessKeyId: __expectString,
        lastAccessed: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_UnusedIamUserPasswordDetails = (output, context) => {
    return take(output, {
        lastAccessed: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
    });
};
const de_UnusedPermissionDetails = (output, context) => {
    return take(output, {
        actions: (_) => de_UnusedActionList(_, context),
        lastAccessed: (_) => __expectNonNull(__parseRfc3339DateTimeWithOffset(_)),
        serviceNamespace: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _aA = "analyzerArn";
const _cT = "clientToken";
const _iRP = "includeResourcePlaceholders";
const _iSLT = "includeServiceLevelTemplate";
const _mR = "maxResults";
const _nT = "nextToken";
const _pA = "principalArn";
const _rA = "resourceArn";
const _rAS = "retryAfterSeconds";
const _ra = "retry-after";
const _t = "type";
const _tK = "tagKeys";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
