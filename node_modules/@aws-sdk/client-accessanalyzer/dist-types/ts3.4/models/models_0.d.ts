import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { AccessAnalyzerServiceException as __BaseException } from "./AccessAnalyzerServiceException";
export interface Access {
  actions: string[] | undefined;
}
export declare class AccessDeniedException extends __BaseException {
  readonly name: "AccessDeniedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<AccessDeniedException, __BaseException>
  );
}
export declare class ConflictException extends __BaseException {
  readonly name: "ConflictException";
  readonly $fault: "client";
  resourceId: string | undefined;
  resourceType: string | undefined;
  constructor(opts: __ExceptionOptionType<ConflictException, __BaseException>);
}
export interface Criterion {
  eq?: string[];
  neq?: string[];
  contains?: string[];
  exists?: boolean;
}
export interface CreateArchiveRuleRequest {
  analyzerName: string | undefined;
  ruleName: string | undefined;
  filter: Record<string, Criterion> | undefined;
  clientToken?: string;
}
export declare class InternalServerException extends __BaseException {
  readonly name: "InternalServerException";
  readonly $fault: "server";
  $retryable: {};
  retryAfterSeconds?: number;
  constructor(
    opts: __ExceptionOptionType<InternalServerException, __BaseException>
  );
}
export declare class ResourceNotFoundException extends __BaseException {
  readonly name: "ResourceNotFoundException";
  readonly $fault: "client";
  resourceId: string | undefined;
  resourceType: string | undefined;
  constructor(
    opts: __ExceptionOptionType<ResourceNotFoundException, __BaseException>
  );
}
export declare class ServiceQuotaExceededException extends __BaseException {
  readonly name: "ServiceQuotaExceededException";
  readonly $fault: "client";
  resourceId: string | undefined;
  resourceType: string | undefined;
  constructor(
    opts: __ExceptionOptionType<ServiceQuotaExceededException, __BaseException>
  );
}
export declare class ThrottlingException extends __BaseException {
  readonly name: "ThrottlingException";
  readonly $fault: "client";
  $retryable: {
    throttling: boolean;
  };
  retryAfterSeconds?: number;
  constructor(
    opts: __ExceptionOptionType<ThrottlingException, __BaseException>
  );
}
export interface ValidationExceptionField {
  name: string | undefined;
  message: string | undefined;
}
export declare const ValidationExceptionReason: {
  readonly CANNOT_PARSE: "cannotParse";
  readonly FIELD_VALIDATION_FAILED: "fieldValidationFailed";
  readonly OTHER: "other";
  readonly UNKNOWN_OPERATION: "unknownOperation";
};
export type ValidationExceptionReason =
  (typeof ValidationExceptionReason)[keyof typeof ValidationExceptionReason];
export declare class ValidationException extends __BaseException {
  readonly name: "ValidationException";
  readonly $fault: "client";
  reason: ValidationExceptionReason | undefined;
  fieldList?: ValidationExceptionField[];
  constructor(
    opts: __ExceptionOptionType<ValidationException, __BaseException>
  );
}
export interface DeleteArchiveRuleRequest {
  analyzerName: string | undefined;
  ruleName: string | undefined;
  clientToken?: string;
}
export interface GetArchiveRuleRequest {
  analyzerName: string | undefined;
  ruleName: string | undefined;
}
export interface ArchiveRuleSummary {
  ruleName: string | undefined;
  filter: Record<string, Criterion> | undefined;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
}
export interface GetArchiveRuleResponse {
  archiveRule: ArchiveRuleSummary | undefined;
}
export interface ListArchiveRulesRequest {
  analyzerName: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface ListArchiveRulesResponse {
  archiveRules: ArchiveRuleSummary[] | undefined;
  nextToken?: string;
}
export interface UpdateArchiveRuleRequest {
  analyzerName: string | undefined;
  ruleName: string | undefined;
  filter: Record<string, Criterion> | undefined;
  clientToken?: string;
}
export interface InlineArchiveRule {
  ruleName: string | undefined;
  filter: Record<string, Criterion> | undefined;
}
export interface UnusedAccessConfiguration {
  unusedAccessAge?: number;
}
export type AnalyzerConfiguration =
  | AnalyzerConfiguration.UnusedAccessMember
  | AnalyzerConfiguration.$UnknownMember;
export declare namespace AnalyzerConfiguration {
  interface UnusedAccessMember {
    unusedAccess: UnusedAccessConfiguration;
    $unknown?: never;
  }
  interface $UnknownMember {
    unusedAccess?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    unusedAccess: (value: UnusedAccessConfiguration) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: AnalyzerConfiguration, visitor: Visitor<T>) => T;
}
export type Type =
  | "ACCOUNT"
  | "ACCOUNT_UNUSED_ACCESS"
  | "ORGANIZATION"
  | "ORGANIZATION_UNUSED_ACCESS";
export interface CreateAnalyzerRequest {
  analyzerName: string | undefined;
  type: Type | undefined;
  archiveRules?: InlineArchiveRule[];
  tags?: Record<string, string>;
  clientToken?: string;
  configuration?: AnalyzerConfiguration;
}
export interface CreateAnalyzerResponse {
  arn?: string;
}
export interface DeleteAnalyzerRequest {
  analyzerName: string | undefined;
  clientToken?: string;
}
export interface GetAnalyzerRequest {
  analyzerName: string | undefined;
}
export type AnalyzerStatus = "ACTIVE" | "CREATING" | "DISABLED" | "FAILED";
export type ReasonCode =
  | "AWS_SERVICE_ACCESS_DISABLED"
  | "DELEGATED_ADMINISTRATOR_DEREGISTERED"
  | "ORGANIZATION_DELETED"
  | "SERVICE_LINKED_ROLE_CREATION_FAILED";
export interface StatusReason {
  code: ReasonCode | undefined;
}
export interface AnalyzerSummary {
  arn: string | undefined;
  name: string | undefined;
  type: Type | undefined;
  createdAt: Date | undefined;
  lastResourceAnalyzed?: string;
  lastResourceAnalyzedAt?: Date;
  tags?: Record<string, string>;
  status: AnalyzerStatus | undefined;
  statusReason?: StatusReason;
  configuration?: AnalyzerConfiguration;
}
export interface GetAnalyzerResponse {
  analyzer: AnalyzerSummary | undefined;
}
export interface ListAnalyzersRequest {
  nextToken?: string;
  maxResults?: number;
  type?: Type;
}
export interface ListAnalyzersResponse {
  analyzers: AnalyzerSummary[] | undefined;
  nextToken?: string;
}
export interface ApplyArchiveRuleRequest {
  analyzerArn: string | undefined;
  ruleName: string | undefined;
  clientToken?: string;
}
export interface CancelPolicyGenerationRequest {
  jobId: string | undefined;
}
export interface CancelPolicyGenerationResponse {}
export declare const AccessCheckPolicyType: {
  readonly IDENTITY_POLICY: "IDENTITY_POLICY";
  readonly RESOURCE_POLICY: "RESOURCE_POLICY";
};
export type AccessCheckPolicyType =
  (typeof AccessCheckPolicyType)[keyof typeof AccessCheckPolicyType];
export interface CheckAccessNotGrantedRequest {
  policyDocument: string | undefined;
  access: Access[] | undefined;
  policyType: AccessCheckPolicyType | undefined;
}
export interface ReasonSummary {
  description?: string;
  statementIndex?: number;
  statementId?: string;
}
export declare const CheckAccessNotGrantedResult: {
  readonly FAIL: "FAIL";
  readonly PASS: "PASS";
};
export type CheckAccessNotGrantedResult =
  (typeof CheckAccessNotGrantedResult)[keyof typeof CheckAccessNotGrantedResult];
export interface CheckAccessNotGrantedResponse {
  result?: CheckAccessNotGrantedResult;
  message?: string;
  reasons?: ReasonSummary[];
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class UnprocessableEntityException extends __BaseException {
  readonly name: "UnprocessableEntityException";
  readonly $fault: "client";
  $retryable: {};
  constructor(
    opts: __ExceptionOptionType<UnprocessableEntityException, __BaseException>
  );
}
export interface CheckNoNewAccessRequest {
  newPolicyDocument: string | undefined;
  existingPolicyDocument: string | undefined;
  policyType: AccessCheckPolicyType | undefined;
}
export declare const CheckNoNewAccessResult: {
  readonly FAIL: "FAIL";
  readonly PASS: "PASS";
};
export type CheckNoNewAccessResult =
  (typeof CheckNoNewAccessResult)[keyof typeof CheckNoNewAccessResult];
export interface CheckNoNewAccessResponse {
  result?: CheckNoNewAccessResult;
  message?: string;
  reasons?: ReasonSummary[];
}
export interface DynamodbStreamConfiguration {
  streamPolicy?: string;
}
export interface DynamodbTableConfiguration {
  tablePolicy?: string;
}
export interface EbsSnapshotConfiguration {
  userIds?: string[];
  groups?: string[];
  kmsKeyId?: string;
}
export interface EcrRepositoryConfiguration {
  repositoryPolicy?: string;
}
export interface EfsFileSystemConfiguration {
  fileSystemPolicy?: string;
}
export interface IamRoleConfiguration {
  trustPolicy?: string;
}
export interface KmsGrantConstraints {
  encryptionContextEquals?: Record<string, string>;
  encryptionContextSubset?: Record<string, string>;
}
export declare const KmsGrantOperation: {
  readonly CREATE_GRANT: "CreateGrant";
  readonly DECRYPT: "Decrypt";
  readonly DESCRIBE_KEY: "DescribeKey";
  readonly ENCRYPT: "Encrypt";
  readonly GENERATE_DATA_KEY: "GenerateDataKey";
  readonly GENERATE_DATA_KEY_PAIR: "GenerateDataKeyPair";
  readonly GENERATE_DATA_KEY_PAIR_WITHOUT_PLAINTEXT: "GenerateDataKeyPairWithoutPlaintext";
  readonly GENERATE_DATA_KEY_WITHOUT_PLAINTEXT: "GenerateDataKeyWithoutPlaintext";
  readonly GET_PUBLIC_KEY: "GetPublicKey";
  readonly REENCRYPT_FROM: "ReEncryptFrom";
  readonly REENCRYPT_TO: "ReEncryptTo";
  readonly RETIRE_GRANT: "RetireGrant";
  readonly SIGN: "Sign";
  readonly VERIFY: "Verify";
};
export type KmsGrantOperation =
  (typeof KmsGrantOperation)[keyof typeof KmsGrantOperation];
export interface KmsGrantConfiguration {
  operations: KmsGrantOperation[] | undefined;
  granteePrincipal: string | undefined;
  retiringPrincipal?: string;
  constraints?: KmsGrantConstraints;
  issuingAccount: string | undefined;
}
export interface KmsKeyConfiguration {
  keyPolicies?: Record<string, string>;
  grants?: KmsGrantConfiguration[];
}
export type RdsDbClusterSnapshotAttributeValue =
  | RdsDbClusterSnapshotAttributeValue.AccountIdsMember
  | RdsDbClusterSnapshotAttributeValue.$UnknownMember;
export declare namespace RdsDbClusterSnapshotAttributeValue {
  interface AccountIdsMember {
    accountIds: string[];
    $unknown?: never;
  }
  interface $UnknownMember {
    accountIds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    accountIds: (value: string[]) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: RdsDbClusterSnapshotAttributeValue,
    visitor: Visitor<T>
  ) => T;
}
export interface RdsDbClusterSnapshotConfiguration {
  attributes?: Record<string, RdsDbClusterSnapshotAttributeValue>;
  kmsKeyId?: string;
}
export type RdsDbSnapshotAttributeValue =
  | RdsDbSnapshotAttributeValue.AccountIdsMember
  | RdsDbSnapshotAttributeValue.$UnknownMember;
export declare namespace RdsDbSnapshotAttributeValue {
  interface AccountIdsMember {
    accountIds: string[];
    $unknown?: never;
  }
  interface $UnknownMember {
    accountIds?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    accountIds: (value: string[]) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(
    value: RdsDbSnapshotAttributeValue,
    visitor: Visitor<T>
  ) => T;
}
export interface RdsDbSnapshotConfiguration {
  attributes?: Record<string, RdsDbSnapshotAttributeValue>;
  kmsKeyId?: string;
}
export interface InternetConfiguration {}
export interface VpcConfiguration {
  vpcId: string | undefined;
}
export type NetworkOriginConfiguration =
  | NetworkOriginConfiguration.InternetConfigurationMember
  | NetworkOriginConfiguration.VpcConfigurationMember
  | NetworkOriginConfiguration.$UnknownMember;
export declare namespace NetworkOriginConfiguration {
  interface VpcConfigurationMember {
    vpcConfiguration: VpcConfiguration;
    internetConfiguration?: never;
    $unknown?: never;
  }
  interface InternetConfigurationMember {
    vpcConfiguration?: never;
    internetConfiguration: InternetConfiguration;
    $unknown?: never;
  }
  interface $UnknownMember {
    vpcConfiguration?: never;
    internetConfiguration?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    vpcConfiguration: (value: VpcConfiguration) => T;
    internetConfiguration: (value: InternetConfiguration) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: NetworkOriginConfiguration, visitor: Visitor<T>) => T;
}
export interface S3PublicAccessBlockConfiguration {
  ignorePublicAcls: boolean | undefined;
  restrictPublicBuckets: boolean | undefined;
}
export interface S3AccessPointConfiguration {
  accessPointPolicy?: string;
  publicAccessBlock?: S3PublicAccessBlockConfiguration;
  networkOrigin?: NetworkOriginConfiguration;
}
export type AclGrantee =
  | AclGrantee.IdMember
  | AclGrantee.UriMember
  | AclGrantee.$UnknownMember;
export declare namespace AclGrantee {
  interface IdMember {
    id: string;
    uri?: never;
    $unknown?: never;
  }
  interface UriMember {
    id?: never;
    uri: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    id?: never;
    uri?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    id: (value: string) => T;
    uri: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: AclGrantee, visitor: Visitor<T>) => T;
}
export declare const AclPermission: {
  readonly FULL_CONTROL: "FULL_CONTROL";
  readonly READ: "READ";
  readonly READ_ACP: "READ_ACP";
  readonly WRITE: "WRITE";
  readonly WRITE_ACP: "WRITE_ACP";
};
export type AclPermission = (typeof AclPermission)[keyof typeof AclPermission];
export interface S3BucketAclGrantConfiguration {
  permission: AclPermission | undefined;
  grantee: AclGrantee | undefined;
}
export interface S3BucketConfiguration {
  bucketPolicy?: string;
  bucketAclGrants?: S3BucketAclGrantConfiguration[];
  bucketPublicAccessBlock?: S3PublicAccessBlockConfiguration;
  accessPoints?: Record<string, S3AccessPointConfiguration>;
}
export interface S3ExpressDirectoryBucketConfiguration {
  bucketPolicy?: string;
}
export interface SecretsManagerSecretConfiguration {
  kmsKeyId?: string;
  secretPolicy?: string;
}
export interface SnsTopicConfiguration {
  topicPolicy?: string;
}
export interface SqsQueueConfiguration {
  queuePolicy?: string;
}
export type Configuration =
  | Configuration.DynamodbStreamMember
  | Configuration.DynamodbTableMember
  | Configuration.EbsSnapshotMember
  | Configuration.EcrRepositoryMember
  | Configuration.EfsFileSystemMember
  | Configuration.IamRoleMember
  | Configuration.KmsKeyMember
  | Configuration.RdsDbClusterSnapshotMember
  | Configuration.RdsDbSnapshotMember
  | Configuration.S3BucketMember
  | Configuration.S3ExpressDirectoryBucketMember
  | Configuration.SecretsManagerSecretMember
  | Configuration.SnsTopicMember
  | Configuration.SqsQueueMember
  | Configuration.$UnknownMember;
export declare namespace Configuration {
  interface EbsSnapshotMember {
    ebsSnapshot: EbsSnapshotConfiguration;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface EcrRepositoryMember {
    ebsSnapshot?: never;
    ecrRepository: EcrRepositoryConfiguration;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface IamRoleMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole: IamRoleConfiguration;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface EfsFileSystemMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem: EfsFileSystemConfiguration;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface KmsKeyMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey: KmsKeyConfiguration;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface RdsDbClusterSnapshotMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot: RdsDbClusterSnapshotConfiguration;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface RdsDbSnapshotMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot: RdsDbSnapshotConfiguration;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface SecretsManagerSecretMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret: SecretsManagerSecretConfiguration;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface S3BucketMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket: S3BucketConfiguration;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface SnsTopicMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic: SnsTopicConfiguration;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface SqsQueueMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue: SqsQueueConfiguration;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface S3ExpressDirectoryBucketMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket: S3ExpressDirectoryBucketConfiguration;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface DynamodbStreamMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream: DynamodbStreamConfiguration;
    dynamodbTable?: never;
    $unknown?: never;
  }
  interface DynamodbTableMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable: DynamodbTableConfiguration;
    $unknown?: never;
  }
  interface $UnknownMember {
    ebsSnapshot?: never;
    ecrRepository?: never;
    iamRole?: never;
    efsFileSystem?: never;
    kmsKey?: never;
    rdsDbClusterSnapshot?: never;
    rdsDbSnapshot?: never;
    secretsManagerSecret?: never;
    s3Bucket?: never;
    snsTopic?: never;
    sqsQueue?: never;
    s3ExpressDirectoryBucket?: never;
    dynamodbStream?: never;
    dynamodbTable?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    ebsSnapshot: (value: EbsSnapshotConfiguration) => T;
    ecrRepository: (value: EcrRepositoryConfiguration) => T;
    iamRole: (value: IamRoleConfiguration) => T;
    efsFileSystem: (value: EfsFileSystemConfiguration) => T;
    kmsKey: (value: KmsKeyConfiguration) => T;
    rdsDbClusterSnapshot: (value: RdsDbClusterSnapshotConfiguration) => T;
    rdsDbSnapshot: (value: RdsDbSnapshotConfiguration) => T;
    secretsManagerSecret: (value: SecretsManagerSecretConfiguration) => T;
    s3Bucket: (value: S3BucketConfiguration) => T;
    snsTopic: (value: SnsTopicConfiguration) => T;
    sqsQueue: (value: SqsQueueConfiguration) => T;
    s3ExpressDirectoryBucket: (
      value: S3ExpressDirectoryBucketConfiguration
    ) => T;
    dynamodbStream: (value: DynamodbStreamConfiguration) => T;
    dynamodbTable: (value: DynamodbTableConfiguration) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: Configuration, visitor: Visitor<T>) => T;
}
export interface CreateAccessPreviewRequest {
  analyzerArn: string | undefined;
  configurations: Record<string, Configuration> | undefined;
  clientToken?: string;
}
export interface CreateAccessPreviewResponse {
  id: string | undefined;
}
export interface GetAccessPreviewRequest {
  accessPreviewId: string | undefined;
  analyzerArn: string | undefined;
}
export declare const AccessPreviewStatus: {
  readonly COMPLETED: "COMPLETED";
  readonly CREATING: "CREATING";
  readonly FAILED: "FAILED";
};
export type AccessPreviewStatus =
  (typeof AccessPreviewStatus)[keyof typeof AccessPreviewStatus];
export declare const AccessPreviewStatusReasonCode: {
  readonly INTERNAL_ERROR: "INTERNAL_ERROR";
  readonly INVALID_CONFIGURATION: "INVALID_CONFIGURATION";
};
export type AccessPreviewStatusReasonCode =
  (typeof AccessPreviewStatusReasonCode)[keyof typeof AccessPreviewStatusReasonCode];
export interface AccessPreviewStatusReason {
  code: AccessPreviewStatusReasonCode | undefined;
}
export interface AccessPreview {
  id: string | undefined;
  analyzerArn: string | undefined;
  configurations: Record<string, Configuration> | undefined;
  createdAt: Date | undefined;
  status: AccessPreviewStatus | undefined;
  statusReason?: AccessPreviewStatusReason;
}
export interface GetAccessPreviewResponse {
  accessPreview: AccessPreview | undefined;
}
export interface GetAnalyzedResourceRequest {
  analyzerArn: string | undefined;
  resourceArn: string | undefined;
}
export type ResourceType =
  | "AWS::DynamoDB::Stream"
  | "AWS::DynamoDB::Table"
  | "AWS::EC2::Snapshot"
  | "AWS::ECR::Repository"
  | "AWS::EFS::FileSystem"
  | "AWS::IAM::Role"
  | "AWS::KMS::Key"
  | "AWS::Lambda::Function"
  | "AWS::Lambda::LayerVersion"
  | "AWS::RDS::DBClusterSnapshot"
  | "AWS::RDS::DBSnapshot"
  | "AWS::S3::Bucket"
  | "AWS::S3Express::DirectoryBucket"
  | "AWS::SNS::Topic"
  | "AWS::SQS::Queue"
  | "AWS::SecretsManager::Secret";
export type FindingStatus = "ACTIVE" | "ARCHIVED" | "RESOLVED";
export interface AnalyzedResource {
  resourceArn: string | undefined;
  resourceType: ResourceType | undefined;
  createdAt: Date | undefined;
  analyzedAt: Date | undefined;
  updatedAt: Date | undefined;
  isPublic: boolean | undefined;
  actions?: string[];
  sharedVia?: string[];
  status?: FindingStatus;
  resourceOwnerAccount: string | undefined;
  error?: string;
}
export interface GetAnalyzedResourceResponse {
  resource?: AnalyzedResource;
}
export interface GetFindingRequest {
  analyzerArn: string | undefined;
  id: string | undefined;
}
export interface FindingSourceDetail {
  accessPointArn?: string;
  accessPointAccount?: string;
}
export type FindingSourceType =
  | "BUCKET_ACL"
  | "POLICY"
  | "S3_ACCESS_POINT"
  | "S3_ACCESS_POINT_ACCOUNT";
export interface FindingSource {
  type: FindingSourceType | undefined;
  detail?: FindingSourceDetail;
}
export interface Finding {
  id: string | undefined;
  principal?: Record<string, string>;
  action?: string[];
  resource?: string;
  isPublic?: boolean;
  resourceType: ResourceType | undefined;
  condition: Record<string, string> | undefined;
  createdAt: Date | undefined;
  analyzedAt: Date | undefined;
  updatedAt: Date | undefined;
  status: FindingStatus | undefined;
  resourceOwnerAccount: string | undefined;
  error?: string;
  sources?: FindingSource[];
}
export interface GetFindingResponse {
  finding?: Finding;
}
export interface GetFindingV2Request {
  analyzerArn: string | undefined;
  id: string | undefined;
  maxResults?: number;
  nextToken?: string;
}
export interface ExternalAccessDetails {
  action?: string[];
  condition: Record<string, string> | undefined;
  isPublic?: boolean;
  principal?: Record<string, string>;
  sources?: FindingSource[];
}
export interface UnusedIamRoleDetails {
  lastAccessed?: Date;
}
export interface UnusedIamUserAccessKeyDetails {
  accessKeyId: string | undefined;
  lastAccessed?: Date;
}
export interface UnusedIamUserPasswordDetails {
  lastAccessed?: Date;
}
export interface UnusedAction {
  action: string | undefined;
  lastAccessed?: Date;
}
export interface UnusedPermissionDetails {
  actions?: UnusedAction[];
  serviceNamespace: string | undefined;
  lastAccessed?: Date;
}
export type FindingDetails =
  | FindingDetails.ExternalAccessDetailsMember
  | FindingDetails.UnusedIamRoleDetailsMember
  | FindingDetails.UnusedIamUserAccessKeyDetailsMember
  | FindingDetails.UnusedIamUserPasswordDetailsMember
  | FindingDetails.UnusedPermissionDetailsMember
  | FindingDetails.$UnknownMember;
export declare namespace FindingDetails {
  interface ExternalAccessDetailsMember {
    externalAccessDetails: ExternalAccessDetails;
    unusedPermissionDetails?: never;
    unusedIamUserAccessKeyDetails?: never;
    unusedIamRoleDetails?: never;
    unusedIamUserPasswordDetails?: never;
    $unknown?: never;
  }
  interface UnusedPermissionDetailsMember {
    externalAccessDetails?: never;
    unusedPermissionDetails: UnusedPermissionDetails;
    unusedIamUserAccessKeyDetails?: never;
    unusedIamRoleDetails?: never;
    unusedIamUserPasswordDetails?: never;
    $unknown?: never;
  }
  interface UnusedIamUserAccessKeyDetailsMember {
    externalAccessDetails?: never;
    unusedPermissionDetails?: never;
    unusedIamUserAccessKeyDetails: UnusedIamUserAccessKeyDetails;
    unusedIamRoleDetails?: never;
    unusedIamUserPasswordDetails?: never;
    $unknown?: never;
  }
  interface UnusedIamRoleDetailsMember {
    externalAccessDetails?: never;
    unusedPermissionDetails?: never;
    unusedIamUserAccessKeyDetails?: never;
    unusedIamRoleDetails: UnusedIamRoleDetails;
    unusedIamUserPasswordDetails?: never;
    $unknown?: never;
  }
  interface UnusedIamUserPasswordDetailsMember {
    externalAccessDetails?: never;
    unusedPermissionDetails?: never;
    unusedIamUserAccessKeyDetails?: never;
    unusedIamRoleDetails?: never;
    unusedIamUserPasswordDetails: UnusedIamUserPasswordDetails;
    $unknown?: never;
  }
  interface $UnknownMember {
    externalAccessDetails?: never;
    unusedPermissionDetails?: never;
    unusedIamUserAccessKeyDetails?: never;
    unusedIamRoleDetails?: never;
    unusedIamUserPasswordDetails?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    externalAccessDetails: (value: ExternalAccessDetails) => T;
    unusedPermissionDetails: (value: UnusedPermissionDetails) => T;
    unusedIamUserAccessKeyDetails: (value: UnusedIamUserAccessKeyDetails) => T;
    unusedIamRoleDetails: (value: UnusedIamRoleDetails) => T;
    unusedIamUserPasswordDetails: (value: UnusedIamUserPasswordDetails) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: FindingDetails, visitor: Visitor<T>) => T;
}
export declare const FindingType: {
  readonly EXTERNAL_ACCESS: "ExternalAccess";
  readonly UNUSED_IAM_ROLE: "UnusedIAMRole";
  readonly UNUSED_IAM_USER_ACCESS_KEY: "UnusedIAMUserAccessKey";
  readonly UNUSED_IAM_USER_PASSWORD: "UnusedIAMUserPassword";
  readonly UNUSED_PERMISSION: "UnusedPermission";
};
export type FindingType = (typeof FindingType)[keyof typeof FindingType];
export interface GetFindingV2Response {
  analyzedAt: Date | undefined;
  createdAt: Date | undefined;
  error?: string;
  id: string | undefined;
  nextToken?: string;
  resource?: string;
  resourceType: ResourceType | undefined;
  resourceOwnerAccount: string | undefined;
  status: FindingStatus | undefined;
  updatedAt: Date | undefined;
  findingDetails: FindingDetails[] | undefined;
  findingType?: FindingType;
}
export interface GetGeneratedPolicyRequest {
  jobId: string | undefined;
  includeResourcePlaceholders?: boolean;
  includeServiceLevelTemplate?: boolean;
}
export interface GeneratedPolicy {
  policy: string | undefined;
}
export interface TrailProperties {
  cloudTrailArn: string | undefined;
  regions?: string[];
  allRegions?: boolean;
}
export interface CloudTrailProperties {
  trailProperties: TrailProperties[] | undefined;
  startTime: Date | undefined;
  endTime: Date | undefined;
}
export interface GeneratedPolicyProperties {
  isComplete?: boolean;
  principalArn: string | undefined;
  cloudTrailProperties?: CloudTrailProperties;
}
export interface GeneratedPolicyResult {
  properties: GeneratedPolicyProperties | undefined;
  generatedPolicies?: GeneratedPolicy[];
}
export declare const JobErrorCode: {
  readonly AUTHORIZATION_ERROR: "AUTHORIZATION_ERROR";
  readonly RESOURCE_NOT_FOUND_ERROR: "RESOURCE_NOT_FOUND_ERROR";
  readonly SERVICE_ERROR: "SERVICE_ERROR";
  readonly SERVICE_QUOTA_EXCEEDED_ERROR: "SERVICE_QUOTA_EXCEEDED_ERROR";
};
export type JobErrorCode = (typeof JobErrorCode)[keyof typeof JobErrorCode];
export interface JobError {
  code: JobErrorCode | undefined;
  message: string | undefined;
}
export declare const JobStatus: {
  readonly CANCELED: "CANCELED";
  readonly FAILED: "FAILED";
  readonly IN_PROGRESS: "IN_PROGRESS";
  readonly SUCCEEDED: "SUCCEEDED";
};
export type JobStatus = (typeof JobStatus)[keyof typeof JobStatus];
export interface JobDetails {
  jobId: string | undefined;
  status: JobStatus | undefined;
  startedOn: Date | undefined;
  completedOn?: Date;
  jobError?: JobError;
}
export interface GetGeneratedPolicyResponse {
  jobDetails: JobDetails | undefined;
  generatedPolicyResult: GeneratedPolicyResult | undefined;
}
export interface ListAccessPreviewFindingsRequest {
  accessPreviewId: string | undefined;
  analyzerArn: string | undefined;
  filter?: Record<string, Criterion>;
  nextToken?: string;
  maxResults?: number;
}
export declare const FindingChangeType: {
  readonly CHANGED: "CHANGED";
  readonly NEW: "NEW";
  readonly UNCHANGED: "UNCHANGED";
};
export type FindingChangeType =
  (typeof FindingChangeType)[keyof typeof FindingChangeType];
export interface AccessPreviewFinding {
  id: string | undefined;
  existingFindingId?: string;
  existingFindingStatus?: FindingStatus;
  principal?: Record<string, string>;
  action?: string[];
  condition?: Record<string, string>;
  resource?: string;
  isPublic?: boolean;
  resourceType: ResourceType | undefined;
  createdAt: Date | undefined;
  changeType: FindingChangeType | undefined;
  status: FindingStatus | undefined;
  resourceOwnerAccount: string | undefined;
  error?: string;
  sources?: FindingSource[];
}
export interface ListAccessPreviewFindingsResponse {
  findings: AccessPreviewFinding[] | undefined;
  nextToken?: string;
}
export interface ListAccessPreviewsRequest {
  analyzerArn: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface AccessPreviewSummary {
  id: string | undefined;
  analyzerArn: string | undefined;
  createdAt: Date | undefined;
  status: AccessPreviewStatus | undefined;
  statusReason?: AccessPreviewStatusReason;
}
export interface ListAccessPreviewsResponse {
  accessPreviews: AccessPreviewSummary[] | undefined;
  nextToken?: string;
}
export interface ListAnalyzedResourcesRequest {
  analyzerArn: string | undefined;
  resourceType?: ResourceType;
  nextToken?: string;
  maxResults?: number;
}
export interface AnalyzedResourceSummary {
  resourceArn: string | undefined;
  resourceOwnerAccount: string | undefined;
  resourceType: ResourceType | undefined;
}
export interface ListAnalyzedResourcesResponse {
  analyzedResources: AnalyzedResourceSummary[] | undefined;
  nextToken?: string;
}
export type OrderBy = "ASC" | "DESC";
export interface SortCriteria {
  attributeName?: string;
  orderBy?: OrderBy;
}
export interface ListFindingsRequest {
  analyzerArn: string | undefined;
  filter?: Record<string, Criterion>;
  sort?: SortCriteria;
  nextToken?: string;
  maxResults?: number;
}
export interface FindingSummary {
  id: string | undefined;
  principal?: Record<string, string>;
  action?: string[];
  resource?: string;
  isPublic?: boolean;
  resourceType: ResourceType | undefined;
  condition: Record<string, string> | undefined;
  createdAt: Date | undefined;
  analyzedAt: Date | undefined;
  updatedAt: Date | undefined;
  status: FindingStatus | undefined;
  resourceOwnerAccount: string | undefined;
  error?: string;
  sources?: FindingSource[];
}
export interface ListFindingsResponse {
  findings: FindingSummary[] | undefined;
  nextToken?: string;
}
export interface ListFindingsV2Request {
  analyzerArn: string | undefined;
  filter?: Record<string, Criterion>;
  maxResults?: number;
  nextToken?: string;
  sort?: SortCriteria;
}
export interface FindingSummaryV2 {
  analyzedAt: Date | undefined;
  createdAt: Date | undefined;
  error?: string;
  id: string | undefined;
  resource?: string;
  resourceType: ResourceType | undefined;
  resourceOwnerAccount: string | undefined;
  status: FindingStatus | undefined;
  updatedAt: Date | undefined;
  findingType?: FindingType;
}
export interface ListFindingsV2Response {
  findings: FindingSummaryV2[] | undefined;
  nextToken?: string;
}
export interface ListPolicyGenerationsRequest {
  principalArn?: string;
  maxResults?: number;
  nextToken?: string;
}
export interface PolicyGeneration {
  jobId: string | undefined;
  principalArn: string | undefined;
  status: JobStatus | undefined;
  startedOn: Date | undefined;
  completedOn?: Date;
}
export interface ListPolicyGenerationsResponse {
  policyGenerations: PolicyGeneration[] | undefined;
  nextToken?: string;
}
export interface ListTagsForResourceRequest {
  resourceArn: string | undefined;
}
export interface ListTagsForResourceResponse {
  tags?: Record<string, string>;
}
export interface Trail {
  cloudTrailArn: string | undefined;
  regions?: string[];
  allRegions?: boolean;
}
export interface CloudTrailDetails {
  trails: Trail[] | undefined;
  accessRole: string | undefined;
  startTime: Date | undefined;
  endTime?: Date;
}
export interface PolicyGenerationDetails {
  principalArn: string | undefined;
}
export interface StartPolicyGenerationRequest {
  policyGenerationDetails: PolicyGenerationDetails | undefined;
  cloudTrailDetails?: CloudTrailDetails;
  clientToken?: string;
}
export interface StartPolicyGenerationResponse {
  jobId: string | undefined;
}
export interface StartResourceScanRequest {
  analyzerArn: string | undefined;
  resourceArn: string | undefined;
  resourceOwnerAccount?: string;
}
export interface TagResourceRequest {
  resourceArn: string | undefined;
  tags: Record<string, string> | undefined;
}
export interface TagResourceResponse {}
export interface UntagResourceRequest {
  resourceArn: string | undefined;
  tagKeys: string[] | undefined;
}
export interface UntagResourceResponse {}
export type FindingStatusUpdate = "ACTIVE" | "ARCHIVED";
export interface UpdateFindingsRequest {
  analyzerArn: string | undefined;
  status: FindingStatusUpdate | undefined;
  ids?: string[];
  resourceArn?: string;
  clientToken?: string;
}
export declare const Locale: {
  readonly DE: "DE";
  readonly EN: "EN";
  readonly ES: "ES";
  readonly FR: "FR";
  readonly IT: "IT";
  readonly JA: "JA";
  readonly KO: "KO";
  readonly PT_BR: "PT_BR";
  readonly ZH_CN: "ZH_CN";
  readonly ZH_TW: "ZH_TW";
};
export type Locale = (typeof Locale)[keyof typeof Locale];
export declare const PolicyType: {
  readonly IDENTITY_POLICY: "IDENTITY_POLICY";
  readonly RESOURCE_POLICY: "RESOURCE_POLICY";
  readonly SERVICE_CONTROL_POLICY: "SERVICE_CONTROL_POLICY";
};
export type PolicyType = (typeof PolicyType)[keyof typeof PolicyType];
export declare const ValidatePolicyResourceType: {
  readonly DYNAMODB_TABLE: "AWS::DynamoDB::Table";
  readonly ROLE_TRUST: "AWS::IAM::AssumeRolePolicyDocument";
  readonly S3_ACCESS_POINT: "AWS::S3::AccessPoint";
  readonly S3_BUCKET: "AWS::S3::Bucket";
  readonly S3_MULTI_REGION_ACCESS_POINT: "AWS::S3::MultiRegionAccessPoint";
  readonly S3_OBJECT_LAMBDA_ACCESS_POINT: "AWS::S3ObjectLambda::AccessPoint";
};
export type ValidatePolicyResourceType =
  (typeof ValidatePolicyResourceType)[keyof typeof ValidatePolicyResourceType];
export interface ValidatePolicyRequest {
  locale?: Locale;
  maxResults?: number;
  nextToken?: string;
  policyDocument: string | undefined;
  policyType: PolicyType | undefined;
  validatePolicyResourceType?: ValidatePolicyResourceType;
}
export declare const ValidatePolicyFindingType: {
  readonly ERROR: "ERROR";
  readonly SECURITY_WARNING: "SECURITY_WARNING";
  readonly SUGGESTION: "SUGGESTION";
  readonly WARNING: "WARNING";
};
export type ValidatePolicyFindingType =
  (typeof ValidatePolicyFindingType)[keyof typeof ValidatePolicyFindingType];
export interface Substring {
  start: number | undefined;
  length: number | undefined;
}
export type PathElement =
  | PathElement.IndexMember
  | PathElement.KeyMember
  | PathElement.SubstringMember
  | PathElement.ValueMember
  | PathElement.$UnknownMember;
export declare namespace PathElement {
  interface IndexMember {
    index: number;
    key?: never;
    substring?: never;
    value?: never;
    $unknown?: never;
  }
  interface KeyMember {
    index?: never;
    key: string;
    substring?: never;
    value?: never;
    $unknown?: never;
  }
  interface SubstringMember {
    index?: never;
    key?: never;
    substring: Substring;
    value?: never;
    $unknown?: never;
  }
  interface ValueMember {
    index?: never;
    key?: never;
    substring?: never;
    value: string;
    $unknown?: never;
  }
  interface $UnknownMember {
    index?: never;
    key?: never;
    substring?: never;
    value?: never;
    $unknown: [string, any];
  }
  interface Visitor<T> {
    index: (value: number) => T;
    key: (value: string) => T;
    substring: (value: Substring) => T;
    value: (value: string) => T;
    _: (name: string, value: any) => T;
  }
  const visit: <T>(value: PathElement, visitor: Visitor<T>) => T;
}
export interface Position {
  line: number | undefined;
  column: number | undefined;
  offset: number | undefined;
}
export interface Span {
  start: Position | undefined;
  end: Position | undefined;
}
export interface Location {
  path: PathElement[] | undefined;
  span: Span | undefined;
}
export interface ValidatePolicyFinding {
  findingDetails: string | undefined;
  findingType: ValidatePolicyFindingType | undefined;
  issueCode: string | undefined;
  learnMoreLink: string | undefined;
  locations: Location[] | undefined;
}
export interface ValidatePolicyResponse {
  findings: ValidatePolicyFinding[] | undefined;
  nextToken?: string;
}
export declare const CheckAccessNotGrantedRequestFilterSensitiveLog: (
  obj: CheckAccessNotGrantedRequest
) => any;
export declare const CheckNoNewAccessRequestFilterSensitiveLog: (
  obj: CheckNoNewAccessRequest
) => any;
