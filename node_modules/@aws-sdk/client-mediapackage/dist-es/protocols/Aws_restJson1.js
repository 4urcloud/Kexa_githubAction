import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectNonNull as __expectNonNull, expectObject as __expectObject, expectString as __expectString, map, take, withBaseException, } from "@smithy/smithy-client";
import { MediaPackageServiceException as __BaseException } from "../models/MediaPackageServiceException";
import { ForbiddenException, InternalServerErrorException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, UnprocessableEntityException, } from "../models/models_0";
export const se_ConfigureLogsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/channels/{Id}/configure_logs");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    body = JSON.stringify(take(input, {
        egressAccessLogs: [, (_) => se_EgressAccessLogs(_, context), `EgressAccessLogs`],
        ingressAccessLogs: [, (_) => se_IngressAccessLogs(_, context), `IngressAccessLogs`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateChannelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/channels");
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
        id: [, , `Id`],
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateHarvestJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/harvest_jobs");
    let body;
    body = JSON.stringify(take(input, {
        endTime: [, , `EndTime`],
        id: [, , `Id`],
        originEndpointId: [, , `OriginEndpointId`],
        s3Destination: [, (_) => se_S3Destination(_, context), `S3Destination`],
        startTime: [, , `StartTime`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateOriginEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/origin_endpoints");
    let body;
    body = JSON.stringify(take(input, {
        authorization: [, (_) => se_Authorization(_, context), `Authorization`],
        channelId: [, , `ChannelId`],
        cmafPackage: [, (_) => se_CmafPackageCreateOrUpdateParameters(_, context), `CmafPackage`],
        dashPackage: [, (_) => se_DashPackage(_, context), `DashPackage`],
        description: [, , `Description`],
        hlsPackage: [, (_) => se_HlsPackage(_, context), `HlsPackage`],
        id: [, , `Id`],
        manifestName: [, , `ManifestName`],
        mssPackage: [, (_) => se_MssPackage(_, context), `MssPackage`],
        origination: [, , `Origination`],
        startoverWindowSeconds: [, , `StartoverWindowSeconds`],
        tags: [, (_) => _json(_), `Tags`],
        timeDelaySeconds: [, , `TimeDelaySeconds`],
        whitelist: [, (_) => _json(_), `Whitelist`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteChannelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/channels/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteOriginEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/origin_endpoints/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DescribeChannelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/channels/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeHarvestJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/harvest_jobs/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_DescribeOriginEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/origin_endpoints/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListChannelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/channels");
    const query = map({
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListHarvestJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/harvest_jobs");
    const query = map({
        [_iCI]: [, input[_ICI]],
        [_iS]: [, input[_IS]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListOriginEndpointsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/origin_endpoints");
    const query = map({
        [_cI]: [, input[_CI]],
        [_mR]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_nT]: [, input[_NT]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_RotateChannelCredentialsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/channels/{Id}/credentials");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_RotateIngestEndpointCredentialsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/channels/{Id}/ingest_endpoints/{IngestEndpointId}/credentials");
    b.p("Id", () => input.Id, "{Id}", false);
    b.p("IngestEndpointId", () => input.IngestEndpointId, "{IngestEndpointId}", false);
    let body;
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: [, (_) => _json(_), `Tags`],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{ResourceArn}");
    b.p("ResourceArn", () => input.ResourceArn, "{ResourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input[_TK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateChannelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/channels/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [, , `Description`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateOriginEndpointCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/origin_endpoints/{Id}");
    b.p("Id", () => input.Id, "{Id}", false);
    let body;
    body = JSON.stringify(take(input, {
        authorization: [, (_) => se_Authorization(_, context), `Authorization`],
        cmafPackage: [, (_) => se_CmafPackageCreateOrUpdateParameters(_, context), `CmafPackage`],
        dashPackage: [, (_) => se_DashPackage(_, context), `DashPackage`],
        description: [, , `Description`],
        hlsPackage: [, (_) => se_HlsPackage(_, context), `HlsPackage`],
        manifestName: [, , `ManifestName`],
        mssPackage: [, (_) => se_MssPackage(_, context), `MssPackage`],
        origination: [, , `Origination`],
        startoverWindowSeconds: [, , `StartoverWindowSeconds`],
        timeDelaySeconds: [, , `TimeDelaySeconds`],
        whitelist: [, (_) => _json(_), `Whitelist`],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_ConfigureLogsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateChannelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateHarvestJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        ChannelId: [, __expectString, `channelId`],
        CreatedAt: [, __expectString, `createdAt`],
        EndTime: [, __expectString, `endTime`],
        Id: [, __expectString, `id`],
        OriginEndpointId: [, __expectString, `originEndpointId`],
        S3Destination: [, (_) => de_S3Destination(_, context), `s3Destination`],
        StartTime: [, __expectString, `startTime`],
        Status: [, __expectString, `status`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateOriginEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        ChannelId: [, __expectString, `channelId`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        Description: [, __expectString, `description`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        ManifestName: [, __expectString, `manifestName`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        Origination: [, __expectString, `origination`],
        StartoverWindowSeconds: [, __expectInt32, `startoverWindowSeconds`],
        Tags: [, _json, `tags`],
        TimeDelaySeconds: [, __expectInt32, `timeDelaySeconds`],
        Url: [, __expectString, `url`],
        Whitelist: [, _json, `whitelist`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteChannelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteOriginEndpointCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DescribeChannelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeHarvestJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        ChannelId: [, __expectString, `channelId`],
        CreatedAt: [, __expectString, `createdAt`],
        EndTime: [, __expectString, `endTime`],
        Id: [, __expectString, `id`],
        OriginEndpointId: [, __expectString, `originEndpointId`],
        S3Destination: [, (_) => de_S3Destination(_, context), `s3Destination`],
        StartTime: [, __expectString, `startTime`],
        Status: [, __expectString, `status`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DescribeOriginEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        ChannelId: [, __expectString, `channelId`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        Description: [, __expectString, `description`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        ManifestName: [, __expectString, `manifestName`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        Origination: [, __expectString, `origination`],
        StartoverWindowSeconds: [, __expectInt32, `startoverWindowSeconds`],
        Tags: [, _json, `tags`],
        TimeDelaySeconds: [, __expectInt32, `timeDelaySeconds`],
        Url: [, __expectString, `url`],
        Whitelist: [, _json, `whitelist`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListChannelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Channels: [, (_) => de___listOfChannel(_, context), `channels`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListHarvestJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        HarvestJobs: [, (_) => de___listOfHarvestJob(_, context), `harvestJobs`],
        NextToken: [, __expectString, `nextToken`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListOriginEndpointsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        NextToken: [, __expectString, `nextToken`],
        OriginEndpoints: [, (_) => de___listOfOriginEndpoint(_, context), `originEndpoints`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RotateChannelCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RotateIngestEndpointCredentialsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateChannelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateOriginEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        ChannelId: [, __expectString, `channelId`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        Description: [, __expectString, `description`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        ManifestName: [, __expectString, `manifestName`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        Origination: [, __expectString, `origination`],
        StartoverWindowSeconds: [, __expectInt32, `startoverWindowSeconds`],
        Tags: [, _json, `tags`],
        TimeDelaySeconds: [, __expectInt32, `timeDelaySeconds`],
        Url: [, __expectString, `url`],
        Whitelist: [, _json, `whitelist`],
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ForbiddenException":
        case "com.amazonaws.mediapackage#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalServerErrorException":
        case "com.amazonaws.mediapackage#InternalServerErrorException":
            throw await de_InternalServerErrorExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.mediapackage#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.mediapackage#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.mediapackage#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnprocessableEntityException":
        case "com.amazonaws.mediapackage#UnprocessableEntityException":
            throw await de_UnprocessableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_ForbiddenExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerErrorExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new InternalServerErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnprocessableEntityExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: [, __expectString, `message`],
    });
    Object.assign(contents, doc);
    const exception = new UnprocessableEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se___listOfHlsManifestCreateOrUpdateParameters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_HlsManifestCreateOrUpdateParameters(entry, context);
    });
};
const se_Authorization = (input, context) => {
    return take(input, {
        cdnIdentifierSecret: [, , `CdnIdentifierSecret`],
        secretsRoleArn: [, , `SecretsRoleArn`],
    });
};
const se_CmafEncryption = (input, context) => {
    return take(input, {
        constantInitializationVector: [, , `ConstantInitializationVector`],
        encryptionMethod: [, , `EncryptionMethod`],
        keyRotationIntervalSeconds: [, , `KeyRotationIntervalSeconds`],
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_CmafPackageCreateOrUpdateParameters = (input, context) => {
    return take(input, {
        encryption: [, (_) => se_CmafEncryption(_, context), `Encryption`],
        hlsManifests: [, (_) => se___listOfHlsManifestCreateOrUpdateParameters(_, context), `HlsManifests`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        segmentPrefix: [, , `SegmentPrefix`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
    });
};
const se_DashEncryption = (input, context) => {
    return take(input, {
        keyRotationIntervalSeconds: [, , `KeyRotationIntervalSeconds`],
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_DashPackage = (input, context) => {
    return take(input, {
        adTriggers: [, _json, `AdTriggers`],
        adsOnDeliveryRestrictions: [, , `AdsOnDeliveryRestrictions`],
        encryption: [, (_) => se_DashEncryption(_, context), `Encryption`],
        includeIframeOnlyStream: [, , `IncludeIframeOnlyStream`],
        manifestLayout: [, , `ManifestLayout`],
        manifestWindowSeconds: [, , `ManifestWindowSeconds`],
        minBufferTimeSeconds: [, , `MinBufferTimeSeconds`],
        minUpdatePeriodSeconds: [, , `MinUpdatePeriodSeconds`],
        periodTriggers: [, _json, `PeriodTriggers`],
        profile: [, , `Profile`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        segmentTemplateFormat: [, , `SegmentTemplateFormat`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
        suggestedPresentationDelaySeconds: [, , `SuggestedPresentationDelaySeconds`],
        utcTiming: [, , `UtcTiming`],
        utcTimingUri: [, , `UtcTimingUri`],
    });
};
const se_EgressAccessLogs = (input, context) => {
    return take(input, {
        logGroupName: [, , `LogGroupName`],
    });
};
const se_EncryptionContractConfiguration = (input, context) => {
    return take(input, {
        presetSpeke20Audio: [, , `PresetSpeke20Audio`],
        presetSpeke20Video: [, , `PresetSpeke20Video`],
    });
};
const se_HlsEncryption = (input, context) => {
    return take(input, {
        constantInitializationVector: [, , `ConstantInitializationVector`],
        encryptionMethod: [, , `EncryptionMethod`],
        keyRotationIntervalSeconds: [, , `KeyRotationIntervalSeconds`],
        repeatExtXKey: [, , `RepeatExtXKey`],
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_HlsManifestCreateOrUpdateParameters = (input, context) => {
    return take(input, {
        adMarkers: [, , `AdMarkers`],
        adTriggers: [, _json, `AdTriggers`],
        adsOnDeliveryRestrictions: [, , `AdsOnDeliveryRestrictions`],
        id: [, , `Id`],
        includeIframeOnlyStream: [, , `IncludeIframeOnlyStream`],
        manifestName: [, , `ManifestName`],
        playlistType: [, , `PlaylistType`],
        playlistWindowSeconds: [, , `PlaylistWindowSeconds`],
        programDateTimeIntervalSeconds: [, , `ProgramDateTimeIntervalSeconds`],
    });
};
const se_HlsPackage = (input, context) => {
    return take(input, {
        adMarkers: [, , `AdMarkers`],
        adTriggers: [, _json, `AdTriggers`],
        adsOnDeliveryRestrictions: [, , `AdsOnDeliveryRestrictions`],
        encryption: [, (_) => se_HlsEncryption(_, context), `Encryption`],
        includeDvbSubtitles: [, , `IncludeDvbSubtitles`],
        includeIframeOnlyStream: [, , `IncludeIframeOnlyStream`],
        playlistType: [, , `PlaylistType`],
        playlistWindowSeconds: [, , `PlaylistWindowSeconds`],
        programDateTimeIntervalSeconds: [, , `ProgramDateTimeIntervalSeconds`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
        useAudioRenditionGroup: [, , `UseAudioRenditionGroup`],
    });
};
const se_IngressAccessLogs = (input, context) => {
    return take(input, {
        logGroupName: [, , `LogGroupName`],
    });
};
const se_MssEncryption = (input, context) => {
    return take(input, {
        spekeKeyProvider: [, (_) => se_SpekeKeyProvider(_, context), `SpekeKeyProvider`],
    });
};
const se_MssPackage = (input, context) => {
    return take(input, {
        encryption: [, (_) => se_MssEncryption(_, context), `Encryption`],
        manifestWindowSeconds: [, , `ManifestWindowSeconds`],
        segmentDurationSeconds: [, , `SegmentDurationSeconds`],
        streamSelection: [, (_) => se_StreamSelection(_, context), `StreamSelection`],
    });
};
const se_S3Destination = (input, context) => {
    return take(input, {
        bucketName: [, , `BucketName`],
        manifestKey: [, , `ManifestKey`],
        roleArn: [, , `RoleArn`],
    });
};
const se_SpekeKeyProvider = (input, context) => {
    return take(input, {
        certificateArn: [, , `CertificateArn`],
        encryptionContractConfiguration: [
            ,
            (_) => se_EncryptionContractConfiguration(_, context),
            `EncryptionContractConfiguration`,
        ],
        resourceId: [, , `ResourceId`],
        roleArn: [, , `RoleArn`],
        systemIds: [, _json, `SystemIds`],
        url: [, , `Url`],
    });
};
const se_StreamSelection = (input, context) => {
    return take(input, {
        maxVideoBitsPerSecond: [, , `MaxVideoBitsPerSecond`],
        minVideoBitsPerSecond: [, , `MinVideoBitsPerSecond`],
        streamOrder: [, , `StreamOrder`],
    });
};
const de___listOfChannel = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Channel(entry, context);
    });
    return retVal;
};
const de___listOfHarvestJob = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HarvestJob(entry, context);
    });
    return retVal;
};
const de___listOfHlsManifest = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_HlsManifest(entry, context);
    });
    return retVal;
};
const de___listOfIngestEndpoint = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IngestEndpoint(entry, context);
    });
    return retVal;
};
const de___listOfOriginEndpoint = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OriginEndpoint(entry, context);
    });
    return retVal;
};
const de_Authorization = (output, context) => {
    return take(output, {
        CdnIdentifierSecret: [, __expectString, `cdnIdentifierSecret`],
        SecretsRoleArn: [, __expectString, `secretsRoleArn`],
    });
};
const de_Channel = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        CreatedAt: [, __expectString, `createdAt`],
        Description: [, __expectString, `description`],
        EgressAccessLogs: [, (_) => de_EgressAccessLogs(_, context), `egressAccessLogs`],
        HlsIngest: [, (_) => de_HlsIngest(_, context), `hlsIngest`],
        Id: [, __expectString, `id`],
        IngressAccessLogs: [, (_) => de_IngressAccessLogs(_, context), `ingressAccessLogs`],
        Tags: [, _json, `tags`],
    });
};
const de_CmafEncryption = (output, context) => {
    return take(output, {
        ConstantInitializationVector: [, __expectString, `constantInitializationVector`],
        EncryptionMethod: [, __expectString, `encryptionMethod`],
        KeyRotationIntervalSeconds: [, __expectInt32, `keyRotationIntervalSeconds`],
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_CmafPackage = (output, context) => {
    return take(output, {
        Encryption: [, (_) => de_CmafEncryption(_, context), `encryption`],
        HlsManifests: [, (_) => de___listOfHlsManifest(_, context), `hlsManifests`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        SegmentPrefix: [, __expectString, `segmentPrefix`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
    });
};
const de_DashEncryption = (output, context) => {
    return take(output, {
        KeyRotationIntervalSeconds: [, __expectInt32, `keyRotationIntervalSeconds`],
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_DashPackage = (output, context) => {
    return take(output, {
        AdTriggers: [, _json, `adTriggers`],
        AdsOnDeliveryRestrictions: [, __expectString, `adsOnDeliveryRestrictions`],
        Encryption: [, (_) => de_DashEncryption(_, context), `encryption`],
        IncludeIframeOnlyStream: [, __expectBoolean, `includeIframeOnlyStream`],
        ManifestLayout: [, __expectString, `manifestLayout`],
        ManifestWindowSeconds: [, __expectInt32, `manifestWindowSeconds`],
        MinBufferTimeSeconds: [, __expectInt32, `minBufferTimeSeconds`],
        MinUpdatePeriodSeconds: [, __expectInt32, `minUpdatePeriodSeconds`],
        PeriodTriggers: [, _json, `periodTriggers`],
        Profile: [, __expectString, `profile`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        SegmentTemplateFormat: [, __expectString, `segmentTemplateFormat`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
        SuggestedPresentationDelaySeconds: [, __expectInt32, `suggestedPresentationDelaySeconds`],
        UtcTiming: [, __expectString, `utcTiming`],
        UtcTimingUri: [, __expectString, `utcTimingUri`],
    });
};
const de_EgressAccessLogs = (output, context) => {
    return take(output, {
        LogGroupName: [, __expectString, `logGroupName`],
    });
};
const de_EncryptionContractConfiguration = (output, context) => {
    return take(output, {
        PresetSpeke20Audio: [, __expectString, `presetSpeke20Audio`],
        PresetSpeke20Video: [, __expectString, `presetSpeke20Video`],
    });
};
const de_HarvestJob = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        ChannelId: [, __expectString, `channelId`],
        CreatedAt: [, __expectString, `createdAt`],
        EndTime: [, __expectString, `endTime`],
        Id: [, __expectString, `id`],
        OriginEndpointId: [, __expectString, `originEndpointId`],
        S3Destination: [, (_) => de_S3Destination(_, context), `s3Destination`],
        StartTime: [, __expectString, `startTime`],
        Status: [, __expectString, `status`],
    });
};
const de_HlsEncryption = (output, context) => {
    return take(output, {
        ConstantInitializationVector: [, __expectString, `constantInitializationVector`],
        EncryptionMethod: [, __expectString, `encryptionMethod`],
        KeyRotationIntervalSeconds: [, __expectInt32, `keyRotationIntervalSeconds`],
        RepeatExtXKey: [, __expectBoolean, `repeatExtXKey`],
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_HlsIngest = (output, context) => {
    return take(output, {
        IngestEndpoints: [, (_) => de___listOfIngestEndpoint(_, context), `ingestEndpoints`],
    });
};
const de_HlsManifest = (output, context) => {
    return take(output, {
        AdMarkers: [, __expectString, `adMarkers`],
        AdTriggers: [, _json, `adTriggers`],
        AdsOnDeliveryRestrictions: [, __expectString, `adsOnDeliveryRestrictions`],
        Id: [, __expectString, `id`],
        IncludeIframeOnlyStream: [, __expectBoolean, `includeIframeOnlyStream`],
        ManifestName: [, __expectString, `manifestName`],
        PlaylistType: [, __expectString, `playlistType`],
        PlaylistWindowSeconds: [, __expectInt32, `playlistWindowSeconds`],
        ProgramDateTimeIntervalSeconds: [, __expectInt32, `programDateTimeIntervalSeconds`],
        Url: [, __expectString, `url`],
    });
};
const de_HlsPackage = (output, context) => {
    return take(output, {
        AdMarkers: [, __expectString, `adMarkers`],
        AdTriggers: [, _json, `adTriggers`],
        AdsOnDeliveryRestrictions: [, __expectString, `adsOnDeliveryRestrictions`],
        Encryption: [, (_) => de_HlsEncryption(_, context), `encryption`],
        IncludeDvbSubtitles: [, __expectBoolean, `includeDvbSubtitles`],
        IncludeIframeOnlyStream: [, __expectBoolean, `includeIframeOnlyStream`],
        PlaylistType: [, __expectString, `playlistType`],
        PlaylistWindowSeconds: [, __expectInt32, `playlistWindowSeconds`],
        ProgramDateTimeIntervalSeconds: [, __expectInt32, `programDateTimeIntervalSeconds`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
        UseAudioRenditionGroup: [, __expectBoolean, `useAudioRenditionGroup`],
    });
};
const de_IngestEndpoint = (output, context) => {
    return take(output, {
        Id: [, __expectString, `id`],
        Password: [, __expectString, `password`],
        Url: [, __expectString, `url`],
        Username: [, __expectString, `username`],
    });
};
const de_IngressAccessLogs = (output, context) => {
    return take(output, {
        LogGroupName: [, __expectString, `logGroupName`],
    });
};
const de_MssEncryption = (output, context) => {
    return take(output, {
        SpekeKeyProvider: [, (_) => de_SpekeKeyProvider(_, context), `spekeKeyProvider`],
    });
};
const de_MssPackage = (output, context) => {
    return take(output, {
        Encryption: [, (_) => de_MssEncryption(_, context), `encryption`],
        ManifestWindowSeconds: [, __expectInt32, `manifestWindowSeconds`],
        SegmentDurationSeconds: [, __expectInt32, `segmentDurationSeconds`],
        StreamSelection: [, (_) => de_StreamSelection(_, context), `streamSelection`],
    });
};
const de_OriginEndpoint = (output, context) => {
    return take(output, {
        Arn: [, __expectString, `arn`],
        Authorization: [, (_) => de_Authorization(_, context), `authorization`],
        ChannelId: [, __expectString, `channelId`],
        CmafPackage: [, (_) => de_CmafPackage(_, context), `cmafPackage`],
        CreatedAt: [, __expectString, `createdAt`],
        DashPackage: [, (_) => de_DashPackage(_, context), `dashPackage`],
        Description: [, __expectString, `description`],
        HlsPackage: [, (_) => de_HlsPackage(_, context), `hlsPackage`],
        Id: [, __expectString, `id`],
        ManifestName: [, __expectString, `manifestName`],
        MssPackage: [, (_) => de_MssPackage(_, context), `mssPackage`],
        Origination: [, __expectString, `origination`],
        StartoverWindowSeconds: [, __expectInt32, `startoverWindowSeconds`],
        Tags: [, _json, `tags`],
        TimeDelaySeconds: [, __expectInt32, `timeDelaySeconds`],
        Url: [, __expectString, `url`],
        Whitelist: [, _json, `whitelist`],
    });
};
const de_S3Destination = (output, context) => {
    return take(output, {
        BucketName: [, __expectString, `bucketName`],
        ManifestKey: [, __expectString, `manifestKey`],
        RoleArn: [, __expectString, `roleArn`],
    });
};
const de_SpekeKeyProvider = (output, context) => {
    return take(output, {
        CertificateArn: [, __expectString, `certificateArn`],
        EncryptionContractConfiguration: [
            ,
            (_) => de_EncryptionContractConfiguration(_, context),
            `encryptionContractConfiguration`,
        ],
        ResourceId: [, __expectString, `resourceId`],
        RoleArn: [, __expectString, `roleArn`],
        SystemIds: [, _json, `systemIds`],
        Url: [, __expectString, `url`],
    });
};
const de_StreamSelection = (output, context) => {
    return take(output, {
        MaxVideoBitsPerSecond: [, __expectInt32, `maxVideoBitsPerSecond`],
        MinVideoBitsPerSecond: [, __expectInt32, `minVideoBitsPerSecond`],
        StreamOrder: [, __expectString, `streamOrder`],
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _CI = "ChannelId";
const _ICI = "IncludeChannelId";
const _IS = "IncludeStatus";
const _MR = "MaxResults";
const _NT = "NextToken";
const _TK = "TagKeys";
const _cI = "channelId";
const _iCI = "includeChannelId";
const _iS = "includeStatus";
const _mR = "maxResults";
const _nT = "nextToken";
const _tK = "tagKeys";
