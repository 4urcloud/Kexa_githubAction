import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { CustomerProfilesServiceException as __BaseException } from "../models/CustomerProfilesServiceException";
import { AccessDeniedException, BadRequestException, InternalServerException, ResourceNotFoundException, ThrottlingException, } from "../models/models_0";
export const se_AddProfileKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/keys");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        KeyName: [],
        ProfileId: [],
        Values: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateCalculatedAttributeDefinitionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/calculated-attributes/{CalculatedAttributeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("CalculatedAttributeName", () => input.CalculatedAttributeName, "{CalculatedAttributeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        AttributeDetails: (_) => _json(_),
        Conditions: (_) => _json(_),
        Description: [],
        DisplayName: [],
        Statistic: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        DeadLetterQueueUrl: [],
        DefaultEncryptionKey: [],
        DefaultExpirationDays: [],
        Matching: (_) => se_MatchingRequest(_, context),
        RuleBasedMatching: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateEventStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/event-streams/{EventStreamName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("EventStreamName", () => input.EventStreamName, "{EventStreamName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Tags: (_) => _json(_),
        Uri: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateIntegrationWorkflowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/workflows/integrations");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        IntegrationConfig: (_) => se_IntegrationConfig(_, context),
        ObjectTypeName: [],
        RoleArn: [],
        Tags: (_) => _json(_),
        WorkflowType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        AccountNumber: [],
        AdditionalInformation: [],
        Address: (_) => _json(_),
        Attributes: (_) => _json(_),
        BillingAddress: (_) => _json(_),
        BirthDate: [],
        BusinessEmailAddress: [],
        BusinessName: [],
        BusinessPhoneNumber: [],
        EmailAddress: [],
        FirstName: [],
        Gender: [],
        GenderString: [],
        HomePhoneNumber: [],
        LastName: [],
        MailingAddress: (_) => _json(_),
        MiddleName: [],
        MobilePhoneNumber: [],
        PartyType: [],
        PartyTypeString: [],
        PersonalEmailAddress: [],
        PhoneNumber: [],
        ShippingAddress: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteCalculatedAttributeDefinitionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/calculated-attributes/{CalculatedAttributeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("CalculatedAttributeName", () => input.CalculatedAttributeName, "{CalculatedAttributeName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteEventStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/event-streams/{EventStreamName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("EventStreamName", () => input.EventStreamName, "{EventStreamName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/integrations/delete");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Uri: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/delete");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        ProfileId: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteProfileKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/keys/delete");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        KeyName: [],
        ProfileId: [],
        Values: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteProfileObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/objects/delete");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        ObjectTypeName: [],
        ProfileId: [],
        ProfileObjectUniqueKey: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteProfileObjectTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/object-types/{ObjectTypeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("ObjectTypeName", () => input.ObjectTypeName, "{ObjectTypeName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteWorkflowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/workflows/{WorkflowId}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("WorkflowId", () => input.WorkflowId, "{WorkflowId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DetectProfileObjectTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/detect/object-types");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Objects: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetAutoMergingPreviewCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/identity-resolution-jobs/auto-merging-preview");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        ConflictResolution: (_) => _json(_),
        Consolidation: (_) => _json(_),
        MinAllowedConfidenceScoreForMerging: (_) => __serializeFloat(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetCalculatedAttributeDefinitionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/calculated-attributes/{CalculatedAttributeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("CalculatedAttributeName", () => input.CalculatedAttributeName, "{CalculatedAttributeName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetCalculatedAttributeForProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/profile/{ProfileId}/calculated-attributes/{CalculatedAttributeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("ProfileId", () => input.ProfileId, "{ProfileId}", false);
    b.p("CalculatedAttributeName", () => input.CalculatedAttributeName, "{CalculatedAttributeName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetEventStreamCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/event-streams/{EventStreamName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("EventStreamName", () => input.EventStreamName, "{EventStreamName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetIdentityResolutionJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/identity-resolution-jobs/{JobId}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("JobId", () => input.JobId, "{JobId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/integrations");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Uri: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetMatchesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/matches");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetProfileObjectTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/object-types/{ObjectTypeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("ObjectTypeName", () => input.ObjectTypeName, "{ObjectTypeName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetProfileObjectTypeTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/templates/{TemplateId}");
    b.p("TemplateId", () => input.TemplateId, "{TemplateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetSimilarProfilesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/matches");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        MatchType: [],
        SearchKey: [],
        SearchValue: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetWorkflowCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/workflows/{WorkflowId}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("WorkflowId", () => input.WorkflowId, "{WorkflowId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetWorkflowStepsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/workflows/{WorkflowId}/steps");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("WorkflowId", () => input.WorkflowId, "{WorkflowId}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListAccountIntegrationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/integrations");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_ih]: [() => input.IncludeHidden !== void 0, () => input[_IH].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        Uri: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCalculatedAttributeDefinitionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/calculated-attributes");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListCalculatedAttributesForProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/profile/{ProfileId}/calculated-attributes");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("ProfileId", () => input.ProfileId, "{ProfileId}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListEventStreamsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/event-streams");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListIdentityResolutionJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/identity-resolution-jobs");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListIntegrationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/integrations");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
        [_ih]: [() => input.IncludeHidden !== void 0, () => input[_IH].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProfileObjectsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/objects");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        ObjectFilter: (_) => _json(_),
        ObjectTypeName: [],
        ProfileId: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProfileObjectTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/object-types");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListProfileObjectTypeTemplatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/templates");
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListRuleBasedMatchesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domains/{DomainName}/profiles/ruleBasedMatches");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListWorkflowsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/workflows");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        QueryEndDate: (_) => Math.round(_.getTime() / 1000),
        QueryStartDate: (_) => Math.round(_.getTime() / 1000),
        Status: [],
        WorkflowType: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_MergeProfilesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/objects/merge");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        FieldSourceProfileIds: (_) => _json(_),
        MainProfileId: [],
        ProfileIdsToBeMerged: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_PutIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/integrations");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        FlowDefinition: (_) => se_FlowDefinition(_, context),
        ObjectTypeName: [],
        ObjectTypeNames: (_) => _json(_),
        Tags: (_) => _json(_),
        Uri: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutProfileObjectCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/objects");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Object: [],
        ObjectTypeName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutProfileObjectTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/object-types/{ObjectTypeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("ObjectTypeName", () => input.ObjectTypeName, "{ObjectTypeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        AllowProfileCreation: [],
        Description: [],
        EncryptionKey: [],
        ExpirationDays: [],
        Fields: (_) => _json(_),
        Keys: (_) => _json(_),
        SourceLastUpdatedTimestampFormat: [],
        Tags: (_) => _json(_),
        TemplateId: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_SearchProfilesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles/search");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    const query = map({
        [_nt]: [, input[_NT]],
        [_mr]: [() => input.MaxResults !== void 0, () => input[_MR].toString()],
    });
    let body;
    body = JSON.stringify(take(input, {
        AdditionalSearchKeys: (_) => _json(_),
        KeyName: [],
        LogicalOperator: [],
        Values: (_) => _json(_),
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateCalculatedAttributeDefinitionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/calculated-attributes/{CalculatedAttributeName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    b.p("CalculatedAttributeName", () => input.CalculatedAttributeName, "{CalculatedAttributeName}", false);
    let body;
    body = JSON.stringify(take(input, {
        Conditions: (_) => _json(_),
        Description: [],
        DisplayName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateDomainCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        DeadLetterQueueUrl: [],
        DefaultEncryptionKey: [],
        DefaultExpirationDays: [],
        Matching: (_) => se_MatchingRequest(_, context),
        RuleBasedMatching: (_) => _json(_),
        Tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateProfileCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domains/{DomainName}/profiles");
    b.p("DomainName", () => input.DomainName, "{DomainName}", false);
    let body;
    body = JSON.stringify(take(input, {
        AccountNumber: [],
        AdditionalInformation: [],
        Address: (_) => _json(_),
        Attributes: (_) => _json(_),
        BillingAddress: (_) => _json(_),
        BirthDate: [],
        BusinessEmailAddress: [],
        BusinessName: [],
        BusinessPhoneNumber: [],
        EmailAddress: [],
        FirstName: [],
        Gender: [],
        GenderString: [],
        HomePhoneNumber: [],
        LastName: [],
        MailingAddress: (_) => _json(_),
        MiddleName: [],
        MobilePhoneNumber: [],
        PartyType: [],
        PartyTypeString: [],
        PersonalEmailAddress: [],
        PhoneNumber: [],
        ProfileId: [],
        ShippingAddress: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_AddProfileKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        KeyName: __expectString,
        Values: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateCalculatedAttributeDefinitionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttributeDetails: _json,
        CalculatedAttributeName: __expectString,
        Conditions: _json,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        DisplayName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Statistic: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DeadLetterQueueUrl: __expectString,
        DefaultEncryptionKey: __expectString,
        DefaultExpirationDays: __expectInt32,
        DomainName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Matching: (_) => de_MatchingResponse(_, context),
        RuleBasedMatching: _json,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateEventStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EventStreamArn: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateIntegrationWorkflowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
        WorkflowId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ProfileId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteCalculatedAttributeDefinitionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteEventStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteProfileKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteProfileObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteProfileObjectTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteWorkflowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DetectProfileObjectTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DetectedProfileObjectTypes: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAutoMergingPreviewCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainName: __expectString,
        NumberOfMatchesInSample: __expectLong,
        NumberOfProfilesInSample: __expectLong,
        NumberOfProfilesWillBeMerged: __expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetCalculatedAttributeDefinitionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttributeDetails: _json,
        CalculatedAttributeName: __expectString,
        Conditions: _json,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        DisplayName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Statistic: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetCalculatedAttributeForProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CalculatedAttributeName: __expectString,
        DisplayName: __expectString,
        IsDataPartial: __expectString,
        Value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DeadLetterQueueUrl: __expectString,
        DefaultEncryptionKey: __expectString,
        DefaultExpirationDays: __expectInt32,
        DomainName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Matching: (_) => de_MatchingResponse(_, context),
        RuleBasedMatching: _json,
        Stats: _json,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetEventStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DestinationDetails: (_) => de_EventStreamDestinationDetails(_, context),
        DomainName: __expectString,
        EventStreamArn: __expectString,
        State: __expectString,
        StoppedSince: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetIdentityResolutionJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AutoMerging: (_) => de_AutoMerging(_, context),
        DomainName: __expectString,
        ExportingLocation: _json,
        JobEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobExpirationTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobId: __expectString,
        JobStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobStats: _json,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Message: __expectString,
        Status: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DomainName: __expectString,
        IsUnstructured: __expectBoolean,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        ObjectTypeNames: _json,
        Tags: _json,
        Uri: __expectString,
        WorkflowId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMatchesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MatchGenerationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Matches: (_) => de_MatchesList(_, context),
        NextToken: __expectString,
        PotentialMatches: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetProfileObjectTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AllowProfileCreation: __expectBoolean,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        EncryptionKey: __expectString,
        ExpirationDays: __expectInt32,
        Fields: _json,
        Keys: _json,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        SourceLastUpdatedTimestampFormat: __expectString,
        Tags: _json,
        TemplateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetProfileObjectTypeTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AllowProfileCreation: __expectBoolean,
        Fields: _json,
        Keys: _json,
        SourceLastUpdatedTimestampFormat: __expectString,
        SourceName: __expectString,
        SourceObject: __expectString,
        TemplateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSimilarProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ConfidenceScore: __limitedParseDouble,
        MatchId: __expectString,
        MatchType: __expectString,
        NextToken: __expectString,
        ProfileIds: _json,
        RuleLevel: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetWorkflowCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Attributes: _json,
        ErrorDescription: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Metrics: _json,
        StartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        WorkflowId: __expectString,
        WorkflowType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetWorkflowStepsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_WorkflowStepsList(_, context),
        NextToken: __expectString,
        WorkflowId: __expectString,
        WorkflowType: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListAccountIntegrationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_IntegrationList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListCalculatedAttributeDefinitionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_CalculatedAttributeDefinitionsList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListCalculatedAttributesForProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_DomainList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEventStreamsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_EventStreamSummaryList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIdentityResolutionJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        IdentityResolutionJobsList: (_) => de_IdentityResolutionJobsList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListIntegrationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_IntegrationList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProfileObjectsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProfileObjectTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_ProfileObjectTypeList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListProfileObjectTypeTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListRuleBasedMatchesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MatchIds: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListWorkflowsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: (_) => de_WorkflowList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_MergeProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DomainName: __expectString,
        IsUnstructured: __expectBoolean,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        ObjectTypeNames: _json,
        Tags: _json,
        Uri: __expectString,
        WorkflowId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutProfileObjectCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ProfileObjectUniqueKey: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutProfileObjectTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AllowProfileCreation: __expectBoolean,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        EncryptionKey: __expectString,
        ExpirationDays: __expectInt32,
        Fields: _json,
        Keys: _json,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        SourceLastUpdatedTimestampFormat: __expectString,
        Tags: _json,
        TemplateId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_SearchProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Items: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateCalculatedAttributeDefinitionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AttributeDetails: _json,
        CalculatedAttributeName: __expectString,
        Conditions: _json,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        DisplayName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Statistic: __expectString,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DeadLetterQueueUrl: __expectString,
        DefaultEncryptionKey: __expectString,
        DefaultExpirationDays: __expectInt32,
        DomainName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Matching: (_) => de_MatchingResponse(_, context),
        RuleBasedMatching: _json,
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ProfileId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.customerprofiles#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "BadRequestException":
        case "com.amazonaws.customerprofiles#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.customerprofiles#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.customerprofiles#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.customerprofiles#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        Message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_AppflowIntegration = (input, context) => {
    return take(input, {
        Batches: (_) => se_Batches(_, context),
        FlowDefinition: (_) => se_FlowDefinition(_, context),
    });
};
const se_AutoMerging = (input, context) => {
    return take(input, {
        ConflictResolution: _json,
        Consolidation: _json,
        Enabled: [],
        MinAllowedConfidenceScoreForMerging: __serializeFloat,
    });
};
const se_Batch = (input, context) => {
    return take(input, {
        EndTime: (_) => Math.round(_.getTime() / 1000),
        StartTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_Batches = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Batch(entry, context);
    });
};
const se_FlowDefinition = (input, context) => {
    return take(input, {
        Description: [],
        FlowName: [],
        KmsArn: [],
        SourceFlowConfig: _json,
        Tasks: _json,
        TriggerConfig: (_) => se_TriggerConfig(_, context),
    });
};
const se_IntegrationConfig = (input, context) => {
    return take(input, {
        AppflowIntegration: (_) => se_AppflowIntegration(_, context),
    });
};
const se_MatchingRequest = (input, context) => {
    return take(input, {
        AutoMerging: (_) => se_AutoMerging(_, context),
        Enabled: [],
        ExportingConfig: _json,
        JobSchedule: _json,
    });
};
const se_ScheduledTriggerProperties = (input, context) => {
    return take(input, {
        DataPullMode: [],
        FirstExecutionFrom: (_) => Math.round(_.getTime() / 1000),
        ScheduleEndTime: (_) => Math.round(_.getTime() / 1000),
        ScheduleExpression: [],
        ScheduleOffset: [],
        ScheduleStartTime: (_) => Math.round(_.getTime() / 1000),
        Timezone: [],
    });
};
const se_TriggerConfig = (input, context) => {
    return take(input, {
        TriggerProperties: (_) => se_TriggerProperties(_, context),
        TriggerType: [],
    });
};
const se_TriggerProperties = (input, context) => {
    return take(input, {
        Scheduled: (_) => se_ScheduledTriggerProperties(_, context),
    });
};
const de_AppflowIntegrationWorkflowStep = (output, context) => {
    return take(output, {
        BatchRecordsEndTime: __expectString,
        BatchRecordsStartTime: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ExecutionMessage: __expectString,
        FlowName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RecordsProcessed: __expectLong,
        Status: __expectString,
    });
};
const de_AutoMerging = (output, context) => {
    return take(output, {
        ConflictResolution: _json,
        Consolidation: _json,
        Enabled: __expectBoolean,
        MinAllowedConfidenceScoreForMerging: __limitedParseDouble,
    });
};
const de_CalculatedAttributeDefinitionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListCalculatedAttributeDefinitionItem(entry, context);
    });
    return retVal;
};
const de_DestinationSummary = (output, context) => {
    return take(output, {
        Status: __expectString,
        UnhealthySince: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Uri: __expectString,
    });
};
const de_DomainList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListDomainItem(entry, context);
    });
    return retVal;
};
const de_EventStreamDestinationDetails = (output, context) => {
    return take(output, {
        Message: __expectString,
        Status: __expectString,
        UnhealthySince: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Uri: __expectString,
    });
};
const de_EventStreamSummary = (output, context) => {
    return take(output, {
        DestinationSummary: (_) => de_DestinationSummary(_, context),
        DomainName: __expectString,
        EventStreamArn: __expectString,
        EventStreamName: __expectString,
        State: __expectString,
        StoppedSince: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Tags: _json,
    });
};
const de_EventStreamSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EventStreamSummary(entry, context);
    });
    return retVal;
};
const de_IdentityResolutionJob = (output, context) => {
    return take(output, {
        DomainName: __expectString,
        ExportingLocation: _json,
        JobEndTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobId: __expectString,
        JobStartTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        JobStats: _json,
        Message: __expectString,
        Status: __expectString,
    });
};
const de_IdentityResolutionJobsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IdentityResolutionJob(entry, context);
    });
    return retVal;
};
const de_IntegrationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListIntegrationItem(entry, context);
    });
    return retVal;
};
const de_ListCalculatedAttributeDefinitionItem = (output, context) => {
    return take(output, {
        CalculatedAttributeName: __expectString,
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        DisplayName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Tags: _json,
    });
};
const de_ListDomainItem = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DomainName: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Tags: _json,
    });
};
const de_ListIntegrationItem = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DomainName: __expectString,
        IsUnstructured: __expectBoolean,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        ObjectTypeNames: _json,
        Tags: _json,
        Uri: __expectString,
        WorkflowId: __expectString,
    });
};
const de_ListProfileObjectTypeItem = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Description: __expectString,
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ObjectTypeName: __expectString,
        Tags: _json,
    });
};
const de_ListWorkflowsItem = (output, context) => {
    return take(output, {
        CreatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        LastUpdatedAt: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        Status: __expectString,
        StatusDescription: __expectString,
        WorkflowId: __expectString,
        WorkflowType: __expectString,
    });
};
const de_MatchesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MatchItem(entry, context);
    });
    return retVal;
};
const de_MatchingResponse = (output, context) => {
    return take(output, {
        AutoMerging: (_) => de_AutoMerging(_, context),
        Enabled: __expectBoolean,
        ExportingConfig: _json,
        JobSchedule: _json,
    });
};
const de_MatchItem = (output, context) => {
    return take(output, {
        ConfidenceScore: __limitedParseDouble,
        MatchId: __expectString,
        ProfileIds: _json,
    });
};
const de_ProfileObjectTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListProfileObjectTypeItem(entry, context);
    });
    return retVal;
};
const de_WorkflowList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListWorkflowsItem(entry, context);
    });
    return retVal;
};
const de_WorkflowStepItem = (output, context) => {
    return take(output, {
        AppflowIntegration: (_) => de_AppflowIntegrationWorkflowStep(_, context),
    });
};
const de_WorkflowStepsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WorkflowStepItem(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _IH = "IncludeHidden";
const _MR = "MaxResults";
const _NT = "NextToken";
const _ih = "include-hidden";
const _mr = "max-results";
const _nt = "next-token";
const _tK = "tagKeys";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
