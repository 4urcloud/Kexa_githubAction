import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { isValidHostname as __isValidHostname, } from "@smithy/protocol-http";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { IoTTwinMakerServiceException as __BaseException } from "../models/IoTTwinMakerServiceException";
import { AccessDeniedException, ConflictException, ConnectorFailureException, ConnectorTimeoutException, InternalServerException, QueryTimeoutException, ResourceNotFoundException, ServiceQuotaExceededException, ThrottlingException, TooManyTagsException, ValidationException, } from "../models/models_0";
export const se_BatchPutPropertyValuesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entity-properties");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        entries: (_) => se_Entries(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CancelMetadataTransferJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/metadata-transfer-jobs/{metadataTransferJobId}/cancel");
    b.p("metadataTransferJobId", () => input.metadataTransferJobId, "{metadataTransferJobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_CreateComponentTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/component-types/{componentTypeId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("componentTypeId", () => input.componentTypeId, "{componentTypeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentTypeName: [],
        compositeComponentTypes: (_) => _json(_),
        description: [],
        extendsFrom: (_) => _json(_),
        functions: (_) => _json(_),
        isSingleton: [],
        propertyDefinitions: (_) => se_PropertyDefinitionsRequest(_, context),
        propertyGroups: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateEntityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entities");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        components: (_) => se_ComponentsMapRequest(_, context),
        compositeComponents: (_) => se_CompositeComponentsMapRequest(_, context),
        description: [],
        entityId: [],
        entityName: [],
        parentEntityId: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateMetadataTransferJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/metadata-transfer-jobs");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        destination: (_) => _json(_),
        metadataTransferJobId: [],
        sources: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateSceneCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/scenes");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        capabilities: (_) => _json(_),
        contentLocation: [],
        description: [],
        sceneId: [],
        sceneMetadata: (_) => _json(_),
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateSyncJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/sync-jobs/{syncSource}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("syncSource", () => input.syncSource, "{syncSource}", false);
    let body;
    body = JSON.stringify(take(input, {
        syncRole: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateWorkspaceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        role: [],
        s3Location: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteComponentTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/component-types/{componentTypeId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("componentTypeId", () => input.componentTypeId, "{componentTypeId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteEntityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/entities/{entityId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("entityId", () => input.entityId, "{entityId}", false);
    const query = map({
        [_iR]: [() => input.isRecursive !== void 0, () => input[_iR].toString()],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteSceneCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/scenes/{sceneId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("sceneId", () => input.sceneId, "{sceneId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteSyncJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/sync-jobs/{syncSource}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("syncSource", () => input.syncSource, "{syncSource}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteWorkspaceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_ExecuteQueryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/queries/execution");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        queryStatement: [],
        workspaceId: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetComponentTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/component-types/{componentTypeId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("componentTypeId", () => input.componentTypeId, "{componentTypeId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetEntityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/entities/{entityId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("entityId", () => input.entityId, "{entityId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMetadataTransferJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/metadata-transfer-jobs/{metadataTransferJobId}");
    b.p("metadataTransferJobId", () => input.metadataTransferJobId, "{metadataTransferJobId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPricingPlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/pricingplan");
    let body;
    body = "";
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetPropertyValueCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entity-properties/value");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentName: [],
        componentPath: [],
        componentTypeId: [],
        entityId: [],
        maxResults: [],
        nextToken: [],
        propertyGroupName: [],
        selectedProperties: (_) => _json(_),
        tabularConditions: (_) => se_TabularConditions(_, context),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetPropertyValueHistoryCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entity-properties/history");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentName: [],
        componentPath: [],
        componentTypeId: [],
        endDateTime: (_) => Math.round(_.getTime() / 1000),
        endTime: [],
        entityId: [],
        interpolation: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        orderByTime: [],
        propertyFilters: (_) => se_PropertyFilters(_, context),
        selectedProperties: (_) => _json(_),
        startDateTime: (_) => Math.round(_.getTime() / 1000),
        startTime: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "data." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetSceneCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}/scenes/{sceneId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("sceneId", () => input.sceneId, "{sceneId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetSyncJobCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sync-jobs/{syncSource}");
    b.p("syncSource", () => input.syncSource, "{syncSource}", false);
    const query = map({
        [_w]: [, input[_wI]],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetWorkspaceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/workspaces/{workspaceId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListComponentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entities/{entityId}/components-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("entityId", () => input.entityId, "{entityId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentPath: [],
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListComponentTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/component-types-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListEntitiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entities-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListMetadataTransferJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/metadata-transfer-jobs-list");
    let body;
    body = JSON.stringify(take(input, {
        destinationType: [],
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
        sourceType: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListPropertiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/properties-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentName: [],
        componentPath: [],
        entityId: [],
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListScenesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/scenes-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSyncJobsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/sync-jobs-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListSyncResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/sync-jobs/{syncSource}/resources-list");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("syncSource", () => input.syncSource, "{syncSource}", false);
    let body;
    body = JSON.stringify(take(input, {
        filters: (_) => _json(_),
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags-list");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
        resourceARN: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_ListWorkspacesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces-list");
    let body;
    body = JSON.stringify(take(input, {
        maxResults: [],
        nextToken: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags");
    let body;
    body = JSON.stringify(take(input, {
        resourceARN: [],
        tags: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags");
    const query = map({
        [_rARN]: [, __expectNonNull(input[_rARN], `resourceARN`)],
        [_tK]: [
            __expectNonNull(input.tagKeys, `tagKeys`) != null,
            () => (input[_tK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateComponentTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/component-types/{componentTypeId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("componentTypeId", () => input.componentTypeId, "{componentTypeId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentTypeName: [],
        compositeComponentTypes: (_) => _json(_),
        description: [],
        extendsFrom: (_) => _json(_),
        functions: (_) => _json(_),
        isSingleton: [],
        propertyDefinitions: (_) => se_PropertyDefinitionsRequest(_, context),
        propertyGroups: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateEntityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/entities/{entityId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("entityId", () => input.entityId, "{entityId}", false);
    let body;
    body = JSON.stringify(take(input, {
        componentUpdates: (_) => se_ComponentUpdatesMapRequest(_, context),
        compositeComponentUpdates: (_) => se_CompositeComponentUpdatesMapRequest(_, context),
        description: [],
        entityName: [],
        parentEntityUpdate: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdatePricingPlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/pricingplan");
    let body;
    body = JSON.stringify(take(input, {
        bundleNames: (_) => _json(_),
        pricingMode: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UpdateSceneCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}/scenes/{sceneId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    b.p("sceneId", () => input.sceneId, "{sceneId}", false);
    let body;
    body = JSON.stringify(take(input, {
        capabilities: (_) => _json(_),
        contentLocation: [],
        description: [],
        sceneMetadata: (_) => _json(_),
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_UpdateWorkspaceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/workspaces/{workspaceId}");
    b.p("workspaceId", () => input.workspaceId, "{workspaceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        role: [],
        s3Location: [],
    }));
    let { hostname: resolvedHostname } = await context.endpoint();
    if (context.disableHostPrefix !== true) {
        resolvedHostname = "api." + resolvedHostname;
        if (!__isValidHostname(resolvedHostname)) {
            throw new Error("ValidationError: prefixed hostname must be hostname compatible.");
        }
    }
    b.hn(resolvedHostname);
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_BatchPutPropertyValuesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        errorEntries: (_) => de_ErrorEntries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CancelMetadataTransferJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        metadataTransferJobId: __expectString,
        progress: _json,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateComponentTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateEntityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        entityId: __expectString,
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateMetadataTransferJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metadataTransferJobId: __expectString,
        status: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSceneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateSyncJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateWorkspaceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteComponentTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteEntityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteSceneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteSyncJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        state: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteWorkspaceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ExecuteQueryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        columnDescriptions: _json,
        nextToken: __expectString,
        rows: (_) => de_Rows(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetComponentTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        componentTypeId: __expectString,
        componentTypeName: __expectString,
        compositeComponentTypes: _json,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        extendsFrom: _json,
        functions: _json,
        isAbstract: __expectBoolean,
        isSchemaInitialized: __expectBoolean,
        isSingleton: __expectBoolean,
        propertyDefinitions: (_) => de_PropertyDefinitionsResponse(_, context),
        propertyGroups: _json,
        status: _json,
        syncSource: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetEntityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        areAllComponentsReturned: __expectBoolean,
        arn: __expectString,
        components: (_) => de_ComponentsMap(_, context),
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        entityId: __expectString,
        entityName: __expectString,
        hasChildEntities: __expectBoolean,
        parentEntityId: __expectString,
        status: _json,
        syncSource: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMetadataTransferJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        destination: _json,
        metadataTransferJobId: __expectString,
        metadataTransferJobRole: __expectString,
        progress: _json,
        reportUrl: __expectString,
        sources: _json,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetPricingPlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        currentPricingPlan: (_) => de_PricingPlan(_, context),
        pendingPricingPlan: (_) => de_PricingPlan(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetPropertyValueCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        propertyValues: (_) => de_PropertyLatestValueMap(_, context),
        tabularPropertyValues: (_) => de_TabularPropertyValues(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetPropertyValueHistoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        propertyValues: (_) => de_PropertyValueList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSceneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        capabilities: _json,
        contentLocation: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        error: _json,
        generatedSceneMetadata: _json,
        sceneId: __expectString,
        sceneMetadata: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSyncJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: _json,
        syncRole: __expectString,
        syncSource: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetWorkspaceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        linkedServices: _json,
        role: __expectString,
        s3Location: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListComponentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        componentSummaries: _json,
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListComponentTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        componentTypeSummaries: (_) => de_ComponentTypeSummaries(_, context),
        maxResults: __expectInt32,
        nextToken: __expectString,
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEntitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        entitySummaries: (_) => de_EntitySummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListMetadataTransferJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        metadataTransferJobSummaries: (_) => de_MetadataTransferJobSummaries(_, context),
        nextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListPropertiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        propertySummaries: (_) => de_PropertySummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListScenesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        sceneSummaries: (_) => de_SceneSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSyncJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        syncJobSummaries: (_) => de_SyncJobSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListSyncResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        syncResources: (_) => de_SyncResourceSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListWorkspacesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        nextToken: __expectString,
        workspaceSummaries: (_) => de_WorkspaceSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateComponentTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        arn: __expectString,
        componentTypeId: __expectString,
        state: __expectString,
        workspaceId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateEntityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        state: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdatePricingPlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        currentPricingPlan: (_) => de_PricingPlan(_, context),
        pendingPricingPlan: (_) => de_PricingPlan(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateSceneCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateWorkspaceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iottwinmaker#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iottwinmaker#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iottwinmaker#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iottwinmaker#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        case "AccessDeniedException":
        case "com.amazonaws.iottwinmaker#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.iottwinmaker#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.iottwinmaker#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "QueryTimeoutException":
        case "com.amazonaws.iottwinmaker#QueryTimeoutException":
            throw await de_QueryTimeoutExceptionRes(parsedOutput, context);
        case "ConnectorFailureException":
        case "com.amazonaws.iottwinmaker#ConnectorFailureException":
            throw await de_ConnectorFailureExceptionRes(parsedOutput, context);
        case "ConnectorTimeoutException":
        case "com.amazonaws.iottwinmaker#ConnectorTimeoutException":
            throw await de_ConnectorTimeoutExceptionRes(parsedOutput, context);
        case "TooManyTagsException":
        case "com.amazonaws.iottwinmaker#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccessDeniedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConnectorFailureExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConnectorFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConnectorTimeoutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConnectorTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_QueryTimeoutExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new QueryTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_ComponentRequest = (input, context) => {
    return take(input, {
        componentTypeId: [],
        description: [],
        properties: (_) => se_PropertyRequests(_, context),
        propertyGroups: _json,
    });
};
const se_ComponentsMapRequest = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ComponentRequest(value, context);
        return acc;
    }, {});
};
const se_ComponentUpdateRequest = (input, context) => {
    return take(input, {
        componentTypeId: [],
        description: [],
        propertyGroupUpdates: _json,
        propertyUpdates: (_) => se_PropertyRequests(_, context),
        updateType: [],
    });
};
const se_ComponentUpdatesMapRequest = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ComponentUpdateRequest(value, context);
        return acc;
    }, {});
};
const se_CompositeComponentRequest = (input, context) => {
    return take(input, {
        description: [],
        properties: (_) => se_PropertyRequests(_, context),
        propertyGroups: _json,
    });
};
const se_CompositeComponentsMapRequest = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_CompositeComponentRequest(value, context);
        return acc;
    }, {});
};
const se_CompositeComponentUpdateRequest = (input, context) => {
    return take(input, {
        description: [],
        propertyGroupUpdates: _json,
        propertyUpdates: (_) => se_PropertyRequests(_, context),
        updateType: [],
    });
};
const se_CompositeComponentUpdatesMapRequest = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_CompositeComponentUpdateRequest(value, context);
        return acc;
    }, {});
};
const se_DataType = (input, context) => {
    return take(input, {
        allowedValues: (_) => se_DataValueList(_, context),
        nestedType: (_) => se_DataType(_, context),
        relationship: _json,
        type: [],
        unitOfMeasure: [],
    });
};
const se_DataValue = (input, context) => {
    return take(input, {
        booleanValue: [],
        doubleValue: __serializeFloat,
        expression: [],
        integerValue: [],
        listValue: (_) => se_DataValueList(_, context),
        longValue: [],
        mapValue: (_) => se_DataValueMap(_, context),
        relationshipValue: _json,
        stringValue: [],
    });
};
const se_DataValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DataValue(entry, context);
    });
};
const se_DataValueMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_DataValue(value, context);
        return acc;
    }, {});
};
const se_Entries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PropertyValueEntry(entry, context);
    });
};
const se_PropertyDefinitionRequest = (input, context) => {
    return take(input, {
        configuration: _json,
        dataType: (_) => se_DataType(_, context),
        defaultValue: (_) => se_DataValue(_, context),
        displayName: [],
        isExternalId: [],
        isRequiredInEntity: [],
        isStoredExternally: [],
        isTimeSeries: [],
    });
};
const se_PropertyDefinitionsRequest = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_PropertyDefinitionRequest(value, context);
        return acc;
    }, {});
};
const se_PropertyFilter = (input, context) => {
    return take(input, {
        operator: [],
        propertyName: [],
        value: (_) => se_DataValue(_, context),
    });
};
const se_PropertyFilters = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PropertyFilter(entry, context);
    });
};
const se_PropertyRequest = (input, context) => {
    return take(input, {
        definition: (_) => se_PropertyDefinitionRequest(_, context),
        updateType: [],
        value: (_) => se_DataValue(_, context),
    });
};
const se_PropertyRequests = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_PropertyRequest(value, context);
        return acc;
    }, {});
};
const se_PropertyValue = (input, context) => {
    return take(input, {
        time: [],
        timestamp: (_) => Math.round(_.getTime() / 1000),
        value: (_) => se_DataValue(_, context),
    });
};
const se_PropertyValueEntry = (input, context) => {
    return take(input, {
        entityPropertyReference: _json,
        propertyValues: (_) => se_PropertyValues(_, context),
    });
};
const se_PropertyValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_PropertyValue(entry, context);
    });
};
const se_TabularConditions = (input, context) => {
    return take(input, {
        orderBy: _json,
        propertyFilters: (_) => se_PropertyFilters(_, context),
    });
};
const de_BatchPutPropertyError = (output, context) => {
    return take(output, {
        entry: (_) => de_PropertyValueEntry(_, context),
        errorCode: __expectString,
        errorMessage: __expectString,
    });
};
const de_BatchPutPropertyErrorEntry = (output, context) => {
    return take(output, {
        errors: (_) => de_Errors(_, context),
    });
};
const de_ComponentResponse = (output, context) => {
    return take(output, {
        areAllCompositeComponentsReturned: __expectBoolean,
        areAllPropertiesReturned: __expectBoolean,
        componentName: __expectString,
        componentTypeId: __expectString,
        compositeComponents: _json,
        definedIn: __expectString,
        description: __expectString,
        properties: (_) => de_PropertyResponses(_, context),
        propertyGroups: _json,
        status: _json,
        syncSource: __expectString,
    });
};
const de_ComponentsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ComponentResponse(value, context);
        return acc;
    }, {});
};
const de_ComponentTypeSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ComponentTypeSummary(entry, context);
    });
    return retVal;
};
const de_ComponentTypeSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        componentTypeId: __expectString,
        componentTypeName: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_DataType = (output, context) => {
    return take(output, {
        allowedValues: (_) => de_DataValueList(_, context),
        nestedType: (_) => de_DataType(_, context),
        relationship: _json,
        type: __expectString,
        unitOfMeasure: __expectString,
    });
};
const de_DataValue = (output, context) => {
    return take(output, {
        booleanValue: __expectBoolean,
        doubleValue: __limitedParseDouble,
        expression: __expectString,
        integerValue: __expectInt32,
        listValue: (_) => de_DataValueList(_, context),
        longValue: __expectLong,
        mapValue: (_) => de_DataValueMap(_, context),
        relationshipValue: _json,
        stringValue: __expectString,
    });
};
const de_DataValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DataValue(entry, context);
    });
    return retVal;
};
const de_DataValueMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_DataValue(value, context);
        return acc;
    }, {});
};
const de_EntitySummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EntitySummary(entry, context);
    });
    return retVal;
};
const de_EntitySummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        entityId: __expectString,
        entityName: __expectString,
        hasChildEntities: __expectBoolean,
        parentEntityId: __expectString,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_ErrorEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchPutPropertyErrorEntry(entry, context);
    });
    return retVal;
};
const de_Errors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BatchPutPropertyError(entry, context);
    });
    return retVal;
};
const de_MetadataTransferJobSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetadataTransferJobSummary(entry, context);
    });
    return retVal;
};
const de_MetadataTransferJobSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        metadataTransferJobId: __expectString,
        progress: _json,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_PricingPlan = (output, context) => {
    return take(output, {
        billableEntityCount: __expectLong,
        bundleInformation: _json,
        effectiveDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pricingMode: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        updateReason: __expectString,
    });
};
const de_PropertyDefinitionResponse = (output, context) => {
    return take(output, {
        configuration: _json,
        dataType: (_) => de_DataType(_, context),
        defaultValue: (_) => de_DataValue(_, context),
        displayName: __expectString,
        isExternalId: __expectBoolean,
        isFinal: __expectBoolean,
        isImported: __expectBoolean,
        isInherited: __expectBoolean,
        isRequiredInEntity: __expectBoolean,
        isStoredExternally: __expectBoolean,
        isTimeSeries: __expectBoolean,
    });
};
const de_PropertyDefinitionsResponse = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_PropertyDefinitionResponse(value, context);
        return acc;
    }, {});
};
const de_PropertyLatestValue = (output, context) => {
    return take(output, {
        propertyReference: _json,
        propertyValue: (_) => de_DataValue(_, context),
    });
};
const de_PropertyLatestValueMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_PropertyLatestValue(value, context);
        return acc;
    }, {});
};
const de_PropertyResponse = (output, context) => {
    return take(output, {
        areAllPropertyValuesReturned: __expectBoolean,
        definition: (_) => de_PropertyDefinitionResponse(_, context),
        value: (_) => de_DataValue(_, context),
    });
};
const de_PropertyResponses = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_PropertyResponse(value, context);
        return acc;
    }, {});
};
const de_PropertySummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropertySummary(entry, context);
    });
    return retVal;
};
const de_PropertySummary = (output, context) => {
    return take(output, {
        areAllPropertyValuesReturned: __expectBoolean,
        definition: (_) => de_PropertyDefinitionResponse(_, context),
        propertyName: __expectString,
        value: (_) => de_DataValue(_, context),
    });
};
const de_PropertyTableValue = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_DataValue(value, context);
        return acc;
    }, {});
};
const de_PropertyValue = (output, context) => {
    return take(output, {
        time: __expectString,
        timestamp: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        value: (_) => de_DataValue(_, context),
    });
};
const de_PropertyValueEntry = (output, context) => {
    return take(output, {
        entityPropertyReference: _json,
        propertyValues: (_) => de_PropertyValues(_, context),
    });
};
const de_PropertyValueHistory = (output, context) => {
    return take(output, {
        entityPropertyReference: _json,
        values: (_) => de_Values(_, context),
    });
};
const de_PropertyValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropertyValueHistory(entry, context);
    });
    return retVal;
};
const de_PropertyValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropertyValue(entry, context);
    });
    return retVal;
};
const de_QueryResultValue = (output, context) => {
    return output;
};
const de_Row = (output, context) => {
    return take(output, {
        rowData: (_) => de_RowData(_, context),
    });
};
const de_RowData = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryResultValue(entry, context);
    });
    return retVal;
};
const de_Rows = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Row(entry, context);
    });
    return retVal;
};
const de_SceneSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SceneSummary(entry, context);
    });
    return retVal;
};
const de_SceneSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        contentLocation: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        sceneId: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_SyncJobSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SyncJobSummary(entry, context);
    });
    return retVal;
};
const de_SyncJobSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        status: _json,
        syncSource: __expectString,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
};
const de_SyncResourceSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SyncResourceSummary(entry, context);
    });
    return retVal;
};
const de_SyncResourceSummary = (output, context) => {
    return take(output, {
        externalId: __expectString,
        resourceId: __expectString,
        resourceType: __expectString,
        status: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_TabularPropertyValue = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropertyTableValue(entry, context);
    });
    return retVal;
};
const de_TabularPropertyValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TabularPropertyValue(entry, context);
    });
    return retVal;
};
const de_Values = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PropertyValue(entry, context);
    });
    return retVal;
};
const de_WorkspaceSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_WorkspaceSummary(entry, context);
    });
    return retVal;
};
const de_WorkspaceSummary = (output, context) => {
    return take(output, {
        arn: __expectString,
        creationDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        linkedServices: _json,
        updateDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        workspaceId: __expectString,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _iR = "isRecursive";
const _rARN = "resourceARN";
const _tK = "tagKeys";
const _w = "workspace";
const _wI = "workspaceId";
