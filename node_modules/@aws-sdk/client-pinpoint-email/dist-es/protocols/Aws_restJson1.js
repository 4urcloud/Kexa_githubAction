import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, take, withBaseException, } from "@smithy/smithy-client";
import { AccountSuspendedException, AlreadyExistsException, BadRequestException, ConcurrentModificationException, LimitExceededException, MailFromDomainNotVerifiedException, MessageRejected, NotFoundException, SendingPausedException, TooManyRequestsException, } from "../models/models_0";
import { PinpointEmailServiceException as __BaseException } from "../models/PinpointEmailServiceException";
export const se_CreateConfigurationSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets");
    let body;
    body = JSON.stringify(take(input, {
        ConfigurationSetName: [],
        DeliveryOptions: (_) => _json(_),
        ReputationOptions: (_) => se_ReputationOptions(_, context),
        SendingOptions: (_) => _json(_),
        Tags: (_) => _json(_),
        TrackingOptions: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateConfigurationSetEventDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/event-destinations");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    body = JSON.stringify(take(input, {
        EventDestination: (_) => _json(_),
        EventDestinationName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDedicatedIpPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/dedicated-ip-pools");
    let body;
    body = JSON.stringify(take(input, {
        PoolName: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDeliverabilityTestReportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/deliverability-dashboard/test");
    let body;
    body = JSON.stringify(take(input, {
        Content: (_) => se_EmailContent(_, context),
        FromEmailAddress: [],
        ReportName: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateEmailIdentityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/identities");
    let body;
    body = JSON.stringify(take(input, {
        EmailIdentity: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteConfigurationSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteConfigurationSetEventDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/event-destinations/{EventDestinationName}");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    b.p("EventDestinationName", () => input.EventDestinationName, "{EventDestinationName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDedicatedIpPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/dedicated-ip-pools/{PoolName}");
    b.p("PoolName", () => input.PoolName, "{PoolName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteEmailIdentityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/identities/{EmailIdentity}");
    b.p("EmailIdentity", () => input.EmailIdentity, "{EmailIdentity}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_GetAccountCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/account");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetBlacklistReportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/blacklist-report");
    const query = map({
        [_BIN]: [
            __expectNonNull(input.BlacklistItemNames, `BlacklistItemNames`) != null,
            () => (input[_BIN] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetConfigurationSetCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetConfigurationSetEventDestinationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/event-destinations");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDedicatedIpCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/dedicated-ips/{Ip}");
    b.p("Ip", () => input.Ip, "{Ip}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDedicatedIpsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/dedicated-ips");
    const query = map({
        [_PN]: [, input[_PN]],
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDeliverabilityDashboardOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/deliverability-dashboard");
    let body;
    body = "";
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDeliverabilityTestReportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/test-reports/{ReportId}");
    b.p("ReportId", () => input.ReportId, "{ReportId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDomainDeliverabilityCampaignCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/campaigns/{CampaignId}");
    b.p("CampaignId", () => input.CampaignId, "{CampaignId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDomainStatisticsReportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/statistics-report/{Domain}");
    b.p("Domain", () => input.Domain, "{Domain}", false);
    const query = map({
        [_SD]: [
            __expectNonNull(input.StartDate, `StartDate`) != null,
            () => (input[_SD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_ED]: [
            __expectNonNull(input.EndDate, `EndDate`) != null,
            () => (input[_ED].toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetEmailIdentityCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/identities/{EmailIdentity}");
    b.p("EmailIdentity", () => input.EmailIdentity, "{EmailIdentity}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_ListConfigurationSetsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/configuration-sets");
    const query = map({
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDedicatedIpPoolsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/dedicated-ip-pools");
    const query = map({
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDeliverabilityTestReportsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/test-reports");
    const query = map({
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListDomainDeliverabilityCampaignsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/deliverability-dashboard/domains/{SubscribedDomain}/campaigns");
    b.p("SubscribedDomain", () => input.SubscribedDomain, "{SubscribedDomain}", false);
    const query = map({
        [_SD]: [
            __expectNonNull(input.StartDate, `StartDate`) != null,
            () => (input[_SD].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_ED]: [
            __expectNonNull(input.EndDate, `EndDate`) != null,
            () => (input[_ED].toISOString().split(".")[0] + "Z").toString(),
        ],
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListEmailIdentitiesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/identities");
    const query = map({
        [_NT]: [, input[_NT]],
        [_PS]: [() => input.PageSize !== void 0, () => input[_PS].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ListTagsForResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/tags");
    const query = map({
        [_RA]: [, __expectNonNull(input[_RA], `ResourceArn`)],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutAccountDedicatedIpWarmupAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/account/dedicated-ips/warmup");
    let body;
    body = JSON.stringify(take(input, {
        AutoWarmupEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutAccountSendingAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/account/sending");
    let body;
    body = JSON.stringify(take(input, {
        SendingEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutConfigurationSetDeliveryOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/delivery-options");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    body = JSON.stringify(take(input, {
        SendingPoolName: [],
        TlsPolicy: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutConfigurationSetReputationOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/reputation-options");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    body = JSON.stringify(take(input, {
        ReputationMetricsEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutConfigurationSetSendingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/sending");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    body = JSON.stringify(take(input, {
        SendingEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutConfigurationSetTrackingOptionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/tracking-options");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    let body;
    body = JSON.stringify(take(input, {
        CustomRedirectDomain: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutDedicatedIpInPoolCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/dedicated-ips/{Ip}/pool");
    b.p("Ip", () => input.Ip, "{Ip}", false);
    let body;
    body = JSON.stringify(take(input, {
        DestinationPoolName: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutDedicatedIpWarmupAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/dedicated-ips/{Ip}/warmup");
    b.p("Ip", () => input.Ip, "{Ip}", false);
    let body;
    body = JSON.stringify(take(input, {
        WarmupPercentage: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutDeliverabilityDashboardOptionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/deliverability-dashboard");
    let body;
    body = JSON.stringify(take(input, {
        DashboardEnabled: [],
        SubscribedDomains: (_) => se_DomainDeliverabilityTrackingOptions(_, context),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutEmailIdentityDkimAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/identities/{EmailIdentity}/dkim");
    b.p("EmailIdentity", () => input.EmailIdentity, "{EmailIdentity}", false);
    let body;
    body = JSON.stringify(take(input, {
        SigningEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutEmailIdentityFeedbackAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/identities/{EmailIdentity}/feedback");
    b.p("EmailIdentity", () => input.EmailIdentity, "{EmailIdentity}", false);
    let body;
    body = JSON.stringify(take(input, {
        EmailForwardingEnabled: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutEmailIdentityMailFromAttributesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/identities/{EmailIdentity}/mail-from");
    b.p("EmailIdentity", () => input.EmailIdentity, "{EmailIdentity}", false);
    let body;
    body = JSON.stringify(take(input, {
        BehaviorOnMxFailure: [],
        MailFromDomain: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_SendEmailCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/outbound-emails");
    let body;
    body = JSON.stringify(take(input, {
        ConfigurationSetName: [],
        Content: (_) => se_EmailContent(_, context),
        Destination: (_) => _json(_),
        EmailTags: (_) => _json(_),
        FeedbackForwardingEmailAddress: [],
        FromEmailAddress: [],
        ReplyToAddresses: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/tags");
    let body;
    body = JSON.stringify(take(input, {
        ResourceArn: [],
        Tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/v1/email/tags");
    const query = map({
        [_RA]: [, __expectNonNull(input[_RA], `ResourceArn`)],
        [_TK]: [
            __expectNonNull(input.TagKeys, `TagKeys`) != null,
            () => (input[_TK] || []).map((_entry) => _entry),
        ],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateConfigurationSetEventDestinationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/v1/email/configuration-sets/{ConfigurationSetName}/event-destinations/{EventDestinationName}");
    b.p("ConfigurationSetName", () => input.ConfigurationSetName, "{ConfigurationSetName}", false);
    b.p("EventDestinationName", () => input.EventDestinationName, "{EventDestinationName}", false);
    let body;
    body = JSON.stringify(take(input, {
        EventDestination: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const de_CreateConfigurationSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateConfigurationSetEventDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateDedicatedIpPoolCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_CreateDeliverabilityTestReportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DeliverabilityTestStatus: __expectString,
        ReportId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateEmailIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DkimAttributes: _json,
        IdentityType: __expectString,
        VerifiedForSendingStatus: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteConfigurationSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteConfigurationSetEventDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDedicatedIpPoolCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteEmailIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GetAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DedicatedIpAutoWarmupEnabled: __expectBoolean,
        EnforcementStatus: __expectString,
        ProductionAccessEnabled: __expectBoolean,
        SendQuota: (_) => de_SendQuota(_, context),
        SendingEnabled: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetBlacklistReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        BlacklistReport: (_) => de_BlacklistReport(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetConfigurationSetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ConfigurationSetName: __expectString,
        DeliveryOptions: _json,
        ReputationOptions: (_) => de_ReputationOptions(_, context),
        SendingOptions: _json,
        Tags: _json,
        TrackingOptions: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetConfigurationSetEventDestinationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EventDestinations: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDedicatedIpCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DedicatedIp: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDedicatedIpsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DedicatedIps: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDeliverabilityDashboardOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        AccountStatus: __expectString,
        ActiveSubscribedDomains: (_) => de_DomainDeliverabilityTrackingOptions(_, context),
        DashboardEnabled: __expectBoolean,
        PendingExpirationSubscribedDomains: (_) => de_DomainDeliverabilityTrackingOptions(_, context),
        SubscriptionExpiryDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDeliverabilityTestReportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DeliverabilityTestReport: (_) => de_DeliverabilityTestReport(_, context),
        IspPlacements: (_) => de_IspPlacements(_, context),
        Message: __expectString,
        OverallPlacement: (_) => de_PlacementStatistics(_, context),
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainDeliverabilityCampaignCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainDeliverabilityCampaign: (_) => de_DomainDeliverabilityCampaign(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainStatisticsReportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DailyVolumes: (_) => de_DailyVolumes(_, context),
        OverallVolume: (_) => de_OverallVolume(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetEmailIdentityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DkimAttributes: _json,
        FeedbackForwardingStatus: __expectBoolean,
        IdentityType: __expectString,
        MailFromAttributes: _json,
        Tags: _json,
        VerifiedForSendingStatus: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListConfigurationSetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ConfigurationSets: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDedicatedIpPoolsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DedicatedIpPools: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDeliverabilityTestReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DeliverabilityTestReports: (_) => de_DeliverabilityTestReports(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListDomainDeliverabilityCampaignsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        DomainDeliverabilityCampaigns: (_) => de_DomainDeliverabilityCampaignList(_, context),
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListEmailIdentitiesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        EmailIdentities: _json,
        NextToken: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        Tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutAccountDedicatedIpWarmupAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutAccountSendingAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutConfigurationSetDeliveryOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutConfigurationSetReputationOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutConfigurationSetSendingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutConfigurationSetTrackingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutDedicatedIpInPoolCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutDedicatedIpWarmupAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutDeliverabilityDashboardOptionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutEmailIdentityDkimAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutEmailIdentityFeedbackAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_PutEmailIdentityMailFromAttributesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_SendEmailCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        MessageId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateConfigurationSetEventDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.pinpointemail#AlreadyExistsException":
            throw await de_AlreadyExistsExceptionRes(parsedOutput, context);
        case "BadRequestException":
        case "com.amazonaws.pinpointemail#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.pinpointemail#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.pinpointemail#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.pinpointemail#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.pinpointemail#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "AccountSuspendedException":
        case "com.amazonaws.pinpointemail#AccountSuspendedException":
            throw await de_AccountSuspendedExceptionRes(parsedOutput, context);
        case "MailFromDomainNotVerifiedException":
        case "com.amazonaws.pinpointemail#MailFromDomainNotVerifiedException":
            throw await de_MailFromDomainNotVerifiedExceptionRes(parsedOutput, context);
        case "MessageRejected":
        case "com.amazonaws.pinpointemail#MessageRejected":
            throw await de_MessageRejectedRes(parsedOutput, context);
        case "SendingPausedException":
        case "com.amazonaws.pinpointemail#SendingPausedException":
            throw await de_SendingPausedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_AccountSuspendedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AccountSuspendedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_AlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_MailFromDomainNotVerifiedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new MailFromDomainNotVerifiedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_MessageRejectedRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new MessageRejected({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_SendingPausedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new SendingPausedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_DomainDeliverabilityTrackingOption = (input, context) => {
    return take(input, {
        Domain: [],
        InboxPlacementTrackingOption: _json,
        SubscriptionStartDate: (_) => Math.round(_.getTime() / 1000),
    });
};
const se_DomainDeliverabilityTrackingOptions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_DomainDeliverabilityTrackingOption(entry, context);
    });
};
const se_EmailContent = (input, context) => {
    return take(input, {
        Raw: (_) => se_RawMessage(_, context),
        Simple: _json,
        Template: _json,
    });
};
const se_RawMessage = (input, context) => {
    return take(input, {
        Data: context.base64Encoder,
    });
};
const se_ReputationOptions = (input, context) => {
    return take(input, {
        LastFreshStart: (_) => Math.round(_.getTime() / 1000),
        ReputationMetricsEnabled: [],
    });
};
const de_BlacklistEntries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BlacklistEntry(entry, context);
    });
    return retVal;
};
const de_BlacklistEntry = (output, context) => {
    return take(output, {
        Description: __expectString,
        ListingTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        RblName: __expectString,
    });
};
const de_BlacklistReport = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_BlacklistEntries(value, context);
        return acc;
    }, {});
};
const de_DailyVolume = (output, context) => {
    return take(output, {
        DomainIspPlacements: (_) => de_DomainIspPlacements(_, context),
        StartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        VolumeStatistics: _json,
    });
};
const de_DailyVolumes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DailyVolume(entry, context);
    });
    return retVal;
};
const de_DeliverabilityTestReport = (output, context) => {
    return take(output, {
        CreateDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        DeliverabilityTestStatus: __expectString,
        FromEmailAddress: __expectString,
        ReportId: __expectString,
        ReportName: __expectString,
        Subject: __expectString,
    });
};
const de_DeliverabilityTestReports = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DeliverabilityTestReport(entry, context);
    });
    return retVal;
};
const de_DomainDeliverabilityCampaign = (output, context) => {
    return take(output, {
        CampaignId: __expectString,
        DeleteRate: __limitedParseDouble,
        Esps: _json,
        FirstSeenDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        FromAddress: __expectString,
        ImageUrl: __expectString,
        InboxCount: __expectLong,
        LastSeenDateTime: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ProjectedVolume: __expectLong,
        ReadDeleteRate: __limitedParseDouble,
        ReadRate: __limitedParseDouble,
        SendingIps: _json,
        SpamCount: __expectLong,
        Subject: __expectString,
    });
};
const de_DomainDeliverabilityCampaignList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainDeliverabilityCampaign(entry, context);
    });
    return retVal;
};
const de_DomainDeliverabilityTrackingOption = (output, context) => {
    return take(output, {
        Domain: __expectString,
        InboxPlacementTrackingOption: _json,
        SubscriptionStartDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
    });
};
const de_DomainDeliverabilityTrackingOptions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainDeliverabilityTrackingOption(entry, context);
    });
    return retVal;
};
const de_DomainIspPlacement = (output, context) => {
    return take(output, {
        InboxPercentage: __limitedParseDouble,
        InboxRawCount: __expectLong,
        IspName: __expectString,
        SpamPercentage: __limitedParseDouble,
        SpamRawCount: __expectLong,
    });
};
const de_DomainIspPlacements = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainIspPlacement(entry, context);
    });
    return retVal;
};
const de_IspPlacement = (output, context) => {
    return take(output, {
        IspName: __expectString,
        PlacementStatistics: (_) => de_PlacementStatistics(_, context),
    });
};
const de_IspPlacements = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_IspPlacement(entry, context);
    });
    return retVal;
};
const de_OverallVolume = (output, context) => {
    return take(output, {
        DomainIspPlacements: (_) => de_DomainIspPlacements(_, context),
        ReadRatePercent: __limitedParseDouble,
        VolumeStatistics: _json,
    });
};
const de_PlacementStatistics = (output, context) => {
    return take(output, {
        DkimPercentage: __limitedParseDouble,
        InboxPercentage: __limitedParseDouble,
        MissingPercentage: __limitedParseDouble,
        SpamPercentage: __limitedParseDouble,
        SpfPercentage: __limitedParseDouble,
    });
};
const de_ReputationOptions = (output, context) => {
    return take(output, {
        LastFreshStart: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        ReputationMetricsEnabled: __expectBoolean,
    });
};
const de_SendQuota = (output, context) => {
    return take(output, {
        Max24HourSend: __limitedParseDouble,
        MaxSendRate: __limitedParseDouble,
        SentLast24Hours: __limitedParseDouble,
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const _BIN = "BlacklistItemNames";
const _ED = "EndDate";
const _NT = "NextToken";
const _PN = "PoolName";
const _PS = "PageSize";
const _RA = "ResourceArn";
const _SD = "StartDate";
const _TK = "TagKeys";
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
