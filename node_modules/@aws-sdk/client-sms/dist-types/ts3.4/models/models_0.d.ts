import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { SMSServiceException as __BaseException } from "./SMSServiceException";
export declare const AppLaunchConfigurationStatus: {
  readonly Configured: "CONFIGURED";
  readonly NotConfigured: "NOT_CONFIGURED";
};
export type AppLaunchConfigurationStatus =
  (typeof AppLaunchConfigurationStatus)[keyof typeof AppLaunchConfigurationStatus];
export declare const AppLaunchStatus: {
  readonly ConfigurationInProgress: "CONFIGURATION_IN_PROGRESS";
  readonly ConfigurationInvalid: "CONFIGURATION_INVALID";
  readonly DeltaLaunchFailed: "DELTA_LAUNCH_FAILED";
  readonly DeltaLaunchInProgress: "DELTA_LAUNCH_IN_PROGRESS";
  readonly LaunchFailed: "LAUNCH_FAILED";
  readonly LaunchInProgress: "LAUNCH_IN_PROGRESS";
  readonly LaunchPending: "LAUNCH_PENDING";
  readonly Launched: "LAUNCHED";
  readonly PartiallyLaunched: "PARTIALLY_LAUNCHED";
  readonly ReadyForConfiguration: "READY_FOR_CONFIGURATION";
  readonly ReadyForLaunch: "READY_FOR_LAUNCH";
  readonly TerminateFailed: "TERMINATE_FAILED";
  readonly TerminateInProgress: "TERMINATE_IN_PROGRESS";
  readonly Terminated: "TERMINATED";
  readonly ValidationInProgress: "VALIDATION_IN_PROGRESS";
};
export type AppLaunchStatus =
  (typeof AppLaunchStatus)[keyof typeof AppLaunchStatus];
export declare const AppReplicationConfigurationStatus: {
  readonly Configured: "CONFIGURED";
  readonly NotConfigured: "NOT_CONFIGURED";
};
export type AppReplicationConfigurationStatus =
  (typeof AppReplicationConfigurationStatus)[keyof typeof AppReplicationConfigurationStatus];
export declare const AppReplicationStatus: {
  readonly ConfigurationInProgress: "CONFIGURATION_IN_PROGRESS";
  readonly ConfigurationInvalid: "CONFIGURATION_INVALID";
  readonly DeltaReplicated: "DELTA_REPLICATED";
  readonly DeltaReplicationFailed: "DELTA_REPLICATION_FAILED";
  readonly DeltaReplicationInProgress: "DELTA_REPLICATION_IN_PROGRESS";
  readonly PartiallyReplicated: "PARTIALLY_REPLICATED";
  readonly ReadyForConfiguration: "READY_FOR_CONFIGURATION";
  readonly ReadyForReplication: "READY_FOR_REPLICATION";
  readonly Replicated: "REPLICATED";
  readonly ReplicationFailed: "REPLICATION_FAILED";
  readonly ReplicationInProgress: "REPLICATION_IN_PROGRESS";
  readonly ReplicationPending: "REPLICATION_PENDING";
  readonly ReplicationStopFailed: "REPLICATION_STOP_FAILED";
  readonly ReplicationStopped: "REPLICATION_STOPPED";
  readonly ReplicationStopping: "REPLICATION_STOPPING";
  readonly ValidationInProgress: "VALIDATION_IN_PROGRESS";
};
export type AppReplicationStatus =
  (typeof AppReplicationStatus)[keyof typeof AppReplicationStatus];
export interface LaunchDetails {
  latestLaunchTime?: Date;
  stackName?: string;
  stackId?: string;
}
export declare const AppStatus: {
  readonly Active: "ACTIVE";
  readonly Creating: "CREATING";
  readonly DELETE_FAILED: "DELETE_FAILED";
  readonly Deleted: "DELETED";
  readonly Deleting: "DELETING";
  readonly Updating: "UPDATING";
};
export type AppStatus = (typeof AppStatus)[keyof typeof AppStatus];
export interface AppSummary {
  appId?: string;
  importedAppId?: string;
  name?: string;
  description?: string;
  status?: AppStatus;
  statusMessage?: string;
  replicationConfigurationStatus?: AppReplicationConfigurationStatus;
  replicationStatus?: AppReplicationStatus;
  replicationStatusMessage?: string;
  latestReplicationTime?: Date;
  launchConfigurationStatus?: AppLaunchConfigurationStatus;
  launchStatus?: AppLaunchStatus;
  launchStatusMessage?: string;
  launchDetails?: LaunchDetails;
  creationTime?: Date;
  lastModified?: Date;
  roleName?: string;
  totalServerGroups?: number;
  totalServers?: number;
}
export declare const AppValidationStrategy: {
  readonly SSM: "SSM";
};
export type AppValidationStrategy =
  (typeof AppValidationStrategy)[keyof typeof AppValidationStrategy];
export declare const ScriptType: {
  readonly POWERSHELL_SCRIPT: "POWERSHELL_SCRIPT";
  readonly SHELL_SCRIPT: "SHELL_SCRIPT";
};
export type ScriptType = (typeof ScriptType)[keyof typeof ScriptType];
export interface S3Location {
  bucket?: string;
  key?: string;
}
export interface Source {
  s3Location?: S3Location;
}
export interface SSMValidationParameters {
  source?: Source;
  instanceId?: string;
  scriptType?: ScriptType;
  command?: string;
  executionTimeoutSeconds?: number;
  outputS3BucketName?: string;
}
export interface AppValidationConfiguration {
  validationId?: string;
  name?: string;
  appValidationStrategy?: AppValidationStrategy;
  ssmValidationParameters?: SSMValidationParameters;
}
export interface SSMOutput {
  s3Location?: S3Location;
}
export interface AppValidationOutput {
  ssmOutput?: SSMOutput;
}
export declare const ServerType: {
  readonly VirtualMachine: "VIRTUAL_MACHINE";
};
export type ServerType = (typeof ServerType)[keyof typeof ServerType];
export declare const VmManagerType: {
  readonly hyperVManager: "HYPERV-MANAGER";
  readonly scvmm: "SCVMM";
  readonly vSphere: "VSPHERE";
};
export type VmManagerType = (typeof VmManagerType)[keyof typeof VmManagerType];
export interface VmServerAddress {
  vmManagerId?: string;
  vmId?: string;
}
export interface VmServer {
  vmServerAddress?: VmServerAddress;
  vmName?: string;
  vmManagerName?: string;
  vmManagerType?: VmManagerType;
  vmPath?: string;
}
export interface Server {
  serverId?: string;
  serverType?: ServerType;
  vmServer?: VmServer;
  replicationJobId?: string;
  replicationJobTerminated?: boolean;
}
export interface ServerGroup {
  serverGroupId?: string;
  name?: string;
  serverList?: Server[];
}
export interface Tag {
  key?: string;
  value?: string;
}
export interface CreateAppRequest {
  name?: string;
  description?: string;
  roleName?: string;
  clientToken?: string;
  serverGroups?: ServerGroup[];
  tags?: Tag[];
}
export interface CreateAppResponse {
  appSummary?: AppSummary;
  serverGroups?: ServerGroup[];
  tags?: Tag[];
}
export declare class InternalError extends __BaseException {
  readonly name: "InternalError";
  readonly $fault: "server";
  constructor(opts: __ExceptionOptionType<InternalError, __BaseException>);
}
export declare class InvalidParameterException extends __BaseException {
  readonly name: "InvalidParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<InvalidParameterException, __BaseException>
  );
}
export declare class MissingRequiredParameterException extends __BaseException {
  readonly name: "MissingRequiredParameterException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      MissingRequiredParameterException,
      __BaseException
    >
  );
}
export declare class OperationNotPermittedException extends __BaseException {
  readonly name: "OperationNotPermittedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<OperationNotPermittedException, __BaseException>
  );
}
export declare class UnauthorizedOperationException extends __BaseException {
  readonly name: "UnauthorizedOperationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<UnauthorizedOperationException, __BaseException>
  );
}
export declare const LicenseType: {
  readonly AWS: "AWS";
  readonly BYOL: "BYOL";
};
export type LicenseType = (typeof LicenseType)[keyof typeof LicenseType];
export interface CreateReplicationJobRequest {
  serverId: string | undefined;
  seedReplicationTime: Date | undefined;
  frequency?: number;
  runOnce?: boolean;
  licenseType?: LicenseType;
  roleName?: string;
  description?: string;
  numberOfRecentAmisToKeep?: number;
  encrypted?: boolean;
  kmsKeyId?: string;
}
export interface CreateReplicationJobResponse {
  replicationJobId?: string;
}
export declare class NoConnectorsAvailableException extends __BaseException {
  readonly name: "NoConnectorsAvailableException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<NoConnectorsAvailableException, __BaseException>
  );
}
export declare class ReplicationJobAlreadyExistsException extends __BaseException {
  readonly name: "ReplicationJobAlreadyExistsException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReplicationJobAlreadyExistsException,
      __BaseException
    >
  );
}
export declare class ServerCannotBeReplicatedException extends __BaseException {
  readonly name: "ServerCannotBeReplicatedException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ServerCannotBeReplicatedException,
      __BaseException
    >
  );
}
export declare class TemporarilyUnavailableException extends __BaseException {
  readonly name: "TemporarilyUnavailableException";
  readonly $fault: "server";
  constructor(
    opts: __ExceptionOptionType<
      TemporarilyUnavailableException,
      __BaseException
    >
  );
}
export interface DeleteAppRequest {
  appId?: string;
  forceStopAppReplication?: boolean;
  forceTerminateApp?: boolean;
}
export interface DeleteAppResponse {}
export interface DeleteAppLaunchConfigurationRequest {
  appId?: string;
}
export interface DeleteAppLaunchConfigurationResponse {}
export interface DeleteAppReplicationConfigurationRequest {
  appId?: string;
}
export interface DeleteAppReplicationConfigurationResponse {}
export interface DeleteAppValidationConfigurationRequest {
  appId: string | undefined;
}
export interface DeleteAppValidationConfigurationResponse {}
export interface DeleteReplicationJobRequest {
  replicationJobId: string | undefined;
}
export interface DeleteReplicationJobResponse {}
export declare class ReplicationJobNotFoundException extends __BaseException {
  readonly name: "ReplicationJobNotFoundException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReplicationJobNotFoundException,
      __BaseException
    >
  );
}
export interface DeleteServerCatalogRequest {}
export interface DeleteServerCatalogResponse {}
export interface DisassociateConnectorRequest {
  connectorId: string | undefined;
}
export interface DisassociateConnectorResponse {}
export declare const OutputFormat: {
  readonly JSON: "JSON";
  readonly YAML: "YAML";
};
export type OutputFormat = (typeof OutputFormat)[keyof typeof OutputFormat];
export interface GenerateChangeSetRequest {
  appId?: string;
  changesetFormat?: OutputFormat;
}
export interface GenerateChangeSetResponse {
  s3Location?: S3Location;
}
export interface GenerateTemplateRequest {
  appId?: string;
  templateFormat?: OutputFormat;
}
export interface GenerateTemplateResponse {
  s3Location?: S3Location;
}
export interface GetAppRequest {
  appId?: string;
}
export interface GetAppResponse {
  appSummary?: AppSummary;
  serverGroups?: ServerGroup[];
  tags?: Tag[];
}
export interface GetAppLaunchConfigurationRequest {
  appId?: string;
}
export interface UserData {
  s3Location?: S3Location;
}
export interface ServerLaunchConfiguration {
  server?: Server;
  logicalId?: string;
  vpc?: string;
  subnet?: string;
  securityGroup?: string;
  ec2KeyName?: string;
  userData?: UserData;
  instanceType?: string;
  associatePublicIpAddress?: boolean;
  iamInstanceProfileName?: string;
  configureScript?: S3Location;
  configureScriptType?: ScriptType;
}
export interface ServerGroupLaunchConfiguration {
  serverGroupId?: string;
  launchOrder?: number;
  serverLaunchConfigurations?: ServerLaunchConfiguration[];
}
export interface GetAppLaunchConfigurationResponse {
  appId?: string;
  roleName?: string;
  autoLaunch?: boolean;
  serverGroupLaunchConfigurations?: ServerGroupLaunchConfiguration[];
}
export interface GetAppReplicationConfigurationRequest {
  appId?: string;
}
export interface ServerReplicationParameters {
  seedTime?: Date;
  frequency?: number;
  runOnce?: boolean;
  licenseType?: LicenseType;
  numberOfRecentAmisToKeep?: number;
  encrypted?: boolean;
  kmsKeyId?: string;
}
export interface ServerReplicationConfiguration {
  server?: Server;
  serverReplicationParameters?: ServerReplicationParameters;
}
export interface ServerGroupReplicationConfiguration {
  serverGroupId?: string;
  serverReplicationConfigurations?: ServerReplicationConfiguration[];
}
export interface GetAppReplicationConfigurationResponse {
  serverGroupReplicationConfigurations?: ServerGroupReplicationConfiguration[];
}
export interface GetAppValidationConfigurationRequest {
  appId: string | undefined;
}
export declare const ServerValidationStrategy: {
  readonly USERDATA: "USERDATA";
};
export type ServerValidationStrategy =
  (typeof ServerValidationStrategy)[keyof typeof ServerValidationStrategy];
export interface UserDataValidationParameters {
  source?: Source;
  scriptType?: ScriptType;
}
export interface ServerValidationConfiguration {
  server?: Server;
  validationId?: string;
  name?: string;
  serverValidationStrategy?: ServerValidationStrategy;
  userDataValidationParameters?: UserDataValidationParameters;
}
export interface ServerGroupValidationConfiguration {
  serverGroupId?: string;
  serverValidationConfigurations?: ServerValidationConfiguration[];
}
export interface GetAppValidationConfigurationResponse {
  appValidationConfigurations?: AppValidationConfiguration[];
  serverGroupValidationConfigurations?: ServerGroupValidationConfiguration[];
}
export interface GetAppValidationOutputRequest {
  appId: string | undefined;
}
export interface ServerValidationOutput {
  server?: Server;
}
export declare const ValidationStatus: {
  readonly Failed: "FAILED";
  readonly InProgress: "IN_PROGRESS";
  readonly Pending: "PENDING";
  readonly ReadyForValidation: "READY_FOR_VALIDATION";
  readonly Succeeded: "SUCCEEDED";
};
export type ValidationStatus =
  (typeof ValidationStatus)[keyof typeof ValidationStatus];
export interface ValidationOutput {
  validationId?: string;
  name?: string;
  status?: ValidationStatus;
  statusMessage?: string;
  latestValidationTime?: Date;
  appValidationOutput?: AppValidationOutput;
  serverValidationOutput?: ServerValidationOutput;
}
export interface GetAppValidationOutputResponse {
  validationOutputList?: ValidationOutput[];
}
export interface GetConnectorsRequest {
  nextToken?: string;
  maxResults?: number;
}
export declare const ConnectorCapability: {
  readonly hyperVManager: "HYPERV-MANAGER";
  readonly scvmm: "SCVMM";
  readonly smsOptimized: "SMS_OPTIMIZED";
  readonly snapshotBatching: "SNAPSHOT_BATCHING";
  readonly vSphere: "VSPHERE";
};
export type ConnectorCapability =
  (typeof ConnectorCapability)[keyof typeof ConnectorCapability];
export declare const ConnectorStatus: {
  readonly Healthy: "HEALTHY";
  readonly Unhealthy: "UNHEALTHY";
};
export type ConnectorStatus =
  (typeof ConnectorStatus)[keyof typeof ConnectorStatus];
export interface Connector {
  connectorId?: string;
  version?: string;
  status?: ConnectorStatus;
  capabilityList?: ConnectorCapability[];
  vmManagerName?: string;
  vmManagerType?: VmManagerType;
  vmManagerId?: string;
  ipAddress?: string;
  macAddress?: string;
  associatedOn?: Date;
}
export interface GetConnectorsResponse {
  connectorList?: Connector[];
  nextToken?: string;
}
export interface GetReplicationJobsRequest {
  replicationJobId?: string;
  nextToken?: string;
  maxResults?: number;
}
export interface ReplicationRunStageDetails {
  stage?: string;
  stageProgress?: string;
}
export declare const ReplicationRunState: {
  readonly Active: "ACTIVE";
  readonly Completed: "COMPLETED";
  readonly Deleted: "DELETED";
  readonly Deleting: "DELETING";
  readonly Failed: "FAILED";
  readonly Missed: "MISSED";
  readonly Pending: "PENDING";
};
export type ReplicationRunState =
  (typeof ReplicationRunState)[keyof typeof ReplicationRunState];
export declare const ReplicationRunType: {
  readonly Automatic: "AUTOMATIC";
  readonly OnDemand: "ON_DEMAND";
};
export type ReplicationRunType =
  (typeof ReplicationRunType)[keyof typeof ReplicationRunType];
export interface ReplicationRun {
  replicationRunId?: string;
  state?: ReplicationRunState;
  type?: ReplicationRunType;
  stageDetails?: ReplicationRunStageDetails;
  statusMessage?: string;
  amiId?: string;
  scheduledStartTime?: Date;
  completedTime?: Date;
  description?: string;
  encrypted?: boolean;
  kmsKeyId?: string;
}
export declare const ReplicationJobState: {
  readonly Active: "ACTIVE";
  readonly Completed: "COMPLETED";
  readonly Deleted: "DELETED";
  readonly Deleting: "DELETING";
  readonly Failed: "FAILED";
  readonly Failing: "FAILING";
  readonly PausedOnFailure: "PAUSED_ON_FAILURE";
  readonly Pending: "PENDING";
};
export type ReplicationJobState =
  (typeof ReplicationJobState)[keyof typeof ReplicationJobState];
export interface ReplicationJob {
  replicationJobId?: string;
  serverId?: string;
  serverType?: ServerType;
  vmServer?: VmServer;
  seedReplicationTime?: Date;
  frequency?: number;
  runOnce?: boolean;
  nextReplicationRunStartTime?: Date;
  licenseType?: LicenseType;
  roleName?: string;
  latestAmiId?: string;
  state?: ReplicationJobState;
  statusMessage?: string;
  description?: string;
  numberOfRecentAmisToKeep?: number;
  encrypted?: boolean;
  kmsKeyId?: string;
  replicationRunList?: ReplicationRun[];
}
export interface GetReplicationJobsResponse {
  replicationJobList?: ReplicationJob[];
  nextToken?: string;
}
export interface GetReplicationRunsRequest {
  replicationJobId: string | undefined;
  nextToken?: string;
  maxResults?: number;
}
export interface GetReplicationRunsResponse {
  replicationJob?: ReplicationJob;
  replicationRunList?: ReplicationRun[];
  nextToken?: string;
}
export interface GetServersRequest {
  nextToken?: string;
  maxResults?: number;
  vmServerAddressList?: VmServerAddress[];
}
export declare const ServerCatalogStatus: {
  readonly Available: "AVAILABLE";
  readonly Deleted: "DELETED";
  readonly Expired: "EXPIRED";
  readonly Importing: "IMPORTING";
  readonly NotImported: "NOT_IMPORTED";
};
export type ServerCatalogStatus =
  (typeof ServerCatalogStatus)[keyof typeof ServerCatalogStatus];
export interface GetServersResponse {
  lastModifiedOn?: Date;
  serverCatalogStatus?: ServerCatalogStatus;
  serverList?: Server[];
  nextToken?: string;
}
export interface ImportAppCatalogRequest {
  roleName?: string;
}
export interface ImportAppCatalogResponse {}
export interface ImportServerCatalogRequest {}
export interface ImportServerCatalogResponse {}
export interface LaunchAppRequest {
  appId?: string;
}
export interface LaunchAppResponse {}
export interface ListAppsRequest {
  appIds?: string[];
  nextToken?: string;
  maxResults?: number;
}
export interface ListAppsResponse {
  apps?: AppSummary[];
  nextToken?: string;
}
export interface NotificationContext {
  validationId?: string;
  status?: ValidationStatus;
  statusMessage?: string;
}
export interface NotifyAppValidationOutputRequest {
  appId: string | undefined;
  notificationContext?: NotificationContext;
}
export interface NotifyAppValidationOutputResponse {}
export interface PutAppLaunchConfigurationRequest {
  appId?: string;
  roleName?: string;
  autoLaunch?: boolean;
  serverGroupLaunchConfigurations?: ServerGroupLaunchConfiguration[];
}
export interface PutAppLaunchConfigurationResponse {}
export interface PutAppReplicationConfigurationRequest {
  appId?: string;
  serverGroupReplicationConfigurations?: ServerGroupReplicationConfiguration[];
}
export interface PutAppReplicationConfigurationResponse {}
export interface PutAppValidationConfigurationRequest {
  appId: string | undefined;
  appValidationConfigurations?: AppValidationConfiguration[];
  serverGroupValidationConfigurations?: ServerGroupValidationConfiguration[];
}
export interface PutAppValidationConfigurationResponse {}
export interface StartAppReplicationRequest {
  appId?: string;
}
export interface StartAppReplicationResponse {}
export interface StartOnDemandAppReplicationRequest {
  appId: string | undefined;
  description?: string;
}
export interface StartOnDemandAppReplicationResponse {}
export declare class DryRunOperationException extends __BaseException {
  readonly name: "DryRunOperationException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<DryRunOperationException, __BaseException>
  );
}
export declare class ReplicationRunLimitExceededException extends __BaseException {
  readonly name: "ReplicationRunLimitExceededException";
  readonly $fault: "client";
  constructor(
    opts: __ExceptionOptionType<
      ReplicationRunLimitExceededException,
      __BaseException
    >
  );
}
export interface StartOnDemandReplicationRunRequest {
  replicationJobId: string | undefined;
  description?: string;
}
export interface StartOnDemandReplicationRunResponse {
  replicationRunId?: string;
}
export interface StopAppReplicationRequest {
  appId?: string;
}
export interface StopAppReplicationResponse {}
export interface TerminateAppRequest {
  appId?: string;
}
export interface TerminateAppResponse {}
export interface UpdateAppRequest {
  appId?: string;
  name?: string;
  description?: string;
  roleName?: string;
  serverGroups?: ServerGroup[];
  tags?: Tag[];
}
export interface UpdateAppResponse {
  appSummary?: AppSummary;
  serverGroups?: ServerGroup[];
  tags?: Tag[];
}
export interface UpdateReplicationJobRequest {
  replicationJobId: string | undefined;
  frequency?: number;
  nextReplicationRunStartTime?: Date;
  licenseType?: LicenseType;
  roleName?: string;
  description?: string;
  numberOfRecentAmisToKeep?: number;
  encrypted?: boolean;
  kmsKeyId?: string;
}
export interface UpdateReplicationJobResponse {}
